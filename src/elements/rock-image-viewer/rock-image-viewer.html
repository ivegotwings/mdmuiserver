<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-image/iron-image.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-asset-viewer/pebble-asset-viewer.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">

<link rel="import" href="../liquid-rest/liquid-rest.html">

<!--
`rock-image-viewer` Represents an element that displays an image.


@group pebble Elements
@element rock-image-viewer
@demo demo/index.html
-->

<dom-module id="rock-image-viewer">
    <template>
        <style>
            :host {
                display: inline-block;
                overflow: hidden;
                position: relative;
                --iron-image-width: var(--pebble-image-width);
                --iron-image-height: var(--pebble-image-height);
            }
            pebble-image-viewer{
                width:100%;
                height:100%;
            }
            #bigImage{
                background-image: url(../../images/loader.gif);
                background-size: 30px 30px;
                background-repeat: no-repeat;
                background-attachment: fixed;
                background-position: center; 
            }
            #pebbleModal{
                text-align: left;
            }
        </style>
        <liquid-rest id="getDownloadUrl" url="/data/binarystreamobjectservice/prepareDownload" method="POST" on-liquid-response="_onGetDownloadUrlResponse">
        </liquid-rest>
        <liquid-rest id="getThumbnail" url="/data/pass-through/binaryobjectservice/get" method="POST"  on-liquid-response="_onGetThumbnailResponse">
        </liquid-rest>
         <template is="dom-if" if="[[!_srcNotFound]]">
            <pebble-image-viewer id="imageView" lazy-load alt="[[alt]]"  error="{{error}}" fade="[[fade]]" height="[[height]]"
                                 loaded="{{loaded}}" loading="{{loading}}" placeholder="[[placeholder]]" position="[[position]]"
                                 preload prevent-load="[[preventLoad]]" sizing="[[sizing]]" src="[[_src]]"
                                 width="[[width]]" active="{{active}}" asset-details="[[assetDetails]]">
            </pebble-image-viewer>
        </template>
        <template is="dom-if" if="[[_srcNotFound]]">
            [[src]]
        </template>
        <pebble-dialog id="pebbleModal" on-tap="_onTapPopover" dialog-title="[[assetDetails.property_originalfilename]]" modal horizontal-align="auto" vertical-align="auto" show-close-icon no-cancel-on-outside-click
        no-cancel-on-esc-key> 
            <pebble-asset-viewer asset-type="[[assetType]]" asset-url="[[assetUrl]]" asset-extension="[[assetExtension]]"></pebble-asset-viewer>
        </pebble-dialog>

    </template>

    <script>
        Polymer({
            is: 'rock-image-viewer',

            properties: {
                /**
                 * Indicates the URL of a primary image.
                 * @type String
                 * @default null
                 */
                src: {
                    type: String,
                    value: ""
                },
                _src: {
                    type: String,
                    value: ""
                },

                /**
                 * Indicates a short text that is alternative for an image.
                 * @type String
                 * @default null
                 */
                alt: {
                    type: String,
                    value: ""
                },

                /**
                 * Specifies whether or not an image is prevented from load.
                 * If it is set to <b>true</b>, then the image is prevented from the load and any placeholder is
                 * shown. This is useful to prevent 404 requests when binding to the `src` property that is
                 * known to be invalid.
                 * @type Boolean
                 * @default false
                 */
                preventLoad: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates the sizing option for the image. The valid values are `contain`, `cover`, or `null`.
                 * If the value is `contain`,then the full aspect ratio of the image is contained within the
                 * element and is letter-boxed. If the value is `cover`, then the image is cropped in order to
                 * fully cover the bounds of the element. If the value is `null`, then the image takes natural size.
                 * @type String
                 * @default null
                 */
                sizing: {
                    type: String,
                    value: null,
                    reflectToAttribute: true
                },

                /**
                 * Specifies whether or not the preload of the image is enabled.
                 * If it is set to <b>true</b>, then any change to the `src` property causes the `placeholder`
                 * image to be shown until the new image is loaded.
                 * @type Boolean
                 * @default false
                 */
                preload: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates a placeholder to place a background image.
                 * This image is used as a background or placeholder until the `src` image is
                 * loaded.  Use of a `data-URI` for placeholder is encouraged for instant rendering.
                 * @type String
                 * @default null
                 */
                placeholder: {
                    type: String,
                    value: ""
                },

                /**
                 * Specifies whether or not an image load has an animation.
                 * If it is set to <b>true</b>, then it causes an image to
                 * fade into place.
                 * @type Boolean
                 * @default false
                 */
                fade: {
                    type: Boolean,
                    value: false
                },

                /**
                 * Specifies whether or not an image is loaded.
                 * If it is set to <b>true</b>, then the image is loaded.
                 * @type Boolean
                 * @default false
                 */
                loaded: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates a value that tracks the load state of the image when the `preload`
                 * option is used.
                 * @type Boolean
                 * @default false
                 */
                loading: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * Specifies that the last set `src` is failed to load.
                 * @type Boolean
                 * @default false
                 */
                error: {
                    notify: true,
                    type: Boolean,
                    value: false
                },

                /**
                 * Indicates the width of image. It is specified either via binding or CSS.
                 * @type number
                 * @default null
                 */
                width: {
                    type: Number
                },

                /**
                 * Indicates the height of image. It is specified either via binding or CSS.
                 * 
                 *
                 * @attribute height
                 * @type number
                 * @default null
                 */
                height: {
                    type: Number
                },

                /**
                 * Indicates the outline of the image thumbnail.
                 * The only valid value is `circle`.
                 * If it is set to <b>null</b>, then the outline is box based on the thumbnail dimensions and element style.
                 * @attribute shape
                 * @type String
                 * @default null
                 */
                shape: {
                    type: String,
                    value: null
                },

                /**
                 * Indicates the URL of the background image for primary image.
                 * The background image pops up once the thumbnail is clicked.
                 * The thumbnail is clickable if background image source is provided.
                 * @attribute shape
                 * @type String
                 * @default null
                 */
                bigImageSrc: {
                    type: String,
                    value: null
                },

                /**
                 * Indicates the expected alignment of background image with the primary image place holder.
                 * The valid values are `topleft`, `topright`, `bottomleft`, and `bottomright`.
                 * The position is set according to the implied value.
                 * If it is set to <b>null</b>, then the image pop-ups at center with the options such as `no-cancel-on-outside-click`, `no-cancel-on-esc-key`, and `with-backdrop`.
                 * Use `--dailog-layout` mixin to set the background image size & styles.
                 * @attribute alignment
                 * @type String
                 * @default null
                 */
                alignment: {
                    type: String,
                    value: 'null'
                } ,
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                thumbnailId:{
                    type:String
                },
                noThumbnailImagePath:{
                    type:String,
                    value:"/src/images/no-thumbnail.svg"
                },
                loadingThumbnailPath: {
                    type: String,
                    value: "/src/images/loading-thumbnail.svg"
                },
                active:{
                    type:Boolean,
                    value:false
                },
                assetDetails: {
                    type:Object
                },
                assetType:{
                    type: String
                },
                assetUrl: {
                    type: String
                },
                assetExtension:{
                    type: String
                },
                _srcNotFound: {
                    type: Boolean,
                    value: false
                }
            },
            observers:[
                "_generateGetThumbnailRequest(thumbnailId,active,src)"
            ],
            listeners: {
                'enlarge-asset': '_onAssetEnlargeEvent',
                'asset-popover-closed': 'assetPopoverClosed'
            },
            _generateGetThumbnailRequest:function () {
                this.set("_srcNotFound", false);
                if(this.thumbnailId) {
                    this.set("_src",this.loadingThumbnailPath);
                    if(this.active) {
                        var req = {
                            "params": {
                                "query": {
                                    "id": this.thumbnailId,
                                    "filters": {}
                                },
                                "fields": {}
                            }
                        };
                        req.params.query.filters.typesCriterion = ["imagerendition"];
                        req.params.fields.attributes = ["blob"];
                        var getThumbnailLiquid = this.$$("#getThumbnail");
                        if (getThumbnailLiquid) {
                            getThumbnailLiquid.requestData = req;
                            getThumbnailLiquid.generateRequest();
                        }
                    }
                } else if(this.src){
                    //checks the source exist and set
                    this._imageExists(this.src).then(function(response){
                        if(response){
                            this.set("_src",this.src);
                        }
                        else{
                            this.set("_srcNotFound", true);
                        }
                    }.bind(this));
                } else {
                    this.set("_src",this.noThumbnailImagePath);
                }
            },
            _onGetThumbnailResponse:function (e) {
                var thumbnail;
                if (e.detail && e.detail.response && e.detail.response.response) {
                    var response = e.detail.response.response;
                    if (response.status.toLowerCase() == "success") {
                        var binaryObjects=response.binaryObjects;
                        if(binaryObjects) {
                            var binaryObject=binaryObjects[0];
                            if (binaryObject.data) {
                                thumbnail= binaryObject.data.blob;
                            }
                        }
                    }
                    if(thumbnail) {
                        // decode the base64 and find the mime type. This is needed to display image/svg+xml images
                        var c = Base64.decode(thumbnail);

                        if (63039 == c.charCodeAt(0)) {
                            e = "image/jpeg"; 
                        }
                        else if (37902 == c.charCodeAt(0)) {
                            e = "image/png";
                        }
                        else if (0 == c.indexOf("GIF")) {
                            e = "image/gif"; 
                        }
                        else if (0 == c.indexOf("BM")) {
                            e = "image/bmp", a = ".bmp"; 
                        }
                        else if (0 < c.indexOf("\x3csvg")) {
                            e = "image/svg+xml";
                        }
                        else {
                            e = "image";
                        }

                        var imgSrc = "data:" + e + ";base64," + thumbnail;
                        
                        this.set("_src", imgSrc);
                    } 
                    else if(this.src){
                        this._imageExists(this.src).then(function(response){
                            if(response){
                                this.set("_src",this.src);
                            }
                            else{
                                this.set("_srcNotFound", true);
                            }
                        }.bind(this));
                    }
                    else {
                        //console.log('no thumbnail path ', this.noThumbnailImagePath);
                        this.set("_src",this.noThumbnailImagePath);
                    }
                }
                
            },
            _imageExists:function(image_url){

                return new Promise(function(resolve, reject) {
                    
                    var img = new Image();
                    img.onload = function(){
                            resolve(true);  
                    }.bind(this);
                    img.onerror = function(){
                            resolve(false);
                    }.bind(this);
                    img.src = image_url;
                });

            },
            _onAssetEnlargeEvent: function(event, eventDetails){
                var imageDetail = eventDetails;
                if(imageDetail){
                    if(imageDetail.name == "view-by-item"){
                        //If item details are provided
                        if(imageDetail.data.filetype){
                            this.set("assetExtension", imageDetail.data.filetype);
                        }
                        else if(imageDetail.data.filenameextension){
                            this.set("assetExtension", imageDetail.data.filenameextension);
                        }
                        this.set("assetType", imageDetail.data.type);
                        var fileName = imageDetail.data.property_objectkey;
                        if (fileName) {
                            var req = {
                                "binaryStreamObject": {
                                "id": fileName,
                                "type": "binarystreamobject",
                                "data": {}
                                }
                            };
                            var downloadUrlLiquid = this.shadowRoot.querySelector("#getDownloadUrl");
                            if (downloadUrlLiquid) {
                                downloadUrlLiquid.requestData = [req];
                                downloadUrlLiquid.generateRequest();
                            }
                        }
                    }
                    else{
                        //if public asset provided(currently done for only images)
                        this.set("assetExtension", "jpg");
                        this.set("assetType", "image");
                        this.set("assetUrl", imageDetail.data); 
                        var assetViewer = this.shadowRoot.querySelector("pebble-asset-viewer");
                        assetViewer.set("isPublicUrl",true);
                        var modal = this.$.pebbleModal;
                        modal.open(); 
                    }
                }                
            },
            
            _onGetDownloadUrlResponse: function (e) {
                LiquidResponseHelper.downloadURLResponseMapper(e, downloadURL => {
                    this.set("assetUrl", downloadURL); 
                    this.$.pebbleModal.open();
                });

            },
            assetPopoverClosed: function (e) {
                var pebbleAssetViewer = this.shadowRoot.querySelector("pebble-asset-viewer");
                if(pebbleAssetViewer){
                    pebbleAssetViewer.onClose();
                }
            },
            _onTapPopover: function (event) {
                event.stopPropagation();
            }
        });
    </script>
</dom-module>
