<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">

<link rel="import" href="../pebble-data-table/pebble-data-table.html">
<link rel="import" href="../pebble-data-table/data-table-column.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-gridsystem.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-toolbar/pebble-toolbar.html">
<link rel="import" href="../rock-attribute/rock-attribute.html">
<link rel="import" href="../rock-entity-tofix/rock-entity-tofix.html">
<link rel="import" href="grid-list-view.html">
<link rel="import" href="grid-tile-view.html">
<link rel="import" href="remote-data.html">
<!--

`rock-grid` Represents the grid control of the framework. It creates the visual consistency between the layouts 
while allowing the flexibility across a wide variety of designs.
Following are the three ways to use the `rock-grid`:

### 1. Pass the "config" and "data":
The following `girdData` JSON object is a sample of data which binds the grid:
```json

	{
		"shortName": "web Price",
		"longName": "Web Price",
		"productType": "Electronics",
		"description": "product web price",
		"isNew": false,
		"isApproved": true
	},
	{
		"shortName": "catalog",
		"longName": "Catalog",
		"productType": "Toys",
		"description": "catalog information",
		"isNew": true,
		"isApproved": false
	},
	{
		"shortName": "cost1",
		"longName": "Cost2",
		"productType": "Value",
		"description": "cost of the product1",
		"isNew": false,
		"isApproved": true
	}
```
### Example
```html
	<rock-grid data="{{gridData}}" config="{{gridConfig}}" page-size="10"></rock-grid>

```
### 2. Use the `x-data-source` component and then pass the data-source, config, record-size, and grid-data-size.
To use the `x-data-source`, you need to pass the following properties:

`request` - This is any liquid request from which the data is loaded.

`operation` - The liquid operation name for which the `request` object is prepared.

`data-formatter`  - This is a callback function which is triggered on every page load in the grid before binding the data to the grid. 
It is used for formatting the response data that comes from the liquid request into an array of records as per the grid configuration.
Then you need to access the auto calculated properties of `data-source` and pass it to the `rock-grid. For example, the properties such as`current-record-size` and 
`total-records` are passed to `record-size` and `grid-data-size` as shown in the following example:
### Example
		<dom-module id="app">
			<template>
				<x-data-source id="remote1" request="[[request]]" data-formatter="{{dataFormatter}}"
					buffer-record-size="{{size}}" total-records="{{totalRecords}}" data-source="{{rDataSource}}"></x-data-source>
				<rock-grid data-source="{{rDataSource}}" data-source-id="remote1" record-size="{{totalRecords}}" config="{{gridConfig}}"
					grid-data-size="{{size}}" page-size="10"></rock-grid>
			</template>
			<script>
				Polymer({
					is: 'app',
					properties: {
						dataFormater: {
							notify: true,
							value: function() {
								return this._dataFormatter.bind(this);
							}
						}
					},
					_dataFormatter: function(response) {
						var data = [];
						........
						.......
						...
						return data;
					}
				});
			</script>
		</dom-module>
### 3. Create external data-source and then pass the data-source, config, record-size, and grid-data-size.
### Example
	A. External Data Source:
```html
			<dom-module id="data-source">
				<template>
					<style include="bedrock-style-common"></style>
				</template>
				<script>
					Polymer({
						is: 'data-source',
						properties: {
							rDataSource: {
								notify: true,
								value: function() {
								return this._dataSource.bind(this);
								}
							},
							size: {
								type: Number,
								notify: true,
								value: 0
							},
							total-records: {
								type: Number,
								notify: true,
								value: 0
							}
						},
						_lastPage: -1,
						_dataSource: function(opts, cb) {
							var xhr = new XMLHttpRequest();
							xhr.onreadystatechange = function() {
								if (xhr.readyState == XMLHttpRequest.DONE) {
									if (xhr.status == 200 && this._lastPage < opts.page) {
										var data = JSON.parse(xhr.responseText);
										// This if condition is required for any data source to make vitualization work
										// pagination will work based on this inputs
										if(opts.pageSize <= data.length)
										{
											if (this.size / opts.pageSize >= opts.page) {
												this.size += this.size == 0 ? opts.pageSize * 2 : opts.pageSize;
											}
										}
										else
										{
											if(this.size == 0) {
												this.size = data.length;
											}
											else {
												this.size -= opts.pageSize;
											}
										}
										cb(data);
										this._lastPage = opts.page;
										this.totalRecords += data.length;
									}
								}
							}.bind(this);
							// page parameters could be used like this:
							xhr.open("GET", 'gridData.json?per_page=' +
								opts.pageSize + '&page=' + opts.page, true);
							xhr.send();
						}
					});
				</script>
			</dom-module>
```
	B. Usage of external data source in the rock grid:
```html
		<data-source data-source="{{rDataSource}}" size="{{size}}" total-records="{{totalRecords}}"></data-source>               
  		<rock-grid data-source="{{rDataSource}}" grid-data-size="{{size}}" record-size="{{totalRecords}}" config="{{gridConfig}}" 
		  page-size="10"></rock-grid>
```
The following JSON object is a config sample which configures the grid in all above three ways:
```json
{
    "viewMode": "Tabular",
    "title": "Simple Data Table",
    "readOnly":true,
    "tabular": {
        "settings": {
        
            "isMultiSelect": true
        
        },
        "columns": [
            {
                "header": "Short Name",
                "name": "shortName",
                "sortable": true,
                "filterable": false,
                "editType":"text"
            },
            {
                "header": "Long Name",
                "name": "longName",
                "sortable": false,
                "filterable": true,
                "editType":""
            },
            {
                "header": "Product Type",
                "name": "productType",
                "sortable": false,
                "filterable": false,
                "editType":"text"
            }
}
```

@demo demo/index.html
-->
<dom-module id="rock-grid">
	<template>
		<style include="bedrock-style-common bedrock-style-gridsystem">
			.attribute {
				width: 100%;
			}

			pebble-data-table {
				--pebble-data-table-header: {
					min-height: 40px;
					padding-top: 10px;
					padding-right: 0;
					padding-bottom: 10px;
					padding-left: 0;
				};
				--pebble-data-table-row-odd: {
					background-color: var(--secondary-button-color, #ffffff);
				};
			}

			pebble-data-table[loading] {
				pointer-events: none;
			}

			pebble-data-table data-table-row[header]{
				font-weight: var(--font-bold, bold);
				color: var(--palette-cerulean, #036bc3);
				border-bottom: none;
				text-transform: uppercase;
				font-size: var(--table-head-font-size, 11px);
			}

			pebble-data-table data-table-row:not([header]) {
				color: var(--palette-dark, #1a2028);
				font-size: var(--default-font-size, 12px);
				height: 100%;
				background-color: var(--palette-white, #ffffff);
			}

			pebble-data-table data-table-row:not([header]):hover,
			data-table-row[selected] {
				background-color: var(--table-row-selected-color, #c1cad4) !important;
			}

			pebble-data-table data-table-row:not([header]):hover data-table-checkbox,
			data-table-row[selected] data-table-checkbox {
				background-color: var(--palette-white, #ffffff) !important;
			}

			#pebbleGridContainer {
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				@apply --pebble-grid-container;
			}

			#pebbleGridContainer grid-list-view {
				--pebble-grid-list-container:{
					will-change: unset;
					transform: none!important;
					-ms-transform: none!important;
					-webkit-transform: none!important;
				}
			}

			#gridHeader {
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				padding: 10px 20px 10px 20px;
				color: var(--palette-steel-grey, #75808b);
				@apply --pebble-grid-container-header;
			}

			#gridHeader .title-container>span {
				font-weight: var(--font-bold, bold);
				color: var(--palette-dark, #1a2028);
			}

			pebble-button {
				vertical-align: -webkit-baseline-middle;
				vertical-align: -moz-baseline-middle;
				vertical-align: baseline-middle;
				--pebble-button: {
					padding-top: 0.5em;
					padding-right: 0em;
					padding-bottom: 0.5em;
					padding-left: 0em;
					min-width: 2.14em;
					margin-top: 0px;
					margin-right: 0px;
					margin-bottom: 0px;
					margin-left: 0px;
				};
				--pebble-button-iron-icon: {
					height: 20px;
					width: 20px;
					color: var(--primary-icon-color, #75808b);
				};
			}

			pebble-button.pageRange {
				--pebble-button:{
					line-height: var(--border-btn-height, 24px);
					height: var(--border-btn-height, 30px);
					box-shadow: none;
					font-family: var(--default-font-family);
					padding-top: 0px;
					padding-right:5px;
					padding-bottom:0px;
					padding-left:4px;
					font-size: var(--default-font-size, 12px)!important;
				}
			}

			pebble-vertical-divider {
				min-width: 1px;
				min-height: 24px;
				border-right: 0;
				background: var(--divider-color, #c1cad4);
			}

			.input-content.paper-input-container .paper-input-label {
				color: var(--palette-white, #ffffff) !important;
				font-family: var(--default-font-family);
			}

			paper-dropdown-menu {
				width: 90px;
				--paper-input-container: {
					padding-top:0px;
					padding-right:0px;
					padding-bottom:0px;
					padding-left:0px;
				};
				--paper-input-container-underline: {
					display: none;
				};				
				--paper-input-container-underline-focus: {
					display: none;
				};				
				--paper-dropdown-menu-icon: {
					color: var(--palette-steel-grey, #75808b);
					margin-top:-5px;
				};				
				--paper-input-container-input: {
					color: var(--palette-steel-grey, #75808b);
					font-size: var(--dropdown-inside-grid-size, 12px);
					vertical-align: top !important;
					line-height: 20px !important;
					padding-left: var(--gutter-width, 5px);
				};
			}

			.actionButton {
				margin-right: var(--default-margin, 10px);
			}

			data-table-checkbox {
				border-right: none;
				padding: 0 10px 0 0;
				height: auto;
				flex-basis: 25px;
			}

			data-table-cell,
			data-table-cell[header] {
				padding: 0 0 0 10px;
				height: auto;
				min-width: 0!important;
			}

			data-table-cell a {
				width: 100%;
			}

			data-table-cell[header] {
				min-height: 30px!important;
				font-size: var(--font-size-sm, 12px);
				color: var(--palette-cerulean, #036bc3);				
				text-transform: uppercase;
				cursor: default;				
			}	

			data-table-cell:not([header]) {
				min-height: 40px!important;
				height: auto !important;
			}

			.check-filter {
				flex-basis: 25px!important;
				flex-grow: 0!important;
				overflow: visible!important;
				position: relative;
				padding: 0;
			}

			grid-selection-popover {
				position: absolute;
				left: 13px;
				top: auto;
			}

			pebble-data-table {
 				--pebble-data-table-header: {
 					min-height: 40px;
 					height: auto;
 				}				
  		}
			#pebbleGridContainer pebble-data-table data-table-row data-table-cell rock-attribute {
 				--attribute-main: {
 					padding-top:0px;
					padding-right:0px;
					padding-bottom:0px;
					padding-left:0px;
 				};
 				--attribute-edit: {
 					margin-top: -4px;					
 				};
 				--textarea-container: {
 					padding-top:0px;
					padding-right:0px;
					padding-bottom:0px;
					padding-left:0px;			
 				};
 				--paper-input-container-input: {
 					min-height: 30px;					
 				}
  		}
			#pebbleGridContainer pebble-data-table data-table-row data-table-cell data-table-column-filter {
 				--paper-input-container-label: {
 					top: -3px;
 					font-size: var(--font-size-sm, 12);
 					color: var(--palette-cerulean, #036bc3);
 					font-weight: var(--font-bold, bold);
 				}				
  		}

			#pebbleGridContainer pebble-data-table data-table-row data-table-cell data-table-column-sort {
				--data-table-column-sort-order: {
					display: none !important;
				}
			}

			.input-content.label-is-floating ::slotted(label),
			.input-content.label-is-floating ::slotted(.paper-input-label) {
				transform: translateY(-30%) scale(0.75);
			}

			#pebbleGridContainer pebble-data-table data-table-row data-table-cell data-table-column-filter {
 				--paper-input-container-input: {
 					font-size: var(--default-font-size, 14px);
				}				
  		}
			#pebbleGridContainer pebble-data-table data-table-row data-table-cell pebble-button {
 				--pebble-button: {
 					margin-top: 5px;
 				}				
  		}
			#pebbleGridContainer pebble-data-table data-table-row data-table-cell pebble-button {
 				--pebble-icon: {
 					width: 16px !important;
 					height: 16px !important;
 				}				
			}

			data-table-column-sort {
				--paper-icon-button:{
					width: 15px;
					height: 13px;
					padding-top:0px;
					padding-right:0px;
					padding-bottom:0px;
					padding-left:0px;
					position: relative;
					top: -2px;
				}
				--paper-icon-button-opacity:{
					opacity:1;
				}
			}
			paper-dropdown-menu {
				--paper-menu-button-content:{
					@apply --common-popup;
					top: 0;
					margin-top: var(--grid-header-height, 29px);
					overflow: visible !important;
				}
			}
			paper-listbox paper-item {
				font-size: var(--font-size-sm, 12px);
				color: var(--palette-steel-grey, #75808b);
				min-height: 30px;
				width: 120px;
				height: 1px;
			}

			paper-listbox.dropdown-content {
				padding: 12px 0px !important;
			}

			paper-listbox.dropdown-content paper-item {
				@apply --popup-item;
			}

			paper-item.iron-selected {
				font-weight: normal;
			}

			.trim {
				display: inline-flex;
				display: -webkit-inline-flex;
				width: 30%;
				text-overflow: ellipsis;
				overflow: hidden;
				white-space: nowrap;
			}

			pebble-actions {
				padding-left: 10px;
				padding-right: 10px;
				height: 32px;
				--pebble-button: {
					background-color: var(--palette-white, #ffffff);
					color: var(--color-steal-grey, #75808b) !important;
				};
			}

			--pebble-button-iron-icon {
				height: 16px;
				width: 16px;
				padding-top: 0px;
				padding-right:3px;
				padding-bottom:0px;
				padding-left:3px;
				color: var(--palette-white, #ffffff);
				@apply --pebble-actions-button-icon;
			}
				
			.error-circle {
				height: 18px;
				width: 18px;
				line-height: 18px;
				text-align: center;
				border-radius: 50%;
				background: var(--error-color, #ed204c);
				font-size: 9px;
				float: right;
				color: var(--palette-white, #ffffff);
			}

			pebble-data-table {
				height: var(--rock-grid-height, 400px);
			}
			/* Firefox specific fix for vertical scroll */

			@media all and (min--moz-device-pixel-ratio:0) and (min-resolution: 3e1dpcm) {
				pebble-data-table {
					height: var(--rock-grid-height, 350px);
				}
			}
			/* IE edge specific fix for vertical scroll */

			_:-ms-lang(x),
			_:-webkit-full-screen,
			pebble-data-table {
				height: var(--rock-grid-height, 349px);
			}

			@media screen and (-ms-high-contrast: active),
			(-ms-high-contrast: none) {
				pebble-data-table {
					height: var(--rock-grid-height, 349px);
				}
			}

			.edit-options {
				display: none;
			}

			.edit-options pebble-button {
				vertical-align: top;
				margin-top: 5px;
			}

			.edit-options.show {
				display: block;
			}

			pebble-toolbar {
				display: inline-block;
				vertical-align: middle;
				--pebble-toolbar-button-icon: {
					padding-top: 4.5px;
					padding-right: 4.5px;
					padding-bottom: 4.5px;
					padding-left: 4.5px;
					border: 0px;
					/*min-width: 2.14em;*/
					margin-top:0;
					margin-right:0;
					margin-bottom:0;
					margin-left:0;
					top: 3px;
				};
				--pebble-toolbar-menubutton: {
					border: 0px;
				};
				--pebble-button: {
					color: var(--palette-kelly-green, #09c021);
					font-weight: var(--font-medium, 500);
				};
				--pebble-button-iron-icon: {
					height: 16px;
					width: 16px;
					margin-right: 5px;
				};
				--pebble-toolbar-pebble-button-menu-item-icon: {
					width: 16px;
					height: 16px;
				};
				--paper-menu-background-color: var(--palette-white, #ffffff);
				--pebble-horizontal-divider-color:var(--buttontext-color, #616161);
			}

			#gridHeader .grid-actions {
				height: 45px;
			}

			.cell {
				font-size: 14px;
				display: inline-block;
				vertical-align: middle;
				max-height: 100px;
				overflow-y: auto;
				max-width: 100%;
			}

			#title{
				display: inline-block;
    		text-align: left;
				max-width: 85%;
				text-overflow: ellipsis;
				overflow: hidden;
				white-space: nowrap;
			}
			#selection-title{
				display: inline-block;
			}
			.title-container{
				justify-content: flex-start;
    			display: flex;
    			width: 51%;
			}
			paper-dropdown-menu {
				--paper-menu-button-dropdown: {
          margin-top: 40px;
				}
			}
			pebble-toolbar paper-toolbar {
				--paper-toolbar-content:{
					padding-right: 5px !important;
					padding-left: 5px !important;
				}
			}
			#pebbleGridContainer pebble-data-table data-table-cell .cell{
				overflow: visible;
			}
			#pebbleGridContainer pebble-data-table data-table-cell span{
				text-overflow: ellipsis;
				white-space: nowrap;
				overflow: hidden;
				display: block;
			}
			.msg{
				text-align: center;
			}
		</style>
		<template is="dom-if" if="{{_dataIsNotNull(config, attributeModels)}}" restamp>
			<template is="dom-if" if="[[!noHeader]]">
				<div id="gridHeader" align="right" class="row layout-middle layout-between">
					<div class="title-container">
						<span id="title" class="tooltip-bottom" data-tooltip$="[[title]]" title="[[title]]">[[title]]</span>
						<span id="selection-title" class="tooltip-bottom" data-tooltip$="[[selectionTitle]]" title="[[selectionTitle]]">[[selectionTitle]]</span>
					
					</div>
					<div class="grid-actions row layout-middle">
						<!-- Start pebble-toolbar -->
						<pebble-toolbar id="gridToolbar" readonly$="[[readonly]]" config-data="[[_toolbarConfig]]"></pebble-toolbar>
						<bedrock-pubsub event-name="toolbar-button-event" handler="_onToolbarEvent" target-id="gridToolbar"></bedrock-pubsub>						
						<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
						<paper-dropdown-menu label="{{config.viewMode}}" no-label-float class="tooltip-bottom" data-tooltip="View Mode">
							<paper-listbox slot="dropdown-content" class="dropdown-content" attr-for-selected="value" selected="{{config.viewMode}}">
								<paper-item value="Tabular">
									<pebble-button icon="pebble-md-icons:Tableview" class="pebble-md-icons m-r-5"></pebble-button>Tabular</paper-item>
								<paper-item value="List">
									<pebble-button icon="pebble-md-icons:Listview" class="pebble-md-icons m-r-5"></pebble-button>List</paper-item>
								<paper-item value="Tile">
									<pebble-button icon="pebble-md-icons:Tileview" class="pebble-md-icons m-r-5"></pebble-button>Tile</paper-item>
							</paper-listbox>
						</paper-dropdown-menu>
					</div>
				</div>
			</template>
			<div id="pebbleGridContainer" class="m-l-20 m-r-20 m-b-10">
				<template is="dom-if" if="{{_isTabularMode(config.viewMode)}}" restamp>
					<div hidden="[[_configPresent('tabular')]]" class="msg" > Config not present for Tabular view of the grid.</div>
					<template is="dom-if" if="[[_configPresent('tabular')]]" >
						<pebble-data-table id="pebbleDataTable"  min-filter-length="[[minFilterLength]]" advance-selection-options="[[config.advanceSelectionOptions]]"
						 advance-selection-enabled="[[config.advanceSelectionEnabled]]" selection-info="{{selectionInfo}}" page-size="[[pageSize]]"
						 size="[[gridDataSize]]" selection-enabled="[[selectionEnabled]]" multi-selection="[[config.tabular.settings.isMultiSelect]]"
						 r-data-source="[[rDataSource]]" items="[[data]]"  selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" sort-order="{{sortOrder}}"
						 disable-select-all="[[config.tabular.settings.disableSelectAll]]" on-row-dbl-clicked="_rowDblClicked">

							<data-table-column slot="column-slot" name="Actions" width="60px" flex="0" hidden$="[[!_hasActions(config.mode)]]">
								<template>
									<template is="dom-repeat" items="[[_actions()]]" as="col" index-as="colIndex">
										<pebble-button slot="cell-slot-content" class="actionButton" icon="[[_actionValue(colIndex)]]" on-tap="_fireActionEvent" item="[[item]]" index="[[index]]"
										 action-index="[[colIndex]]"></pebble-button>
									</template>
								</template>
								<span id="error-circle[[index]]" class="error-circle" hidden item="[[item]]" index="[[index]]" on-tap="_openPopover" on-mouseenter="_openPopover"> </span>
							</data-table-column>
							<data-table-column slot="column-slot" name="Status" width="60px" flex="0" hidden$="[[!config.statusEnabled]]">
								<template>
									<pebble-icon slot="cell-slot-content" id="rowStatus" icon="{{_getRowStatusIcon(item)}}"></pebble-icon>
								</template>
							</data-table-column>
							<template is="dom-if" if="[[config.readOnly]]" restamp>
								<template is="dom-repeat" items="[[config.tabular.columns]]" as="col" index-as="colIndex">
									<data-table-column slot="column-slot" name="[[col.header]]" column-index="{{colIndex}}" filter-by="[[_isFilterEnabled(col)]]" sort-by="[[_isSortable(col)]]"
									 icon="pebble-md-icons:Edit" class="pebble-md-icons" column-object="[[col]]" width="[[_getColWidth(col)]]">
										<template>

											<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
												<a slot="cell-slot-content" href$="[[_getLink(column.columnObject, item)]]">
													<div class="cell tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
														<span>[[_columnValue(item, column.columnIndex)]]</span>
													</div>
												</a>

											</template>
											<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
												<div slot="cell-slot-content" class="cell tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
													<span>[[_columnValue(item, column.columnIndex)]]</span>
												</div>
											</template>

										</template>
									</data-table-column>
								</template>
							</template>
							<template is="dom-if" if="[[!config.readOnly]]" restamp>
								<template is="dom-repeat" items="[[config.tabular.columns]]" as="col" index-as="colIndex">
									<data-table-column model-object="{{_getAttributeModelObject(col)}}" slot="column-slot" name="[[col.header]]" column-index="{{colIndex}}" filter-by="[[_isFilterEnabled(col)]]" sort-by="[[_isSortable(col)]]"
									 icon="pebble-md-icons:Edit" class="pebble-md-icons" column-object="[[col]]"
									 width="[[_getColWidth(col)]]">
										<template>
											<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
												<a href$="[[_getLink(column.columnObject, item)]]" slot="cell-slot-content">
													<template is="dom-if" if="[[!column.columnObject.readOnly]]">
														<rock-attribute index="[[index]]" item="[[item]]" row-index$="[[index]]" column-index$="[[column.columnIndex]]" functional-mode="grid" id="row[[index]]col[[column.columnIndex]]"
														 class="attribute" mode="[[config.mode]]" attribute-model-object="[[column.modelObject]]" attribute-object="[[_getAttributeObject(item, column.modelObject, column.columnIndex, index)]]"
														 dependent-attribute-model-objects="[[_getDependentAttributeModels(column.modelObject)]]" dependent-attribute-objects="[[_getDependentAttributes(item, column.modelObject, index)]]"
														 on-attribute-value-changed="_updateValue"></rock-attribute>
													</template>
													<template is="dom-if" if="[[column.columnObject.readOnly]]">
														<div data-tooltip$="[[_columnValue(item, column.columnIndex)]]" class="tooltip-bottom">
															<span>[[_columnValue(item, column.columnIndex)]]</span>
														</div>
													</template>
												</a>
											</template>
											<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
												<template is="dom-if" if="[[!column.columnObject.readOnly]]">
													<rock-attribute slot="cell-slot-content" index="[[index]]" item="[[item]]" row-index$="[[index]]" column-index$="[[column.columnIndex]]" functional-mode="grid" id="row[[index]]col[[column.columnIndex]]"
													 class="attribute" mode="[[config.mode]]" attribute-model-object="[[column.modelObject]]" attribute-object="[[_getAttributeObject(item, column.modelObject, column.columnIndex, index)]]"
													 dependent-attribute-model-objects="[[_getDependentAttributeModels(column.modelObject)]]" dependent-attribute-objects="[[_getDependentAttributes(item, column.modelObject, index)]]"
													 on-attribute-value-changed="_updateValue"></rock-attribute>
												</template>
												<template is="dom-if" if="[[column.columnObject.readOnly]]">
													<div slot="cell-slot-content" class="tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
														<span>[[_columnValue(item, column.columnIndex)]]</span>
													</div>
												</template>
											</template>
										</template>
									</data-table-column>
								</template>
							</template>
						</pebble-data-table>
					</template>
					<pebble-popover id="errorPopover" no-overlap>
						<pebble-error-list id="errorList"></pebble-error-list>
					</pebble-popover>
					<bedrock-pubsub target-id="errorList" event-name="fix-error" handler="_fixError"></bedrock-pubsub>
				</template>
				<template is="dom-if" if="{{_isTileMode(config.viewMode)}}" restamp>
					<div hidden="[[_configPresent('tile')]]" class="msg" > Config not present for Tile view of the grid.</div>
					<template is="dom-if" if="[[_configPresent('tile')]]" >
						<grid-tile-view  show-select-all="[[config.tile.settings.isMultiSelect]]"
										result-record-size="{{resultRecordSize}}"
										attribute-model-object="[[attributeModels]]"
										id="gridTileView"
										advance-selection-options="[[config.advanceSelectionOptions]]"
										advance-selection-enabled="[[config.advanceSelectionEnabled]]"
										items="[[data]]"
										grid-tile-data-source="{{rDataSource}}"
										page-size="[[pageSize]]"
										multi-selection="{{config.tile.settings.isMultiSelect}}"
										selected-item="{{selectedItem}}"
										selected-items="{{selectedItems}}"
										tile-items="{{config.tile.tileItems}}"
										actions="{{config.tile.settings.actions}}"
										selection-info="{{selectionInfo}}">
						</grid-tile-view>
					</template>
				</template>
				<template is="dom-if" if="{{_isListMode(config.viewMode)}}" restamp>
					<div hidden="[[_configPresent('list')]]" class="msg" > Config not present for List view of the grid.</div>
					<template is="dom-if" if="[[_configPresent('list')]]" >
						<grid-list-view id="gridListView"  attribute-model-object="[[attributeModels]]" advance-selection-options="[[config.advanceSelectionOptions]]" advance-selection-enabled="[[config.advanceSelectionEnabled]]"
						 items="[[data]]" grid-list-data-source="{{rDataSource}}" page-size="[[pageSize]]" multi-selection="{{config.list.settings.isMultiSelect}}"
						 selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" schema-type="{{config.schemaType}}" list-items="{{config.list.listItems}}"
						 actions="{{config.list.settings.actions}}"
						 selection-info="{{selectionInfo}}"></grid-list-view>
					</template>
				</template>
			</div>
		</template>
		<pebble-dialog id="gridMsgDialog" show-ok show-cancel show-close-icon>
			<p id="msgDialog">
			</p>
		</pebble-dialog>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttonok-clicked" handler="_onDialogOk"></bedrock-pubsub>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttoncancel-clicked" handler="_onDialogCancel"></bedrock-pubsub>
	</template>

	<script>
		(function () {
			'use strict';
			Polymer({
				is: 'rock-grid',
				/**
				 * Fired when the user clicks on a item to select it.
				 *
				 * @event grid-selecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be selected
				 */
				/**
				 * Fired when the user clicks on a item to deselect it.
				 *
				 * @event grid-deselecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be deselected
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to select the items.
				 *
				 * @event grid-selecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to deselect the items.
				 *
				 * @event grid-deselecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on a item to expand it.
				 *
				 * @event grid-expanding-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be expanded
				 */
				/**
				 * Fired when the user clicks on a item to collapse it.
				 *
				 * @event grid-collapsing-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be collapsed
				 */
				properties: {
					/**
					 * Indicates the data which is wrapped in a grid-data-source that is used as a "grid data".
					 * The format for the JSON object is given in the above description.
					 */
					data: {
						type: Array,
						notify: true,
						observer: '_gridDataLoad'
					},
					/**
					 *  If set as true , it indicates the component is in read only mode
					 */
					readonly: {
						type: Boolean,
						value: false		
					},
					/**
					 * Indicates the number of items fetched at a time from the grid-data-source.
					 */
					pageSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates a config object which decides the rendering behavior.
					 * The format for the JSON object is given in the above description.
					 */
					config: {
						type: Object,
						value: function () {
							return {}
						},
						notify: true
					},
					/**
					 * Indicates an identifier of grid-data-source component used for a particular grid.
					 * It requires to reset the grid-data-source for a particular grid.
					 */
					rDataSourceId: {
						type: String,
						value: ''
					},
					/**
					 * Indicates a function that provides items lazily. The function receives the parameters such as `opts`, `callback`, and `err`.
					 *
					 * `opts.page` indicates a requested page index.
					 *
					 * `opts.pageSize` indicates the current page size.
					 *
					 * `opts.filter` indicates the current filter parameters.
					 *
					 * `opts.sortOrder` indicates the current sorting parameters.
					 */
					rDataSource: {
						type: Function,
						notify: true
					},
					/**
					 * Indicates an incremental data size for each page in the grid along with the use of "rDataSource" for virtualization.
					 * The above description depicts on how to increase this `gridDataSize`.
					 **/
					gridDataSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates the total record size of the grid.
					 * The above description depicts on how to increase this `currentRecordSize`.
					 */
					currentRecordSize: {
						notify: true,
						type: Number,
						value: 0
					},
					/**
					 * Indicates the total record size of the data available for the grid.
					 *
					 */

					resultRecordSize: {
						notify: true,
						type: Number,
						value: 0
					},
					/**
					 * Indicates an attribute model to be use if the schema type is an <b>attribute</b>.
					 */
					attributeModels: {
						type: Object,
						value: function () {
							return {};
						}
					},
					/**
					 * Indicates an array that contains the selected items when `multiSelection` is set to true.
					 * It indicates null if no item is selected.
					 */
					selectedItems: {
						type: Array,
						value: function () {
							return [];
						},
						notify: true
					},
					/**
					 * Indicates the currently selected item when `multiSelection` is set to false.
					 * It indicates null if no item is selected.
					 */
					selectedItem: {
						type: Object,
						//value : {},
						notify: true,
						reflectToAttribute: true
					},
					/**
					 * Specifies whether or not multiple items are selected at once. When it is set to <b>true</b>,
					 * you can select multiple items at once. In this case, it indicates an array of currently selected items.
					 * When it is set to <b>false</b>, you can select only one item at a time.
					 */
					multiSelection: {
						type: Boolean,
						value: false,
						notify: true,
						reflectToAttribute: true
					},
					/**
					 * Indicates the title for the grid.
					 */
					title: {
						type: String,
						notify: true
					},
					/**
					 * Indicates an array with a path and a sort order. The <b>`asc`</b> or <b>`desc</b>` pairs
					 * are used to sort the items.
					 */
					sortOrder: {
						type: Array,
						value: function () {
							return [];
						},
						notify: true
					},
					/**
					* Specifies whether or not a row tapping selects the item. If it is set to true, tapping a row selects the item.
	
					*/
					selectionEnabled: {
						type: Boolean,
						value: false
					},
					/**
					 * Specifies whether or not grid header is shown.
					 */
					noHeader: {
						type: Boolean,
						value: false
					},
					/**
					  * <b><i>Content development is under progress... </b></i> 
					  */
					maxConfiguredCount: {
						type: Number,
						value: 0
					},
					isDirty: {
						type: Boolean,
						value: false,
						notify: true,
						reflectToAttribute: true
					},
					_pageRange: {
						value: ""
					},
					_attributeModelMap: {
						type: Object
					},
					selectionInfo: {
						type: Object,
						value: function () { return {} },
						observer: "_onSelectionInfoChange"
					},
					totalCount: {
						type: Number
					},
					selectionTitle: {
						type: String
					},
					_dataTableWidth: {
						type: Number
					},
					minFilterLength: {
						type: Number,
						value: 2
					},
					_toolbarConfig: {
						type: Object,
						value: function() {
							return {};
						}
					},
					isWorkflowCriterion: {
						type: Boolean,
						value: false
					}
				},
				behaviors: [
					RUFBehaviors.UIBehavior
				],
				observers: [
					'_calculatePageRange(currentRecordSize, pageSize,resultRecordSize)',
					'_computeTitle(config, data, currentRecordSize, sortOrder,resultRecordSize,rDataSource,config.viewMode, config.*)',
					'_setSelectionTitle(currentRecordSize,selectionInfo,selectedItems.*)',
					'_setToolbarConfig(config.toolbarConfig, isWorkflowCriterion)',
					'_prepareConfig(config, attributeModels)',
					'_viewModeChanged(config.viewMode)'
				],
				listeners: {
					'selecting-item': '_onSelectingItem',
					'deselecting-item': '_onDeselectingItem',
					'selecting-all-items': '_onSelectingAllItems',
					'deselecting-all-items': '_onDeselectingAllItems',
					'expanding-item': '_onExpandingItem',
					'collapsing-item': '_onCollapsingItem',
					'sort-direction-changed': '_sortDirectionChanged'
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				reloadListData: function () {
					var listView = this.shadowRoot.querySelector("#gridListView");
					if (listView) {
						listView.reloadData();
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				reloadTileData: function () {
					var tileView = this.shadowRoot.querySelector("#gridTileView");
					if (tileView) {
						tileView.reloadData();
					}
				},
				//On selection info change, set the delete button
				_onSelectionInfoChange: function() {					
					if((this.selectionInfo && this.selectionInfo.mode == "query") || this.isWorkflowCriterion) {
						//Disable the toolbar button
						this._setToolbarDeleteAttr("disabled", true);
						return;
					}

					//Enable the toolbar button
					this._setToolbarDeleteAttr("disabled", false);
				},
				// Change the configuration on workflow criterion - Hide delete
				_setToolbarConfig: function() {
					if(!this.config) {
						return;
					}

					if(this.isWorkflowCriterion) {
						var toolbarConfig = DataHelper.cloneObject(this.config.toolbarConfig);
						//Hide button
						var buttons = toolbarConfig.buttonItems[0].buttons;
						for(var i = 0; i < buttons.length; i++) {
							if(buttons[i].name == "bulkdelete") {
								buttons[i].visible = false;
								break;
							}
						}

						this._toolbarConfig = toolbarConfig;
						return;
					}

					this._toolbarConfig = this.config.toolbarConfig;
				},
				_setToolbarDeleteAttr: function(attribute, addAttr) {
					var toolBar = this.shadowRoot.querySelector("#gridToolbar");

					if(!toolBar) {
						return;
					} else {
						var deleteButton = toolBar.shadowRoot.querySelector("pebble-button#bulkdelete");
						if(!deleteButton) {
							return;
						}
					}

					if(addAttr) {
						deleteButton.setAttribute(attribute, "");
					} else {
						deleteButton.removeAttribute(attribute);
					}
				},
				_onToolbarEvent: function (e, detail) {
					var event = detail.name;

					switch (event.toLowerCase()) {
						case "refresh":
							this._onRefresh(e, detail);
							break;
						case "edit":
							this.changeToEditMode(e, detail);
							break;
						case "bulkedit":
							this._onBulkEdit(e, detail);
							break;
						case "addrow":
							this._addNewRow(e, detail);
							break;
						case "download":
							this._onDownload(e, detail);
							break;
						case "upload":
							this._onUpload(e, detail);
							break;
						case "bulkdelete":
							this._onBulkDelete(e, detail);
							break;
						case "pagerange": // Just display, so no functionality here
							break;
						default:
							this.fireBedrockEvent("grid-custom-toolbar-event", detail);
							break;
					}
				},
				_addNewRow: function (e, detail) {
				    //only to be used with tabular view static mode
					var newItem = {};
					newItem.status = 'new';
					newItem.errors = [];
					var oldsize = this.currentRecordSize;
					var data = this.getData();
					data.unshift(newItem);
					this.data = data;
					this._getIronDataTable()._sizeChanged(oldsize + 1, oldsize);
					this._getIronDataTable()._resetData(this.rDataSource);
					this.editInline(0);
				},
				_prepareConfig: function (config, attributeModel) {
					if(config && attributeModel) {
						if(config.tabular && config.tabular.columns) {
							config.tabular.columns.forEach(function(column){
								column.headerDescription = this._extractHeaderDescription(column);
							}.bind(this));
						}
					}
				},
				_extractHeaderDescription: function (column) {
					var descriptionObject = {};
					var attributeModel = this._getAttributeModelObject(column);
					if (attributeModel && attributeModel.properties) {
						descriptionObject.description = attributeModel.properties.description;
					}
					return descriptionObject;
				},
				/**
				 * Can be used to add the new rows to the grid.
				 */
				addNewRows: function (noOfRows) {
					for (var i = 0; i < noOfRows; i++) {
						var newItem = {};
						newItem.status = 'new';
						var data = this.getData();
						data.unshift(newItem);
					}
					this.data = data;
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						var oldSize = ironDataTable.size;
						ironDataTable.size = oldSize + noOfRows.length;
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
                addNewRecords: function (records) {
//                  Only to be used with tabular mode
                    if (records && records.length > 0) {
                        var ironDataTable = this._getIronDataTable();
                        if(this.rDataSourceId){
                            if(ironDataTable) {
                                records.forEach(function (record) {
                                    record._rowStatus = {
                                        "status": "new",
                                        "statusIcon": "pebble-sm-icons:Add"
                                    };
                                    ironDataTable.unshift("_cachedItems", record);
                                }, this);
                                this.currentRecordSize=records.length+ironDataTable.size;
                            }
                        } else {
                            var data = this.getData();
                            records.forEach(function (record) {
                                record._rowStatus = {
                                    "status": "new",
                                    "statusIcon": "pebble-sm-icons:Add"
                                };
                                data.unshift(record);
                            }, this);
                            this.data = data;
                            if (ironDataTable) {
                                var oldSize = ironDataTable.size;
                                ironDataTable.size = oldSize + data.length;
                            }
                            this.reRenderGrid();
                        }

                        //TODO:: This has been added for temporary for 24th April release
                        //When user adds new record since that is not part of current grid,
                        //change to edit mode is taking all current rock-attribute and start setting mode = edit for them.
                        //So because of that it's not behaving properly so making this temporary fix.
                        setTimeout(function () {
                            this.changeToEditMode();
                        }.bind(this), 500);
                    }
                },

                /**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getIsDirty: function () {
					var data = this.getData();
					if (data && data.length > 0) {
						for (var i = 0; i < data.length; i++) {
							if (data[i]._rowStatus && data[i]._rowStatus.status) {
								if (data[i]._rowStatus.status == "update" || data[i]._rowStatus.status == "new") {
									return true;
								}
							}
						}
					}

					return false;
				},
				getControlIsDirty: function () {
					var controlDirty = false;
					var selectedItems = this.getSelectedItems();
					if(selectedItems.length>0){
						controlDirty = true;
					}
					
					var editMode = false;
					if(this.get('config.mode') == "edit"){
						editMode = true;
					}
					var rockAttributeObj = Polymer.dom(this.root).querySelectorAll('rock-attribute');
					var rockAttributeDirty = false;
					if (rockAttributeObj && rockAttributeObj.getControlIsDirty) {
						rockAttributeDirty = rockAttributeObj.getControlIsDirty();
					}

					if(controlDirty || rockAttributeDirty || editMode) {
						return true;
					}
					
					return false;				
				},
				refresh: function(){
					this._onRefresh();
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				revertData: function () {
					this.set('config.mode', "read");

					var attrs = this.shadowRoot.querySelectorAll('rock-attribute');
					if (attrs && attrs.length) {
						for (var i=0;i<attrs.length;i++) {
							attrs[i].mode = "read";
						}
					}

					var data = this.getData();
					var filteredData = [];

					if (data && data.length > 0) {
						filteredData = data.filter(function (item) {
							if (item._rowStatus) {
								if (item._rowStatus.status) {
									if (item._rowStatus.status != "new") {
										if (item._rowStatus.status == "update") {
											this._setOriginalValue(item);
										}
										item._rowStatus = {
											"statusIcon": ""
										};
										return item;
									}
								} else {
									item._rowStatus = {
										"statusIcon": ""
									};
									return item;
								}
							} else {
								item._rowStatus = {
									"statusIcon": ""
								};
								return item;
							}
						}.bind(this));
					}

					this.data = [];
					this.data = filteredData;

					this.reRenderGrid();
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getData: function () {
					if (this.config.viewMode == "List" ) {
                       var  listView = this.shadowRoot.querySelector("#gridListView");
                       if(listView) {
                           return listView.items;
                       }
					} else if ( this.config.viewMode == "Tile"){
                        var  tileView = this.shadowRoot.querySelector("#gridTileView");
                        if(tileView) {
                            return tileView.items;
                        }
					}else {
						var filteredData = [];
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
                            if(this.data && this.data.length > 0) {
                                return ironDataTable.items;
                            }
							var allData = ironDataTable.$.list.items;
							if (allData && allData.length > 0) {
								var sumedLength = allData.length - this.pageSize;
								var lastPageData;
								if(sumedLength > 0){
								 	lastPageData = allData.slice(allData.length - this.pageSize, allData.length);
								}else{
									lastPageData = allData;
								}
								var lastPageFilteredData = lastPageData.filter(function (element) {
									if (element != undefined) {
										var keys = Object.keys(element);
										if (!(keys.length <= 0 || (keys.length == 1 && keys[0] == "errors"))) {
											return element;
										}
									}
								});
								if (allData.length > this.pageSize) {
									filteredData = allData.slice(0, allData.length - this.pageSize);
									if (lastPageFilteredData && lastPageFilteredData.length) {
										lastPageFilteredData.forEach(function (item) {
											filteredData.push(item);
										}, this);
									}
								} else {
									filteredData = lastPageFilteredData;
								}
							}
						}
						return filteredData;
					}
				},
				/*
 				 * Can be used to get updated rows from the grid.
 				 */
				getModifiedData: function () {
					var modifiedData = [];
					var gridData = this.getData();
					if (gridData && gridData.length > 0) {
						gridData.forEach(function (data) {
							if (!_.isEmpty(data["_rowStatus"])) {
								var _status = data["_rowStatus"]["status"];
								if (!_.isEmpty(_status)) {
									if (_status == "update" || _status == "new" || _status == "delete") {
										modifiedData.push(data);
									}
								}
							}
						}, this);
					}
					return modifiedData;
				},
				/*
				 * Can be used to re-render the grid.
				 */
				reRenderGrid: function () {
					if (!this.config) {
						return;
					}
					if (typeof (this.rDataSource) == 'function') {
						if (this.rDataSourceId) {
							var dataSourceElement = Polymer.dom(this).node.parentNode.querySelector('#' + this.rDataSourceId);
							if (dataSourceElement) {
								dataSourceElement.resetDataSource();
							}
						}
						if (this.config.viewMode == "List") {
							this.reloadListData();
						} else if (this.config.viewMode == "Tile") {
							this.reloadTileData();
						} else {
							if (this._getIronDataTable()) {
								this._getIronDataTable()._resetData(this.rDataSource);
							}
						}
					} else {
						var self = this;
						this.fireBedrockEvent('refresh-grid', self);
					}

					this._resetAdvanceSelection();
				},
				_resetAdvanceSelection: function () {
					if (this.config.viewMode == "Tabular") {
						var getpebbleDataTable = this.shadowRoot.querySelector("#pebbleDataTable");
						if (getpebbleDataTable && getpebbleDataTable.resetAdvanceSelection) {
							getpebbleDataTable.resetAdvanceSelection();
						}
					} else if (this.config.viewMode == "List") {
						var getgridListView = this.shadowRoot.querySelector("#gridListView");
						if (getgridListView && getgridListView.resetAdvanceSelection) {
							getgridListView.resetAdvanceSelection();
						}
					} else if (this.config.viewMode == "Tile") {
						var getgridTileView = this.shadowRoot.querySelector("#gridTileView");
						if (getgridTileView && getgridTileView.resetAdvanceSelection) {
							getgridTileView.resetAdvanceSelection();
						}
					}
				},
				/**
				 * Can be used to clear the cached pages and reload the data from the data-source when needed.
				 */
				clearCache: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.clearCache();
				},
				/**
				 * Can be used to clear the cache for a page and reload the data from the data-source.
				 */
				refreshPage: function (page) {
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						ironDataTable.refreshPage(page);
					}
				},
				/*
				 * Can be used to select all the items in the list.
				 */
				selectAll: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.selectAll();
				},
				/**
				 * Can be used to clear the current selection state.
				 */
				clearSelection: function () {
					if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						if (listView) {
							listView.clearSelection();
						}
					} else if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						if (tileView) {
							tileView.clearSelection();
						}
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.clearSelection();
					}
				},
				/**
				 * Can be used to select the list item at the given index.
				 *
				 * @method selectItem
				 * @param {(Object|number)} item The item object or its index
				 */
				selectItem: function (item) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						tileView.selectItem(item);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						listView.selectItem(item);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.selectItem(item);
					}
				},
				/**
				 * Can be used to deselect the given item list if it is already selected.
				 *
				 * @method deselect
				 * @param {(Object|number)} item The item object or its index
				 */
				deselectItem: function (item) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("gridTileView");
						tileView.deselectItem(item);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("gridListView");
						listView.deselectItem(item);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.deselectItem(item);
					}
				},
				/**
				 * Can be used to expand the row details for this item if it is available.
				 */
				expandItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.expandItem(item);
				},
				/**
				 * Can be used to collapse the row details for this item if it is expanded.
				 */
				collapseItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.collapseItem(item);
				},
				/**
				 * Can be used to return the array of `selectedItems`.
				 * When `multiSelection` is set to true, then the array contains the selected items.
				 * @return {Array<object>} The `selectedItems` is an array of objects and other properties as below.
				 * If `selectedItems.inverted` is `true`, then the array contains deselected items.
				 * The `selectedItems.filters` contains an array of filters that are active when the selection changes.
				 */
				getSelectedItem: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.selectedItem;
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getSelectedItems: function () {
					if (!this.selectedItems.inverted) {
						return this.selectedItems;
					} else {
						var items = this.getData();
						this.selectedItems.forEach(function (item) {
							var index = items.indexOf(item);
							if (index > -1) {
								items.splice(index, 1);
							}
						});
						return items;
					}
				},
				/**
				 * Can be used to change the mode to edit mode.
				 *
				 */

				getSelectionMode: function () {
					if (this.selectionInfo && this.selectionInfo.mode) {
						return this.selectionInfo.mode;
					}
					return 'count';//default value
				},


				changeToEditMode: function (e, detail) {
					this.set('config.mode', "edit");
					this._dataChanged();
					var attrs = this.shadowRoot.querySelectorAll('rock-attribute');
					for (var i=0;i<attrs.length;i++) {
						attrs[i].mode = "edit";
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				changeToReadMode: function () {
					this.set('config.mode', "read");

					var attrs = this.shadowRoot.querySelectorAll('rock-attribute');
                    if (attrs && attrs.length) {
                        for (var i=0;i<attrs.length;i++) {
                            attrs[i].mode = "read";
                        }
                    }

					var data = this.data;
					if (data && data.length) {
						data.forEach(function (item) {
							if (item._rowStatus) {
								if (item._rowStatus.status && item._rowStatus.status == "new" || item._rowStatus.status == "update") {
									item._rowStatus.status = "read";
									item._rowStatus.statusIcon = "";
								}
							}
						}, this);
						this.data = [];
						this.data = data;
					}
					this.reRenderGrid();
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				openGridMsgDialog: function (msg) {
					this.shadowRoot.querySelector('p[id="msgDialog"]').innerText = msg;
					this.$.gridMsgDialog.open();
				},
				_computeTitle: function (config, data, currentRecordSize, sortOrder) {
                    var status = "";
					if (config && config.header && config.header.displayTitle) {
						if (config.title) {
							this.set('title', config.title);
						}
						this.set('title', config.header.defaultValue);
					} else if (currentRecordSize) {
						var resultRecordSize = this.resultRecordSize ? this.resultRecordSize : currentRecordSize;
						if (resultRecordSize != 0 && resultRecordSize == this.maxConfiguredCount) {
							resultRecordSize = this.maxConfiguredCount + "+";
						}
						status = "Showing 1 - " + currentRecordSize + " items of total " + resultRecordSize + " results ";
						if (data && sortOrder && sortOrder.length > 0) {
							status += ' Sorted by ';
							//TODO:: Commented code for now since system doesn't support multiple column support.
							//for (var i = 0; i < sortOrder.length; i++) {
							var sort = sortOrder[sortOrder.length - 1];
							status += sort.path + ' ' + sort.direction;
							// if (i < sortOrder.length - 1) {
							// 	status += ', ';
							// }
							//}
						}

					} else {
						status = "Showing 0 result ";
					}
					if(config) {
						if (config.titleTemplates) {
							if (config.titleTemplates.contextTemplate) {
								var matchFound = false;
								var message = config.titleTemplates.contextTemplate.replace(/\{\S+?\}/g,
									function (match) {
										var attrName = match.replace("{", "").replace("}", "");
										if (config.dataContexts) {
											for (var i = 0; i < config.dataContexts.length; i++) {
												var context = config.dataContexts[i];
												if (context[attrName]) {
													if (matchFound) {
														match += ", " + context[attrName];
													} else {
														match = context[attrName];
														matchFound = true;
													}

												}
											}
										}
										if (config.valueContexts) {
											for (var i = 0; i < config.valueContexts.length; i++) {
												var context = config.valueContexts[i];
												if (context[attrName]) {
													if (matchFound) {
														match += context[attrName];
													} else {
														match = context[attrName];
														matchFound = true;
													}
												}
											}
										}
										return match;
									});
								if (matchFound) {
									status += message;
								}
							}
						}

						if (config.workflowTitle) {
							status += ": " + config.workflowTitle;
						}
					}
					this.set('title', status);
				},
				_calculatePageRange: function (currentRecordSize, pageSize, resultRecordSize) {
					if (!(currentRecordSize === undefined || pageSize === undefined || resultRecordSize === undefined)) {
						var from = currentRecordSize && currentRecordSize > 0 ? 1 : 0;

						if (resultRecordSize) {
							this._pageRange = from + " - " + currentRecordSize + " / " + (resultRecordSize > 0 && resultRecordSize == this.maxConfiguredCount ? this.maxConfiguredCount + "+" : resultRecordSize);
						} else {
							this._pageRange = from + " - " + currentRecordSize + " / " + currentRecordSize;
						}

						//Set range to pebble-toolbar
						if (this.shadowRoot.querySelector('pebble-toolbar') && this.shadowRoot.querySelector('pebble-toolbar').shadowRoot.querySelector('pebble-button#pageRange')) {
							this.shadowRoot.querySelector('pebble-toolbar').shadowRoot.querySelector('pebble-button#pageRange').buttonText = this._pageRange;
						}
					}
				},
				_columnValue: function (gridData, index) {
					var cellData;
					var columnName = this.config.tabular.columns[index].name;
					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
						"colModel") {
						cellData = this._formatValue(gridData[columnName], columnName);
					} else if (this.config.schemaType == "attribute") {
						if (gridData.attributes && gridData.attributes.hasOwnProperty(columnName)) {
							cellData = this._formatValue(gridData.attributes[columnName].value, columnName);
						}
					}
					if (cellData != undefined) {
						index++;
					}
					if (typeof (cellData) === "boolean") {
						return cellData.toString();
						//Had to manually convert to string because pebble-boolean is not working when you pass boolean.
					}
					return cellData;
				},
				_formatValue: function (value, columnName) {
					if (this.attributeModels.hasOwnProperty(columnName)) {
						var dataType = this.attributeModels[columnName].dataType.toLowerCase();

						if (dataType == "datetime" || dataType == "date") {
							return FormatHelper.convertFromISODateTime(value, dataType);
						}
					}

					return value;
				},
				_isTabularMode: function (viewMode) {
					return viewMode == 'Tabular';
				},
				_isTileMode: function (viewMode) {
					return viewMode == 'Tile';
				},
				_isListMode: function (viewMode) {
					return viewMode == 'List';
				},
				_getAttributeModelObject: function (col) {
					var displayType = "";
					if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
						if (!col.displayType) {
							col.displayType = col.editType;
						}

						return col;
					} else if (this.config.schemaType == "attribute" || this.config.schemaType == "colModel") {
						if (this.attributeModels[col.name]) {
							return this.attributeModels[col.name];
						}
						else {
							return {};
						}
					}
				},
				_getAttributeObject: function (item, currentAttributeModelObject, columnIndex, index) {
					var attributeObject = {
						"name": currentAttributeModelObject.name,
						"value": this._columnValue(item, columnIndex)
					};
					var columnName = this.config.tabular.columns[columnIndex].name;
					if(this.config.schemaType == "attribute" && item.attributes && item.attributes.hasOwnProperty(columnName) && item.attributes[columnName].referenceDataId) {
						attributeObject["referenceDataId"] = item.attributes[columnName].referenceDataId;
					}
					if(this.config.schemaType == "colModel" && item[columnName + "_referenceDataId"]) {
						attributeObject["referenceDataId"] = item[columnName + "_referenceDataId"];
					}
					if (this.config.tabular.columns.length == columnIndex + 1) {
						 Polymer.Async.microTask.run(() => {
							this._updateError(item, index);
						})
					}

					return attributeObject;
				},
				_isFilterEnabled: function (col) {
					return col.filterable ? col.name : undefined;
				},
				_isSortable: function (col) {
					return col.sortable ? col.name : undefined;
				},
				_dataIsNotNull: function (config, attributeModels) {
					var result = typeof (config) == "object" && Object.keys(config).length ? true : false;
					if (result && (config.schemaType == "attribute" || config.schemaType == "colModel") && Object.keys(attributeModels).length == 0) {
						result = false;
					}

					return result;
				},
				_onRefresh: function (e, detail) {
					this.reRenderGrid();
				},
				_onBulkEdit: function (e) {
					this.fireBedrockEvent("grid-bulk-edit-items");
				},
				_onBulkDelete: function (e) {
					this.fireBedrockEvent("grid-bulk-delete-items", e.detail);
				},
				_onDownload: function (e) {
					this.fireBedrockEvent("grid-download-item");
				},
				_onUpload: function (e, detail) {
					//this.clearSelection();
					this.fireBedrockEvent("grid-upload-item");
				},
				_getIronDataTable: function () {
					return ElementHelper.getElement(this, "pebble-data-table");
				},
				_onSelectingItem: function (e) {
					this.fireBedrockEvent("grid-selecting-item", e.detail);
				},
				_onDeselectingItem: function (e) {
					this.fireBedrockEvent("grid-deselecting-item", e.detail);
				},
				_onSelectingAllItems: function (e) {
					this.fireBedrockEvent("grid-selecting-all-items", e.detail);
				},
				_onDeselectingAllItems: function (e) {
					this.fireBedrockEvent("grid-deselecting-all-items", e.detail);
				},
				_onExpandingItem: function (e) {
					this.fireBedrockEvent("grid-expanding-item", e.detail);
				},
				_onCollapsingItem: function (e) {
					this.fireBedrockEvent("grid-collapsing-item", e.detail);
				},
				_dataChanged: function () {
					//TO-DO will get changed
					this.dispatchEvent(new CustomEvent('editMode',{bubbles:true,composed:true}));
				},
				_actionValue: function (index) {
					var action = this.config.tabular.settings.actions[index];
					var icon = action.icon;
					if (!icon) {
						if (action.name == 'delete') {
							return 'pebble-md-icons:Delete';
						} else if (action.name == 'edit') {
							return 'pebble-md-icons:Edit'
						} else {
							return '';
						}
					}
					return icon;
				},
				_updateValue: function (e) {
					var columnIndex = typeof e.target.column === 'undefined' ? e.srcElement.__dataHost.column.columnIndex : e.target.column.columnIndex;
					var item = e.target.item;
					var value = e.detail.value;
					var columnName = this.config.tabular.columns[columnIndex].name;
					var row = this._getParentRow(e.currentTarget);
					var status = "";
					var referenceDataId = e.detail.referenceDataId ? e.detail.referenceDataId : undefined;

					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType == "colModel") {
						var columnOriginalValue = columnName + "_originalValue";

						if (item[columnOriginalValue] || item[columnOriginalValue] == "") {
							if (item[columnOriginalValue] != value) {
								status = "update";
							} else {
								status = "read";
							}
						} else {
							item[columnOriginalValue] = item[columnName] ? item[columnName] : "";
							status = "update";
						}
						item[columnName] = value;
						if(referenceDataId) {
							item[columnName + "_referenceDataId"] = referenceDataId;
						}

						this._updateRowStatus(item, status);

					} else if (this.config.schemaType == "attribute") {
						if (item.attributes.hasOwnProperty(columnName)) {
							if (item.attributes[columnName]._originalValue || item.attributes[columnName]._originalValue == "") {
								if (item.attributes[columnName]._originalValue != value) {
									status = "update";
								} else {
									status = "read";
								}
							} else {
								item.attributes[columnName]._originalValue = item.attributes[columnName] && item.attributes[columnName].value ? item.attributes[columnName].value : "";
								status = "update";
							}
							item.attributes[columnName].value = value;
							this._updateRowStatus(item, status);
						}
					}

					if (row) {
						var rowStatusIcon = row.querySelector('pebble-icon[id="rowStatus"]');
						if (rowStatusIcon && item._rowStatus) {
							if (item._rowStatus.status == "update") {
								item._rowStatus.statusIcon = rowStatusIcon.icon = "pebble-icons:Edit";
							} else if (item._rowStatus.status == "read") {
								item._rowStatus.statusIcon = rowStatusIcon.icon = "";
							}
						} else {
							rowStatusIcon.icon = "";
							item._rowStatus = {
								"statusIcon": ""
							};
						}
					}
					var index = e.currentTarget.index;
					Polymer.Async.microTask.run(() => {
						this._updateError(item, index);
					});
					this.notifyPath("isDirty", undefined);
					this.isDirty = this.getIsDirty();

					var attribute = e.currentTarget || e.sourceElement;
					var isRevertClicked = e.detail.revertClicked;
					this._updateDependentAttributes(attribute, row.index, isRevertClicked);
				},

				_updateDependentAttributes: function(currentAttribute, rowIndex, isRevertButtonClicked) {
                    var dependentAttributeElements = this.getDependentAttributeElementsInRow(currentAttribute, rowIndex);
					DataHelper.updateDependentAttributeElements(dependentAttributeElements, currentAttribute, isRevertButtonClicked);
                },

				getDependentAttributeElementsInRow: function(currentAttribute, rowIndex) {
					var node = Polymer.dom(this).node;
                    var allAttributeElements = Polymer.dom(this).node.querySelectorAll('rock-attribute[row-index="' + rowIndex + '"]');
                    if(allAttributeElements == undefined || allAttributeElements.length == 0) {
                        allAttributeElements = Polymer.dom(this).node.root.querySelectorAll('rock-attribute[row-index="' + rowIndex + '"]');
					}

                    return DataHelper.getDependentAttributesOfAttribute(allAttributeElements, currentAttribute);
				},
				_fireActionEvent: function (e) {
					var action = this.config.tabular.settings.actions[e.currentTarget.actionIndex];
					var eventName = action.eventName;
					if (!eventName) {
						if (action.name == 'delete') {
							eventName = "grid-delete-item";
						} else if (action.name == 'edit') {
							eventName = "grid-edit-item";
						} else {
							return;
						}
					}
					if (action.name == "edit") {
						this.editInline(e.currentTarget.index);
						e.currentTarget.item.index = e.currentTarget.index;
						this._dataChanged();
					}
					if(action.name == "delete") {
						var row = this._getParentRow(e.currentTarget);
						this._markRowAsDelete(row);
						this.changeRowToViewMode(e.currentTarget.index);
					}
					this.fireBedrockEvent(eventName, e.currentTarget.item);
				},
				_markRowAsDelete: function(row) {
					if(row) {
						var rowStatusIcon = row.querySelector('pebble-icon[id="rowStatus"]');
						rowStatusIcon.icon = "pebble-md-icons:Delete";
						var item = row.item;
						if(item && item._rowStatus) {
							item._rowStatus.statusIcon = "pebble-md-icons:Delete";
							item._rowStatus.status = "delete";
						}						
					}
				},
				_hasActions: function (mode) {
					if (this.config && this.config.tabular && this.config.tabular.settings && this.config.tabular.settings.actions && this.config.tabular.settings.actions.length > 0 && mode==="edit") {
						return true;
					}
					return false;
				},
				_actions: function () {
					var actions = undefined;

					if (this.config.tabular.settings) {
						var actions = this.config.tabular.settings.actions;

						if (this.config.hasWritePermission != undefined && !this.config.hasWritePermission) {
							for (var action in actions) {
								if (actions[action].name == "delete") {
									actions.splice(action, 1);
								}
							}
						}
					}

					return actions;
				},
				_updateError: function (item, index) {
					var errors = [];
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.shadowRoot.querySelector("#row" + index + "col" + i);
						if (attr && attr.errors.length > 0) {
							var errorObj = {};
							errorObj.name = this.config.tabular.columns[i].name;
							errorObj.externalName = this.config.tabular.columns[i].header;
							errorObj.type = "error";
							errorObj.message = attr.errors;
							errorObj.index = index;
							errors.push(errorObj);
						}
					}
					item.errors = errors;
					var errorLength = errors.length;
					var sp = this.shadowRoot.querySelector("#error-circle" + index);
					if (sp) {
						if (errorLength) {
							sp.hidden = false;
							sp.textContent = errorLength;
						} else {
							sp.hidden = true;
						}
					}
				},
				_openPopover: function (e) {
					var sp = e.currentTarget;
					var item = e.currentTarget.item;
					var index = e.currentTarget.index;
					var popover = this.shadowRoot.querySelector("#errorPopover");
					popover.positionTarget = sp;
					popover.setAttribute("for", "error-circle" + index);
					popover.querySelector("pebble-error-list").errors = item.errors;
					popover.show();
				},
				// Can be used to change the mode of a row to the edit mode.
				editInline: function (index) {
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.shadowRoot.querySelector("#row" + index + "col" + i);
						if (attr) {
							attr.mode = 'edit';
						}
					}
				},
				// Can be used to change the mode of a row to the read mode.
				changeRowToViewMode: function (index) {
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.shadowRoot.querySelector("#row" + index + "col" + i);
						if (attr) {
							attr.mode = 'read';
						}
					}
				},
				_gridDataLoad: function () {
					if (this.data) {
						this.gridDataSize = this.currentRecordSize = this.data.length;
					}
				},
				_onDialogOk: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-ok", e);
				},
				_onDialogCancel: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-cancel", e);
				},
				_getParentRow: function (element) {
					if (element) {
						if (element.is == "data-table-row") {
							return element;
						} else {
							return this._getParentRow(element.parentNode);
						}
					}
					return undefined;
				},
				_setOriginalValue: function (element) {
					if (element) {
						if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
							"colModel") {
							Object.keys(element).forEach(function (item) {
								if (element[item + "_originalValue"] || element[item + "_originalValue"] == "") {
									element[item] = element[item + "_originalValue"];
								}
							}, this);

						} else if (this.config.schemaType == "attribute") {
							for (var attrKey in element.attributes) {
								if (element.attributes[attrKey]._originalValue || element.attributes[attrKey]._originalValue == "") {
									element.attributes[attrKey].value = element.attributes[attrKey]._originalValue;
								}
							}
						}
					}
				},
				_getRowStatusIcon: function (item) {
					if (item && Object.keys(item).length > 0) {
						var icon = "";
						if (item && item._rowStatus) {
							if (item._rowStatus.statusIcon) {
								icon = item._rowStatus.statusIcon;
							} else {
								item._rowStatus.statusIcon = "";
							}
						} else {
							item._rowStatus = {
								"statusIcon": ""
							}
						}
						return icon;
					}
				},
				_updateRowStatus: function (item, status) {
					if (item) {
						if(status == "read") {
							if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType == "colModel") {
								var keys = Object.keys(item);
								if(keys && keys.length > 0) {
									for(var i=0; i<keys.length; i++) {
										var columnName = keys[i];
										if(this.attributeModels[columnName] && item[columnName + "_originalValue"] && item[columnName] && item[columnName + "_originalValue"].toString() !== item[columnName].toString()) {
											status = "update";
										} else {
											continue;
										}
									}
								}
							}
						}
						if (item._rowStatus) {
							if (item._rowStatus.status) {
								if (item._rowStatus.status != "new") {
									item._rowStatus.status = status;
								}
							} else {
								item._rowStatus.status = status;
							}
						} else {
							item._rowStatus = {
								"status": status
							}
						}
					}
				},

				_getLink: function (col, item) {
					var _this = this;
					
					if(col.linkTemplate) {
						return col.linkTemplate.replace(/\{\S+?\}/g,
						function (match) {
							var attrName = match.replace("{", "").replace("}", "");
							if (attrName.toLowerCase() == "id") {
								return encodeURIComponent(item.id);
							}
							if (attrName.toLowerCase() == "type") {
								return encodeURIComponent(item.type);
							}

							var colModels = _this.config.tabular.columns;
							var index = -1;
							for (var i = 0; i < colModels.length; i++) {
								if (colModels[i].name == attrName) {
									index = i;
									break;
								}
							}
							if (index > -1) {
								return encodeURIComponent(_this._columnValue(item, index));
							}
							return encodeURIComponent(match);
						});
					}

					return "";
				},

				_hasLinkTemplate: function (col, item) {
					if (col.linkTemplate && col.linkTemplate != "") {
						var notEditable = (this.config && this.config.mode && this.config.mode.toLowerCase() != "edit") || (item.mode && item.mode.toLowerCase() !=
							"edit");
						if (notEditable) {
							return true;
						}
					}
					return false;
				},

				/**
				 * Can be used to set the multi-selection on the grid.
				 */
				setMultiSelection: function (flag) {
					if (flag != undefined) {
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							ironDataTable.multiSelection = flag;
						}
					}
				},

				/**
				 * Can be used to reset the grid size.
				 */
				notifyResize: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.notifyResize()
				},

				/**
				 * Can be used to set the scroll position dynamically.
				 */
				scrollToIndex: function (index) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						tileView.scrollToIndex(index);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						listView.scrollToIndex(index);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.shadowRoot.querySelector('#list').scrollToIndex(index);
					}
				},

				/**
				 * Can be used to get the selected grid row.
				 */
				getSelectedGridRow: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.querySelector('data-table-row[selected]');
				},

				/**
				 * Can be used to get the selected item index.
				 */
				getSelectedItemIndex: function () {
					if (this.getData().length > 0 && this.selectedItem) {
						return this.getData().indexOf(this.selectedItem);
					}

					return -1;
				},
				_fixError: function (e, detail) {
					var errors = detail.data;
					if (errors.length) {
						this.editInline(errors[0].index);
					}
					this.shadowRoot.querySelector("#errorPopover").hide();
				},			
				_getDataSourceElement: function () {
					var dataSourceElement;
					if (this.rDataSourceId) {
						dataSourceElement = Polymer.dom(this).node.parentNode.querySelector('#' + this.rDataSourceId);
					}
					return dataSourceElement
				},
				_sortDirectionChanged: function (e) {
					if (e.detail && !e.detail.direction) {
						this.sortOrder = [];
					}
					var dataSourceElement = this._getDataSourceElement();
					if (dataSourceElement) {
						dataSourceElement.resetDataSource();
					}
					this._resetAdvanceSelection();
				},
				_setSelectionTitle: function (currentRecordSize, selectionInfo) {
					var startStatusMsg = '('
					var endStatusMsg = 'selected )'
					var selectionMode = this.getSelectionMode();
					var selectedItems = this.getSelectedItems();
					this.selectionTitle = '';
					if (selectedItems.length > 0) {
						if (selectionMode == 'query') {
							var totalCount = this.totalCount.toString();

							if (this.totalCount > 0) {
								this.selectionTitle = startStatusMsg + ' ' + totalCount + ' ' + endStatusMsg;
							}
						} else {
                            this.selectionTitle = startStatusMsg + ' ' + selectedItems.length + ' ' + endStatusMsg;
                        }
					}
				},
				getSelectedItemsAsQuery: function (e) {
					var queryObject = {};
					var dataSourceElement = this._getDataSourceElement();
					var selectionMode = this.getSelectionMode();

					if (dataSourceElement && dataSourceElement.request && dataSourceElement.request.params) {
						var searchQueryRequest = dataSourceElement.request;
						var searchQueryParams = searchQueryRequest.params;
						if (selectionMode == 'query') {
							queryObject = DataHelper.cloneObject(searchQueryRequest);
						} else if (selectionMode == 'count') {
							var selectedItems = this.getSelectedItems();
							if (selectedItems && selectedItems.length > 0) {
								var entityIds = [];
								for (var i = 0; i < selectedItems.length; i++) {
									entityIds.push(selectedItems[i].id);
								}
								queryObject.ids = entityIds;
								queryObject.filters = {};
								if (searchQueryParams && searchQueryParams.isCombinedQuerySearch) {
									if (searchQueryRequest.entity.data && searchQueryRequest.entity.data.jsonData) {
										var searchQueries = searchQueryRequest.entity.data.jsonData.searchQueries;
										for (var i = 0; i < searchQueries.length; i++) {
											if (searchQueries[i].serviceName === "entityservice") {
												queryObject.filters.typesCriterion = searchQueries[i].searchQuery.query.filters.typesCriterion;
												break;
											}
										}
									}
								} else {
									queryObject.filters.typesCriterion = searchQueryParams.query.filters.typesCriterion;
								}
							}
						}
					}
					return queryObject;
				},
				_getColWidth: function (col) {
					if (col.width) {
						if (!this._dataTableWidth) {
							var dataTable = this._getIronDataTable();
							this._dataTableWidth = dataTable && dataTable.clientWidth ? dataTable.clientWidth : undefined
						}
						if (this._dataTableWidth && this._dataTableWidth > 100) {
							return (this._dataTableWidth * col.width) / 100 + "px";
						}
					}
				},
				_getDependentAttributeModels: function(currentAttributeModel) {
					return DataHelper.getDependentAttributeModels(this.attributeModels, currentAttributeModel);
				},
				_getDependentAttributes: function(item, currentAttributeModel, index) {
                    var dependentAttributeModels = DataHelper.getDependentAttributeModels(this.attributeModels, currentAttributeModel);
					var dependentAttributeValues = [];

					var gridColumns = this.config.tabular.columns;
                    if(gridColumns && gridColumns.length && dependentAttributeModels && dependentAttributeModels.length) {
                        for(let i = 0; i < dependentAttributeModels.length; i++) {

                            var dependentAttributeModel = dependentAttributeModels[i]
                            for(let colIndex = 0; colIndex < gridColumns.length; colIndex++) {
                                if(dependentAttributeModel.name === gridColumns[colIndex].name) {
									dependentAttributeValues.push(this._getAttributeObject(item, dependentAttributeModel, colIndex, index));
                                    break;
                                }
                            }
                        }
                    }

                    return dependentAttributeValues
                },
                _rowDblClicked:function (e) {
					var detail=e.detail;
					if(detail && detail.item) {
					    if(this.config && this.config.mode =="edit"){
					        return;
						}
                        var item = detail.item;
                        if (DataHelper.isValidObjectPath(this.config, 'tabular.settings.linkTemplate')) {
                            var link = this._getLink(this.config.tabular.settings, item);
                            window.history.pushState("", "", link);
                            window.dispatchEvent(new CustomEvent('location-changed'));
                        }
                    }
                },
				_configPresent:function (type) {
					return !(this.config[type]===undefined);
                },
                _viewModeChanged: function () {
                    if (this.data) {
                        this.gridDataSize = this.currentRecordSize = this.data.length;
                    } else {
                        this.gridDataSize = 0;
                        this.currentRecordSize = 0;
                    }
                }
			});
		})();
	</script>
</dom-module>