<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-data-table/iron-data-table.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../rock-attribute/rock-attribute.html">
<link rel="import" href="../rock-entity-tofix/rock-entity-tofix.html">
<link rel="import" href="grid-list-view.html">
<link rel="import" href="grid-tile-view.html">
<link rel="import" href="remote-data.html">
<!--

`rock-grid` Represents the grid control of the framework. It creates the visual consistency between the layouts 
while allowing flexibility across a wide variety of designs.
There are three ways to use the `rock-grid`. You can

### 1. Pass the config and data:
The following `girdData` JSON object is a sample of data which is used to bind the grid.
```json

	{
		"shortName": "web Price",
		"longName": "Web Price",
		"productType": "Electronics",
		"description": "product web price",
		"isNew": false,
		"isApproved": true
	},
	{
		"shortName": "catalog",
		"longName": "Catalog",
		"productType": "Toys",
		"description": "catalog information",
		"isNew": true,
		"isApproved": false
	},
	{
		"shortName": "cost1",
		"longName": "Cost2",
		"productType": "Value",
		"description": "cost of the product1",
		"isNew": false,
		"isApproved": true
	}
```
### Example
```html
	<rock-grid data="{{gridData}}" config="{{gridConfig}}" page-size="10"></rock-grid>

```
### 2. Use the `x-data-source` component and then pass data-source, config, record-size and grid-data-size:
To use `x-data-source`, you need to pass the following properties:

`request` - This is any liquid request from which the data has to be loaded.

`operation` - The liquid operation name for which the `request` object is prepared.

`data-formatter`  - This is call back function which is triggred on every page load in grid before binding the data to grid. 
It is used for formatting the response data that comes from the liquid request into an array of records as per the grid configuration.
And you need to access the auto calculated properties of `data-source` and pass it to `rock-grid` like `current-record-size` and 
`total-records` to `record-size` and `grid-data-size` as shown in example.
### Example
		<dom-module id="app">
			<template>
				<x-data-source id="remote1" request="[[request]]" data-formatter="{{dataFormatter}}"
					current-record-size="{{size}}" total-records="{{totalRecords}}" data-source="{{dataSource}}"></x-data-source>
				<rock-grid data-source="{{dataSource}}" data-source-id="remote1" record-size="{{totalRecords}}" config="{{gridConfig}}"
					grid-data-size="{{size}}" page-size="10"></rock-grid>
			</template>
			<script>
				Polymer({
					is: 'app',
					properties: {
						dataFormater: {
							notify: true,
							value: function() {
								return this._dataFormatter.bind(this);
							}
						}
					},
					_dataFormatter: function(response) {
						var data = [];
						........
						.......
						...
						return data;
					}
				});
			</script>
		</dom-module>
### 3. Create external data-source and then pass data-source, config, record-size and grid-data-size:
### Example
	A. External Data Source
```html
			<dom-module id="data-source">
				<template>
					<style include="pebble-styles-shared"></style>
				</template>
				<script>
					Polymer({
						is: 'data-source',
						properties: {
							dataSource: {
								notify: true,
								value: function() {
								return this._dataSource.bind(this);
								}
							},
							size: {
								type: Number,
								notify: true,
								value: 0
							},
							total-records: {
								type: Number,
								notify: true,
								value: 0
							}
						},
						_lastPage: -1,
						_dataSource: function(opts, cb) {
							var xhr = new XMLHttpRequest();
							xhr.onreadystatechange = function() {
								if (xhr.readyState == XMLHttpRequest.DONE) {
									if (xhr.status == 200 && this._lastPage < opts.page) {
										var data = JSON.parse(xhr.responseText);
										// This if condition is required for any data source to make vitualization work
										// pagination will work based on this inputs
										if(opts.pageSize <= data.length)
										{
											if (this.size / opts.pageSize >= opts.page) {
												this.size += this.size == 0 ? opts.pageSize * 2 : opts.pageSize;
											}
										}
										else
										{
											if(this.size == 0) {
												this.size = data.length;
											}
											else {
												this.size -= opts.pageSize;
											}
										}
										cb(data);
										this._lastPage = opts.page;
										this.totalRecords += data.length;
									}
								}
							}.bind(this);
							// page parameters could be used like this:
							xhr.open("GET", 'gridData.json?per_page=' +
								opts.pageSize + '&page=' + opts.page, true);
							xhr.send();
						}
					});
				</script>
			</dom-module>
```
	B. Usage of external data source in the rock grid.
```html
		<data-source data-source="{{dataSource}}" size="{{size}}" total-records="{{totalRecords}}"></data-source>               
  		<rock-grid data-source="{{dataSource}}" grid-data-size="{{size}}" record-size="{{totalRecords}}" config="{{gridConfig}}" 
		  page-size="10"></rock-grid>
```
The following JSON object is a config sample which configures the grid in all above three ways.
```json
{
    "viewMode": "Tabular",
    "title": "Simple Data Table",
    "readOnly":true,
    "tabular": {
        "settings": {
        
            "isMultiSelect": true
        
        },
        "columns": [
            {
                "header": "Short Name",
                "name": "shortName",
                "sortable": true,
                "filterable": false,
                "editType":"text"
            },
            {
                "header": "Long Name",
                "name": "longName",
                "sortable": false,
                "filterable": true,
                "editType":""
            },
            {
                "header": "Product Type",
                "name": "productType",
                "sortable": false,
                "filterable": false,
                "editType":"text"
            }
}
```

@demo demo/index.html
-->
<dom-module id="rock-grid">
	<template>
		<style include="pebble-styles-shared">
			.attribute {
				width: 100%;
			}
			
			h1 {
				text-align: center;
				font-family: var(--default-font-family);
			}
			
			div.clearboth {
				clear: both;
			}
			
			iron-data-table {
				--iron-data-table-header: {
					height: 45px;
				}
				--iron-data-table-row-odd: {
					background-color: var(--secondary-button-color, #ffffff);
				}
			}
			
			iron-data-table data-table-row[header],
			iron-data-table data-table-row[header] /deep/ label {
				font-weight: var(--font-bold, bold);
				color: var(--palette-cerulean, #036bc3);
				border-bottom: none;
				text-transform: uppercase;
				font-size: var(--table-head-font-size, 11px);
			}
			
			iron-data-table data-table-row:not([header]) {
				color: var(--palette-dark, #1a2028);
				font-size: var(--default-font-size, 12px);
				border-bottom: solid 1px var(--table-row-border, #e6ebf0);
				transition: all 0.3s;
			}
			
			iron-data-table data-table-row:not([header]):hover {
				background-color: var(--table-row-hover-color, #f9fbfd);
			}
			
			iron-data-table data-table-row[header] /deep/ paper-icon-button:not([direction]) {
				opacity: 0.7 !important;
			}
			
			#pebbleGridContainer {
				border: 1px solid var(--palette-cloudy-blue, #c1cad4);
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				border-radius: var(--default-border-radius, 3px);
			}
			
			#pebbleGridContainer grid-list-view::shadow .container {
				will-change: unset;
				transform: none!important;
				-ms-transform: none!important;
				-webkit-transform: none!important;
				position: relative;
			}
			
			#gridHeader {
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				padding: 10px;
				color: var(--palette-steel-grey, #75808b);
			}
			
			#gridHeader>span {
				font-weight: var(--font-bold, bold);
				color: var(--palette-dark, #1a2028);
			}
			
			pebble-button {
				vertical-align: -webkit-baseline-middle;
				vertical-align: -moz-baseline-middle;
				vertical-align: baseline-middle;
				--pebble-button: {
					padding: 0.5em 0em 0.5em 0em;
					min-width: 2.14em;
					margin: 0px;
				}
				--pebble-button-iron-icon: {
					height: 20px;
					width: 20px;
					color: var(--primary-icon-color, #75808b);
				}
			}
			
			pebble-button.pageRange::shadow paper-button {
				line-height: var(--border-btn-height, 24px);
				height: var(--border-btn-height, 30px);
				box-shadow: none;
				font-family: var(--default-font-family);
				padding: 0 5px 0px 4px;
				font-size: var(--default-font-size, 12px)!important;
			}
			
			pebble-vertical-divider {
				min-width: 1px;
				min-height: 24px;
				border-right: 0;
				background: var(--divider-color, #c1cad4);
			}
			
			.input-content.paper-input-container .paper-input-label {
				color: var(--white, #fff) !important;
				font-family: var(--default-font-family);
			}
			
			paper-dropdown-menu {
				width: 90px;
				--paper-input-container: {
					padding: 0;
				}
				--paper-input-container-underline: {
					display: none;
				};
				--paper-input-container-underline-focus: {
					display: none;
				};
				--paper-dropdown-menu-icon: {
					color: var(--palette-steel-grey, #75808b);
				};
				--paper-input-container-input: {
					color: var(--palette-steel-grey, #75808b);
					font-size: var(--dropdown-inside-grid-size, 12px);
					vertical-align: top !important;
					line-height: 20px !important;
					padding-left: var(--gutter-width, 5px);
				};
			}
			
			.actionButton {
				margin-right: var(--default-margin, 10px);
			}
			
			data-table-checkbox {
				border-right: none;
				flex-basis: 30px;
				-webkit-flex-basis: 30px;
				padding: 0 0 0 15px;
			}
			
			data-table-checkbox[header] {
				height: 32px!important;
			}

			data-table-cell, data-table-cell[header] {
				padding: 0 0 0 15px;
			}
			
			data-table-cell[header] {
				height: 32px!important;
				font-size: var(--font-size-sm, 12px);
				color: var(--palette-cerulean, #036bc3);
			}
			
			data-table-cell[header]:hover {
				color: var(--palette-steel-grey, #75808b);
			}
			
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container {
				padding: 0;
				margin: 0;
			}
			
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container::shadow .floated-label-placeholder {
				line-height: 3px;
			}
			
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container::shadow .unfocused-line {
				border-bottom-color: var(--palette-cerulean, #036bc3);
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container::shadow .underline{
				bottom: 4px;
			}

			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container::shadow .underline{
				bottom: 4px;
			}

			iron-data-table::shadow #header {
				height: 32px;
			}
			
			#pebbleGridContainer iron-data-table data-table-row data-table-cell rock-attribute::shadow .attribute-main {
				padding: 0;
			}
			
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container label {
				top: 1px;
				font-size: var(--font-size-sm, 12);
				color: var(--palette-cerulean, #036bc3);
				font-weight: var(--font-bold, bold);
			}
			
			.input-content.label-is-floating ::content label, .input-content.label-is-floating ::content .paper-input-label{
				transform: translateY(-30%) scale(0.75);
			}

			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container input {
				font-size: var(--default-font-size, 14px);
				line-height: 26px;
			}
			
			data-table-row[header] {
				border-bottom: 1px solid var(--table-border, #c1cad4)!important;
			}
			
			data-table-column-sort::shadow paper-icon-button {
				width: 15px;
				height: 13px;
				padding: 0;
				position: relative;
				top: -2px;
				opacity: 1;
			}
			
			paper-dropdown-menu::shadow paper-menu-button::shadow .dropdown-content {
				@apply --common-popup;
				margin-top: 0;
				top: var(--grid-header-height, 47px);
				overflow: visible !important;
			}
			
			paper-dropdown-menu::shadow paper-menu-button::shadow .dropdown-content:after {
				content: "";
				position: absolute;
				width: 0;
				height: 0;
				margin-left: 4px;
				top: 0;
				left: 50%;
				box-sizing: border-box;
				border: 4px solid var(--border-black, #000);
				border-color: transparent transparent var(--palette-white) var(--palette-white);
				transform-origin: 0 0;
				-ms-transform-origin: 0 0;
				-webkit-transform-origin: 0 0;
				transform: rotate(135deg);
				-ms-transform: rotate(135deg);
				-webkit-transform: rotate(135deg);
				box-shadow: -1px 1px 1px 0 var(--palette-cloudy-blue, #c1cad4);
			}
			
			paper-listbox paper-item {
				font-size: var(--font-size-sm, 12px);
				color: var(--main-content-text-color, #192027);
				min-height: 30px;
				width: 100px;
				line-height: 0;
			}
			
			paper-listbox paper-item:hover {
				background-color: var(--grid-hover, #e9f1f9);
				font-weight: bold;
			}
			
			.trim {
				display: inline-flex;
				display: -webkit-inline-flex;
				width: 30%;
				text-overflow: ellipsis;
				overflow: hidden;
				white-space: nowrap;
			}
			
			pebble-actions {
				padding-left: 10px;
				padding-right: 10px;
				height: 32px;
			}
			
			--pebble-button-iron-icon: {
				height: 20px;
				width: 20px;
				padding: 0 3px 0 3px;
				color: var(--white, #fff);
				@apply(--pebble-actions-button-icon);
			}
			
			pebble-actions::shadow pebble-button::shadow paper-button {
				background-color: var(--white, #fff);
				color: var(--color-steal-grey, #75808b) !important;
			}
			
			pebble-actions::shadow pebble-button::shadow iron-icon {
				color: var(--default-icon-color, #8994a0) !important;
			}
			
			.error-circle {
				height: 18px;
				width: 18px;
				line-height: 18px;
				text-align: center;
				border-radius: 50%;
				background: var(--error-color, #ed204c);
				font-size: 9px;
				float: right;
				color: var(--white, #fff);
			}
			
			iron-data-table {
				height: var(--rock-grid-height, 400px);
			}
		</style>
		<template is="dom-if" if="{{_dataIsNotNull(config, attributeModels)}}">
			<template is="dom-if" if="[[!noHeader]]">
				<div id="gridHeader" align="right" class="row layout-middle layout-between">
					<span class="trim">[[title]] </span>
					<div class="grid-actions row layout-middle">
						<pebble-button class="pageRange m-r-5 m-l-5" button-text="{{_pageRange}}" noink></pebble-button>
						<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
						<pebble-button icon="pebble-md-icons:ToolbarRefresh" class="pebble-md-icons m-l-5 m-r-5" on-tap="_onRefresh" noink></pebble-button>
						<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
						<template is="dom-if" if="[[!config.readOnly]]">
							<pebble-button icon="pebble-md-icons:Edit" class="pebble-md-icons m-l-5 m-r-5" on-tap="changeToEditMode" noink></pebble-button>
							<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
						</template>
						<pebble-button class="pageRange btn-with-border m-l-5 m-r-5" button-text="Add" on-tap="_addNewRow" noink></pebble-button>
						<pebble-button icon="pebble-md-icons:Import" on-tap="_onDownload" class="pebble-md-icons m-l-5 m-r-5" noink></pebble-button>
						<pebble-button icon="pebble-md-icons:Upload" on-tap="_onUpload" class="pebble-md-icons m-l-5 m-r-5" noink></pebble-button>
						<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
						<paper-dropdown-menu label="{{config.viewMode}}" no-label-float>
							<paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{config.viewMode}}">
								<paper-item value="Tabular">
									<pebble-button icon="pebble-md-icons:Tableview" class="pebble-md-icons m-r-5"></pebble-button>Tabular</paper-item>
								<paper-item value="List">
									<pebble-button icon="pebble-md-icons:Listview" class="pebble-md-icons m-r-5"></pebble-button>List</paper-item>
								<paper-item value="Tile">
									<pebble-button icon="pebble-md-icons:Tileview" class="pebble-md-icons m-r-5"></pebble-button>Tile</paper-item>
							</paper-listbox>
						</paper-dropdown-menu>
					</div>
				</div>
			</template>
			<div id="pebbleGridContainer" class="m-l-10 m-r-10 m-b-10">
				<template is="dom-if" if="{{_isTabularMode(config.viewMode)}}">
					<iron-data-table id="[[id]]" page-size="[[pageSize]]" size="[[gridDataSize]]" selection-enabled="[[selectionEnabled]]" multi-selection="[[config.tabular.settings.isMultiSelect]]"
					    data-source="[[dataSource]]" items="{{data}}" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" sort-order="{{sortOrder}}">
						<data-table-column name="Actions" hidden$="[[!_hasActions()]]">
							<template>
								<template is="dom-repeat" items="[[_actions()]]" as="col" index-as="colIndex">
									<pebble-button class="actionButton" icon="[[_actionValue(colIndex)]]" on-tap="_fireActionEvent" item="[[item]]" index="[[colIndex]]"></pebble-button>
								</template>
								<span id="error-circle[[item.id]]" class="error-circle" hidden item="[[item]]" on-tap="_openPopover" on-mouseenter="_openPopover"> </span>
							</template>
						</data-table-column>
						<data-table-column name="Status" hidden$="[[!config.statusEnabled]]">
							<template>
								<pebble-icon id="rowStatus" icon="{{_getRowStatusIcon(item)}}"></pebble-icon>
							</template>
						</data-table-column>
						<template is="dom-repeat" items="[[config.tabular.columns]]" as="col" index-as="colIndex">
							<data-table-column name="[[col.header]]" column-index="{{colIndex}}" filter-by$="[[_isFilterEnabled(col)]]" sort-by$="[[_isSortable(col)]]"
							    icon="pebble-icons:Edit" column-object="[[col]]" model-object="{{_getAttributeModelObject(col)}}">
								<template>
									<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
										<a href$="[[_getLink(column.columnObject, item)]]">
											<rock-attribute functional-mode="grid" id="row[[item.id]]col[[column.columnIndex]]" class="attribute" mode="{{_getViewMode(_mode,item)}}"
											    attribute-model-object="{{column.modelObject}}" attribute-object="{{_getAttributeObject(item, column.columnIndex)}}"
											    on-attribute-value-changed="_updateValue"></rock-attribute>
										</a>
									</template>
									<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
										<rock-attribute functional-mode="grid" id="row[[item.id]]col[[column.columnIndex]]" class="attribute" mode="{{_getViewMode(_mode,item)}}"
										    attribute-model-object="{{column.modelObject}}" attribute-object="{{_getAttributeObject(item, column.columnIndex)}}"
										    on-attribute-value-changed="_updateValue"></rock-attribute>
									</template>
								</template>
							</data-table-column>

						</template>
					</iron-data-table>
					<pebble-popover id="errorPopover" no-overlap>
						<pebble-error-list></pebble-error-list>
					</pebble-popover>
				</template>
				<template is="dom-if" if="{{_isTileMode(config.viewMode)}}">
					<grid-tile-view items="{{data}}" multi-selection="{{config.tile.settings.isMultiSelect}}" selected-item="{{selectedItem}}"
					    selected-items="{{selectedItems}}" tile-items="{{config.tile.tileItems}}" actions="{{config.tile.settings.actions}}"></grid-tile-view>
				</template>
				<template is="dom-if" if="{{_isListMode(config.viewMode)}}">
					<grid-list-view id="gridListView" items="{{data}}" multi-selection="{{config.list.settings.isMultiSelect}}" selected-item="{{selectedItem}}"
					    selected-items="{{selectedItems}}" list-items="{{config.list.listItems}}" actions="{{config.list.settings.actions}}"></grid-list-view>
				</template>
			</div>
		</template>
		<pebble-dialog id="gridMsgDialog" show-ok show-cancel show-close-icon>
			<p id="msgDialog">
			</p>
		</pebble-dialog>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttonok-clicked" handler="_onDialogOk"></bedrock-pubsub>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttoncancel-clicked" handler="_onDialogCancel"></bedrock-pubsub>
	</template>
	<script>
		(function () {
			'use strict';
			Polymer({
				is: 'rock-grid',
				/**
				 * Fired when the user clicks on a item to select it.
				 *
				 * @event grid-selecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be selected
				 */
				/**
				 * Fired when the user clicks on a item to deselect it.
				 *
				 * @event grid-deselecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be deselected
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to select the items.
				 *
				 * @event grid-selecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to deselect the items.
				 *
				 * @event grid-deselecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on a item to expand it.
				 *
				 * @event grid-expanding-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be expanded
				 */
				/**
				 * Fired when the user clicks on a item to collapse it.
				 *
				 * @event grid-collapsing-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be collapsed
				 */
				properties: {
					/**
					 * Indicates the data which is wrapped in a data-source that is used as a grid data.
					 * The format for the JSON object is given in the above description.
					 */
					data: {
						type: Object,
						notify: true,
						observer: '_gridDataLoad'
					},
					/**
					 * Indicates the number of items fetched at a time from the data-source.
					 */
					pageSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates a config object which decides the rendering behavior.
					 * The format for the JSON object is given in above description.
					 */
					config: {
						type: Object,
						notify: true
					},
					/**
					 * Indicates an identifier of data-source component used for a particular grid.
					 * It requires to reset the data-source for a particular grid.
					 */
					dataSourceId: {
						type: String,
						value: ''
					},
					/**
					 * Indicates a function that provides items lazily. The function receives the parameters such as `opts`, `callback`, and `err`.
					 *
					 * `opts.page` indicates a requested page index.
					 *
					 * `opts.pageSize` indicates the current page size.
					 *
					 * `opts.filter` indicates the current filter parameters.
					 *
					 * `opts.sortOrder` indicates the current sorting parameters.
					 */
					dataSource: {
						type: Object,
						notify: true
					},
					/**
					 * Indicates an incremental data size for each page in the grid while use of "dataSource" for virtualization.
					 * How to increase this `gridDataSize` is given in the above description.
					 **/
					gridDataSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates the total record size of the grid.
					 * How to increase this `recordSize` is given in the above description.
					 */
					recordSize: {
						notify: true,
						type: Number,
						value: 0
					},
					/**
					 * Indicates an attribute model to be used if the schema type is an <b>attribute</b>.
					 */
					attributeModels: {
						type: Object,
						notify: true,
						value: function () {
							return {};
						}
					},
					/**
					 * Indicates an array that contains the selected items when `multiSelection` is set to true.
					 * Otherwise, it indicates null if no item is selected.
					 */
					selectedItems: {
						type: Array,
						//value : [],
						notify: true,
						reflectToAttribute: true
					},
					/**
					 * Indicates the currently selected item when `multiSelection` is set to false.
					 * Otherwise, it indicates null if no item is selected.
					 */
					selectedItem: {
						type: Object,
						//value : {},
						notify: true,
						reflectToAttribute: true
					},
					/**
					 * Specifies whether or not multiple items are selected at once. When it is set to <b>true</b>,
					 * you can select multiple items at once. In this case, it indicates an array of currently selected items.
					 * When it is set to <b>false</b>, you can select only one item at a time.
					 */
					multiSelection: {
						type: Boolean,
						value: false,
						notify: true,
						reflectToAttribute: true
					},
					/**
					 * Indicates the title for the grid.
					 */
					title: {
						type: String,
						notify: true
					},
					/**
					 * Indicates an array with a path and a sort order. <b>`asc`</b> or <b>`desc</b>` pairs
					 * are used to sort the items.
					 */
					sortOrder: {
						type: Array,
						notify: true
					},
					/**
					* If true, tapping a row will select the item.

					*/
					selectionEnabled: {
						type: Boolean,
						value: false
					},
					/**
					 * Specifies not to show grid header
					 */
					noHeader: {
						type: Boolean,
						value: false
					},
					_mode: {
						type: String,
						computed: '_getMode(config.mode)',
						notify: true
					},
					_pageRange: {
						value: ""
					},
					_attributeModelMap: {
						type: Object
					}
				},
				behaviors: [
					RUFBehaviors.UIBehavior
				],
				observers: [
					'_calculatePageRange(recordSize, pageSize)',
					'_computeTitle(config, data, recordSize, sortOrder, sortOrder.*)'
				],
				listeners: {
					'selecting-item': '_onSelectingItem',
					'deselecting-item': '_onDeselectingItem',
					'selecting-all-items': '_onSelectingAllItems',
					'deselecting-all-items': '_onDeselectingAllItems',
					'expanding-item': '_onExpandingItem',
					'collapsing-item': '_onCollapsingItem'
				},
				_addNewRow: function () {
					var newItem = {};
					newItem.isEditable = true;
					newItem.status = 'new';
					newItem.errors = [];
					var oldsize = this.data.length;
					this.data.unshift(newItem);
					this._getIronDataTable()._sizeChanged(oldsize + 1, oldsize);
					this._getIronDataTable()._resetData(this.dataSource);
				},
				/**
				 * Can be used to add the new rows to the grid.
				 */
				addNewRows: function (noOfRows) {
					for (var i = 0; i < noOfRows; i++) {
						var newItem = {};
						newItem.isEditable = true;
						newItem.status = 'new';
						this.data.unshift(newItem);
					}
					var oldsize = this.data.length;
					this._getIronDataTable()._sizeChanged(oldsize + noOfRows, oldsize);
					this._getIronDataTable()._resetData(this.dataSource);
				},
				addNewRecords: function (records) {
					if (records && records.length > 0) {
						var data = this.getData();
						records.forEach(function (record) {
							record._rowStatus = {
								"status": "new",
								"statusIcon": "pebble-icons:Colors"
							};
							data.unshift(record);
						}, this);

						this.data = data;
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							var oldSize = ironDataTable.size;
							ironDataTable.size = oldSize + data.length;
						}
						this.reRenderGrid();
						this.changeToEditMode();
					}
				},
				isDirty: function () {
					var data = this.getData();
					if (data && data.length > 0) {
						for (var i = 0; i < data.length; i++) {
							if (data[i]._rowStatus && data[i]._rowStatus.status) {
								if (data[i]._rowStatus.status == "update" || data[i]._rowStatus.status == "new") {
									return true;
								}
							}
						}
					}

					return false;
				},
				revertData: function () {
					var data = this.getData();
					var filteredData = [];

					if (data && data.length > 0) {
						filteredData = data.filter(function (item) {
							if (item._rowStatus) {
								if (item._rowStatus.status) {
									if (item._rowStatus.status != "new") {
										if (item._rowStatus.status == "update") {
											this._setOriginalValue(item);
										}
										item._rowStatus = {
											"statusIcon": ""
										};
										return item;
									}
								} else {
									item._rowStatus = {
										"statusIcon": ""
									};
									return item;
								}
							} else {
								item._rowStatus = {
									"statusIcon": ""
								};
								return item;
							}
						}.bind(this));
					}

					this.data = [];
					this.data = filteredData;
					this.set('config.mode', "read");
					this.reRenderGrid();
				},
				getData: function () {
					var allData = this._getIronDataTable().$.list.items;
					var filteredData = [];
					if (allData && allData.length > 0) {
						var lastPageData = allData.slice(allData.length - this.pageSize, allData.length);
						var lastPageFilteredData = lastPageData.filter(function (element) {
							if (element != undefined) {
								var keys = Object.keys(element);
								if (!(keys.length <= 0 || (keys.length == 1 && keys[0] == "errors"))) {
									return element;
								}
							}
						});
						if (allData.length > this.pageSize) {
							filteredData = allData.slice(0, allData.length - this.pageSize);
							if (lastPageFilteredData && lastPageFilteredData.length) {
								lastPageFilteredData.forEach(function (item) {
									filteredData.push(item);
								}, this);
							}
						} else {
							filteredData = lastPageFilteredData;
						}
					}
					return filteredData;
				},
				/*
				 * Can be used to re-render the grid.
				 */
				reRenderGrid: function () {
					if (this.dataSourceId) {
						var dataSourceElement = Polymer.dom(this).node.parentNode.querySelector('#' + this.dataSourceId);
						if (dataSourceElement) {
							dataSourceElement._resetDataSource();
						}
					}
					if (this._getIronDataTable()) {
						this._getIronDataTable()._resetData(this.dataSource);
					}
				},
				/**
				 * Can be used to clear the cached pages and reload the data from the data-source when needed.
				 */
				clearCache: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.clearCache();
				},
				/**
				 * Can be used to clear the cache for a page and reload the data from the data-source.
				 */
				refreshPage: function (page) {
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						ironDataTable.refreshPage(page);
					}
				},
				/*
				 * Can be used to select all the items in the list.
				 */
				selectAll: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.selectAll();
				},
				/**
				 * Can be used to clear the current selection state.
				 */
				clearSelection: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.clearSelection();
				},
				/**
				 * Can be used to select the list item at the given index.
				 *
				 * @method selectItem
				 * @param {(Object|number)} item The item object or its index
				 */
				selectItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.selectItem(item);
				},
				/**
				 * Can be used to de-select the given item list if it is already selected.
				 *
				 * @method deselect
				 * @param {(Object|number)} item The item object or its index
				 */
				deselectItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.deselectItem(item);
				},
				/**
				 * Can be used to expand the row details for this item if it is available.
				 */
				expandItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.expandItem(item);
				},
				/**
				 * Can be used to collapse the row details for this item if it is expanded.
				 */
				collapseItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.collapseItem(item);
				},
				/**
				 * Can be used to return the array of `selectedItems`.
				 * When `multiSelection` is set to true, then the array contains the selected items.
				 * @return {Array<object>} The selectedItems is an array of object and other properties as below.
				 * If `selectedItems.inverted` is `true`, the array contains de-selected items.
				 * `selectedItems.filters` contains an array of filters that are active when the selection changes.
				 */
				getSelectedItem: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.selectedItem;
				},
				/**
				 * Can be used to change the mode to edit mode.
				 *
				 */
				changeToEditMode: function () {
					this.set('config.mode', "edit");
					this._dataChanged();
				},
				changeToReadMode: function () {
					this.set('config.mode', "read");
				},
				openGridMsgDialog: function (msg) {
					this.$$('p[id="msgDialog"]').innerText = msg;
					this.$.gridMsgDialog.open();
				},
				_computeTitle: function (config, data, recordSize, sortOrder) {
					if (config && config.header && config.header.displayTitle) {
						if (config.title) {
							this.set('title', config.title);
						}
						this.set('title', config.header.defaultValue);
					} else if (data && recordSize) {
						var status = recordSize + ' items.';
						if (sortOrder && sortOrder.length > 0) {
							status += ' Sorted by ';
							for (var i = 0; i < sortOrder.length; i++) {
								var sort = sortOrder[i];
								status += sort.path + ' ' + sort.direction;
								if (i < sortOrder.length - 1) {
									status += ', ';
								}
							}
						}
						this.set('title', status);
					} else if (recordSize) {
						var status = recordSize + ' items.';
						this.set('title', status);
					}
				},
				_calculatePageRange: function (recordSize, pageSize) {
					this._pageRange = "1 - " + recordSize + " / " + recordSize;
				},
				_columnValue: function (gridData, index) {
					var cellData;
					var columnName = this.config.tabular.columns[index].name;
					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
						"colModel") {
						cellData = gridData[columnName];
					} else if (this.config.schemaType == "attribute") {
						for (var key in gridData.attributes) {
							if (gridData.attributes[key].hasOwnProperty(columnName)) {
								cellData = gridData.attributes[key][columnName].value;
								break;
							}
						}
					}
					if (cellData != undefined) {
						index++;
					}
					if (typeof (cellData) === "boolean") {
						return cellData.toString();
						//Had to manually convert to string because pebble-boolean is not working when you pass boolean.
					}
					return cellData;
				},
				_isTabularMode: function (viewMode) {
					return viewMode == 'Tabular';
				},
				_isTileMode: function (viewMode) {
					return viewMode == 'Tile';
				},
				_isListMode: function (viewMode) {
					return viewMode == 'List';
				},
				_getAttributeModelObject: function (col) {
					var displayType = "";
					if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
						if (!col.displayType) {
							col.displayType = col.editType;
						}
						return col;
					} else if (this.config.schemaType == "attribute" || this.config.schemaType == "colModel") {
						return this._getAttributeModelMap(col.name);
					}
				},
				_getAttributeObject: function (item, columnIndex) {
					var value = {
						"value": this._columnValue(item, columnIndex)
					};
					if (this.config.tabular.columns.length == columnIndex + 1) {
						this.async(function () {
							this._updateError(item);
						})
					}
					return value;
				},
				_isFilterEnabled: function (col) {
					return col.filterable ? col.name : undefined;
				},
				_isSortable: function (col) {
					return col.sortable ? col.name : undefined;
				},
				_dataIsNotNull: function (config, attributeModels) {
					var result = typeof (config) == "object";
					if (result && (config.schemaType == "attribute" || config.schemaType == "colModel") && Object.keys(
							attributeModels).length == 0) {
						result = false;
					}
					return result;
				},
				_onRefresh: function (e) {
					this.reRenderGrid();
				},
				_onDownload: function (e) {
					this.selectAll();
				},
				_onUpload: function (e) {
					this.clearSelection();
				},
				_getIronDataTable: function () {
					return ElementHelper.getElement(this, "iron-data-table");
				},
				_onSelectingItem: function (e) {
					this.fireBedrockEvent("grid-selecting-item", e.detail);
				},
				_onDeselectingItem: function (e) {
					this.fireBedrockEvent("grid-deselecting-item", e.detail);
				},
				_onSelectingAllItems: function (e) {
					this.fireBedrockEvent("grid-selecting-all-items", e.detail);
				},
				_onDeselectingAllItems: function (e) {
					this.fireBedrockEvent("grid-deselecting-all-items", e.detail);
				},
				_onExpandingItem: function (e) {
					this.fireBedrockEvent("grid-expanding-item", e.detail);
				},
				_onCollapsingItem: function (e) {
					this.fireBedrockEvent("grid-collapsing-item", e.detail);
				},
				_getAttributeModelMap: function (name) {
					if (this.attributeModels) {
						if (this._attributeModelMap == undefined) {
							this._attributeModelMap = {};
							for (var key in this.attributeModels) {
								for (var attrKey in this.attributeModels[key]) {
									if (attrKey != "name") {
										this._attributeModelMap[attrKey] = this.attributeModels[key][attrKey];
									}
								}
							}
						}
						return this._attributeModelMap[name];
					}
					return {};
				},
				_dataChanged: function () {
					//TO-DO will get changed
					this.fire('editMode');
				},
				_actionValue: function (index) {
					var action = this.config.tabular.settings.actions[index];
					var icon = action.icon;
					if (!icon) {
						if (action.name == 'delete') {
							return 'pebble-icons:Delete';
						} else if (action.name == 'edit') {
							return 'pebble-icons:Edit'
						} else {
							return '';
						}
					}
					return icon;
				},
				_updateValue: function (e) {
					var columnIndex = typeof e.target.column === 'undefined' ? e.srcElement.dataHost.column.columnIndex : e.target
						.column.columnIndex;
					var item = e.model.item;
					var value = e.detail;
					var columnName = this.config.tabular.columns[columnIndex].name;
					var row = this._getParentRow(e.currentTarget);
					var status = "";

					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
						"colModel") {
						var columnOriginalValue = columnName + "_originalValue";

						if (item[columnOriginalValue] || item[columnOriginalValue] == "") {
							if (item[columnOriginalValue] != value) {
								status = "update";
							} else {
								status = "read";
							}
						} else {
							item[columnOriginalValue] = item[columnName] ? item[columnName] : "";
							status = "update";
						}
						item[columnName] = value;

						this._updateRowStatus(item, status);

					} else if (this.config.schemaType == "attribute") {
						for (var key in item.attributes) {
							if (item.attributes[key].hasOwnProperty(columnName)) {
								if (item.attributes[key][columnName]._originalValue || item.attributes[key][columnName]._originalValue ==
									"") {
									if (item.attributes[key][columnName]._originalValue != value) {
										status = "update";
									} else {
										status = "read";
									}
								} else {
									item.attributes[key][columnName]._originalValue = item[columnName] ? item[columnName] : "";
									status = "update";
								}
								item.attributes[key][columnName].value = value;
								this._updateRowStatus(item, status);

								break;
							}
						}
					}

					if (row) {
						var rowStatusIcon = row.querySelector('pebble-icon[id="rowStatus"]');
						if (rowStatusIcon && item._rowStatus) {
							if (item._rowStatus.status == "update") {
								item._rowStatus.statusIcon = rowStatusIcon.icon = "pebble-icons:Edit";
							} else if (item._rowStatus.status == "read") {
								item._rowStatus.statusIcon = rowStatusIcon.icon = "";
							}
						} else {
							rowStatusIcon.icon = "";
							item._rowStatus = {
								"statusIcon": ""
							};
						}
					}
				},
				_fireActionEvent: function (e) {
					var action = this.config.tabular.settings.actions[e.currentTarget.index];
					var eventName = action.eventName;
					if (!eventName) {
						if (action.name == 'delete') {
							eventName = "grid-delete-item";
						} else if (action.name == 'edit') {
							eventName = "grid-edit-item";
						} else {
							return;
						}
					}
					if (action.name == "edit") {
						this.editInline(e.currentTarget.item);
						this._dataChanged();
					}
					this.fireBedrockEvent(eventName, e.currentTarget.item);
				},
				_hasActions: function () {
					if (this.config.tabular.settings.actions && this.config.tabular.settings.actions.length > 0) {
						return true;
					}
					return false;
				},
				_actions: function () {
					return this.config.tabular.settings.actions;
				},
				_getMode: function (mode) {
					return mode;
				},
				_getViewMode: function (mode, item) {
					if (item.isEditable) {
						return "edit";
					}
					return mode;
				},
				_updateError: function (item) {
					var errors = [];
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.$$("#row" + item.id + "col" + i);
						if (attr && attr.errors.length > 0) {
							var error = {};
							error.name = this.config.tabular.columns[i].name;
							error.error = attr.errors;
							errors.push(error);
						}
					}
					item.errors = errors;
					var errorLength = errors.length;
					var sp;
					if (item.id) {
						sp = this.$$("#error-circle" + item.id);
					} else {
						sp = this.$$("#error-circle");
					}
					if (sp) {
						if (errorLength) {
							sp.hidden = false;
							sp.textContent = errorLength;
						} else {
							sp.hidden = true;
						}
					}
				},
				_openPopover: function (e) {
					var sp = e.currentTarget;
					var item = e.currentTarget.item;
					var popover = this.$$("#errorPopover");
					popover.positionTarget = sp;
					popover.setAttribute("for", "error-circle" + item.id);
					popover.querySelector("pebble-error-list").errors = item.errors;
					popover.show();
				},
				// Can be used to change a row's mode to the edit mode.
				editInline: function (item) {
					item.isEditable = true;
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.$$("#row" + item.id + "col" + i);
						if (attr) {
							attr.mode = 'edit';
						}
					}
				},
				// Can be used to change a row's mode to the read mode.
				changeRowToViewMode: function (item) {
					item.isEditable = false;
					for (var i = 0; i < this.config.tabular.columns.length; i++) {
						var attr = this.$$("#row" + item.id + "col" + i);
						if (attr) {
							attr.mode = 'read';
						}
					}
				},
				_getAttributeFormattedData: function (data, opts) {
					//tranform method needs data context, what do we pass here?
					var dataContext = {
						"list": "productMaster",
						"classification": "nivea/niveaBodyCare/niveaBody/nbodyEssential/nbody/ess/nourishingMilkDry",
						"source": "SAP",
						"time": "now",
						"locale": "en-US"
					};
					DataHelper.transformEntitySchemaForGrid(data, this.attributeModels);
					return data;
				},
				_gridDataLoad: function () {
					if (this.data) {
						this.gridDataSize = this.recordSize = this.data.length;
					}
				},
				_onDialogOk: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-ok", e);
				},
				_onDialogCancel: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-cancel", e);
				},
				_getParentRow: function (element) {
					if (element) {
						if (element.is == "data-table-row") {
							return element;
						} else {
							return this._getParentRow(element.parentNode);
						}
					}
					return undefined;
				},
				_setOriginalValue: function (element) {
					if (element) {
						if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
							"colModel") {
							Object.keys(element).forEach(function (item) {
								if (element[item + "_originalValue"] || element[item + "_originalValue"] == "") {
									element[item] = element[item + "_originalValue"];
								}
							}, this);

						} else if (this.config.schemaType == "attribute") {
							for (var key in element.attributes) {
								for (var attrKey in element.attributes[key]) {
									if (element.attributes[key][attrKey]._originalValue || element.attributes[key][attrKey]._originalValue ==
										"") {
										element.attributes[key][attrKey].value = element.attributes[key][attrKey]._originalValue;
									}
								}
							}
						}
					}
				},
				_getRowStatusIcon: function (item) {
					if (item && Object.keys(item).length > 0) {
						var icon = "";
						if (item && item._rowStatus) {
							if (item._rowStatus.statusIcon) {
								icon = item._rowStatus.statusIcon;
							} else {
								item._rowStatus.statusIcon = "";
							}
						} else {
							item._rowStatus = {
								"statusIcon": ""
							}
						}
						return icon;
					}
				},
				_updateRowStatus: function (item, status) {
					if (item) {
						if (item._rowStatus) {
							if (item._rowStatus.status) {
								if (item._rowStatus.status != "new") {
									item._rowStatus.status = status;
								}
							} else {
								item._rowStatus.status = status;
							}
						} else {
							item._rowStatus = {
								"status": status
							}
						}
					}
				},

				_getLink: function (col, item) {
					var _this = this;
					return col.linkTemplate.replace(/\{\S+?\}/g,
						function (match) {
							var attrName = match.replace("{", "").replace("}", "");
							if (attrName.toLowerCase() == "id") {
								return item.id;
							}
							var colModels = _this.config.tabular.columns;
							var index = -1;
							for (var i = 0; i < colModels.length; i++) {
								if (colModels[i].name == attrName) {
									index = i;
									break;
								}
							}
							if (index > -1) {
								return _this._columnValue(item, index);
							}
							return match;
						});
				},

				_hasLinkTemplate: function (col, item) {
					if (col.linkTemplate && col.linkTemplate != "") {
						var notEditable = (this.config.mode && this.config.mode.toLowerCase() != "edit") || (item.mode && item.mode.toLowerCase() !=
							"edit");
						if (notEditable) {
							return true;
						}
					}
					return false;
				},

				/**
				 * Set multi selection to grid
				 */
				setMultiSelection: function (flag) {
					if (flag != undefined) {
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							ironDataTable.multiSelection = flag;
						}
					}
				},

				/**
				 * Reset the grid size
				 */
				notifyResize: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.notifyResize()
				},

				/**
				 * To set scroll position dynamically
				 */
				scrollToIndex: function (index) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.$$('#list').scrollToIndex(index);
				},

				/**
				 * To get selected grid row
				 */
				getSelectedGridRow: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.querySelector('data-table-row[selected]');
				},

				/**
				 * To get selected item index
				 */
				getSelectedItemIndex: function () {
					if (this.getData().length > 0 && this.selectedItem) {
						return this.getData().indexOf(this.selectedItem);
					}

					return -1;
				}
			});
		})();
	</script>
</dom-module>