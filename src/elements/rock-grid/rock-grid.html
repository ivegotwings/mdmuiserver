<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-tooltip/paper-tooltip.html">
<link rel="import" href="../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-gridsystem.html">

<link rel="import" href="../pebble-data-table/pebble-data-table.html">
<link rel="import" href="../pebble-data-table/data-table-column.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">

<link rel="import" href="../rock-attribute/rock-attribute.html">
<link rel="import" href="../rock-nested-attribute-grid/rock-nested-attribute-grid.html">
<link rel="import" href="../rock-entity-tofix/rock-entity-tofix.html">
<link rel="import" href="../rock-toolbar-default-actions/rock-toolbar-default-actions.html">

<link rel="import" href="grid-list-view.html">
<link rel="import" href="grid-tile-view.html">
<link rel="import" href="remote-data.html">
<!--

`rock-grid` Represents the grid control of the framework. It creates the visual consistency between the layouts 
while allowing the flexibility across a wide variety of designs.
Following are the three ways to use the `rock-grid`:

### 1. Pass the "config" and "data":
The following `girdData` JSON object is a sample of data which binds the grid:
```json

	{
		"shortName": "web Price",
		"longName": "Web Price",
		"productType": "Electronics",
		"description": "product web price",
		"isNew": false,
		"isApproved": true
	},
	{
		"shortName": "catalog",
		"longName": "Catalog",
		"productType": "Toys",
		"description": "catalog information",
		"isNew": true,
		"isApproved": false
	},
	{
		"shortName": "cost1",
		"longName": "Cost2",
		"productType": "Value",
		"description": "cost of the product1",
		"isNew": false,
		"isApproved": true
	}
```
### Example
```html
	<rock-grid data="{{gridData}}" config="{{gridConfig}}" page-size="10"></rock-grid>

```
### 2. Use the `x-data-source` component and then pass the data-source, config, record-size, and grid-data-size.
To use the `x-data-source`, you need to pass the following properties:

`request` - This is any liquid request from which the data is loaded.

`operation` - The liquid operation name for which the `request` object is prepared.

`data-formatter`  - This is a callback function which is triggered on every page load in the grid before binding the data to the grid. 
It is used for formatting the response data that comes from the liquid request into an array of records as per the grid configuration.
Then you need to access the auto calculated properties of `data-source` and pass it to the `rock-grid. For example, the properties such as`current-record-size` and 
`total-records` are passed to `record-size` and `grid-data-size` as shown in the following example:
### Example
		<dom-module id="app">
			<template>
				<x-data-source id="remote1" request="[[request]]" data-formatter="{{dataFormatter}}"
					buffer-record-size="{{size}}" total-records="{{totalRecords}}" data-source="{{rDataSource}}"></x-data-source>
				<rock-grid data-source="{{rDataSource}}" data-source-id="remote1" record-size="{{totalRecords}}" config="{{gridConfig}}"
					grid-data-size="{{size}}" page-size="10"></rock-grid>
			</template>
			<script>
				Polymer({
					is: 'app',
					properties: {
						dataFormater: {
							notify: true,
							value: function() {
								return this._dataFormatter.bind(this);
							}
						}
					},
					_dataFormatter: function(response) {
						var data = [];
						........
						.......
						...
						return data;
					}
				});
			</script>
		</dom-module>
### 3. Create external data-source and then pass the data-source, config, record-size, and grid-data-size.
### Example
	A. External Data Source:
```html
			<dom-module id="data-source">
				<template>
					<style include="bedrock-style-common"></style>
				</template>
				<script>
					Polymer({
						is: 'data-source',
						properties: {
							rDataSource: {
								notify: true,
								value: function() {
								return this._dataSource.bind(this);
								}
							},
							size: {
								type: Number,
								notify: true,
								value: 0
							},
							total-records: {
								type: Number,
								notify: true,
								value: 0
							}
						},
						_lastPage: -1,
						_dataSource: function(opts, cb) {
							var xhr = new XMLHttpRequest();
							xhr.onreadystatechange = function() {
								if (xhr.readyState == XMLHttpRequest.DONE) {
									if (xhr.status == 200 && this._lastPage < opts.page) {
										var data = JSON.parse(xhr.responseText);
										// This if condition is required for any data source to make vitualization work
										// pagination will work based on this inputs
										if(opts.pageSize <= data.length)
										{
											if (this.size / opts.pageSize >= opts.page) {
												this.size += this.size == 0 ? opts.pageSize * 2 : opts.pageSize;
											}
										}
										else
										{
											if(this.size == 0) {
												this.size = data.length;
											}
											else {
												this.size -= opts.pageSize;
											}
										}
										cb(data);
										this._lastPage = opts.page;
										this.totalRecords += data.length;
									}
								}
							}.bind(this);
							// page parameters could be used like this:
							xhr.open("GET", 'gridData.json?per_page=' +
								opts.pageSize + '&page=' + opts.page, true);
							xhr.send();
						}
					});
				</script>
			</dom-module>
```
	B. Usage of external data source in the rock grid:
```html
		<data-source data-source="{{rDataSource}}" size="{{size}}" total-records="{{totalRecords}}"></data-source>               
  		<rock-grid data-source="{{rDataSource}}" grid-data-size="{{size}}" record-size="{{totalRecords}}" config="{{gridConfig}}" 
		  page-size="10"></rock-grid>
```
The following JSON object is a config sample which configures the grid in all above three ways:
```json
{
    "viewMode": "Tabular",
    "title": "Simple Data Table",
    "readOnly":true,
    "tabular": {
        "settings": {
        
            "isMultiSelect": true
        
        },
        "columns": [
            {
                "header": "Short Name",
                "name": "shortName",
                "sortable": true,
                "filterable": false,
                "editType":"text"
            },
            {
                "header": "Long Name",
                "name": "longName",
                "sortable": false,
                "filterable": true,
                "editType":""
            },
            {
                "header": "Product Type",
                "name": "productType",
                "sortable": false,
                "filterable": false,
                "editType":"text"
            }
}
```

@demo demo/index.html
-->
<dom-module id="rock-grid">
	<template>
		<style include="bedrock-style-common bedrock-style-gridsystem">
			.attribute {
				width: 100%;
			}

			:host {
				display: block;
				height: 100%;
			}

			pebble-data-table {
				--pebble-data-table-header: {
					min-height: 40px;
					padding-top: 10px;
					padding-right: 0;
					padding-bottom: 10px;
					padding-left: 0;
				}
				--pebble-data-table-row-odd: {
					background-color: var(--secondary-button-color, #ffffff);
				}
			}

			pebble-data-table[loading] {
				pointer-events: none;
			}

			pebble-data-table data-table-row[header] {
				font-weight: var(--font-bold, bold);
				color: var(--palette-cerulean, #036bc3);
				border-bottom: none;
				text-transform: uppercase;
				font-size: var(--table-head-font-size, 11px);
			}

			pebble-data-table data-table-row:not([header]) {
				color: var(--palette-dark, #1a2028);
				font-size: var(--default-font-size, 12px);
				height: 100%;
				background-color: var(--palette-white, #ffffff);
			}

			pebble-data-table data-table-row:not([header]):hover,
			data-table-row[selected] {
				background-color: var(--table-row-selected-color, #c1cad4) !important;
			}

			pebble-data-table data-table-row.value-updated {
				background-color: var(--edit-attribute-bgcolor, #EDF8FE) !important;
			}

			pebble-data-table data-table-row:not([header]):hover data-table-checkbox,
			data-table-row[selected] data-table-checkbox {
				background-color: var(--palette-white, #ffffff) !important;
			}

			.outer-flex {}

			#pebbleGridContainer {
				height: auto;
				min-height: 0px;
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				margin-left: 20px;
				margin-right: 20px;
				@apply --pebble-grid-container;
			}

			#pebbleGridContainer grid-list-view {
				--pebble-grid-list-container: {
					will-change: unset;
					transform: none!important;
					-ms-transform: none!important;
					-webkit-transform: none!important;
				}
			}

			#gridHeader {
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 12px);
				padding: 10px 20px 10px 20px;
				color: var(--palette-steel-grey, #75808b);
				@apply --pebble-grid-container-header;
			}

			#gridHeader #title,
			#selection-title {
				font-weight: var(--font-bold, bold);
				color: var(--palette-dark, #1a2028);
			}

			pebble-button {
				--pebble-button: {
					padding-top: 0.5em;
					padding-right: 0em;
					padding-bottom: 0.5em;
					padding-left: 0em;
					min-width: 2.14em;
					margin-top: 0px;
					margin-right: 0px;
					margin-bottom: 0px;
					margin-left: 0px;
				}
				;
			}

			pebble-vertical-divider {
				min-width: 1px;
				min-height: 24px;
				border-right: 0;
				background: var(--divider-color, #c1cad4);
			}

			.input-content.paper-input-container .paper-input-label {
				color: var(--palette-white, #ffffff) !important;
				font-family: var(--default-font-family);
			}

			paper-dropdown-menu {
				width: 90px;
				--paper-input-container: {
					padding-top: 0px;
					padding-right: 0px;
					padding-bottom: 0px;
					padding-left: 0px;
				}
				--paper-input-container-underline: {
					display: none;
				}
				--paper-input-container-underline-focus: {
					display: none;
				}
				--paper-dropdown-menu-icon: {
					color: var(--palette-steel-grey, #75808b);
					margin-top: -5px;
				}
				--paper-input-container-input: {
					color: var(--palette-steel-grey, #75808b);
					font-size: var(--dropdown-inside-grid-size, 12px);
					vertical-align: top !important;
					line-height: 20px !important;
					padding-left: var(--gutter-width, 5px);
				}
			}

			data-table-checkbox {
				border-right: none;
				padding: 0 10px 0 0;
				height: auto;
				flex-basis: 35px;
				background: var(--palette-white, #ffffff);
				justify-content: flex-start;
			}

			data-table-cell,
			data-table-cell[header] {
				padding: 0px 10px 0px 0;
				min-width: 0!important;
				flex-basis: 150px;
				/* Set minimum width for columns */
				@apply --data-table-cell-width;
			}

			data-table-cell:not([header]) [slot=cell-slot-content] {
				width: 100%;
			}

			data-table-cell[header] {
				font-size: var(--font-size-sm, 12px);
				color: var(--palette-cerulean, #036bc3);
				text-transform: uppercase;
				cursor: default;
				height:40px;
				align-items: center;
			}

			data-table-row:not([header]) data-table-cell {
				min-height: 40px!important;
				height: 48px !important;
				z-index:auto !important;
			}

			.check-filter {
				flex-basis: 35px!important;
				flex-grow: 0!important;
				overflow: visible!important;
				position: relative;
				padding: 0;
			}

			grid-selection-popover {
				position: absolute;
				left: 20px;
				top: auto;
			}

			pebble-data-table {
				--pebble-data-table-header: {
					height: auto;
				}
			}

			#pebbleGridContainer pebble-data-table data-table-row data-table-cell rock-attribute {
				--attribute-main: {
					padding-top: 0px;
					padding-right: 0px;
					padding-bottom: 0px;
					padding-left: 0px;
				}
				--attribute-edit: {
					margin-top: -4px;
				}
				--textarea-container: {
					padding-top: 0px;
					padding-right: 0px;
					padding-bottom: 0px;
					padding-left: 0px;
				}
				--paper-input-container-input: {
					min-height: 30px;
				}
			}

			#pebbleGridContainer pebble-data-table data-table-row data-table-cell data-table-column-sort {
				--data-table-column-sort-order: {
					display: none !important;
				}
			}

			.input-content.label-is-floating ::slotted(label),
			.input-content.label-is-floating ::slotted(.paper-input-label) {
				transform: translateY(-30%) scale(0.75);
			}

			#pebbleGridContainer pebble-data-table data-table-row data-table-cell pebble-button {
				--pebble-button: {
					margin-top: 5px;
				}
			}

			data-table-column-sort {
				--pebble-icon-opacity: {
					opacity: 1;
				}
			}

			paper-dropdown-menu {
				--paper-menu-button-content: {
					@apply --common-popup;
					top: 0;
					margin-top: var(--grid-header-height, 29px);
					overflow: visible !important;
				}
			}

			paper-listbox paper-item {
				font-size: var(--font-size-sm, 12px);
				color: var(--palette-steel-grey, #75808b);
				min-height: 30px;
				width: 120px;
				height: 1px;
			}

			paper-listbox.dropdown-content {
				padding: 12px 0px !important;
			}

			paper-listbox.dropdown-content paper-item {
				@apply --popup-item;
			}

			paper-listbox.dropdown-content paper-item:hover,
			paper-item.iron-selected {
				--pebble-icon-color: {
					fill: var(--focused-line, #026bc3);
				}
			}

			paper-item.iron-selected {
				font-weight: normal;
			}

			.trim {
				display: inline-flex;
				display: -webkit-inline-flex;
				width: 30%;
				text-overflow: ellipsis;
				overflow: hidden;
				white-space: nowrap;
			}

			pebble-actions {
				padding-left: 10px;
				padding-right: 10px;
				height: 32px;
				--pebble-button: {
					background-color: var(--palette-white, #ffffff);
					color: var(--color-steal-grey, #75808b) !important;
				}
			}

			.error-circle {
				height: 18px;
				width: 18px !important;
				line-height: 18px;
				text-align: center;
				border-radius: 50%;
				background: var(--error-color, #ed204c);
				font-size: 9px;
				float: right;
				color: var(--palette-white, #ffffff);
			}

			.edit-options {
				display: none;
			}

			.edit-options pebble-button {
				vertical-align: top;
				margin-top: 5px;
			}

			.edit-options.show {
				display: block;
			}

			#gridHeader .grid-actions {
				@apply --rock-grid-actions;
			}

			.cell {
				font-size: 14px;
				display: inline-block;
				vertical-align: middle;
				max-height: 100px;
				overflow-y: auto;
				max-width: 100%;
			}

			#title {
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				text-align: left;
				padding-right:5px;
			}

			#selection-title {
				flex: 1;
				text-align: left;
				white-space: nowrap
			}

			paper-tooltip {
				--paper-tooltip-background: var(--tooltip-bg-color, rgba(25, 32, 39, 1));
				--paper-tooltip: {
					color: var(--tooltip-text-color, #ffffff);
					font-size: var(--font-size-sm, 12px);
					padding-top: 3px;
					padding-right: 5px;
					padding-bottom: 3px;
					padding-left: 5px;
					z-index: 99;
					line-height: 1.2;
					border-radius: 3px;
					text-align: center;
					word-wrap: break-word;
					max-width: 200px;
					text-transform: capitalize;
				}
			}

			paper-dropdown-menu {
				--paper-menu-button-dropdown: {
					margin-top: 40px;
				}
			}

			#pebbleGridContainer pebble-data-table data-table-cell .cell {
				overflow: visible;
			}

			#pebbleGridContainer pebble-data-table data-table-cell span {
				text-overflow: ellipsis;
				white-space: nowrap;
				overflow: hidden;
				display: block;
			}

			.msg {
				text-align: center;
			}

			.image-container {
				width: 30px;
				height: 30px;
			}

			.fallback-value {
				color: var(--color-variant-1);
			}

			.disabled-value {
				color: var(--palette-steel-grey, #75808b);
			}

			.coalesced-value {
				font-style: italic;
			}

			.view-source-information-popover {
				font-weight: normal;
				text-transform: initial;
				text-align: left;
				margin-left: -12px;
				margin-top: 7px;
				--default-popup-b-p: 5px;
				--default-popup-t-p: 5px;
				--default-font-size: 12px;
				width: 180px;
			}

			.view-source-information-popover::after,
			.view-source-information-popover::before {
				bottom: 100%;
				left: 20px;
				border: solid transparent;
				content: " ";
				height: 0;
				width: 0;
				position: absolute;
				pointer-events: none;
			}

			.view-source-information-popover::after {
				border-color: rgba(255, 255, 255, 0);
				border-bottom-color: #ffffff;
				border-width: 6px;
				margin-left: -6px;
			}

			.view-source-information-popover::before {
				border-color: rgba(194, 225, 245, 0);
				border-bottom-color: rgb(216, 221, 228);
				border-width: 7px;
				margin-left: -7px;
			}

			.source-information-header,
			.source-information-description,
			.source-information-path {
				padding-left: 10px;
				padding-right: 10px;
			}

			.source-information-header {
				font-weight: bold;
				border-bottom: thin solid rgb(216, 221, 228);
				padding-bottom: 3px;
			}

			.source-information-path {
				margin-top: 10px;
				margin-bottom: 0px;
			}

			.source-information-path .path-item {
				color: var(--link-text-color, #139ee7);
				display: inline-block;
			}

			.source-information-path .path-item::after {
				content: " >>";
				color: var(--default-text-color, #444444);
			}

			.source-information-path .path-item:last-of-type::after {
				content: "";
			}

			li {
				text-align: inherit;
			}

			.actionsPopover {
				@apply --pebble-actions-popover;
				width: 30px !important;
				--default-popup-t-p: 5px;
				--default-popup-b-p: 5px;
			}

			pebble-popover paper-item {
				cursor: pointer;
				font-size: var(--default-font-size, 14px);
				min-height: 40px;
				color: var(--palette-steel-grey, #75808b);
				text-align: left;
				transition: all 0.3s;
				-webkit-transition: all 0.3s;
				padding-left: var(--default-popup-item-l-p, 20px);
				padding-right: var(--default-popup-item-r-p, 20px);
			}

			pebble-popover paper-item:hover {
				background-color: var(--bgColor-hover, #e8f4f9);
				color: var(--focused-line, #026bc3);
			}

			pebble-popover paper-item:focus {
				color: var(--primary-button-color, #036bc3);
				background-color: var(--bgColor-hover, #e8f4f9);
			}

			pebble-popover paper-item pebble-icon:hover {
				color:  var(--focused-line, #026bc3) !important;
			}

			pebble-icon {
				padding: 0;
				color: var(--primary-icon-color, #75808b);
				color: var(--palette-steel-grey, #75808b);
			}

			data-table-cell[header] [slot=cell-slot-content]{
				position: relative;
				padding-right: 15px; 
				max-width: calc(100% - 14px);
			}
			data-table-cell[header] [slot=cell-slot-content] .cell-content-text {
				max-width: 100%; 
                    cursor: default;
			}
			data-table-cell[header] [slot=cell-slot-content] pebble-info-icon {
				position: absolute;
                    top: 1px;
                    right: 0px;
			}

			.grid-header-wrapper {
				height: 100%;
			}
		</style>
		<template is="dom-if" if="{{_dataIsNotNull(config, attributeModels)}}" restamp>
			<div class="base-grid-structure">
				<div class="base-grid-structure-child-1">
					<template is="dom-if" if="[[!noHeader]]">
						<div class="grid-header-wrapper">
							<div id="gridHeader" align="right" class="row layout-middle layout-between">
								<div id="title">[[title]]</div>
								<paper-tooltip for="title" position="bottom" animation-delay="0">[[title]][[selectionTitle]]</paper-tooltip>
								<div id="selection-title">[[selectionTitle]]</div>
								<div class="grid-actions row layout-middle">
									<!-- Toolbar slot -->
									<template is="dom-if" if="[[!hideToolbar]]">
										<slot slot="toolbar" name="toolbar"></slot>
										<template is="dom-if" if="[[_isToolbarSlotEmpty()]]">
											<rock-toolbar-default-actions id="gridActions" domain="[[domain]]" context-data="[[contextData]]"></rock-toolbar-default-actions>
										</template>
									</template>
									<bedrock-pubsub event-name="rock-toolbar-button-event" handler="_onToolbarEvent" target-id="gridActions"></bedrock-pubsub>
									<bedrock-pubsub event-name="on-page-range-requested" handler="_setPageRange" target-id="gridActions"></bedrock-pubsub>
									<template is="dom-if" if="[[!hideViewSelector]]">
										<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
										<paper-dropdown-menu id="viewMode" label="{{config.viewMode}}" no-label-float class="tooltip-bottom" data-tooltip="View Mode">
											<paper-listbox slot="dropdown-content" class="dropdown-content" attr-for-selected="value" selected="{{config.viewMode}}">
												<paper-item value="Tabular">
													<pebble-icon icon="pebble-icon:view-tabular" class="pebble-icon-size-16 m-r-10"></pebble-icon>Tabular</paper-item>
												<paper-item value="List">
													<pebble-icon icon="pebble-icon:view-list" class="pebble-icon-size-16 m-r-10"></pebble-icon>List</paper-item>
												<paper-item value="Tile">
													<pebble-icon icon="pebble-icon:view-tile" class="pebble-icon-size-16 m-r-10"></pebble-icon>Tile</paper-item>
											</paper-listbox>
										</paper-dropdown-menu>
									</template>
								</div>
							</div>
						</div>
					</template>
				</div>
				<div id="pebbleGridContainer" class="base-grid-structure-child-2">
					<template is="dom-if" if="{{_isTabularMode(config.viewMode)}}" restamp>
						<div hidden="[[_configPresent('tabular')]]" class="msg default-message"> Config not present for Tabular view of the grid.</div>
						<template is="dom-if" if="[[_configPresent('tabular')]]">
							<pebble-data-table id="pebbleDataTable" min-filter-length="[[minFilterLength]]" advance-selection-options="[[config.advanceSelectionOptions]]"
							 advance-selection-enabled="[[config.advanceSelectionEnabled]]" selection-info="{{selectionInfo}}" page-size="[[pageSize]]"
							 size="[[gridDataSize]]" selection-enabled="[[selectionEnabled]]" multi-selection="[[config.itemConfig.isMultiSelect]]"
							 r-data-source="[[rDataSource]]" items="[[data]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
							 sort-order="{{sortOrder}}" disable-select-all="[[config.itemConfig.disableSelectAll]]" on-row-dbl-clicked="_rowDblClicked"
							 rows="[[config.itemConfig.rows]]" on-row-drop-event="_onRowDropEvent" row-drag-drop-enabled="[[rowDragDropEnabled]]"
							 enable-column-select="[[enableColumnSelect]]" enable-column-multi-select="[[enableColumnMultiSelect]]">

								<data-table-column slot="column-slot" name="Actions" width="60px" flex="0" hidden$="[[!_showActions(config.mode)]]">
									<template>
										<div slot="cell-slot-content">
											<template is="dom-repeat" id="actionsDomRepeat" items="[[_getActions(config.mode, item)]]" as="action" index-as="colIndex">
												<pebble-icon id="actions_container_[[item.id]]" class="actionButton pebble-icon-size-16" icon="[[_actionValue(action)]]"
												 on-tap="_fireActionEvent" item="[[item]]" index="[[index]]" action-index="[[colIndex]]"></pebble-icon>

												<template is="dom-if" if="[[_hasPopoverInfo(action)]]">
													<template is="dom-if" if="[[_hasContextCoalescedValue(item)]]">
														<pebble-popover class="view-source-information-popover" id="action_[[item.id]]_sourceInfo-popover" for="actions_container_[[item.id]]">
															<div class="attributes-description">
																<div class="source-information-header">Source Information</div>
																<div class="source-information-description">This value was sourced from the following path</div>
																<ul class="source-information-path">
																	Context:
																	</br>
																	<template is="dom-repeat" items="[[item.contextCoalescePaths]]" as="coalescePath">
																		<li class="path-item">[[coalescePath]]</li>
																	</template>
																</ul>
															</div>
														</pebble-popover>
													</template>
												</template>
											</template>
										</div>
									</template>
									<span id="error-circle[[index]]" class="error-circle" hidden item="[[item]]" index="[[index]]" on-tap="_openPopover" on-mouseenter="_openPopover">
									</span>
								</data-table-column>
								<data-table-column slot="column-slot" name="Status" width="60px" flex="0" hidden$="[[!_isStatusEnabled(config.statusEnabled, config.mode)]]">
									<template>
										<pebble-icon slot="cell-slot-content" id="rowStatus" class="pebble-icon-size-16" icon="{{_getRowStatusIcon(item)}}"></pebble-icon>
									</template>
								</data-table-column>

								<template is="dom-if" if="[[config.readOnly]]" restamp>
									<template is="dom-repeat" items="[[_fields]]" as="col" index-as="colIndex">
										<template is="dom-if" if="[[col.visible]]">
											
											<template is="dom-if" if="{{_isIconColumn(col)}}">
												<data-table-column slot="column-slot" flex="0" width="60px" name="[[col.header]]" column-index="{{colIndex}}" filter-by="[[_isFilterEnabled(col)]]"
												 sort-by="[[_isSortable(col)]]" sort-type="[[_getColumnSortType(col)]]" data-type="[[_getColumnDataType(col)]]" icon="pebble-icon:action-edit" class="pebble-icon-size-16"
												 column-object="[[col]]" width="[[_getColWidth(col)]]">
													<template>
														<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
															<template is="dom-if" if="[[_hasIcon(column.columnObject, item)]]">
																<a slot="cell-slot-content" href$="[[_getLink(column.columnObject, item)]]">
																	<div class="cell tooltip-bottom" data-tooltip$="[[_columnIconTooltip(item, column.columnIndex)]]">
																		<pebble-icon icon="[[_columnIcon(item, column.columnIndex)]]" class="download-icon"></pebble-icon>
																	</div>
																</a>
															</template>
														</template>
														<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
															<template is="dom-if" if="[[_hasIcon(column.columnObject, item)]]">
																<div slot="cell-slot-content">
																	<div class="cell tooltip-bottom" data-tooltip$="[[_columnIconTooltip(item, column.columnIndex)]]">
																		<pebble-icon icon="[[_columnValue(item, column.columnIndex)]]" class="pebble-icon-size-16"></pebble-icon>
																	</div>
																</div>
															</template>
														</template>
													</template>
												</data-table-column>
											</template>
											<template is="dom-if" if="{{!_isIconColumn(col)}}">
												<data-table-column slot="column-slot" name="[[col.header]]" column-index="{{colIndex}}" filter-by="[[_isFilterEnabled(col)]]"
												 sort-by="[[_isSortable(col)]]" sort-type="[[_getColumnSortType(col)]]" data-type="[[_getColumnDataType(col)]]" icon="pebble-icon:action-edit" class="pebble-icon-size-16"
												 column-object="[[col]]" width="[[_getColWidth(col)]]">
													<template>

														<template is="dom-if" if="[[_isNestedAttribute(column.columnObject, item)]]">
															<template is="dom-if" if="[[_getNestedAttributeValueCount(item, column.columnObject)]]">
																<a slot="cell-slot-content" href="#" on-tap="_openNestedAttr" data="[[column.columnObject]]">
																	<div class="cell tooltip-bottom" data-tooltip$="click here to see values">
																		<span> [[_getNestedAttributeMessage(item, column.columnObject)]] </span>
																	</div>
																</a>
															</template>
															<template is="dom-if" if="[[!_getNestedAttributeValueCount(item, column.columnObject)]]">
																<div slot="cell-slot-content" class="cell tooltip-bottom" data-tooltip$="No values">
																	<span> No values </span>
																</div>
															</template>
														</template>

														<template is="dom-if" if="[[!_isNestedAttribute(column.columnObject, item)]]">
															<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
																<a slot="cell-slot-content" href$="[[_getLink(column.columnObject, item)]]">
																	<div class="cell tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
																		<span class$="[[_getCellClassValue(item, column.columnIndex)]]">[[_columnValue(item, column.columnIndex)]]</span>
																	</div>
																</a>
																<template is="dom-if" if="[[_hasIcon(column.columnObject, item)]]">
																	<a slot="cell-slot-content" href$="[[_getLink(column.columnObject, item)]]">
																		<div class="cell tooltip-bottom" data-tooltip$="[[_columnIconTooltip(item, column.columnIndex)]]">
																			<pebble-icon icon="[[_columnIcon(item, column.columnIndex)]]" class="pebble-icon-size-16 download-icon"></pebble-icon>
																		</div>
																	</a>
																</template>
															</template>


															<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
																<!--Thumbnail and src will be computed and passed and rockimage viewer takes care of the value -->
																<template is="dom-if" if="[[_hasImage(column.columnObject, item)]]">
																	<div slot="cell-slot-content" class="cell tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex, column.columnObject)]]">
																		<rock-image-viewer class="image-container" sizing="contain" src="[[_columnValue(item, column.columnIndex, column.columnObject)]]" thumbnail-id="[[_columnValue(item, column.columnIndex, column.columnObject)]]"
																		 asset-details="[[_getAssetDetails(item)]]">
																		</rock-image-viewer>
																	</div>
																</template>
																<template is="dom-if" if="[[!_hasImage(column.columnObject, item)]]">
																	<div slot="cell-slot-content" class="tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
																		<span class$="[[_getCellClassValue(item, column.columnIndex)]]">[[_columnValue(item, column.columnIndex)]]</span>
																	</div>
																</template>
															</template>
														</template>
													</template>
												</data-table-column>
											</template>
										</template>
									</template>
								</template>
								<template is="dom-if" if="[[!config.readOnly]]" restamp>
									<template is="dom-repeat" items="[[_fields]]" as="col" index-as="colIndex">
										<template is="dom-if" if="[[col.visible]]">											
											<data-table-column width="" model-object="{{_getAttributeModelObject(col)}}" slot="column-slot" name="[[col.header]]" column-index="{{colIndex}}"
											 filter-by="[[_isFilterEnabled(col)]]" sort-by="[[_isSortable(col)]]" sort-type="[[_getColumnSortType(col)]]" data-type="[[_getColumnDataType(col)]]" icon="pebble-icon:action-edit"
											 class="pebble-icon-size-16" column-object="[[col]]" width="[[_getColWidth(col)]]">
												<template>

													<template is="dom-if" if="[[_hasLinkTemplate(column.columnObject, item)]]">
														<a href$="[[_getLink(column.columnObject, item)]]" slot="cell-slot-content">
															<template is="dom-if" if="[[!column.columnObject.readOnly]]">
																<rock-attribute index="[[index]]" context-data="[[_getContextData(column.columnIndex)]]" apply-locale-coalesce="[[applyLocaleCoalesce]]" item="[[item]]"
																 row-index$="[[index]]" column-index$="[[column.columnIndex]]" functional-mode="grid" id="row[[index]]col[[column.columnIndex]]"
																 class="attribute" mode="[[config.mode]]" attribute-model-object="[[column.modelObject]]" attribute-object="[[_getAttributeObject(item, column.modelObject, column.columnIndex, index)]]"
																 dependent-attribute-model-objects="[[_getDependentAttributeModels(column.modelObject)]]" dependent-attribute-objects="[[_getDependentAttributes(item, column.modelObject, index)]]"
																 on-attribute-value-changed="_updateValue"></rock-attribute>
															</template>
															<template is="dom-if" if="[[column.columnObject.readOnly]]">
																<div data-tooltip$="[[_columnValue(item, column.columnIndex)]]" class="tooltip-bottom">
																	<span class$="[[_getCellClassValue(item, column.columnIndex)]]">[[_columnValue(item, column.columnIndex)]]</span>
																</div>
															</template>
														</a>
													</template>
													<template is="dom-if" if="[[!_hasLinkTemplate(column.columnObject, item)]]">
														<template is="dom-if" if="[[!column.columnObject.readOnly]]">
															<rock-attribute slot="cell-slot-content" index="[[index]]" context-data="[[_getContextData(column.columnIndex)]]" apply-locale-coalesce="[[applyLocaleCoalesce]]"
															 item="[[item]]" row-index$="[[index]]" column-index$="[[column.columnIndex]]" functional-mode="grid" id="row[[index]]col[[column.columnIndex]]"
															 class="attribute" mode="[[config.mode]]" attribute-model-object="[[column.modelObject]]" attribute-object="[[_getAttributeObject(item, column.modelObject, column.columnIndex, index)]]"
															 dependent-attribute-model-objects="[[_getDependentAttributeModels(column.modelObject)]]" dependent-attribute-objects="[[_getDependentAttributes(item, column.modelObject, index)]]"
															 on-attribute-value-changed="_updateValue"></rock-attribute>
														</template>
														<template is="dom-if" if="[[column.columnObject.readOnly]]">
															<!--Thumbnail and src will be computed and passed and rockimage viewer takes care of the value -->
															<template is="dom-if" if="[[_hasImage(column.columnObject, item)]]">
																<div slot="cell-slot-content" class="cell tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex, column.columnObject)]]">
																	<rock-image-viewer class="image-container" sizing="contain" src="[[_columnValue(item, column.columnIndex, column.columnObject)]]" thumbnail-id="[[_columnValue(item, column.columnIndex, column.columnObject)]]"
																	 asset-details="[[_getAssetDetails(item)]]">
																	</rock-image-viewer>
																</div>
															</template>
															<template is="dom-if" if="[[!_hasImage(column.columnObject, item)]]">
																<div slot="cell-slot-content" class="tooltip-bottom" data-tooltip$="[[_columnValue(item, column.columnIndex)]]">
																	<span class$="[[_getCellClassValue(item, column.columnIndex)]]">[[_columnValue(item, column.columnIndex)]]</span>
																</div>
															</template>
														</template>
													</template>
												</template>
											</data-table-column>
										</template>
									</template>
								</template>

								<!-- New  column for validation badge-->
								<template is="dom-if" if="[[inlineValidationEnabled]]">
									<data-table-column slot="column-slot" name="" flex="0" width="60px">
										<template is="dom-if" if="[[!hidden]]">
											<!-- <pebble-icon slot="cell-slot-content" id="rowStatus2" class="pebble-icon-size-16" icon="pebble-icon:window-action-close"></pebble-icon> -->
											<span slot="cell-slot-content" hidden id="error-circle[[index]]" class="error-circle" item="[[item]]" index="[[index]]" on-tap="_openPopover"
											 on-mouseover="_openPopover">
											</span>

										</template>
									</data-table-column>
								</template>


							</pebble-data-table>
						</template>

						<pebble-popover id="errorPopover" no-overlap>
							<pebble-error-list id="errorList"></pebble-error-list>
						</pebble-popover>

						<bedrock-pubsub target-id="errorList" event-name="fix-error" handler="_fixError"></bedrock-pubsub>
					</template>
					<template is="dom-if" if="{{_isTileMode(config.viewMode)}}" restamp>
						<div hidden="[[_configPresent('tile')]]" class="msg default-message"> Config not present for Tile view of the grid.</div>
						<template is="dom-if" if="[[_configPresent('tile')]]">
							<grid-tile-view show-select-all="[[config.itemConfig.isMultiSelect]]" result-record-size="{{resultRecordSize}}" attribute-model-object="[[attributeModels]]"
							 id="gridTileView" advance-selection-options="[[config.advanceSelectionOptions]]" advance-selection-enabled="[[config.advanceSelectionEnabled]]"
							 items="[[data]]" grid-item-data-source="{{rDataSource}}" page-size="[[pageSize]]" multi-selection="{{config.itemConfig.isMultiSelect}}"
							 selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" tile-items="{{config.itemConfig}}" actions="{{_getArrayFromObject(config.viewConfig.tile.settings.actions)}}"
							 selection-info="{{selectionInfo}}">
							</grid-tile-view>
						</template>
					</template>
					<template is="dom-if" if="{{_isListMode(config.viewMode)}}" restamp>
						<div hidden="[[_configPresent('list')]]" class="msg default-message"> Config not present for List view of the grid.</div>
						<template is="dom-if" if="[[_configPresent('list')]]">
							<grid-list-view id="gridListView" attribute-model-object="[[attributeModels]]" advance-selection-options="[[config.advanceSelectionOptions]]"
							 advance-selection-enabled="[[config.advanceSelectionEnabled]]" items="[[data]]" grid-item-data-source="{{rDataSource}}"
							 page-size="[[pageSize]]" multi-selection="{{config.itemConfig.isMultiSelect}}" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
							 schema-type="{{config.schemaType}}" list-items="{{config.itemConfig}}" actions="{{_getArrayFromObject(config.viewConfig.list.settings.actions)}}"
							 selection-info="{{selectionInfo}}"></grid-list-view>
						</template>
					</template>
				</div>
			</div>
			<pebble-dialog id="gridMsgDialog" dialog-title="Confirmation" show-ok show-cancel show-close-icon alert-box modal>
				<p id="msgDialog"></p>
			</pebble-dialog>

			<pebble-dialog id="attributeDialog" dialog-title="Confirmation" modal medium vertical-offset=1 50 horizontal-align="auto" vertical-align="auto" no-cancel-on-outside-click
            		no-cancel-on-esc-key show-ok show-cancel show-close-icon alert-box>
				<div id="attrDialogContainer" style="overflow-y: auto;overflow-x: auto;"></div>
			</pebble-dialog>
		</template>
		<bedrock-pubsub event-name="toggle-sidebar" handler="_flashTileview"></bedrock-pubsub>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttonok-clicked" handler="_onDialogOk"></bedrock-pubsub>
		<bedrock-pubsub target-id="gridMsgDialog" event-name="on-buttoncancel-clicked" handler="_onDialogCancel"></bedrock-pubsub>
	</template>

	<script>
		(function () {
			'use strict';
			Polymer({
				is: 'rock-grid',
				/**
				 * Fired when the user clicks on a item to select it.
				 *
				 * @event grid-selecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be selected
				 */
				/**
				 * Fired when the user clicks on a item to deselect it.
				 *
				 * @event grid-deselecting-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be deselected
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to select the items.
				 *
				 * @event grid-selecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on the select-all checkbox to deselect the items.
				 *
				 * @event grid-deselecting-all-items (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item containing current filters for items
				 */
				/**
				 * Fired when the user clicks on a item to expand it.
				 *
				 * @event grid-expanding-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be expanded
				 */
				/**
				 * Fired when the user clicks on a item to collapse it.
				 *
				 * @event grid-collapsing-item (pub-sub event)
				 * @param {Object} detail
				 * @param {Object} detail.item item to be collapsed
				 */
				properties: {
					/**
					 * Indicates the data which is wrapped in a grid-data-source that is used as a "grid data".
					 * The format for the JSON object is given in the above description.
					 */
					data: {
						type: Array,
						notify: true,
						observer: '_gridDataLoad'
					},
					/**
					 *  If set as true , it indicates the component is in read only mode
					 */
					readonly: {
						type: Boolean,
						value: false
					},
					/**
					 * Indicates the number of items fetched at a time from the grid-data-source.
					 */
					pageSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates a config object which decides the rendering behavior.
					 * The format for the JSON object is given in the above description.
					 */
					config: {
						type: Object,
						value: function () {
							return {}
						},
						notify: true
					},
					contextData: {
						type: Object,
						value: function () {
							return {}
						}
					},
					/**
					 * Indicates an identifier of grid-data-source component used for a particular grid.
					 * It requires to reset the grid-data-source for a particular grid.
					 */
					rDataSourceId: {
						type: String,
						value: ''
					},
					/**
					 * Indicates a function that provides items lazily. The function receives the parameters such as `opts`, `callback`, and `err`.
					 *
					 * `opts.page` indicates a requested page index.
					 *
					 * `opts.pageSize` indicates the current page size.
					 *
					 * `opts.filter` indicates the current filter parameters.
					 *
					 * `opts.sortOrder` indicates the current sorting parameters.
					 */
					rDataSource: {
						type: Function,
						notify: true
					},
					/**
					 * Indicates an incremental data size for each page in the grid along with the use of "rDataSource" for virtualization.
					 * The above description depicts on how to increase this `gridDataSize`.
					 **/
					gridDataSize: {
						type: Number,
						notify: true,
						value: 0
					},
					/**
					 * Indicates the total record size of the grid.
					 * The above description depicts on how to increase this `currentRecordSize`.
					 */
					currentRecordSize: {
						notify: true,
						type: Number,
						value: 0
					},
					/**
					 * Indicates the total record size of the data available for the grid.
					 *
					 */

					resultRecordSize: {
						notify: true,
						type: Number,
						value: 0
					},
					/**
					 * Indicates an attribute model to be use if the schema type is an <b>attribute</b>.
					 */
					attributeModels: {
						type: Object,
						value: function () {
							return {};
						}
					},
					/**
					 * Indicates an array that contains the selected items when `multiSelection` is set to true.
					 * It indicates null if no item is selected.
					 */
					selectedItems: {
						type: Array,
						value: function () {
							return [];
						},
						notify: true
					},
					/**
					 * Indicates the currently selected item when `multiSelection` is set to false.
					 * It indicates null if no item is selected.
					 */
					selectedItem: {
						type: Object,
						//value : {},
						notify: true
					},
					/**
					 * Specifies whether or not multiple items are selected at once. When it is set to <b>true</b>,
					 * you can select multiple items at once. In this case, it indicates an array of currently selected items.
					 * When it is set to <b>false</b>, you can select only one item at a time.
					 */
					multiSelection: {
						type: Boolean,
						value: false,
						notify: true
					},
					/**
					 * Indicates the title for the grid.
					 */
					title: {
						type: String,
						notify: true
					},
					/**
					 * Indicates an array with a path and a sort order. The <b>`asc`</b> or <b>`desc</b>` pairs
					 * are used to sort the items.
					 */
					sortOrder: {
						type: Array,
						value: function () {
							return [];
						},
						notify: true
					},
					/**
					* Specifies whether or not a row tapping selects the item. If it is set to true, tapping a row selects the item.
	
					*/
					selectionEnabled: {
						type: Boolean,
						value: false
					},
					/**
					 * Specifies whether or not grid header is shown.
					 */
					noHeader: {
						type: Boolean,
						value: false
					},
					/**
					  * <b><i>Content development is under progress... </b></i> 
					  */
					maxConfiguredCount: {
						type: Number,
						value: 0
					},
					isDirty: {
						type: Boolean,
						value: false,
						notify: true
					},
					selectionInfo: {
						type: Object,
						value: function () { return {} },
						observer: "_onSelectionInfoChange"
					},
					totalCount: {
						type: Number
					},
					selectionTitle: {
						type: String
					},

					minFilterLength: {
						type: Number,
						value: 2
					},
					isWorkflowCriterion: {
						type: Boolean,
						value: false
					},
					rowDragDropEnabled: {
						type: Boolean
					},

					applyLocaleCoalesceStyle: {
						type: Boolean,
						value: false
					},
					domain: {
						type: String
					},

					_pageRange: {
						value: ""
					},
					_attributeModelMap: {
						type: Object
					},
					_dataTableWidth: {
						type: Number
					},
					_fields: {
						type: Array,
						value: function () {
							return [];
						},
						computed: '_getArrayFromObject(config.itemConfig.fields)'
					},
					_actions: {
						type: Array,
						value: function () {
							return [];
						}
					},
					applyLocaleCoalesce: {
						type: Boolean,
						value: false
					},
					applyContextCoalesce: {
						type: Boolean,
						value: false
					},
					inlineValidationEnabled: {
						type: Boolean,
						value: false
					},
					defaultSortingEnabled: {
						type: Boolean,
						value: true
					},
					enableColumnSelect: {
						type: Boolean,
						value: false
					},
					enableColumnMultiSelect: {
						type: Boolean,
						value: false
					},
					hideViewSelector: {
						type: Boolean,
						value: false
					},
					sortType: {
						type: String
					},
					hideToolbar: {
						type: Boolean,
						value: false
					},
					gridItemView: {
						type: Boolean,
						value: false
					},
					nestedAttributeMessage: {
						type: String,
						value: function () {
							return "click here to see values ({noOfValues})";
						}
					},
					preSelectItem:{
						type:Object,
						value:function(){
							return {};
						}
					},
					currentSelectedItem:{
						type:Object,
						value:function(){
							return {};
						}
					}
				},
				behaviors: [
					RUFBehaviors.UIBehavior
				],
				observers: [
					'_calculatePageRange(currentRecordSize, pageSize,resultRecordSize)',
					'_computeTitle(config, data, currentRecordSize, sortOrder,resultRecordSize,rDataSource,config.viewMode, config.*)',
					'_setSelectionTitle(currentRecordSize,selectionInfo,selectedItems.*)',
					'_prepareConfig(config, attributeModels)',
					'_viewModeChanged(config.viewMode)',
					'_modeChange(config.mode)'
				],
				listeners: {
					'selecting-item': '_onSelectingItem',
					'deselecting-item': '_onDeselectingItem',
					'selecting-all-items': '_onSelectingAllItems',
					'deselecting-all-items': '_onDeselectingAllItems',
					'expanding-item': '_onExpandingItem',
					'collapsing-item': '_onCollapsingItem',
					'sort-direction-changed': '_sortDirectionChanged',
					'is-data-loaded':'_isDataLoaded'
				},
				_getContextData:function(){
					return this.contextData;
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				reloadListData: function () {
					var listView = this.shadowRoot.querySelector("#gridListView");
					if (listView) {
						listView.reloadData();
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				reloadTileData: function () {
					var tileView = this.shadowRoot.querySelector("#gridTileView");
					if (tileView) {
						tileView.reloadData();
					}
				},
				//On selection info change, set the delete button
				_onSelectionInfoChange: function () {
					var disable = false;
					if ((this.selectionInfo && this.selectionInfo.mode == "query")) {
						disable = true;
					}

					//set Enable/Disable the toolbar button
					var gridActionsEl = this._getToolbar();
					if (gridActionsEl) {
						gridActionsEl.setAttributeToToolbarButton("bulkdelete", "disabled", disable);
					}
				},
				_onToolbarEvent: function (e, detail) {
					var event = detail.name;

					switch (event.toLowerCase()) {
						case "refresh":
							this._onRefresh(e, detail);
							break;
						case "edit":
							this._modeChange('edit', detail);
							break;
						case "bulkedit":
							this._onBulkEdit(e, detail);
							break;
						case "bulkrelationshipedit":
							this._onBulkRelationshipEdit(e, detail);
							break;
						case "addrow":
							this._addNewRow(e, detail);
							break;
						case "download":
							this._onDownload(e, detail);
							break;
						case "upload":
							this._onUpload(e, detail);
							break;
						case "bulkdelete":
							this._onBulkDelete(e, detail);
							break;
						case "quickmanage": // Fire event and capture the event where needed
							this.fireBedrockEvent("quick-manage-event", detail, { ignoreId: true });
							this._flashTileview();
							break;
						case "pagerange": // Just display, so no functionality here
							break;
						default:
							this.fireBedrockEvent("grid-custom-toolbar-event", detail);
							break;
					}
				},
				_addNewRow: function (e, detail) {
					//only to be used with tabular view static mode
					var newItem = {};
					newItem.status = 'new';
					newItem.errors = [];
					var oldsize = this.currentRecordSize;
					var data = this.getData();
					data.unshift(newItem);
					this.data = data;
					this._getIronDataTable()._sizeChanged(oldsize + 1, oldsize);
					this._getIronDataTable()._resetData(this.rDataSource);
					this.setRowMode(0, 'edit');
				},
				_prepareConfig: function (config, attributeModel) {
					if (this._fields && this._fields.length > 0 && attributeModel) {
						this._fields.forEach(function (column) {
							column.headerDescription = this._extractHeaderDescription(column);
							column.dataType = this._extractDataType(column);
						}.bind(this));
					}
				},
				_extractDataType: function (column) {
					var dataType = "";
					var attributeModel = this._getAttributeModelObject(column);
					if (attributeModel && attributeModel.properties) {
						dataType = attributeModel.properties.dataType;
					}
					return dataType;
				},
				_extractHeaderDescription: function (column) {
					var descriptionObject = {};
					var attributeModel = this._getAttributeModelObject(column);
					if (attributeModel && attributeModel.properties) {
						descriptionObject.description = attributeModel.properties.description;
					}
					return descriptionObject;
				},
				/**
				 * Can be used to add the new rows to the grid.
				 */
				addNewRows: function (noOfRows) {
					for (var i = 0; i < noOfRows; i++) {
						var newItem = {};
						newItem.status = 'new';
						var data = this.getData();
						data.unshift(newItem);
					}
					this.data = data;
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						var oldSize = ironDataTable.size;
						ironDataTable.size = oldSize + noOfRows.length;
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				addNewRecords: function (records) {
					//                  Only to be used with tabular mode
					if (records && records.length > 0) {
						var ironDataTable = this._getIronDataTable();
						if (this.rDataSourceId) {
							if (ironDataTable) {
								records.forEach(function (record) {
									record._rowStatus = {
										"status": "new",
										"statusIcon": "pebble-icon:action-add"
									};
									ironDataTable.unshift("_cachedItems", record);
								}, this);
								this.currentRecordSize = records.length + ironDataTable.size;
							}
						} else {
							var data = this.getData();
							records.forEach(function (record) {
								record._rowStatus = {
									"status": "new",
									"statusIcon": "pebble-icon:action-add"
								};
								data.unshift(record);
							}, this);
							this.data = data;
							if (ironDataTable) {
								ironDataTable.size = data.length;
							}
							this.reRenderGrid();
						}

						setTimeout(() => {
							this._modeChange('edit');
						}, 0);
					}
				},

				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getIsDirty: function () {
					var data = this.getData();
					if (data && data.length > 0) {
						for (var i = 0; i < data.length; i++) {
							if (data[i]._rowStatus && data[i]._rowStatus.status) {
								if (data[i]._rowStatus.status == "update" || data[i]._rowStatus.status == "new") {
									return true;
								}
							}
						}
					}

					return false;
				},
				_isIconColumn: function (col) {
					return (col.icon && col.icon != "") || col.iconColumn;
				},
				getControlIsDirty: function () {
					//To-do Need to have logic to check whether selected Item attr is updated in quick manage
					// Currently allowing selectedItems is only one.. assuming that one item is selected and page is not dirty.
					var controlDirty = this.getSelectedItems().length > 1;

					var editMode = this.get('config.mode') === "edit";

					var rockAttributeObj = Polymer.dom(this.root).querySelectorAll('rock-attribute');
					var rockAttributeDirty = false;
					if (rockAttributeObj && rockAttributeObj.getControlIsDirty) {
						rockAttributeDirty = rockAttributeObj.getControlIsDirty();
					}

					return controlDirty || rockAttributeDirty || editMode;
				},
				getItemFromData:function(item){
					if(item.id && item.type){
						var data = this.getData();
						if(data && data.length){
							for(var i = 0; i < data.length; i++){
								if((data[i].id == item.id) && (data[i].type == item.type)){
										return data[i];
									}
							}
						}
					}
					return;
				},
				_isDataLoaded:function(ev){
					if(ev && ev.detail && ev.detail.item && !_.isEmpty(this.preSelectItem)){
						//set selected item here
						if(this.preSelectItem.id && this.preSelectItem.type){
							var preSelectItem = this.getItemFromData(this.preSelectItem)
							if(preSelectItem){
								this.selectItem(preSelectItem);
								this.fireBedrockEvent("quick-manage-event", {enableQuickManage:true}, { ignoreId: true });
							}
						}
						//Resetting preSelectItem
						this.set("preSelectItem", {});
					}
				},
				refresh: function (options) {
					//Resetting preSelectItem
					this.set("preSelectItem", {});
					var _isRefresh = true;
					if(options && options.partialRefresh){
						_isRefresh = false;
						if(this.selectedItem && this.selectedItem.id && this.selectedItem.type){
							if(options.selectedItem && options.selectedItem.id && options.selectedItem.type ){
								if((this.selectedItem.id == options.selectedItem.id) && 
									(this.selectedItem.type == options.selectedItem.type)){
										var clonedSelectedItem = DataHelper.cloneObject(options.selectedItem);
										this.set("preSelectItem", clonedSelectedItem);
										_isRefresh = true;
									}
							}
						}
						if(!_isRefresh && options.toastData){
							var notificationObj = RUFUtilities.mainApp.$$('bedrock-dataobject-notification-handler');
							notificationObj.showToast(options.toastData);
						}
					}
					if(_isRefresh){
						this._onRefresh();
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				revertData: function () {
					this.set('config.mode', "read");

					var attrs = this.shadowRoot.querySelectorAll('rock-attribute');
					if (attrs && attrs.length) {
						for (var i = 0; i < attrs.length; i++) {
							attrs[i].mode = "read";
						}
					}

					var data = this.getData();
					var filteredData = [];

					if (data && data.length > 0) {
						filteredData = data.filter(function (item) {
							if (item._rowStatus) {
								if (item._rowStatus.status) {
									if (item._rowStatus.status != "new") {
										if (item._rowStatus.status == "update") {
											this._setOriginalValue(item);
										}
										item._rowStatus = {
											"statusIcon": ""
										};
										return item;
									}
								} else {
									item._rowStatus = {
										"statusIcon": ""
									};
									return item;
								}
							} else {
								item._rowStatus = {
									"statusIcon": ""
								};
								return item;
							}
						}.bind(this));
					}

					this.data = [];
					this.data = filteredData;

					this.reRenderGrid();
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getData: function () {
					if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						if (listView) {
							return listView.items;
						}
					} else if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						if (tileView) {
							return tileView.items;
						}
					} else {
						var filteredData = [];
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							if (this.data && this.data.length > 0) {
								return ironDataTable.items;
							}
							var allData = ironDataTable.$.list.items;
							if (allData && allData.length > 0) {
								var sumedLength = allData.length - this.pageSize;
								var lastPageData;
								if (sumedLength > 0) {
									lastPageData = allData.slice(allData.length - this.pageSize, allData.length);
								} else {
									lastPageData = allData;
								}
								var lastPageFilteredData = lastPageData.filter(function (element) {
									if (element != undefined) {
										var keys = Object.keys(element);
										if (!(keys.length <= 0 || (keys.length == 1 && keys[0] == "errors"))) {
											return element;
										}
									}
								});
								if (allData.length > this.pageSize) {
									filteredData = allData.slice(0, allData.length - this.pageSize);
									if (lastPageFilteredData && lastPageFilteredData.length) {
										lastPageFilteredData.forEach(function (item) {
											filteredData.push(item);
										}, this);
									}
								} else {
									filteredData = lastPageFilteredData;
								}
							}
						}
						return filteredData;
					}
				},
				/*
					 * Can be used to get updated rows from the grid.
					 */
				getModifiedData: function () {
					var modifiedData = [];
					var gridData = this.getData();
					if (gridData && gridData.length > 0) {
						gridData.forEach(function (data) {
							if (!_.isEmpty(data["_rowStatus"])) {
								var _status = data["_rowStatus"]["status"];
								if (!_.isEmpty(_status)) {
									if (_status == "update" || _status == "new" || _status == "delete") {
										modifiedData.push(data);
									}
								}
							}
						}, this);
					}
					return modifiedData;
				},
				/*
				 * Can be used to re-render the grid.
				 */
				reRenderGrid: function () {
					if (!this.config) {
						return;
					}
					var dropdown = this.shadowRoot.querySelector("#viewMode");
					if (dropdown) {
						dropdown.disabled = false;
					}
					if (typeof (this.rDataSource) == 'function') {
						if (this.rDataSourceId) {
							var dataSourceElement =  ComponentHelper.getParentElement(Polymer.dom(this).node).shadowRoot.querySelector('#' + this.rDataSourceId)
							if (dataSourceElement) {
								dataSourceElement.resetDataSource();
							}
						}
						if (this.config.viewMode == "List") {
							this.reloadListData();
						} else if (this.config.viewMode == "Tile") {
							this.reloadTileData();
						} else {
							if (this._getIronDataTable()) {
								this._getIronDataTable()._resetData(this.rDataSource);
							}
						}
					} else {
						var self = this;
						this.fireBedrockEvent('refresh-grid', self);
					}
					this.fireBedrockEvent('grid-data-refreshed', null, { ignoreId: true });
					this.clearSelection();
					this._resetAdvanceSelection();
				},
				_resetAdvanceSelection: function () {
					if (this.config.viewMode == "Tabular") {
						var getpebbleDataTable = this.shadowRoot.querySelector("#pebbleDataTable");
						if (getpebbleDataTable && getpebbleDataTable.resetAdvanceSelection) {
							getpebbleDataTable.resetAdvanceSelection();
						}
					} else if (this.config.viewMode == "List") {
						var getgridListView = this.shadowRoot.querySelector("#gridListView");
						if (getgridListView && getgridListView.resetAdvanceSelection) {
							getgridListView.resetAdvanceSelection();
						}
					} else if (this.config.viewMode == "Tile") {
						var getgridTileView = this.shadowRoot.querySelector("#gridTileView");
						if (getgridTileView && getgridTileView.resetAdvanceSelection) {
							getgridTileView.resetAdvanceSelection();
						}
					}
				},
				/**
				 * Can be used to clear the cached pages and reload the data from the data-source when needed.
				 */
				clearCache: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.clearCache();
				},
				/**
				 * Can be used to clear the cache for a page and reload the data from the data-source.
				 */
				refreshPage: function (page) {
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						ironDataTable.refreshPage(page);
					}
				},
				/*
				 * Can be used to select all the items in the list.
				 */
				selectAll: function () {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.selectAll();
				},
				/**
				 * Can be used to clear the current selection state.
				 */
				clearSelection: function () {
					if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						if (listView) {
							listView.clearSelection();
						}
					} else if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						if (tileView) {
							tileView.clearSelection();
						}
					} else {
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							ironDataTable.clearSelection();
						}
					}
				},
				/**
				 * Can be used to select the list item at the given index.
				 *
				 * @method selectItem
				 * @param {(Object|number)} item The item object or its index
				 */
				selectItem: function (item) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						tileView.selectItem(item);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						listView.selectItem(item);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.selectItem(item);
					}
				},
				/**
				 * Can be used to deselect the given item list if it is already selected.
				 *
				 * @method deselect
				 * @param {(Object|number)} item The item object or its index
				 */
				deselectItem: function (item) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("gridTileView");
						tileView.deselectItem(item);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("gridListView");
						listView.deselectItem(item);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.deselectItem(item);
					}
				},
				/**
				 * Can be used to expand the row details for this item if it is available.
				 */
				expandItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.expandItem(item);
				},
				/**
				 * Can be used to collapse the row details for this item if it is expanded.
				 */
				collapseItem: function (item) {
					var ironDataTable = this._getIronDataTable();
					ironDataTable.collapseItem(item);
				},
				/**
				 * Can be used to return the array of `selectedItems`.
				 * When `multiSelection` is set to true, then the array contains the selected items.
				 * @return {Array<object>} The `selectedItems` is an array of objects and other properties as below.
				 * If `selectedItems.inverted` is `true`, then the array contains deselected items.
				 * The `selectedItems.filters` contains an array of filters that are active when the selection changes.
				 */
				getSelectedItem: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.selectedItem;
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				getSelectedItems: function () {
					if (!this.selectedItems.inverted) {
						return this.selectedItems;
					} else {
						var items = this.getData();
						this.selectedItems.forEach(function (item) {
							var index = items.indexOf(item);
							if (index > -1) {
								items.splice(index, 1);
							}
						});
						return items;
					}
				},
				/**
				 * Can be used to change the mode to edit mode.
				 *
				 */

				getSelectionMode: function () {
					if (this.selectionInfo && this.selectionInfo.mode) {
						return this.selectionInfo.mode;
					}
					return 'count';//default value
				},

				_isStatusEnabled(statusEnabled, mode) {
					return statusEnabled && mode === 'edit';
				},

				_changeToEditMode: function (detail) {
					this.set('config.mode', "edit");
					if (this.config.viewMode != "Tabular") {
						this.set('config.viewMode', "Tabular");
					}
					var dropdown = this.shadowRoot.querySelector("#viewMode");
					if (dropdown) {
						dropdown.disabled = true;
					}
					if(detail && detail.tooltip && detail.tooltip == "Edit"){
						this.refresh();
					}
					this._dataChanged();
				},

				_modeChange(mode,detail) {
					switch (mode) {
						case 'edit':
							this._changeToEditMode(detail);
							break;
						case 'read':
							this._changeToReadMode();
							break;
					}

					var domRepeats = this.shadowRoot.querySelectorAll("#actionsDomRepeat");
					if (!_.isEmpty(domRepeats)) {
						for (let domRepeat of domRepeats) {
							let item = (domRepeat.parentElement && domRepeat.parentElement.parentElement) && domRepeat.parentElement.parentElement.item;
							domRepeat.items = this._getActions(mode, item);
							domRepeat.render();
						}
					}

					var attrs = this.shadowRoot.querySelectorAll('rock-attribute');
					if (attrs && attrs.length) {
						for (var i = 0, l = attrs.length; i < l; i++) {
							attrs[i].mode = mode;
						}
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				_changeToReadMode: function () {
					this.set('config.mode', "read");
					var data = this.data ? this.data : this.getData();
					if (data && data.length) {
						data.forEach(function (item) {
							if (item._rowStatus) {
								if (item._rowStatus.status && item._rowStatus.status == "new" || item._rowStatus.status == "update") {
									item._rowStatus.status = "read";
									item._rowStatus.statusIcon = "";
								}
							}
						}, this);
						if (this.data && this.data.length) {
							this.data = [];
							this.data = data;
						}
					}
					this.reRenderGrid();
				},
				changeToReadMode() {
					this._modeChange('read');
				},
				changeToEditMode() {
					this._modeChange('edit');
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				openGridMsgDialog: function (msg) {
					this.shadowRoot.querySelector('#msgDialog').innerText = msg;
					this.shadowRoot.querySelector('#gridMsgDialog').open();
				},
				_computeTitle: function (config, data, currentRecordSize, sortOrder) {
					var status = "";
					if (config && config.header && config.header.displayTitle) {
						if (config.title) {
							this.set('title', config.title);
						}
						this.set('title', config.header.defaultValue);
					} else if (currentRecordSize) {
						var resultRecordSize = this.resultRecordSize ? this.resultRecordSize : currentRecordSize;
						if (resultRecordSize != 0 && resultRecordSize == this.maxConfiguredCount) {
							resultRecordSize = this.maxConfiguredCount + "+";
						}
						status = "Showing 1 - " + currentRecordSize + " items of total " + resultRecordSize + " results ";
						if (data && sortOrder && sortOrder.length > 0) {
							status += ' Sorted by ';
							//TODO:: Commented code for now since system doesn't support multiple column support.
							//for (var i = 0; i < sortOrder.length; i++) {
							var sort = sortOrder[sortOrder.length - 1];
							status += sort.path + ' ' + sort.direction;
							// if (i < sortOrder.length - 1) {
							// 	status += ', ';
							// }
							//}
						}

					} else {
						status = "Showing 0 result ";
					}
					if (config) {
						if (config.titleTemplates) {
							if (config.titleTemplates.contextTemplate) {
								var matchFound = false;
								var message = config.titleTemplates.contextTemplate.replace(/\{\S+?\}/g,
									function (match) {
										var attrName = match.replace("{", "").replace("}", "");
										if (config.dataContexts) {
											for (var i = 0; i < config.dataContexts.length; i++) {
												var context = config.dataContexts[i];
												if (context[attrName]) {
													if (matchFound) {
														match += ", " + context[attrName];
													} else {
														match = context[attrName];
														matchFound = true;
													}

												}
											}
										}
										if (config.valueContexts) {
											for (var i = 0; i < config.valueContexts.length; i++) {
												var context = config.valueContexts[i];
												if (context[attrName]) {
													if (matchFound) {
														match += context[attrName];
													} else {
														match = context[attrName];
														matchFound = true;
													}
												}
											}
										}
										return match;
									});
								if (matchFound) {
									status += message;
								}
							}

							if (config.titleTemplates.compareEntitiesTitle) {
								var entityColumns = this._fields.filter(function (item) {
									if (!item.isRowHeader) {
										return item;
									}
								});
								status = config.titleTemplates.compareEntitiesTitle.replace("{noOfEntities}", entityColumns.length).replace("{noOfAttributes}", config.itemConfig.rows.length);
							}
						}

						if (config.workflowTitle) {
							status += ": " + config.workflowTitle;
						}


					}
					this.set('title', status);
				},
				_calculatePageRange: function (currentRecordSize, pageSize, resultRecordSize) {
					if (!(currentRecordSize === undefined || pageSize === undefined || resultRecordSize === undefined)) {
						var from = currentRecordSize && currentRecordSize > 0 ? 1 : 0;

						if (resultRecordSize) {
							this._pageRange = from + " - " + currentRecordSize + " / " + (resultRecordSize > 0 && resultRecordSize == this.maxConfiguredCount ? this.maxConfiguredCount + "+" : resultRecordSize);
						} else {
							this._pageRange = from + " - " + currentRecordSize + " / " + currentRecordSize;
						}

						//Set range to pebble-toolbar
						this._setPageRange();
					}
				},
				_setPageRange: function () {
					var gridActionsEl = this._getToolbar();
					if (gridActionsEl) {
						gridActionsEl.setPageRange(this._pageRange);
					}
				},
				_getToolbar: function () {
					//Finding element under slot
					var gridActionsEl = this._getSlotNode("gridActions");
					//Find default toolbar
					if (!gridActionsEl) {
						gridActionsEl = this.shadowRoot.querySelector("#gridActions");
					}
					return gridActionsEl;
				},
				_getSlotNode: function (id) {
					var slotNodes = Polymer.FlattenedNodesObserver.getFlattenedNodes(this).filter(n => n.nodeType === Node.ELEMENT_NODE);
					var slotNode;
					for (var i = 0; i < slotNodes.length; i++) {
						if (slotNodes[i].getAttribute("id") == id) {
							slotNode = slotNodes[i];
							break;
						}
					}
					return slotNode;
				},
				_isToolbarSlotEmpty: function () {
					var gridActionsEl = this._getSlotNode("gridActions");
					return !gridActionsEl;
				},
				_columnValue: function (gridData, index, columnObj) {
					var cellData;
					var columnName = this._fields[index].name;
					var defaultValue = this._fields[index].defaultValue;

					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
						"colModel") {
						cellData = this._formatValue(gridData[columnName], columnName);
					} else if (this.config.schemaType == "attribute" && gridData.attributes && gridData.attributes[columnName]) {
						cellData = this._formatValue(gridData.attributes[columnName].value, columnName);
					} else if (defaultValue) {
						cellData = defaultValue;
					}

					//Pick thumbnailid from entity properties
					if (!cellData && this._hasImage(columnObj)) {
						if(gridData && gridData.properties && gridData.properties[columnName]) {
							cellData = gridData.properties[columnName]
						}
					}

					if (cellData != undefined) {
						index++;
					}
					if (typeof (cellData) === "boolean") {
						return cellData.toString();
						//Had to manually convert to string because pebble-boolean is not working when you pass boolean.
					}
					return cellData;
				},
				_columnIcon: function (gridData, index) {
					var cellData;
					var icon = this._fields[index].icon;
					if (this.config.schemaType == "attribute") {
						if (icon) {
							cellData = icon;
						}
					}

					return cellData;
				},

				_columnIconTooltip: function (gridData, index) {
					var cellData;
					var iconTooltip = this._fields[index].iconTooltip;
					if (this.config.schemaType == "attribute") {
						if (iconTooltip) {
							cellData = iconTooltip;
						}
					}
					return cellData;
				},

				_formatValue: function (value, columnName) {
					if (this.attributeModels.hasOwnProperty(columnName)) {
						var dataType = this.attributeModels[columnName].dataType.toLowerCase();
						//formatting for date & time
						if (dataType == "datetime" || dataType == "date") {
							return FormatHelper.convertFromISODateTime(value, dataType);
						}

						//formatting for object collections
						if (this.attributeModels[columnName].isCollection && this.attributeModels[columnName].dataType.toLowerCase() !== "nested") {
							return this._formatCollectionAttributeValueForGrid(value, columnName);
						}
					}
					return value;
				},
				_formatCollectionAttributeValueForGrid: function (value, columnName) {
					//formatting for object collections
					if (!_.isEmpty(value) && Array.isArray(value)) {
						var resultString = value[0];
						for (let i = 1; i < value.length; i++) {
							resultString = resultString + ',' + value[i];
						}
						return resultString;
					} else {
						return value;
					}
				},
				_isTabularMode: function (viewMode) {
					return viewMode == 'Tabular';
				},
				_isTileMode: function (viewMode) {
					return viewMode == 'Tile';
				},
				_isListMode: function (viewMode) {
					return viewMode == 'List';
				},
				_getAttributeModelObject: function (col) {
					var displayType = "";
					if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
						if (!col.displayType) {
							col.displayType = col.editType;
						}

						return col;
					} else if (this.config.schemaType == "attribute" || this.config.schemaType == "colModel") {
						if (this.attributeModels[col.name]) {
							return this.attributeModels[col.name];
						}
						else {
							return {};
						}
					}
				},
				_getAttributeRowModelObject: function (attrName) {
					// var displayType = "";
					// if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
					// 	if (!col.displayType) {
					// 		col.displayType = col.editType;
					// 	}

					// 	return col;
					// } else if (this.config.schemaType == "attribute" || this.config.schemaType == "colModel") {
					// 	if (this.attributeModels[col.name]) {
					// 		return this.attributeModels[col.name];
					// 	}
					// 	else {
					// 		return {};
					// 	}
					// }
					if (attrName && this.attributeModels) {
						return this.attributeModels[attrName];
					}
				},
				_getAttributeObject: function (item, currentAttributeModelObject, columnIndex, index) {
					var attributeObject = {
						"name": currentAttributeModelObject.name,
						"value": this._columnValue(item, columnIndex)
					};
					var columnName = this._fields[columnIndex].name;
					if (this.config.schemaType == "attribute" && item.attributes && item.attributes.hasOwnProperty(columnName)) {
						if (item.attributes[columnName].referenceDataId) {
							attributeObject["referenceDataId"] = item.attributes[columnName].referenceDataId;
						}
						if (item.attributes[columnName].properties) {
							attributeObject["properties"] = item.attributes[columnName].properties;
						}
						if (item.attributes[columnName].contextCoalescePaths) {
							attributeObject["contextCoalescePaths"] = item.attributes[columnName].contextCoalescePaths;
						}
					}
					if (this.config.schemaType == "colModel") {
						if (item[columnName + "_referenceDataId"]) {
							attributeObject["referenceDataId"] = item[columnName + "_referenceDataId"];
						}
						if (item[columnName + "_properties"]) {
							attributeObject["properties"] = item[columnName + "_properties"];
						}
						if (item[columnName + "_contextCoalescePaths"]) {
							attributeObject["contextCoalescePaths"] = item[columnName + "_contextCoalescePaths"];
						}
						if (item["contextCoalescePaths"]) {
							attributeObject["contextCoalescePaths"] = item["contextCoalescePaths"];
						}
					}
					if (this._fields.length == columnIndex + 1) {
						Polymer.Async.microTask.run(() => {
							this._updateError(item, index);
						});
					}

					return attributeObject;
				},
				_isFilterEnabled: function (col) {
					return col.filterable ? col.name : undefined;
				},
				_isSortable: function (col) {
					return col.sortable ? col.name : undefined;
				},
				_getColumnSortType: function (col) {
					if (this.config && this.config.itemConfig && this.config.itemConfig.sort && this.config.itemConfig.sort.default) {
						const sortColumn = DataHelper._findItemByKeyValue(this.config.itemConfig.sort.default, "field", col.name);
						if (!_.isEmpty(sortColumn)) {
							return sortColumn.sortType;
						}
					}
				},
				_getColumnDataType: function (col) {
					if (col && !_.isEmpty(col) && col.dataType) {
							return col.dataType;
					}
				},
				_dataIsNotNull: function (config, attributeModels) {
					var result = typeof (config) == "object" && Object.keys(config).length ? true : false;
					if (result) {
						if ((config.schemaType == "attribute" || config.schemaType == "colModel") && Object.keys(attributeModels).length == 0) {
							result = false;
						}

						if (DataHelper.isValidObjectPath(config, 'viewConfig.tabular.settings.actions')) {
							this._actions = this._getArrayFromObject(this.config.viewConfig.tabular.settings.actions);

							//TODO : This has to be moved to some helper.
							if (this.applyContextCoalesce) {
								this._actions.push({
									"name": "sourceInfo",
									"icon": "pebble-icon:hierarchy",
									"text": "",
									"visible": true,
									"tooltip": "Source Info",
									"intent": "read"
								});
							}
						}
					}

					return result;
				},
				_onRefresh: function (e, detail) {
					this.reRenderGrid();
					var eventDetail = { "invalidateEntityCache": true };
					this.fireBedrockEvent("grid-refresh-items", eventDetail);
				},
				_onBulkEdit: function (e) {
					this.fireBedrockEvent("grid-bulk-edit-items");
				},
				_onBulkRelationshipEdit: function (e) {
					this.fireBedrockEvent("grid-bulk-relationship-edit-items");
				},
				_onBulkDelete: function (e) {
					this.fireBedrockEvent("grid-bulk-delete-items", e.detail);
				},
				_onDownload: function (e) {
					this.fireBedrockEvent("grid-download-item");
				},
				_onUpload: function (e, detail) {
					//this.clearSelection();
					this.fireBedrockEvent("grid-upload-item");
				},
				_getIronDataTable: function () {
					return ElementHelper.getElement(this, "pebble-data-table");
				},
				_onSelectingItem: function (e) {
					this.fireBedrockEvent("grid-selecting-item", e.detail);
				},
				_onDeselectingItem: function (e) {
					this.fireBedrockEvent("grid-deselecting-item", e.detail);
				},
				_onSelectingAllItems: function (e) {
					this.fireBedrockEvent("grid-selecting-all-items", e.detail);
				},
				_onDeselectingAllItems: function (e) {
					this.fireBedrockEvent("grid-deselecting-all-items", e.detail);
				},
				_onExpandingItem: function (e) {
					this.fireBedrockEvent("grid-expanding-item", e.detail);
				},
				_onCollapsingItem: function (e) {
					this.fireBedrockEvent("grid-collapsing-item", e.detail);
				},
				_dataChanged: function () {
					//TO-DO will get changed
					this.dispatchEvent(new CustomEvent('editMode', { bubbles: true, composed: true }));
				},
				_actionValue: function (action) {
					if (action) {
						var icon = action.icon;
						if (!icon) {
							if (action.name == 'delete') {
								return 'pebble-icon:action-delete';
							} else if (action.name == 'edit') {
								return 'pebble-icon:action-edit'
							} else {
								return '';
							}
						}
						return icon;
					}
				},
				_updateValue: function (e) {
					var columnIndex = typeof e.target.column === 'undefined' ? e.target.__dataHost.column.columnIndex : e.target.column.columnIndex;
					var item = e.target.item;
					var value = e.detail.value;
					var columnName = this._fields[columnIndex].name;
					var row = this._getParentRow(e.currentTarget);
					var status = "";
					var referenceDataId = e.detail.referenceDataId ? e.detail.referenceDataId : undefined;
					var selectedLocales = e.detail.selectedLocales ? e.detail.selectedLocales : undefined;

					if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType == "colModel") {
						var columnOriginalValue = columnName + "_originalValue";

						if (item[columnOriginalValue] || item[columnOriginalValue] == "") {
							if (item[columnOriginalValue] != value) {
								status = "update";
							} else {
								status = "read";
							}
						} else {
							item[columnOriginalValue] = item[columnName] ? item[columnName] : "";
							status = "update";
						}
						item[columnName] = value;
						if (referenceDataId) {
							item[columnName + "_referenceDataId"] = referenceDataId;
						}

						if (selectedLocales) {
							item[columnName + "_selectedLocales"] = selectedLocales;
						}

						this._updateRowStatus(item, status);
						this._addClassOnUpdateRow(e);

					} else if (this.config.schemaType == "attribute") {
						if (item.attributes.hasOwnProperty(columnName)) {
							if (item.attributes[columnName]._originalValue || item.attributes[columnName]._originalValue == "") {
								if (item.attributes[columnName]._originalValue != value) {
									status = "update";
								} else {
									status = "read";
								}
							} else {
								item.attributes[columnName]._originalValue = item.attributes[columnName] && item.attributes[columnName].value ? item.attributes[columnName].value : "";
								status = "update";
							}
							item.attributes[columnName].value = value;
							this._updateRowStatus(item, status);
						}
					}

					if (row) {
						var rowStatusIcon = row.querySelector('pebble-icon[id="rowStatus"]');
						if (rowStatusIcon) {
							if (item._rowStatus) {
								if (item._rowStatus.status == "update") {
									item._rowStatus.statusIcon = rowStatusIcon.icon = "pebble-icon:action-edit";
								} else if (item._rowStatus.status == "read") {
									item._rowStatus.statusIcon = rowStatusIcon.icon = "";
								}
							} else {
								rowStatusIcon.icon = "";
								item._rowStatus = {
									"statusIcon": ""
								};
							}
						}
					}
					var index = e.currentTarget.index;
					Polymer.Async.microTask.run(() => {
						this._updateError(item, index);
					});
					this.notifyPath("isDirty", undefined);
					this.isDirty = this.getIsDirty();

					var attribute = e.currentTarget || e.sourceElement;
					var isRevertClicked = e.detail.revertClicked;
					this._updateDependentAttributes(attribute, row.index, isRevertClicked);
				},

				_updateDependentAttributes: function (currentAttribute, rowIndex, isRevertButtonClicked) {
					var dependentAttributeElements = this.getDependentAttributeElementsInRow(currentAttribute, rowIndex);
					DataHelper.updateDependentAttributeElements(dependentAttributeElements, currentAttribute, isRevertButtonClicked);
				},

				getDependentAttributeElementsInRow: function (currentAttribute, rowIndex) {
					var node = Polymer.dom(this).node;
					var allAttributeElements = Polymer.dom(this).node.querySelectorAll('rock-attribute[row-index="' + rowIndex + '"]');
					if (allAttributeElements == undefined || allAttributeElements.length == 0) {
						allAttributeElements = Polymer.dom(this).node.root.querySelectorAll('rock-attribute[row-index="' + rowIndex + '"]');
					}

					return DataHelper.getDependentAttributesOfAttribute(allAttributeElements, currentAttribute);
				},
				_fireActionEvent: function (e) {
					var action = e.model.action;
					var eventName = action.eventName;
					var detail = e.currentTarget.item;
					if (!eventName) {
						if (action.name.toLowerCase() == 'delete') {
							eventName = "grid-delete-item";
						} else if (action.name.toLowerCase() == 'edit') {
							eventName = "grid-edit-item";
						} else if (action.name.toLowerCase() == 'sourceinfo') {
							var sourceInformation = this.$$("#action_" + e.model.item.id + "_" + action.name + "-popover");
							if (sourceInformation) {
								sourceInformation.show();
							}
						} else {
							return;
						}
					}
					if (action.name == "edit") {
						this.setRowMode(e.currentTarget.index, 'edit');
						e.currentTarget.item.index = e.currentTarget.index;
						this._dataChanged();
					}
					if (action.name == "delete") {
						var row = this._getParentRow(e.currentTarget);
						//delete data row added newly else mark data row status as deleted
						if(this._isNewlyAddedDataRow(row)){			
							this._deleteNewRowById(row.__data.item.id);						
							detail.isNewlyAddedDataRowDelete = true;
						} else {
							this._markRowAsDelete(row);
							this.setRowMode(e.currentTarget.index, 'view');
						}		
						
					}
					this.fireBedrockEvent(eventName, detail);
				},
				_markRowAsDelete: function (row) {
					if (row) {
						var rowStatusIcon = row.querySelector('pebble-icon[id="rowStatus"]');
						rowStatusIcon.icon = "pebble-icon:action-delete";
						var item = row.item;
						if (item && item._rowStatus) {
							item._rowStatus.statusIcon = "pebble-icon:action-delete";
							item._rowStatus.status = "delete";
						}
					}
				},
				_showActions: function (mode) {
					if (this._actions) {
						if (mode === "edit" || this.applyContextCoalesce) {
							return true;
						}
					}
					return false;
				},
				_getActions: function (mode, item) {
					var actions = undefined;
					if (this._actions) {
						var actions = this._actions;

						if (this.config && this.config.mode && this.config.mode.toLowerCase() == "edit") {
							if (this.config.hasWritePermission != undefined && !this.config.hasWritePermission) {
								for (var action in actions) {
									if (actions[action].name == "delete") {
										actions.splice(action, 1);
									}
								}
							}
						} else if (this.config && this.config.mode && this.config.mode.toLowerCase() == "read") {
							actions = actions.filter(v => v.intent == "read");
						}

						if (actions && this.applyContextCoalesce && item) {
							if (!this._hasContextCoalescedValue(item)) {
								var sourceAction;
								if (actions.length == 1 && actions[0].name.toLowerCase() == "sourceinfo") {
									sourceAction = actions[0];
								} else {
									sourceAction = actions.filter(v => v.name.toLowerCase() == "sourceinfo")[0];
								}

								if (sourceAction) {
									sourceAction.disable = true;
									sourceAction.tooltip = "Source info is not available.";
								}
							}
						}

					}

					return actions;
				},
				_updateError: function (item, index) {
					var errors = [];
					for (var i = 0; i < this._fields.length; i++) {
						var attr = this.shadowRoot.querySelector("#row" + index + "col" + i);
						if (attr && attr.errors.length > 0) {
							var errorObj = {};
							errorObj.name = this._fields[i].name;
							errorObj.externalName = this._fields[i].header;
							errorObj.type = "error";
							errorObj.message = attr.errors;
							errorObj.index = index;
							errors.push(errorObj);
						}
					}
					item.errors = errors;
					var errorLength = errors.length;
					var sp = this.shadowRoot.querySelector("#error-circle" + index);
					if (sp) {
						if (errorLength) {
							sp.hidden = false;
							sp.textContent = errorLength;
						} else {
							sp.hidden = true;
						}
					}
				},
				_openPopover: function (e) {
					var sp = e.currentTarget;
					var item = e.currentTarget.item;
					var index = e.currentTarget.index;
					var popover = this.shadowRoot.querySelector("#errorPopover");
					popover.positionTarget = sp;
					popover.setAttribute("for", "error-circle" + index);
					popover.querySelector("pebble-error-list").errors = item.errors;
					popover.show();
				},
				// Can be used to change the mode of a row to the read/edit mode.
				setRowMode: function (index, mode) {
					for (var i = 0; i < this._fields.length; i++) {
						var attr = this.shadowRoot.querySelector("#row" + index + "col" + i);
						if (attr) {
							attr.mode = mode;
						}
					}
				},
				_gridDataLoad: function () {
					if (this.data) {
						this.gridDataSize = this.currentRecordSize = this.data.length;
						if (this.data.length > 0 && this.defaultSortingEnabled) {
							this._sortGridData();
							this.defaultSortingEnabled = !this.defaultSortingEnabled;
						}
					}
				},
				_sortGridData: function () {
					if (this.config && this.config.itemConfig && this.config.itemConfig.sort && this.config.itemConfig.sort.default) {
						var sortConfig = this.config.itemConfig.sort.default;
						if (sortConfig && sortConfig.length) {
							var gridData = this.data;
							var direction = [];
							var field = [];
							var sortData = {};
							const sortCriteria = DataHelper.assignDefaultSequnceandSort(sortConfig);
							sortCriteria.map(function (item) {
								if (item && item.sortType && item.field) {
									direction.push(item.sortType);
									field.push(item.field);
								}
							});

							if (direction && field) {
								sortData['directions'] = direction;
								sortData['fields'] = field;
							};
							if (gridData && !_.isEmpty(sortData)) {
								gridData = gridData.sort(new DataHelper.sortingFunction(sortData).sort);
								this.set("data", gridData);
							}
						}
					}
				},
				_onDialogOk: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-ok", e);
				},
				_onDialogCancel: function (e) {
					this.fireBedrockEvent("on-grid-msg-dialog-cancel", e);
				},
				_getParentRow: function (element) {
					if (element) {
						if (element.is == "data-table-row") {
							return element;
						} else {
							return this._getParentRow(element.parentNode);
						}
					}
					return undefined;
				},
				_setOriginalValue: function (element) {
					if (element) {
						if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType ==
							"colModel") {
							Object.keys(element).forEach(function (item) {
								if (element[item + "_originalValue"] || element[item + "_originalValue"] == "") {
									element[item] = element[item + "_originalValue"];
								}
							}, this);

						} else if (this.config.schemaType == "attribute") {
							for (var attrKey in element.attributes) {
								if (element.attributes[attrKey]._originalValue || element.attributes[attrKey]._originalValue == "") {
									element.attributes[attrKey].value = element.attributes[attrKey]._originalValue;
								}
							}
						}
					}
				},
				_getRowStatusIcon: function (item) {
					if (item && Object.keys(item).length > 0) {
						var icon = "";
						if (item && item._rowStatus) {
							if (item._rowStatus.statusIcon) {
								icon = item._rowStatus.statusIcon;
							} else {
								item._rowStatus.statusIcon = "";
							}
						} else {
							item._rowStatus = {
								"statusIcon": ""
							}
						}
						return icon;
					}
				},
				_addClassOnUpdateRow: function (event) {
					var dataTableRows;
					if(event && !_.isEmpty(event.path)) {
						for (var key = 0; key < event.path.length; key++) {
							if (event.path[key].tagName) {
								if (event.path[key].tagName.toUpperCase() == "DATA-TABLE-ROW") {
									dataTableRows = event.path[key];
									break;
								}
							}
						}
					}
					
					if(!_.isEmpty(dataTableRows)) {
						dataTableRows.classList.add('value-updated');
					}
				},
				_updateRowStatus: function (item, status) {
					if (item) {
						if (status == "read") {
							if (this.config.schemaType == undefined || this.config.schemaType == "simple" || this.config.schemaType == "colModel") {
								var keys = Object.keys(item);
								if (keys && keys.length > 0) {
									for (var i = 0; i < keys.length; i++) {
										var columnName = keys[i];
										if (this.attributeModels[columnName] && item[columnName + "_originalValue"] && item[columnName] && item[columnName + "_originalValue"].toString() !== item[columnName].toString()) {
											status = "update";
										} else {
											continue;
										}
									}
								}
							}
						}
						if (item._rowStatus) {
							if (item._rowStatus.status) {
								if (item._rowStatus.status != "new") {
									item._rowStatus.status = status;
								}
							} else {
								item._rowStatus.status = status;
							}
						} else {
							item._rowStatus = {
								"status": status
							}
						}
					}
				},

				_getLink: function (col, item) {
					var _this = this;

					if (col.linkTemplate) {
						return col.linkTemplate.replace(/\{\S+?\}/g,
							function (match) {
								var attrName = match.replace("{", "").replace("}", "");
								if (attrName.toLowerCase() == "id") {
									return encodeURIComponent(item.id);
								}
								if (attrName.toLowerCase() == "type") {
									return encodeURIComponent(item.type);
								}

								var colModels = _this._fields;
								var index = -1;
								for (var i = 0; i < colModels.length; i++) {
									if (colModels[i].name == attrName) {
										index = i;
										break;
									}
								}
								if (index > -1) {
									return encodeURIComponent(_this._columnValue(item, index));
								}
								return encodeURIComponent(match);
							});
					}

					return "";
				},

				_hasLinkTemplate: function (col, item) {
					if (col) {
						if (col.linkTemplate && col.linkTemplate != "") {
							var notEditable = (this.config && this.config.mode && this.config.mode.toLowerCase() != "edit") || (item && item.mode && item.mode.toLowerCase() !=
								"edit");
							if (notEditable) {
								return true;
							}
						}
					}

					return false;
				},
				_hasIcon: function (col, item) {
					if (col) {
						if ((col.icon && col.icon != "") || col.iconColumn) {
							return true;
						}
					}

					return false;
				},
				_hasImage: function (col) {
					if (col) {
						if (col.displayType && col.imageSrc) {
							if (col.displayType == "image") {
								if (col.imageSrc == "entityThumbnail" || col.imageSrc == "publicUrl") {
									return true;
								}
							}
						} else {
							var attrModel = this.attributeModels[col.name];
							if (attrModel && attrModel.properties) {
								if (attrModel.properties.displayType == "image") {
									return true;
								}
							}
						}
					}
					return false;
				},
				_getAssetDetails: function (item) {
					if (item) {
						if (item.property_objectkey && item.property_originalfilename && item.type) {
							var item = {
								"property_objectkey": item.property_objectkey,
								"property_originalfilename": item.property_originalfilename,
								"type": item.type
							};
							return item;
						}

					}

				},
				/**
				 * Can be used to set the multi-selection on the grid.
				 */
				setMultiSelection: function (flag) {
					if (flag != undefined) {
						var ironDataTable = this._getIronDataTable();
						if (ironDataTable) {
							ironDataTable.multiSelection = flag;
						}
					}
				},

				/**
				 * Can be used to reset the grid size.
				 */
				notifyResize: function (e) {
					var ironDataTable = this._getIronDataTable();

					if (ironDataTable) {
						if (typeof (ironDataTable.notifyResize) == "function") {
							ironDataTable.notifyResize();
						}
					}

					const gridTileView = this.shadowRoot.querySelector('grid-tile-view');

					if (gridTileView) {
						gridTileView.notifyResize(e);
					}
				},

				/**
				 * Can be used to set the scroll position dynamically.
				 */
				scrollToIndex: function (index) {
					if (this.config.viewMode == "Tile") {
						var tileView = this.shadowRoot.querySelector("#gridTileView");
						tileView.scrollToIndex(index);
					} else if (this.config.viewMode == "List") {
						var listView = this.shadowRoot.querySelector("#gridListView");
						listView.scrollToIndex(index);
					} else {
						var ironDataTable = this._getIronDataTable();
						ironDataTable.shadowRoot.querySelector('#list').scrollToIndex(index);
					}
				},

				/**
				 * Can be used to get the selected grid row.
				 */
				getSelectedGridRow: function () {
					var ironDataTable = this._getIronDataTable();
					return ironDataTable.querySelector('data-table-row[selected]');
				},

				/**
				 * Can be used to get the selected item index.
				 */
				getSelectedItemIndex: function () {
					if (this.getData().length > 0 && this.selectedItem) {
						return this.getData().indexOf(this.selectedItem);
					}

					return -1;
				},
				_fixError: function (e, detail) {
					var errors = detail.data;
					if (errors.length) {
						this.setRowMode(errors[0].index, 'edit');
					}
					this.shadowRoot.querySelector("#errorPopover").hide();
				},
				_getDataSourceElement: function () {
					var dataSourceElement;
					if (this.rDataSourceId) {
						dataSourceElement = ComponentHelper.getParentElement(Polymer.dom(this).node).shadowRoot.querySelector('#' + this.rDataSourceId);
					}
					return dataSourceElement
				},
				_sortDirectionChanged: function (e) {
					if (e.detail && !e.detail.direction) {
						this.sortOrder = [];
					}
					var dataSourceElement = this._getDataSourceElement();
					if (dataSourceElement) {
						dataSourceElement.resetDataSource();
					}
					this._resetAdvanceSelection();
				},
				_setSelectionTitle: function (currentRecordSize, selectionInfo) {
					var startStatusMsg = '('
					var endStatusMsg = ' selected)'
					var selectionMode = this.getSelectionMode();
					var selectedItems = this.getSelectedItems();
					this.selectionTitle = '';
					if (selectedItems && selectedItems.length > 0) {
						if (selectionMode == 'query') {
							var totalCount = this.totalCount.toString();

							if (this.totalCount > 0) {
								this.selectionTitle = startStatusMsg + ' ' + totalCount + ' ' + endStatusMsg;
							}
						} else {
							this.selectionTitle = startStatusMsg + selectedItems.length + endStatusMsg;
						}
					}
				},
				getSelectedItemsAsQuery: function (e) {
					var queryObject = {};
					var dataSourceElement = this._getDataSourceElement();
					var selectionMode = this.getSelectionMode();

					if (dataSourceElement && dataSourceElement.request && dataSourceElement.request.params) {
						var searchQueryRequest = dataSourceElement.request;
						var searchQueryParams = searchQueryRequest.params;
						if (selectionMode == 'query') {
							queryObject = DataHelper.cloneObject(searchQueryRequest);
						} else if (selectionMode == 'count') {
							var selectedItems = this.getSelectedItems();
							if (selectedItems && selectedItems.length > 0) {
								var entityIds = [];
								for (var i = 0; i < selectedItems.length; i++) {
									entityIds.push(selectedItems[i].id);
								}
								queryObject.ids = entityIds;
								queryObject.filters = {};
								if (searchQueryParams && searchQueryParams.isCombinedQuerySearch) {
									if (searchQueryRequest.entity.data && searchQueryRequest.entity.data.jsonData) {
										var searchQueries = searchQueryRequest.entity.data.jsonData.searchQueries;
										for (var i = 0; i < searchQueries.length; i++) {
											if (searchQueries[i].serviceName === "entityservice") {
												queryObject.filters.typesCriterion = searchQueries[i].searchQuery.query.filters.typesCriterion;
												break;
											}
										}
									}
								} else {
									queryObject.filters.typesCriterion = searchQueryParams.query.filters.typesCriterion;
								}
							}
						}
					}
					return queryObject;
				},
				_getColWidth: function (col) {
					if (col.width) {
						if (!this._dataTableWidth) {
							var dataTable = this._getIronDataTable();
							this._dataTableWidth = dataTable && dataTable.clientWidth ? dataTable.clientWidth : undefined
						}
						if (this._dataTableWidth && this._dataTableWidth > 100) {
							return (this._dataTableWidth * col.width) / 100 + "px";
						}
					}
				},
				_getDependentAttributeModels: function (currentAttributeModel) {
					return DataHelper.getDependentAttributeModels(this.attributeModels, {},  currentAttributeModel);
				},
				_getDependentAttributes: function (item, currentAttributeModel, index) {
					var dependentAttributeModels = DataHelper.getDependentAttributeModels(this.attributeModels, {}, currentAttributeModel);
					var dependentAttributeValues = [];

					var gridColumns = this._fields;
					if (gridColumns && gridColumns.length && dependentAttributeModels && dependentAttributeModels.length) {
						for (let i = 0; i < dependentAttributeModels.length; i++) {

							var dependentAttributeModel = dependentAttributeModels[i]
							for (let colIndex = 0; colIndex < gridColumns.length; colIndex++) {
								if (dependentAttributeModel.name === gridColumns[colIndex].name) {
									dependentAttributeValues.push(this._getAttributeObject(item, dependentAttributeModel, colIndex, index));
									break;
								}
							}
						}
					}

					return dependentAttributeValues
				},
				_onRowDropEvent: function (e, detail) {
					if (this.config.mode != "edit") {
						this._modeChange('edit');
					}
					this.dispatchEvent(new CustomEvent("row-drop-event-raised", { detail: detail, bubbles: true, composed: true }));
				},
				_rowDblClicked: function (e) {
					//Disabling double click on row if configured
					if(this.config.isRowDoubleClickDisabled){
						return;
					}
					var detail = e.detail;
					if (detail && detail.item) {
						if (this.config && this.config.mode == "edit") {
							return;
						}
						var item = detail.item;
						if (this.config && this.config.itemConfig && this.config.itemConfig.linkTemplate) {
							var link = this._getLink(this.config.itemConfig, item);
							window.history.pushState("", "", link);
							window.dispatchEvent(new CustomEvent('location-changed'));
						}
					}
				},
				_configPresent: function (type) {
					if (this.config && this.config.viewConfig && this.config.viewConfig[type]) {
						return true;
					}
					return false;
				},
				_viewModeChanged: function () {
					if (this.config && this.config.viewMode) {
						this.dispatchEvent(new CustomEvent('view-mode-changed', { detail: { data: this.config.viewMode }, bubbles: true, composed: true }));
						if (this.data) {
							this.gridDataSize = this.currentRecordSize = this.data.length;
						} else {
							this.gridDataSize = 0;
							this.currentRecordSize = 0;
						}
					}
				},

				_isNestedAttribute: function (col, item) {
					if (this.gridItemView && !_.isEmpty(item)) {
						if (!col.isRowHeader && this.attributeModels[item.attributeName] && this.attributeModels[item.attributeName].dataType == "nested") {
							return true;
						}
					} else if (col && col.isNested) {
						return true;
					}

					return false;
				},

				_getRowModelAndData: function (item, col) {
					if (item) {
						var attrName = this.gridItemView ? item.attributeName : col.name;
						var attrModel = this.attributeModels[attrName];

						var firstDataContext = ContextHelper.getFirstDataContext(this.contextData);
						var firstValueContext = ContextHelper.getFirstValueContext(this.contextData);

						if (item.localeId) {
							firstValueContext.locale = item.localeId;
						}

						//debugger;
						if (attrModel && attrModel.group && attrModel.group.length > 0) {
							var attrValue = DataTransformHelper.transformNestedAttributes({ "group": item[col.name] }, attrModel.group[0], false, firstDataContext, firstValueContext);

							var attributeObject = {
								"value": attrValue
							};
							return {
								"attrModel": attrModel,
								"attr": attributeObject,
								"colHeader": col.header
							};
						}
					}
				},

				_openNestedAttr: function (e) {
					var parentRow = this._getParentRow(e.currentTarget);
					var item;
					if (parentRow) {
						item = parentRow.item;
					}
					var col = e.currentTarget.data;
					var attrDialog = this.$$('#attributeDialog');
					if (attrDialog && col && item) {
						var data = this._getRowModelAndData(item, col);
						var attrModel = data.attrModel;
						var rockComponent = customElements.get("rock-nested-attribute-grid");
						var rockElement = new rockComponent();

						delete attrModel.group[0].id;

						rockElement.attributeModelObject = attrModel;
						rockElement.attributeObject = data.attr;
						rockElement.originalAttributeObject = data.attr;
						rockElement.contextData = this.contextData;
						rockElement.mode = "view";

						var attrDialogContainer = attrDialog.querySelector('#attrDialogContainer');

						if (attrDialogContainer) {
							ComponentHelper.removeNode(attrDialogContainer.firstElementChild);

							attrDialogContainer.appendChild(rockElement);
							attrDialog.dialogTitle = data.colHeader + " : " + attrModel.externalName;
						}

						attrDialog.open();
					}
				},
				updateRowStatus: function (item, status) {
					this._updateRowStatus(item, status);
				},
				_getNestedAttributeValueCount: function (item, col) {
					if (!_.isEmpty(item) && col) {
						if (this.gridItemView) {
							return item[col.name] ? item[col.name].length : '0';
						}
						return item[col.header] && item[col.header].value ? item[col.header].value.length : '0';
					}
				},
				_getNestedAttributeMessage: function (item, col) {
					var count = this._getNestedAttributeValueCount(item, col) || 0;
					return this.nestedAttributeMessage.replace("{noOfValues}", count);
				},
				_flashTileview: function (e) {
					setTimeout(() => {
						this.notifyResize(e);
					}, 500);
				},
				updateGridData: function (data, detail) {
					var ironDataTable = this._getIronDataTable();
					if (ironDataTable) {
						ironDataTable.updateData(data, detail);
					}
				},
				_getCellClassValue: function (gridRowData, columnIndex) {
					var styleClass = "";
					if (this.applyLocaleCoalesceStyle) {
						let attributeName = this._fields[columnIndex].name;
						if (attributeName && this._isLocalizbale(attributeName) && this._hasLocaleCoalescePath(gridRowData, attributeName)) {
							styleClass = "fallback-value";
						}
					};

					if (this._columnValue(gridRowData, columnIndex) == "NA") {
						styleClass = _.isEmpty(styleClass) ? "disabled-value" : styleClass + " disabled-value";
					};

					if (this._hasContextCoalescedValue(gridRowData)) {
						styleClass = _.isEmpty(styleClass) ? "coalesced-value" : styleClass + " coalesced-value";
					}

					return styleClass;
				},
				_isLocalizbale: function (columnName) {
					return this.attributeModels[columnName] && this.attributeModels[columnName].isLocalizable;
				},
				_hasLocaleCoalescePath: function (gridRowData, columnName) {
					return gridRowData &&
						gridRowData.attributes &&
						gridRowData.attributes[columnName] &&
						gridRowData.attributes[columnName].properties &&
						gridRowData.attributes[columnName].properties.localeCoalescePath;
				},
				_getArrayFromObject: function (obj) {
					return DataHelper.convertObjectToArray(obj);
				},

				_hasContextCoalescedValue: function (item) {
					if (!_.isEmpty(item.contextCoalescePaths)) {
						return true;
					}
				},

				_hasPopoverInfo: function (action) {
					if (action && action.name.toLowerCase() == "sourceinfo") {
						return true;
					}
					return false;
				},

				/**
				 * Can be used to delete the row with status as 'new' or record id having status 'new'.
				 * {id} id record id having status as 'new'
				 */
				_deleteNewRowById: function (id) {
					var ironDataTable = this._getIronDataTable();
					if(id){
						ironDataTable._cachedItems = ironDataTable._cachedItems.filter(function(dataItem){
							return dataItem.id != id;
						});
					}
					this.set("data", "");
					this.set("data", ironDataTable._cachedItems);
					this.currentRecordSize = ironDataTable.size;
				},

				_isNewlyAddedDataRow(rowDetail) {
					if(rowDetail && rowDetail.__data && rowDetail.__data.item){
						const rowItem = rowDetail.__data.item;
						return DataHelper.isValidObjectPath(rowItem, "_rowStatus.status") && 
									rowItem._rowStatus.status.toLowerCase() == "new";
					}
				}
			});
		})();
	</script>
</dom-module>