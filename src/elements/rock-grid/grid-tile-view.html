<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../../bower_components/iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">

<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../rock-image-viewer/rock-image-viewer.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">

<!--
`grid-tile-view` Represents an element that displays the items in the `grid-tile-view`.

@demo demo/index.html
-->

<dom-module id="grid-tile-view">
    <template>
        <style include="pebble-styles-shared">

            iron-list {
                --iron-list-items-container: {
                    margin: auto;
                };
            }

            :host {
                /*display: block;*/
                @apply(--paper-font-common-base);
            }

            iron-list {
                /*margin-top: 90px;*/
                /*padding-bottom: 16px;*/
                /*margin-left: 0px;*/
            }

            .loadingIndicator {
                text-align: center;
                height: 40px;
            }

            .loadingIndicator {
                position: relative;
                text-align: center;
                width:100%;
                height: 100%;
            }

            #scrollingRegion {
                /*background-color: #ddd;*/
                top: 10vh;
                height: var(--rock-grid-height, 400px);
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
            }
            .tile{
                margin-left: -10px;
                margin-right: -10px;
            }

            .trim {
                display: block;
                width: 100%;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
            }

            .title {
                font-weight: bold;
            }

            .subtitle{
                margin-bottom: 5px;
                font-size: var(--font-size-sm, 12px);
                color: var(--palette-steel-grey, #75808b);
            }
            
            .block-text{
                font-weight: 500;
            }

            /*.actions {*/
            /*margin-left: 2%;*/
            /*!*margin-top: -7px;*!*/
            /*}*/

            .button-container {
                position: relative;
                float: left;
                margin: 20px 0 0 20px;
            }

            .photoContent {
                position: relative;
                width: 100%;
                background-color: white;
                border: solid 1px #c1cad4;
                border-radius: var(--default-border-radius, 3px);
                box-shadow: 0 0 3px 0 rgba(193, 202, 212, 0.7);
            }

            .photoContent .right {
                float:right;
                Padding: 10px 10px 0 0;
            }

            #image-container {
                width:  calc(100% - 20px);;
                height: 120px;
                margin: 10px;
                text-align: center;
                border-radius: var(--default-border-radius);
                float: left;
            }

            .text {
                margin: 20px;
            }

            .item-container {
                display: inline-flex;
                min-height: 302px;
                min-width: 236px;
                max-width: 260px;
                display: -webkit-inline-flex;
                border-radius: var(--default-border-radius);
                width: calc(20% - 20px);
                margin: 0 10px 20px 10px;
                float: left;
                -webkit-transition: all 0.3s;
                transition: all 0.3s;

            }
            .item-container:hover{
                box-shadow: 1px 2px 5px -1px var(--default-border-color);
            }

            @media (max-width: 800px) {
                .item-container {
                    display: inline-flex;
                    display: -webkit-inline-flex;
                    border-radius: var(--default-border-radius);
                    width: calc(50% - 16px);
                }
                .photoContent {
                    width: auto;
                }
            }

            @media (max-width: 400px) {

                .item-container {
                    @apply(--layout-flex);
                    width: 100%;
                }

                .photoContent > .detail {
                    opacity: 1;
                }
            }

            paper-checkbox::shadow #checkboxContainer {
                height: var(--paper-checkbox-size, var(--default-checkbox-size));
                width: var(--paper-checkbox-size, var(--default-checkbox-size));
                min-width: var(--paper-checkbox-size, var(--default-checkbox-size));
            }

            paper-checkbox::shadow #checkbox {
                border: solid 1px;
                border-color: var(--paper-checkbox-unchecked-color, var(--palette-cloudy-blue));
                border-radius: var(--default-border-radius);
                height: var(--paper-checkbox-size, var(--default-checkbox-size));
                width: var(--paper-checkbox-size, var(--default-checkbox-size));
            }

            paper-checkbox[checked]::shadow #checkbox {
                background-color: var(--paper-checkbox-checked-color, var(--palette-cerulean-two));
                border-color: var(--paper-checkbox-checked-color, var(--palette-white));
            }

            paper-checkbox[checked]::shadow #checkmark {
                width: 20%;
                height: 50%;
                -webkit-transform-origin: 60% 110%;
                -ms-transform-origin: 60% 110%;
                transform-origin: 60% 110%;
            }

            .right {
                float: right;
            }

            .center {
                text-align: center;
                color: #36ABEA;
            }

            .top {
                display: inline-flex;
                display: -webkit-inline-flex;
                width: 100%;
                text-align: center;
                box-sizing: border-box;
                border-bottom: 1px solid var(--divider-color, #c1cad4);
                padding: var(--list-padding, 7px);
            }

            .header-button-container {
                position: relative;
                /*top:30%;*/
                left: 0.6%;
                float: left;
                margin-top: -15px;
            }

            .actions {
                margin-left: 2%;
                /*margin-top: -7px;*/
            }

             .actionsPopover {
                @apply(--pebble-actions-popover);
                 --default-popup-t-p:5px;
                 --default-popup-b-p:5px;
            }
            pebble-popover paper-item {
                cursor: pointer;
                font-size: var(--default-font-size, 14px);
                min-height: 10px;
            }

            pebble-popover paper-item iron-icon {
                --iron-icon-width: 18px;
                --iron-icon-height: 18px;
            }
            
            pebble-popover paper-item:hover{
                background-color:#eee;
                color:var(--palette-cerulean);
            }
            paper-icon-button{
                padding: 0;
                margin-top: 8px;
                margin-right: 5px;
                color: var(--primary-icon-color, #75808b);
            }
            .dropdown-trigger {
                --pebble-button-iron-icon: {
                    height: 20px;
                    width: 20px ;
                    padding:0 3px 0 3px;
                    color: #7d8690;
                    @apply(--pebble-actions-button-icon);
                }
                --pebble-button-dropdown-icon: {
                    height: 20px;
                    width: 20px;
                    color: #7d8690;
                    @apply(--pebble-actions-button-drop-down-icon);
                }
            }
            .listContent {
                font-size: var(--default-font-size);
                color: var(--palette-steel-grey);
            }



        </style>


        <div class="top" hidden="[[!showSelectAll]]">
            <pebble-checkbox  class="header-button-container" header on-tap="_toggleSelectAll"
                                                checked="[[_isSelectAllChecked(selectedItems.length, selectedItems.inverted, items.length)]]"
                                                indeterminate="[[_isSelectAllIndeterminate(selectedItems.length, items.length)]]"></pebble-checkbox>
        </div>
        <div id="scrollingRegion">
            <div class ="tile">
            <template is="dom-repeat" items="{{items}}" as="item">
                <div class="item-container" id$="gridItem[[index]]">
                    <div class="photoContent" tabindex$="[[tabIndex]]" >
                            <paper-checkbox on-tap="_tapEvent" class="button-container"
                                            checked="[[_isSelected(item, selectedItems, selectedItems.*)]]" noink></paper-checkbox>
                            <div class = "right">
                            <paper-icon-button id="actions_container_{{item.id}}" class="dropdown-trigger pebble-md-icons" name="more" icon="pebble-md-icons:MoreVert"
                                               title="More options" on-tap = "_onActionsTap" noink></paper-icon-button>
                            <pebble-popover id$="action_list_{{item.id}}" class = "actionsPopover" for="actions_container_{{item.id}}" auto-fit-on-attach no-overlap horizontal-align="right">
                                <template is="dom-repeat" items="[[actions]]" as="action">
                                    <paper-item on-tap="_onActionItemTap" action = "[[action]]" item="[[item]]" class="tooltip-bottom" data-tooltip$="[[action.tooltip]]">
                                        <div>
                                            <template is="dom-if" if="[[action.icon]]">
                                                <iron-icon icon="[[action.icon]]"></iron-icon>
                                            </template>
                                        </div>
                                        <div>
                                            <template is="dom-if" if="[[action.text]]">
                                                [[action.text]]
                                            </template>
                                        </div>
                                    </paper-item>
                                </template>
                            </pebble-popover>
                            </div>
                            <rock-image-viewer alt="Product image." id="image-container" sizing="contain"
                                               src="{{_computeImage(item,tileItems.image)}}" thumbnail-id="{{_computeValue(item,tileItems.thumbnailId)}}">
                            </rock-image-viewer>
                            <div class="clearfix"></div>
                            <div class="text">
                                <div class="title block-text tooltip-bottom" data-tooltip$="[[_computeTitle(item,tileItems.title)]]">
                                    <div class="text-ellipsis">[[_computeTitle(item,tileItems.title)]]</div>
                                </div>
                                <div class="subtitle tooltip-bottom" data-tooltip$="[[_computeSubtitle(item,tileItems.subtitle)]]"><div class="text-ellipsis">[[_computeSubtitle(item,tileItems.subtitle)]]</div></div>
                                <template is="dom-repeat" items="{{tileItems.fields}}" as="field">
                                    <div class="listContent tooltip-bottom" data-tooltip$="[[_computeValue(item,field.name)]]"><span class$="{{_computeClass(field)}}">{{_getDisplayName(field.label)}} <span
                                            class="block-text">&nbsp;[[_computeValue(item,field.name)]]</span></span>
                                    </div>
                                </template>
                            </div>
                    </div>
                </div>
            </template>
            </div>
            <template is="dom-if" if="{{loading}}">
                <div class="loadingIndicator">
                    <pebble-spinner active="[[loading]]"></pebble-spinner>
                </div>
            </template>
            <!-- this element will load more data when the user scrolls down and reached the lower threshold -->
            <iron-scroll-threshold id="scrollThreshold"  on-lower-threshold="_loadMoreData"
                                   scroll-target="scrollingRegion">
            </iron-scroll-threshold>
        </div>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'grid-tile-view',
                properties: {
                    /**
                     * Indicates an array of items that needs the display in the `grid-tile-view`.
                     */
                    items: {
                        type: Array,
                        value: [],
                        notify: true
                    },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                    dataSource: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },
                    /**
                     * Indicates the current page in the `grid-tile-view`.
                     */
                    page: {
                        type: Number,
                        value: 0,
                        notify: true
                    },
                    /**
                     * Indicates the page size in the `grid-tile-view`.
                     */
                    pageSize: {
                        type: Number,
                        value: 15,
                        notify: true
                    },
                    /**
                     * Specifies whether or not to load the data. Set it to <b>true</b> to load the data.
                     *
                     */
                    loading: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Specifies whether or not multiple items are selected at once. When it is set to <b>true</b>, multiple items are selected at once.
                     * Otherwise, only one item is selected at a time.
                     */
                    multiSelection: {
                        type: Boolean,
                        value: false,
                        notify: true
                    },
                    /**
                     * Indicates an array of the selected items. When it is <b>true</b>, this array contains the selected items. 
                     * However, if `selectedItems.inverted` is <b>true</b>, the array contains deselected items.
                     */
                    selectedItems: {
                        type: Array,
                        value: [],
                        notify: true
                    },
                    /**
                     * Indicates the currently selected item if the `multiSelection` is set to <b>false</b>.
                     * It is set to "null" when no items are selected.
                     */
                    selectedItem: {
                        type: Object,
                        //value : {},
                        notify: true,
                        reflectToAttribute: true
                    },
                    /**
                     * Specifies whether or not the tapping a row selects the item.
                     * The selection of the item places its data model in the set of selected items. 
                     * This is retrievable via the selection property.
                     */
                    selectionEnabled: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },

                    /**
                     * Indicates the config of the `grid-tile-view`.
                     */
                    tileItems: {
                        type: Object
                    },
                    

                    /**
                     *  Indicates the supported actions in the `grid-tile-view`.
                     * 
                     */
                    actions : {
                         type:Array,
                         value : []
                     },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                    showSelectAll:{
                        type:Boolean,
                        value:false
                    }
                },
                observers: [
                    '_pageChanged(dataSource, page)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior
                ],
                _loadMoreData: function () {
                    this.page++;
                },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                reloadData: function () {
                    this.items = [];
                    this.page=0;
                    this.page=1;
                },

                /**
                 * This is an internal function, used to calculate the display name of an attribute.
                 */
                _getDisplayName: function (label) {
                        return label+" :";
                },
                /**
                 * This is an internal function, used to calculate the class to apply trim or not.
                 */
                _computeClass: function (field) {
                    if(field.noTrim) {
                        return 'default';
                    }
                    return 'default trim';
                },
                /**
                 * This is an internal function, returns true if number of fields to display is greater than 4.
                 */
                _areFieldsGreaterThan4: function (fields) {
                    if (fields && fields.length > 4) {
                        return true;
                    }
                    return false;
                },
                /**
                 * This is an internal function to handle the tap event. It fires event 'deselecting-item' if an item was already selected.
                 *  It fires event 'selecting-item' if an item was not selected. The data of the event fired is the data of the item.
                 */
                _tapEvent: function (e) {
                    if (this._isSelected(e.model.item, this.selectedItems)) {
                        this._fireEvent('deselecting-item', e.model.item, this.deselectItem);
                    } else {
                        this._fireEvent('selecting-item', e.model.item, this.selectItem);
                    }
                },
                /**
                 * This is an internal function, used to compute the image url based on the config.
                 */
                _computeImage: function (item, image) {
                    return item[image];
                },
                /**
                 * This is an internal function, used to compute the title based on the config.
                 */
                _computeTitle: function (item, title) {
                    return item[title];
                },
                /**
                 * This is an internal function, used to compute the id based on the config.
                 */
                _computeSubtitle: function (item, subtitle) {
                    return item[subtitle];
                },
                /**
                 * This is an internal function, used to compute the value of the attribute to be displayed.
                 */
                _computeValue: function (item, field) {
                    return item[field];
                },
                _setSelectedItem: function (item) {
                    this.set('selectedItem', item);
                },
                _setSelectedItems: function (items) {
                    this.set('selectedItems', items);
                },
                /**
                 * Can be used to select the list item at the given index.
                 *
                 * @method selectItem
                 * @param {(Object|number)} item The item object or its index
                 */
                selectItem: function (item) {
                    if (typeof item === 'number' && item >= 0 && this.items && this.items.length > item) {
                        this._selectItem(this.items[item]);
                    } else {
                        this._selectItem(item);
                    }
                },
                _selectItem: function (item) {
                    this._setSelectedItem(item);
                    if (this.multiSelection) {
                        if (this.selectedItems.inverted) {
                            var index;
                            if ((index = this.selectedItems.indexOf(item)) > -1) {
                                this.splice('selectedItems', index, 1);
                            }
                        } else {
                            this.push('selectedItems', item);
                        }
                    } else {
                        this.splice('selectedItems', 0, this.selectedItems.length, item);
                    }
                },
                /**
                 * Can be used to deselect the given item list if it is already selected.
                 *
                 * @method deselect
                 * @param {(Object|number)} item The item object or its index
                 */
                deselectItem: function (item) {
                    if (typeof item === 'number' && item >= 0 && this.items && this.items.length > item) {
                        this._deselectItem(this.items[item]);
                    } else {
                        this._deselectItem(item);
                    }
                },
                _deselectItem: function (item) {
                    this._setSelectedItem(null);
                    var index = this.selectedItems.indexOf(item);
                    if (this.selectedItems.inverted) {
                        if (index === -1) {
                            this.push('selectedItems', item);
                        }
                    } else {
                        if (index > -1) {
                            this.splice('selectedItems', index, 1);
                        }
                    }
                },
                _isSelected: function (item, selectedItems) {
                    var selected = selectedItems.indexOf(item) > -1;
                    return selectedItems.inverted ? !selected : selected;
                },
                /*
                 * Can be used to select all the items in the list.
                 */
                selectAll: function () {
                    var length = this.selectedItems.length;
                    this.splice('selectedItems', 0, length);
                    this.set('selectedItems.inverted', true);
                },
                /**
                 * Can be used to clear the current selection state.
                 */
                clearSelection: function () {
                    var length = this.selectedItems.length;
                    this.splice('selectedItems', 0, length);
                    this.set('selectedItems.inverted', false);
                    if (this.selectedItem !== undefined) {
                        this._setSelectedItem(null);
                    }
                },
                _fireEvent: function (eventName, item, defaultAction) {
                    var e = this.fire(eventName, {item: item}, {cancelable: true});
                    if (!e.defaultPrevented) {
                        defaultAction.call(this, item);
                    }
                },
                _toggleSelectAll: function () {
                    if (this._isSelectAllChecked(this.selectedItems.length, this.selectedItems.inverted, this.items.length)) {
                        this._fireEvent("deselecting-all-items", {items: this.selectedItems}, this.clearSelection);
                    } else {
                        this._fireEvent("selecting-all-items", {items: this.selectedItems}, this.selectAll);
                    }
                },
                _isSelectAllChecked: function (selectedItemsLength, inverted, size) {
                    return size > 0 && selectedItemsLength === (inverted ? 0 : size);
                },
                _isSelectAllIndeterminate: function (length, size) {
                    return size > 0 && length > 0 && length < size;
                },
                 _onActionsTap: function (e) {
                     var id = 'action_list_' + e.model.item.id;
                    this.$$('#' + id).show();
                },

                _onActionItemTap : function(e) {
                    var action = e.model.action;
                    var eventName = action.eventName;
                    if (!eventName) {
                        if (action.name == 'delete') {
                            eventName = "grid-delete-item";
                        } else if (action.name == 'edit') {
                            eventName = "grid-edit-item";
                        } 
                    }
                    this.fireBedrockEvent(eventName,  e.model.item ,{"ignoreId":"true"});
                    var id = 'action_list_' + e.model.item.id;
                    this.$$('#' + id).hide();
                },
                _pageChanged: function (dataSource, currentPage) {
                    if (typeof (dataSource) == 'function' && currentPage > 0) {
                        this.loading = true;
                        var success = this._success.bind(this);
                        var error = this._error.bind(this);
                        dataSource({
                            page: this.page,
                            pageSize: this.pageSize,
                            sortOrder: this.sortOrder
                        }, success, error);
                    }
                },
                _success: function (data) {
                    if (data.length > 0) {
                        for (var i = 0; i < data.length; i++) {
                            this.push('items', data[i]);
                        }
                        this.$.scrollThreshold.clearTriggers();
                    } else {
                        this.page = -1; // Future Enhancement
                    }
                    this.loading = false;
                },
                _error: function () {
                    this.loading = false;
                },
                scrollToIndex:function (index) {
                    var item=this.$$("#gridItem"+index);
                    if(item) {
                        item.scrollIntoView();
                    }
                }

            });
        })();
    </script>
</dom-module>