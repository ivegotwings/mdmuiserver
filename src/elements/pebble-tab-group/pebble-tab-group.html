<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-menu-behavior/iron-menubar-behavior.html">
<link rel="import" href="../../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../../bower_components/paper-tabs/paper-tabs-icons.html">

<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/flattened-nodes-observer.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../pebble-tab/pebble-tab.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">

<!--
` <pebble-tab-group>` Represents a group of tabs with material design styling.

### Accessibility

See the docs for `Polymer.IronResizableBehavior`, `Polymer.IronMenubarBehavior` for accessibility features implemented by this element.

@demo demo/index.html
-->
<dom-module id="pebble-tab-group">
    <template>
        <style include="bedrock-style-common">
             :host {
                @apply --layout;
                @apply --layout-center;
                height: var(--default-tab-height);
                font-size: var(--default-font-size, 14px);
                font-weight: var(--font-medium, 500);
                /*overflow: hidden;*/
                -moz-user-select: none;
                -ms-user-select: none;
                -webkit-user-select: none;
                user-select: none;
                /* NOTE: Both values are needed, since some phones require the value to be `transparent`. */
                -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                -webkit-tap-highlight-color: transparent;
                @apply --paper-tabs;
                border-bottom: 1px solid var(--palette-cloudy-blue, #c1cad4);
                box-sizing: border-box;
                margin-top: 5px;
            }

             :host-context([dir=rtl]) {
                @apply --layout-horizontal-reverse;
            }

            #tabsContainer {
                position: relative;
                height: 100%;
                white-space: nowrap;
                overflow: hidden;
                @apply --layout-flex-auto;
                @apply --paper-tabs-container;
            }

            #tabsContent {
                height: 100%;
                flex-basis: auto;
                -webkit-flex-basis: auto;
                /* Safari 6.1+ */
                @apply --paper-tabs-content;
            }

            #tabsContent.scrollable {
                position: absolute;
                white-space: nowrap;
            }

            #tabsContent:not(.scrollable),
            #tabsContent.scrollable.fit-container {
                @apply --layout-horizontal;
            }
            
            #tabsContent.scrollable.fit-container {
                min-width: 100%;
            }

            #tabsContent.scrollable.fit-container> ::slotted(*) {
                /* IE - prevent tabs from compressing when they should scroll. */
                -ms-flex: 1 0 auto;
                -webkit-flex: 1 0 auto;
                flex: 1 0 auto;
            }

            .hidden {
                display: none;
            }

            .not-visible {
                opacity: 0;
                cursor: default;
            }
            pebble-tab paper-menu paper-item {
                padding: 0 10px;
            }

            #selectionBar {
                position: absolute;
                height: 2px;
                bottom: 0;
                left: 0;
                right: 0;
                background: var(--palette-cerulean-two, #026bc3);
                -webkit-transform: scale(0);
                -ms-transform: scale(0);
                transform: scale(0);
                -webkit-transform-origin: left center;
                -ms-transform-origin: left center;
                transform-origin: left center;
                transition: -webkit-transform;
                transition: transform;
                @apply --paper-tabs-selection-bar;
            }

            #selectionBar.align-bottom {
                top: 0;
                bottom: auto;
            }

            #selectionBar.expand {
                transition-duration: 0.15s;
                -webkit-transition-duration: 0.15s;
                transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
                -webkit-transition-timing-function: cubic-bezier(0.4, 0.0, 1, 1);
            }

            #selectionBar.contract {
                transition-duration: 0.18s;
                -webkit-transition-duration: 0.18s;
                transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
                -webkit-transition-timing-function: cubic-bezier(0.0, 0.0, 0.2, 1);
            }

            /* #tabsContent> ::slotted(*) {
                height: 100%;
            } */
          
        </style>
        <pebble-icon icon="pebble-icon:action-scope-release-selection" class$="[[_computeScrollButtonClass(_leftHidden, scrollable, hideScrollButtons)]] pebble-icon-size-16 m-r-15 m-l-5" 
            on-up="_onScrollButtonUp" on-down="_onLeftScrollButtonDown" tabindex="-1" noink></pebble-icon>

        <div id="tabsContainer" on-track="_scroll" on-down="_down">
            <div id="tabsContent" class$="[[_computeTabsContentClass(scrollable, fitContainer)]]">
                <div id="selectionBar" class$="[[_computeSelectionBarClass(noBar, alignBottom)]]" on-transitionend="_onBarTransitionEnd"></div>
                <slot></slot>
            </div>
        </div>
        
        <pebble-icon icon="pebble-icon:action-scope-take-selection" class$="[[_computeScrollButtonClass(_rightHidden, scrollable, hideScrollButtons)]] pebble-icon-size-16 m-r-5 m-l-15"
            on-up="_onScrollButtonUp" on-down="_onRightScrollButtonDown" tabindex="-1" noink></pebble-icon>
      
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'pebble-tab-group',
                properties: {
                    /**
                     * Indicates the identification of an `element`.
                     */
                    id: {
                        type: String,
                        reflectToAttribute: true
                    },

                    /**
                     * Indicates whether or not the ink ripple effect is disabled.
                     * Change in this property causes all descendant <paper-tab> 
                     * elements to have their noink property changed to the new value. 
                     */
                    noink: {
                        type: Boolean,
                        value: false,
                        observer: '_noinkChanged'
                    },

                    /**
                     * Indicates whether or not the `bottom bar` that shows the selected tab is displayed.
                     */
                    noBar: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether or not the slide effect for the `bottom bar` is disabled.
                     */
                    noSlide: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Specifies whether or not the tabs are scrollable and the tab width is based on the label width.
                     */
                    scrollable: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether or not the tabs can expand to fit their container. Currently this is applied only when
                     * scrollable is true.
                     */
                    fitContainer: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether or not the dragging on the tabs to scroll is disabled.
                     */
                    disableDrag: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether or not the left and right arrow scroll buttons are hidden for scrollable tabs.
                     */
                    hideScrollButtons: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether or not the tabs are aligned to the `bottom`. Note that the selection bar appears at the top.
                     */
                    alignBottom: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates the name of the item element that is used as a sub-tree of pebble-tab-group.
                     */
                    selectable: {
                        type: String,
                        value: 'pebble-tab' // * This property is used by the 'IronMenubarBehavior' behaviour. See issue #192 on github in paper tabs repo.
                    },

                    /**
                     * Indicates whether or not the tabs are selected automatically when you focus using the
                     * keyboard.
                     */
                    autoselect: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates the delay when the user stops interacting
                     * with the tabs through the keyboard and when the focused item is
                     * automatically selected. This happens only when `autoselect` is set to <b>true</b>. 
                     * Note that the delay is in milliseconds.
                     */
                    autoselectDelay: {
                        type: Number,
                        value: 0
                    },

                    _step: {
                        type: Number,
                        value: 10
                    },

                    _holdDelay: {
                        type: Number,
                        value: 1
                    },

                    _leftHidden: {
                        type: Boolean,
                        value: false
                    },

                    _rightHidden: {
                        type: Boolean,
                        value: false
                    },

                    _previousTab: {
                        type: Object
                    },
                    /**
                     * Indicates the data model that is passed to `pebble-tab-group`.
                     */
                    data: {
                        type: Object,
                        notify: true
                    },

                    _isMenuItemSelected: {
                        type: Boolean,
                        value: false
                    }
                },

                behaviors: [
                    Polymer.IronResizableBehavior,
                    Polymer.IronMenubarBehavior,
                    RUFBehaviors.UIBehavior
                ],

                listeners: {
                    'iron-items-changed': '_onTabSizingChanged',
                    'iron-select': '_onIronSelect',
                    'iron-deselect': '_onIronDeselect'
                },

                keyBindings: {
                    'left:keyup right:keyup': '_onArrowKeyup'
                },
          /**
            * Content is not appearing - Content development is under progress. 
            */
                created: function () {
                    this._holdJob = null;
                    this._pendingActivationItem = undefined;
                    this._pendingActivationTimeout = undefined;
                    this._bindDelayedActivationHandler = this._delayedActivationHandler.bind(this);
                    this.addEventListener('blur', this._onBlurCapture.bind(this), true);
                },
          /**
            * Content is not appearing - Content development is under progress. 
            */
                ready: function () {
                    this.setScrollDirection('y', this.$.tabsContainer);
                    this._tabsContent = this.shadowRoot.querySelector("#tabsContent");
                },
          /**
            * Content is not appearing - Content development is under progress. 
            */
                detached: function () {
                    this._cancelPendingActivation();
                },

                _noinkChanged: function (noink) {
                    var childTabs = Polymer.dom(this).querySelectorAll('pebble-tab');
                    childTabs.forEach(noink ? this._setNoinkAttribute : this._removeNoinkAttribute);
                },

                _setNoinkAttribute: function (element) {
                    element.setAttribute('noink', '');
                },

                _removeNoinkAttribute: function (element) {
                    element.removeAttribute('noink');
                },

                /**
                 * Function to compute 'transition end' and call the handler to handle it.
                 * Note : Edge browser does'nt listen to the "transition end" event all times by default
                 */   
                _computeTransitionEnd: function (){
                    var transitions = {
                        'transition':'transitionend',
                        'OTransition':'oTransitionEnd',
                        'MozTransition':'transitionend',
                        'WebkitTransition':'webkitTransitionEnd'
                    }

                    var transitionEnd = false;
                    for(var t in transitions){
                        if( this.$.selectionBar.style[t] !== undefined ){
                            transitionEnd = true;
                            break;
                        }
                    }
                   
                    if(transitionEnd) {
                        this._onBarTransitionEnd();
                    }
                },

                _computeScrollButtonClass: function (hideThisButton, scrollable, hideScrollButtons) {
                    if (!scrollable || hideScrollButtons) {
                        return 'hidden';
                    }

                    if (hideThisButton) {
                        // Note: Show both icons on a page 
                        // return 'not-visible';
                    }

                    return '';
                },

                _computeTabsContentClass: function (scrollable, fitContainer) {
                    return scrollable ? 'scrollable' + (fitContainer ? ' fit-container' : '') :
                        ' fit-container';
                },

                _computeSelectionBarClass: function (noBar, alignBottom) {
                    if (noBar) {
                        return 'hidden';
                    } else if (alignBottom) {
                        return 'align-bottom';
                    }

                    return '';
                },

               _onTabSizingChanged: function () {
                     this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(10), () => {
                        this._scroll();
                        this._tabChanged(this.selectedItem);

                        var tabGroupRect = this.getBoundingClientRect();
                        var tabs = this.querySelectorAll("pebble-tab");
                        if(tabs && tabs.length > 0) {
                            var totalWidth = 0;
                            for(var i = 0; i < tabs.length; i++) {
                                var tab = tabs[i.toString()];
                                if(tab) {
                                    totalWidth += tab.getBoundingClientRect().width;
                                }
                            }
                            if(totalWidth <= tabGroupRect.width) {
                                this.hideScrollButtons = true;
                            }
                        }
                    });
                },

                _onIronSelect: function (event) {
                    var tab;

                    // Note: More Info. available in Select method
                    if (event) {
                        if (event.target.nodeName === "PAPER-LISTBOX") {
                            this._isMenuItemSelected = true;
                            if (event.detail && event.detail.item) {
                                var item = event.detail.item;
                                if (item) {
                                    tab = this.querySelector("#" + item.tabConfig.name);
                                }
                            }
                            tab.closeMenu();
                        } else {
                            tab = event.detail.item;
                        }
                    }

                    this._tabChanged(tab, this._previousTab);
                    this._previousTab = tab;
                    if(this._debouncer && this._debouncer.cancel) {
                        this._debouncer.cancel();
                    }
                },

                _onIronDeselect: function (event) {
                    if(event.detail.item.nodeName !== "PAPER-ITEM") {
                        this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(1), () => {
                            this._tabChanged(null, this._previousTab);
                            this._previousTab = null;
                            // See polymer/polymer#1305
                        });
                    }
                },

                _activateHandler: function () {
                    // Cancel item activations scheduled by keyboard events when any other
                    // action causes an item to be activated (e.g. clicks).
                    this._cancelPendingActivation();
                    Polymer.IronMenuBehaviorImpl._activateHandler.apply(this, arguments);
                },

                _scheduleActivation: function (item, delay) {
                    this._pendingActivationItem = item;
                    this._pendingActivationTimeout = setTimeout(() =>{
                        this._bindDelayedActivationHandler, delay
                    });
                },

                _delayedActivationHandler: function () {
                    var item = this._pendingActivationItem;
                    this._pendingActivationItem = undefined;
                    this._pendingActivationTimeout = undefined;
                    item.fire(this.activateEvent, null, {
                        bubbles: true,
                        cancelable: true
                    });
                },

                _cancelPendingActivation: function () {
                    if (this._pendingActivationTimeout !== undefined) {
                        this.cancelAsync(this._pendingActivationTimeout);
                        this._pendingActivationItem = undefined;
                        this._pendingActivationTimeout = undefined;
                    }
                },

                _onArrowKeyup: function (event) {
                    if (this.autoselect) {
                        this._scheduleActivation(this.focusedItem, this.autoselectDelay);
                    }
                },

                _onBlurCapture: function (event) {
                    // Cancel a scheduled item activation (if any) when that item is
                    // blurred.
                    if (event.target === this._pendingActivationItem) {
                        this._cancelPendingActivation();
                    }
                },

                get _tabContainerScrollSize() {
                    return Math.max(0,
                        this.$.tabsContainer.scrollWidth -
                        this.$.tabsContainer.offsetWidth
                    );
                },

                _scroll: function (e, detail) {
                    if (!this.scrollable) {
                        return;
                    }

                    var ddx = (detail && -detail.ddx) || 0;
                    this._affectScroll(ddx);
                },

                _down: function (e) {
                    // go one beat async to defeat IronMenuBehavior
                    // autorefocus-on-no-selection timeout
                    setTimeout(() =>{
                        if (this._defaultFocusAsync) {
                            this.cancelAsync(this._defaultFocusAsync);
                            this._defaultFocusAsync = null;
                        }
                    }, 1);
                },

                _affectScroll: function (dx) {
                    this.$.tabsContainer.scrollLeft += dx;

                    var scrollLeft = this.$.tabsContainer.scrollLeft;

                    this._leftHidden = scrollLeft === 0;
                    this._rightHidden = scrollLeft === this._tabContainerScrollSize;
                },

                _onLeftScrollButtonDown: function () {
                    this._clearHoldJobInterval();
                    this._scrollToLeft();
                    this._holdJob = setInterval(this._scrollToLeft.bind(this), this._holdDelay);
                },

                _onRightScrollButtonDown: function () {
                    this._clearHoldJobInterval();
                    this._scrollToRight();
                    this._holdJob = setInterval(this._scrollToRight.bind(this), this._holdDelay);
                },

                _clearHoldJobInterval() {
                    if(!this._holdJob) return;
                    
                    clearInterval(this._holdJob);
                    this._holdJob = null;
                },

                _onScrollButtonUp: function () {
                    this._clearHoldJobInterval();
                },

                _scrollToLeft: function () {
                    this._affectScroll(-this._step);
                },

                _scrollToRight: function () {
                    this._affectScroll(this._step);
                },

                _tabChanged: function (tab, old) {
                    if (!tab) {
                        // Remove the bar without animation.
                        this.$.selectionBar.classList.remove('expand');
                        this.$.selectionBar.classList.remove('contract');
                        this._positionBar(0, 0);
                        return;
                    }

                    var r = this.$.tabsContent.getBoundingClientRect();
                    var w = r.width;
                    var tabRect = tab.getBoundingClientRect();
                    var tabOffsetLeft = tabRect.left - r.left;

                    this._pos = {
                        width: this._calcPercent(tabRect.width, w),
                        left: this._calcPercent(tabOffsetLeft, w)
                    };

                    if (this.noSlide || old == null) {
                        // Position the bar without animation.
                        this.$.selectionBar.classList.remove('expand');
                        this.$.selectionBar.classList.remove('contract');
                        this._positionBar(this._pos.width, this._pos.left);
                        return;
                    }

                    var oldRect = old.getBoundingClientRect();
                    var oldIndex = this.items.indexOf(old);
                    var index = this.items.indexOf(tab);
                    var m = 5;

                    // bar animation: expand
                    this.$.selectionBar.classList.add('expand');

                    var moveRight = oldIndex < index;
                    var isRTL = this._isRTL;
                    if (isRTL) {
                        moveRight = !moveRight;
                    }

                    if (moveRight) {
                        this._positionBar(this._calcPercent(tabRect.left + tabRect.width - oldRect.left,
                                w) - m,
                            this._left);
                    } else {
                        this._positionBar(this._calcPercent(oldRect.left + oldRect.width - tabRect.left,
                                w) - m,
                            this._calcPercent(tabOffsetLeft, w) + m);
                    }                   

                    if (this.scrollable) {
                        this._scrollToSelectedIfNeeded(tabRect.width, tabOffsetLeft);
                    }

                    //Compute transition end for Edge browser as the browser does'nt listen to the "transition end" event all times
                    if(DataHelper.checkBrowser('edge')) {
                        this._computeTransitionEnd();
                    }                    
                },

                _scrollToSelectedIfNeeded: function (tabWidth, tabOffsetLeft) {
                    var l = tabOffsetLeft - this.$.tabsContainer.scrollLeft;
                    if (l < 0) {
                        this.$.tabsContainer.scrollLeft += l;
                    } else {
                        l += (tabWidth - this.$.tabsContainer.offsetWidth);
                        if (l > 0) {
                            this.$.tabsContainer.scrollLeft += l;
                        }
                    }
                },

                _calcPercent: function (w, w0) {
                    return 100 * w / w0;
                },

                _positionBar: function (width, left) {
                    width = width || 0;
                    left = left || 0;

                    this._width = width;
                    this._left = left;
                    this.transform(
                        'translateX(' + left + '%) scaleX(' + (width / 100) + ')',
                        this.$.selectionBar);
                },

                _onBarTransitionEnd: function (e) {
                    var cl = this.$.selectionBar.classList;
                    // bar animation: expand -> contract
                    if (cl.contains('expand')) {
                        cl.remove('expand');
                        cl.add('contract');
                        this._positionBar(this._pos.width, this._pos.left);
                        // bar animation done
                    } else if (cl.contains('contract')) {
                        cl.remove('contract');
                    }
                },
                /**
                 * Can be used to override the method from Polymer.IronSelectionBehavior.
                 */
                select: function (selectedTabIndex) {
                    /*
                    Hacky Work: Here we have overrided the method of IronSelection Behaviour
                    */
                    var eventName = "selection-changed";
                    var eventDetail = {
                        name: eventName
                    };
                    var e = this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true,
                        cancelable: true
                    });
                    if (e.defaultPrevented == false) {
                        this._selectTab(selectedTabIndex);
                    }
                },
                _selectTab: function (selectedTabIndex) {
                    /*
                        Issue 1: If a user has loaded some content of a menuitem and
                                 if user wants to loaded the content of a tab, then
                                 it will not work because the tabitem selection has not been changed.

                        Fix:     Added a flag "_isMenuItemSelected". If true then allow then control to load
                                 tab content else ignore
                    */
                    var selectedTab = this.querySelectorAll('pebble-tab')[selectedTabIndex];

                    this._closeDropdownMenus(selectedTab.id);

                    if (selectedTab) {
                        var menu = selectedTab.querySelector("paper-listbox");
                        if (menu && menu.selected >= 0) {
                            menu.selected = -1;
                        }
                    }

                    if (this._previousTab) {
                        menu = this._previousTab.querySelector("paper-listbox");
                        if (menu && menu.selected >= 0) {
                            menu.selected = -1;
                        }
                    }

                    if (this._selection.multi) {
                        this._selection.toggle(selectedTab);
                    } else if (this._selection.get() !== selectedTab || this._isMenuItemSelected) {
                        this._isMenuItemSelected = false;
                        this._selection.setItemSelected(this._selection.get(), false);
                        this._selection.setItemSelected(selectedTab, true);
                    }
                },

                _closeDropdownMenus: function (tabId) {
                    var tabs =  Polymer.FlattenedNodesObserver.getFlattenedNodes(this._tabsContent)
                            .filter(n => n.nodeType === Node.ELEMENT_NODE);
                    if (tabs) {
                        for (var index in tabs) {
                            var tab = tabs[index];
                            if (tab && tab.shadowRoot) {
                                var ironDropdown = tab.shadowRoot.querySelector("iron-dropdown"); // Shadow DOM
                                if (tab.id !== tabId) {
                                    if (ironDropdown && ironDropdown.opened) {
                                        ironDropdown.close();
                                    }
                                }
                            }
                        }
                    }
                },

                /***
                 * Function which can be used for adding specific CSS class to
                 * element with 'index' (for instance: we want to make some tab header blinking).
                 * this.selectedClass will be applied if no className value is provided.
                 * @param index
                 * @param className
                 */
                highlightTabWithoutSelection: function (index, className) {
                    className = className || this.selectedClass;
                    if (className) {
                        var tabs = this.querySelectorAll("pebble-tab");
                        for (var i = 0, length = tabs.length; i < length; i++) {
                            if (i == index) {
                                tabs[i].classList.add(className);
                            } else {
                                tabs[i].classList.remove(className);
                            }
                        }
                    }
                }
            });
        })();
    </script>
</dom-module>