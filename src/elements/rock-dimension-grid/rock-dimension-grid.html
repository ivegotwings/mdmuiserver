<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../rock-grid-data-sources/entity-dimension-grid-datasource.html">

<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-accordion/pebble-accordion.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../pebble-lov/pebble-lov.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-layout/rock-layout.html">
<link rel="import" href="../rock-layout/rock-titlebar/rock-titlebar.html">
<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-context-lov/rock-context-lov.html">
<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">

<!--
`rock-dimension-grid` Represents a component that displays the dimension value of the given attribute.
It also updates or adds the current and future value for that attribute.

It displays dimensions like locale, source, context, and time.
The user can select any dimension where locale, source, and context is shown in "multiselect LOVs". 
The time is displayed in the "date-time-picker" control. The user can select the time range to list the attribute's 
history and future value.

The grid renders the data based on the selected dimensions from the left panel.
The user can view the past data but cannot modify it. However he/she can add or update the current and future value.

@demo demo/index.html
-->

<dom-module id="rock-dimension-grid">
  <template>
    <style include="bedrock-styles-scroll-bar">
      :host {
        --pebble-grid-container: {
          margin-top:0px;
          margin-bottom:0px;
        };
        --pebble-grid-container-header: {
          padding-right: 0;
          padding-left: 0;
        };
        --rock-grid-actions:{
          display:none;
        }
      }
      #dimensionGridContainer {
        height: 450px;
      }

      #dimensionFilters {
        width: 310px;
        float: left;
        height: 100%;
        padding-right: 10px;
        overflow: auto;
      }

      #dimensionGrid {
        width: calc(100% - 320px);
        float: right;
      }
      
      pebble-lov {
        width: 100%;
        position: static !important;
      }

      .action-container {
        text-align: center;
      }

      pebble-lov {
        --pebble-lov-height: 125px;
      }

      pebble-checkbox {
        margin-top: 3px;
      }

      rock-grid {
        --rock-grid-height: 350px;
      }
    </style>
    <div id="dimensionGridContainer">
      <div id="dimensionFilters">
        <template is="dom-repeat" items="[[dimensionConfigs]]" as="configDataItem" notify-dom-change>
          <pebble-accordion header-text="[[configDataItem.title]]" default-icon="chevron-right" open-icon="expand-more">
            <div class="header-content">
              <pebble-checkbox id="[[configDataItem.id]]Chk" on-change="_onSelectAll"></pebble-checkbox>
            </div>
            <template is="dom-if" if="[[_isContextLovType(configDataItem)]]">
              <rock-context-lov id="[[configDataItem.id]]" entity-id="[[entityId]]" entity-type="[[entityType]]"
                context-name="[[configDataItem.id]]" config-data-item-id="[[configDataItem.id]]" on-selection-changed="_onDimensionChange" 
                multi-select no-sub-title></rock-context-lov>
            </template>
            <!--template id="[[configDataItem.id]]" is="dom-if" if="[[_compareRequestType(configDataItem.dataRequestType, 'entity')]]" notify-dom-change>
              <rock-entity-lov id="[[configDataItem.id]]" config-data-item-id="[[configDataItem.id]]" id-field="[[configDataItem.dataMappings.id]]"
                title-pattern="[[configDataItem.dataMappings.title]]" type-field="[[configDataItem.dataMappings.type]]" request-data="[[configDataItem.dataRequest]]"
                on-selection-changed="_onDimensionChange" multi-select no-sub-title></rock-entity-lov>
            </template-->
            <template is="dom-if" if="[[!_isContextLovType(configDataItem)]]">
              <rock-entity-lov id="[[configDataItem.id]]" config-data-item-id="[[configDataItem.id]]" id-field="[[configDataItem.dataMappings.id]]"
                title-pattern="[[configDataItem.dataMappings.title]]" type-field="[[configDataItem.dataMappings.type]]" request-data="[[configDataItem.dataRequest]]"
                on-selection-changed="_onDimensionChange" multi-select no-sub-title></rock-entity-lov>
            </template>
          </pebble-accordion>
        </template>        
      </div>
      <div id="dimensionGrid">
        <!--pebble-button icon="pebble-md-icons:actions" class="dropdownText dropdownIcon btn dropdown-success pull-right" menu-button
          dropdown-icon button-text="Action" on-click=""></pebble-button-->
        <div class="clearfix"></div>
        <rock-grid config="[[_gridConfig]]" page-size="10" attribute-models="[[gridAttributeModel]]"></rock-grid>
      </div>
      <div class="clearfix"></div>
    </div>
    <!--div class="action-container m-t-10">
      <pebble-button class="btn btn-secondary m-r-10" button-text="Cancel" on-tap="_cancelAction" noink></pebble-button>
      <pebble-button class="btn btn-success" button-text="Save" on-tap="_saveAction" noink></pebble-button>
    </div-->
    <entity-dimension-grid-datasource id="searchGridDatasource" context-data="[[contextData]]" value-contexts="{{_valueContexts}}" contexts="{{_contexts}}"
        request="{{_request}}" r-data-source="{{rDataSource}}" total-count="{{totalCount}}"></entity-dimension-grid-datasource>
    <liquid-entity-data-get verbose name="attributeGetDataService" operation="getbyids" request-data="{{_request}}" on-response="[[_onAttributesGetResponse]]"></liquid-entity-data-get>
    <liquid-entity-data-save name="attributeSaveDataService" operation="update" request-data="{{_saveRequest}}" last-response="{{saveResponse}}"
      on-response="_onSaveResponse"></liquid-entity-data-save>
  </template>
  <script>
    (function () {
      'use strict';

      Polymer({
        is: 'rock-dimension-grid',
        properties: {
          /*
           * Indicates an identifier for an entity.
           */
          dataId: {
            type: String,
            notify: true,
            value: ""
          },

          /*
           * Indicates an array of locales for the dimension panel.
           */
          locales: {
            type: Array,
            value: function () {
              return [];
            }
          },

          /*
           * Indicates an array of channels for the dimension panel.
           */
          channels: {
            type: Array,
            value: function () {
              return [];
            }
          },

          /*
           * Indicates an array of "sources" for the dimension panel.
           */
          sources: {
            type: Array,
            value: function () {
              return [];
            }
          },

          /*
           * Indicates an attribute model object of the given entity 
           * for which dimension values are rendered.
           */
          attributeModelObject: {
            type: String,
            value: function () {
              return {};
            }
          },

          /**
           * Indicates dimensions configuration
           */
          dimensionConfigs: {
            type: Array,
            value: function() {
              return [];
            }
          },

          /*
           * Indicates current selected locales in dimension grid.
           */
          _selectedLocales: {
            type: Array,
            value: function () {
              return [];
            }
          },

          /*
           * Indicates current selected contexts in dimension grid.
           */
          _selectedChannels: {
            type: Array,
            value: function () {
              return [];
            }
          },

          /*
           * Indicates current selected sources in dimension grid.
           */
          _selectedSources: {
            type: Array,
            value: function () {
              return [];
            }
          },
          /*
           * Indicates current selected texonomy in dimension grid.
           */
          _selectedTaxonomy: {
            type: Array,
            value: function () {
              return [];
            }
          },
          /*
           * Indicates current selected classification in dimension grid.
           */
          _selectedClassifications: {
            type: Array,
            value: function () {
              return [];
            }
          },
          rDataSource:{
            type:Function
          },
          totalCount:{
            type:Number,
            value:10
          },
          entityId: {
            type: String,
            value: ""
          },
          entityType: {
            type: String,
            value: ""
          },
          _valueContexts:{
              type:Array,
              value:function(){
                  return []
              }
          },
          _contexts:{
              type:Array,
              value:function(){
                  return []
              }
          },
          _dataContextModelObjects:{
            type:Object,
            value: function(){
              return {}
            }
          },
          _valueContextModelObjects:{
            type:Object,
            value: function(){
              return {}
            }
          },
          /*
           * Indicates request object based on current selected dimension objects.
           */
          _request: {
            type: Object,
            value: function () {
              return {};
            }
          },

          /*
           * Indicates save request object based on current selected dimension objects.
           */
          _saveRequest: {
            type: Object,
            value: function () {
              return {};
            }
          },

          _gridConfig: {
            type: Object,
            value: function () {
              return {};
            }
          }
        },

        observers: [
          // '_onSelectionChange(_selectedLocales, _selectedChannels, _selectedSources, _selectedTaxonomy, _selectedClassifications)',
          // '_entityGet(response)'
        ],

        behaviors: [
          RUFBehaviors.UIBehavior,
          RUFBehaviors.ComponentContextBehavior
        ],
        /**
          * <b><i>Content development is under progress... </b></i> 
          */
        ready: function () {
          this.entityId = DataHelper.getParamValue('id');
          this.entityType = DataHelper.getParamValue('type');

          if(this.dimensionConfigs){
              var arrayToObj = {}
              for (let i = 0; i < this.dimensionConfigs.length; i++) {
                const dimension = this.dimensionConfigs[i];
                if(dimension){
                  arrayToObj[dimension.id] = dimension;
                  if(dimension.useContextModel){
                    this._dataContextModelObjects[dimension.id] = dimension;
                    this._dataContextModelObjects[dimension.id]["selectedItems"] = [];
                  }
                }
              }
          
              if (!_.isEmpty(this.contextData) && !_.isEmpty(arrayToObj)) {
                var dataContexts = this.getDataContexts();
                var valueContexts = this.getValueContexts();

                dataContexts.forEach(function(contextObj){
                    var selectedItems = [];
                    for (const contextKey in contextObj) {
                      if (contextObj.hasOwnProperty(contextKey) && arrayToObj[contextKey]) {
                          var _obj = {
                            id:contextObj[contextKey],
                            title:contextObj[contextKey],
                            type:contextKey
                          }
                          if(this._dataContextModelObjects[contextKey]){
                            this._dataContextModelObjects[contextKey]["selectedItems"].push(_obj);
                          }else{
                            this._dataContextModelObjects[contextKey] = arrayToObj[contextKey];
                            this._dataContextModelObjects[contextKey]["selectedItems"] = [ _obj ];
                          }
                      }
                    }
                }.bind(this));
                
                valueContexts.forEach(function(valueContextObj){
                    for (const valueContextKey in valueContextObj) {
                      if (valueContextObj.hasOwnProperty(valueContextKey) && arrayToObj[valueContextKey]) {
                          var _obj = {
                            id:valueContextObj[valueContextKey],
                            title:valueContextObj[valueContextKey],
                            type:valueContextKey
                          }
                          if(this._valueContextModelObjects[valueContextKey]){
                            this._valueContextModelObjects[valueContextKey]["selectedItems"].push( _obj );
                          }else{
                            this._valueContextModelObjects[valueContextKey] = arrayToObj[valueContextKey];
                            this._valueContextModelObjects[valueContextKey]["selectedItems"] = [ _obj ];
                          }
                      }
                    }
                }.bind(this));

              }

        }

          this._gridConfig = undefined;
          this._gridConfig = this._getGridConfig();

          var attrModels = {};
          var modelObject = JSON.parse(this.attributeModelObject);
          attrModels[modelObject.name] = modelObject;

          this.gridAttributeModel = undefined;
          this.gridAttributeModel = attrModels;

          
          // this._setInitDimensions();        
          this._onSelectionChange();
        },
        
        attached:function(){
          
          setTimeout(() => {
            this._setDimensionSelection();
          }, 0)
        },

        _isContextLovType: function(configContext){
            if(this._dataContextModelObjects){
              if(this._dataContextModelObjects[configContext.id]){
                return true;
              }
            }
            return false;
        },
        _onDimensionChange: function (e) {
          if (e.currentTarget.selectedItems) {
            this._onSelectionChange();
            // var selectedItems = e.currentTarget.selectedItems;
            // var _id = e.currentTarget.id;
            // if(this._dataContextModelObjects[_id]){
            //   this._dataContextModelObjects[_id].selectedItems = 
            // }else if(this._valueContextModelObjects[_id]){
              
            // }
            // if (e.currentTarget.id == "locale") {
            //   this._selectedLocales = undefined;
            //   this._selectedLocales = selectedItems;
            // } else if (e.currentTarget.id == "channel") {
            //   this._selectedChannels = undefined;
            //   this._selectedChannels = selectedItems;
            // } else if (e.currentTarget.id == "source") {
            //   this._selectedSources = undefined;
            //   this._selectedSources = selectedItems;
            // } else if (e.currentTarget.id == "taxonomy") {
            //   this._selectedTaxonomy = undefined;
            //   this._selectedTaxonomy = selectedItems;
            // } else if (e.currentTarget.id == "classification") {
            //   this._selectedClassifications = undefined;
            //   this._selectedClassifications = selectedItems;
            // }
          }
        },

        _onSelectionChange: function (_selectedLocales, _selectedChannels, _selectedSources) {
          // if (!(_selectedLocales === undefined || _selectedChannels === undefined || _selectedSources === undefined)) {
            if (this.dataId) {
              var attributeNames = [];
              var valueContexts = [];
              var contexts = [];
              var typesCriterion = [];
              var modelObject = JSON.parse(this.attributeModelObject);
              attributeNames.push(modelObject.name);

              var firstLoop = true;
              for (const valueContext in this._valueContextModelObjects) {
                if (this._valueContextModelObjects.hasOwnProperty(valueContext)) {
                  var selectedItems = this._valueContextModelObjects[valueContext].selectedItems;

                  for (let i = 0; i < selectedItems.length; i++) {
                    const selItem = selectedItems[i];
                    var obj = {}
                    obj[valueContext] = selItem["id"];
                    if(firstLoop){
                      valueContexts.push(obj);
                    }else if(valueContexts[i]){
                      valueContexts[i][valueContext] =  selItem["id"];
                    }else{
                      valueContexts.push(obj);
                    }
                  }
                }
                firstLoop = false
              }
              this.set("_valueContexts", valueContexts);

              firstLoop = true;
              for (const context in this._dataContextModelObjects) {
                if (this._dataContextModelObjects.hasOwnProperty(context)) {
                  var selectedItems = this._dataContextModelObjects[context].selectedItems;

                  for (let i = 0; i < selectedItems.length; i++) {
                    const selItem = selectedItems[i];
                    var obj = {}
                    obj[context] = selItem["id"];
                    if(firstLoop){
                      contexts.push(obj);
                    }else if(contexts[i]){
                      contexts[i][context] =  selItem["id"];
                    }else{
                      contexts.push(obj);
                    }
                  }
                }
                firstLoop = false
              }
              this.set("_contexts", contexts);

              // if (this._selectedSources) {
              //   this._selectedSources.forEach(function (sourceItem) {
              //     valueContexts.push({
              //         "source": sourceItem.title
              //       });
              //   }, this);
              // }
              // if (this._selectedLocales) {
              //   for (let i = 0; i < this._selectedLocales.length; i++) {
              //     const localeItem = this._selectedLocales[i];
              //     if(valueContexts && valueContexts[i]){
              //       valueContexts[i]["locale"] = localeItem.title;
              //     }else{
              //       valueContexts.push({"locale" : localeItem.title });
              //     }
              //   }
              // }

              // this.set("_valueContexts", valueContexts);
              
              // if (this._selectedChannels) {
              //   this._selectedChannels.forEach(function (contextItem) {
              //     contexts.push({
              //       "classification": "_ALL",
              //       "list": contextItem.title
              //     });
              //   }, this);
              // // }
              // if (this._selectedTaxonomy) {
              //   this._selectedTaxonomy.forEach(function (taxonomy) {
              //     contexts.push({"taxonomy" : taxonomy.title });
              //   }, this);
              // }
              // if(this._selectedClassifications){
              //   for (let i = 0; i < this._selectedClassifications.length; i++) {
              //     const classification = this._selectedClassifications[i];
              //     if(contexts && contexts[i]){
              //       contexts[i]["classification"] = classification.title;
              //     }else{
              //       contexts.push({"classification" : classification.title });
              //     }
              //   }
              // }
              // this.set("_contexts", contexts);

              var itemContext = this.getFirstItemContext();

              if (!_.isEmpty(itemContext)) {
                typesCriterion.push(itemContext.type);
              }

              //TODO: need to check how can we replace this request with request-helper.
              // Here this component has it's own set of contexts.
              //TODO: Overall comment for this is dimensions of this component's are working only on locale, source, channel. It has to br dynamic.
              // var req = {
              //   "params": {
              //     "query": {
              //       "contexts": contexts,
              //       "valueContexts": valueContexts,
              //       "filters": {
              //         "attributesCriterion": [],
              //         "typesCriterion": typesCriterion
              //       },
              //       "id": this.dataId
              //     },
              //     "fields": {
              //       "ctxTypes": [
              //         "properties"
              //       ],
              //       "attributes": attributeNames
              //     }
              //   }
              // };
              
              var req = {
                "params": {
                  "query": {
                    // "contexts": contexts,
                    // "valueContexts": valueContexts,
                    "filters": {
                      "typesCriterion": [
                        "entitymanageevent"
                      ],
                      "attributesCriterion": [
                        {
                          "entityId": {
                            "exact": this.dataId
                          }
                        }
                      ]
              
                    }
                  },
                  "fields": {
                    "attributes": attributeNames
                  },
                  "sort": {
                    "properties": [
                      {
                        "modifiedDate": "_DESC",
                        "sortType": "_DATETIME"
                      }
                    ]
                  }

                }
              };

              this._request = req;
              this.rDataSource({page: 0, pageSize: this.totalCount}, this._onAttributesGetResponse.bind(this), this._onAttributesGetErrorResponse.bind(this))
            }
          // }
        },
        _onAttributesGetResponse:function(res){
            if (res && res.status && (res.status == "success")) {
              var dimGrid = this.shadowRoot.querySelector('rock-grid');
              var data = [];
              var modelObject = JSON.parse(this.attributeModelObject);
              var attrName = modelObject.name;
              var dimensions = {
                "locales": this._selectedLocales,
                "channels": this._selectedChannels,
                "sources": this._selectedSources
              };

              if (res.content && res.content.events && res.content.events.length > 0) {
                var events = res.content.events;
                events.forEach(function (eventObj) {
                    var _attribute = EntityHelper.getAttribute(eventObj, attrName);
                    if(_attribute && _attribute.values){

                      var record = {};
                      record[attrName] = _attribute.values[0].value;
                      record.Locale = _attribute.values[0].locale;
                      record.Source = _attribute.values[0].source;
                      record.Channel = _attribute.values[0].channel;
                      if(eventObj.properties && eventObj.properties.modifiedDate){
                        record.Time = FormatHelper.convertFromISODateTime(eventObj.properties.modifiedDate, 'datetime');
                      }
                      data.push(record);
                    }
                })
                // var entity = ev.details.response.content.events[0];
                // if (entity) {
                //   DataTransformHelper.transformEntityForDimensionGrid(entity, dimensions, modelObject);
                //   var currentContexts = entity.data.contexts;
                //   var selfAttributes = entity.data.attributes;

                //   if (selfAttributes && selfAttributes[attrName]) {
                //     var values = selfAttributes[attrName].values;
                //     if (values) {
                //       values.forEach(function (valueItem) {
                //         var record = {};
                //         record[attrName] = valueItem.value;
                //         record.Locale = valueItem.locale;
                //         record.Source = valueItem.source;
                //         record.Channel = "";
                //         data.push(record);
                //       }, this);
                //     }
                //   }

                //   if (currentContexts) {
                //     currentContexts.forEach(function (item) {

                //       var attributes = item.attributes;

                //       if (attributes) {
                //         var values = attributes[attrName].values;
                //         if (values) {
                //           values.forEach(function (valueItem) {
                //             var record = {};
                //             record[attrName] = valueItem.value;
                //             record.Locale = valueItem.locale;
                //             record.Source = valueItem.source;
                //             record.Channel = item.context.list;
                //             data.push(record);
                //           }, this);
                //         }
                //       }
                //     }, this);
                //   }
                // }

                if (data) {
                  var grid = this.shadowRoot.querySelector('rock-grid');
                  grid.data = data;
                  if (grid._getIronDataTable()) {
                    grid._getIronDataTable()._sizeChanged(data.length, 0);
                    grid.reRenderGrid();
                  }
                }
              }
            }
        },
        _onAttributesGetErrorResponse: function(e){

        },
        _onSelectAll: function (e) {
          if (e.currentTarget.id == 'localeChk') {
            var localeLov = Polymer.dom(this).node.shadowRoot.querySelector('rock-entity-model-lov[id="locale"]');
            localeLov.selectedItems = undefined;
            this._selectedLocales = undefined;
            if (e.currentTarget.checked) {
              var items = this._getAllItemsOfLov(localeLov);
              localeLov.selectedItems = items;
              this._selectedLocales = items;
            } else {
              localeLov.selectedItems = [];
              this._selectedLocales = [];
            }
          } else if (e.currentTarget.id == 'sourceChk') {
            var sourceLov = Polymer.dom(this).node.shadowRoot.querySelector('rock-entity-model-lov[id="source"]');
            sourceLov.selectedItems = undefined;
            this._selectedSources = undefined;
            if (e.currentTarget.checked) {
              var items = this._getAllItemsOfLov(sourceLov);
              sourceLov.selectedItems = items;
              this._selectedSources = items;
            } else {
              sourceLov.selectedItems = [];
              this._selectedSources = [];
            }
          } else if (e.currentTarget.id == 'channelChk') {
            var channelLov = Polymer.dom(this).node.shadowRoot.querySelector('rock-entity-lov[id="channel"]');
            channelLov.selectedItems = undefined;
            this._selectedChannels = undefined;
            if (e.currentTarget.checked) {
              var items = this._getAllItemsOfLov(channelLov);
              channelLov.selectedItems = items;
              this._selectedChannels = items;
            } else {
              channelLov.selectedItems = [];
              this._selectedChannels = [];
            }
          }
        },

        _getAllItemsOfLov: function (lovElement) {
          var items = [];

          if (lovElement) {
            var pebbleLov = Polymer.dom(lovElement).node.shadowRoot.querySelector('pebble-lov');
            if (pebbleLov) {
              items = pebbleLov.$.selector.items;
            }
          }

          return items;
        },

        _saveAction: function (e) {
          var attributesJSON = {};
          var grid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
          var modelObject = JSON.parse(this.attributeModelObject);
          var attrName = modelObject.name;

          if (grid) {
            var data = grid.data;

            var entityData = {};
            if (this.response && this.response.content && this.response.content.entities) {
              var entities = DataHelper.cloneObject(this.response.content.entities);
              if (!_.isEmpty(entities)) {
                entityData = entities[0];
              }
            }

            if (!_.isEmpty(entityData)) {

              data.forEach(function (item) {
                item.Channel = _.isEmpty(item.Channel) ? item.Channel = 'self' : item.Channel;
                if (attributesJSON[item.Channel] == undefined) {
                  attributesJSON[item.Channel] = {};
                  attributesJSON[item.Channel][attrName] = {};
                  attributesJSON[item.Channel][attrName].values = [];
                }

                if (attributesJSON[item.Channel][attrName]) {
                  attributesJSON[item.Channel][attrName].values.push({
                    "value": item[attrName],
                    "source": item.Source,
                    "locale": item.Locale
                  })
                }
              }, this);

              if (this.dataId == entityData.id) {
                if (entityData.data) {
                  if (!_.isEmpty(entityData.data.contexts)) {
                    entityData.data.contexts.forEach(function (item) {
                      if (attributesJSON[item.context.channel]) {
                        item.attributes = attributesJSON[item.context.channel];
                      }
                    }, this);
                  }

                  if (!_.isEmpty(entityData.data.attributes)) {
                    entityData.data.attributes = attributesJSON['self'];
                  }
                }

              }

              //set requestObject for save liquid
              this._saveRequest = {
                "entities": entityData
              };

              var liquidSave = this.shadowRoot.querySelector("[name=attributeSaveDataService]");
              if (liquidSave) {
                liquidSave.generateRequest();
              }
            }
          }
        },

        _cancelAction: function (e) {
          var dimGrid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
          var pebbleDialog = this._getParentPebbleDialog(Polymer.dom(this).node.parentElement);

          if (dimGrid) {
            dimGrid.changeToReadMode();
          }

          if (pebbleDialog) {
            pebbleDialog._close();
          }
          Polymer.dom(this).node.parentElement.removeChild(this);
        },

        _getParentPebbleDialog: function (element) {
          if (element) {
            if (element.is == "pebble-dialog") {
              return element;
            } else {
              return this._getParentPebbleDialog(element.parentNode);
            }
          }
          return undefined;
        },

        _onSaveResponse: function () {
          var mainApp = document.querySelector('#app');
          mainApp.toastText = this.saveResponse.content.msg;
          var toastElement = mainApp.shadowRoot.querySelector("#pebbleAppToast");
          toastElement.toastType = "success";
          toastElement.heading = "Success";
          toastElement.autoClose = true;

          toastElement.show();
          this._cancelAction();
        },

        _entityGet: function () {
          if (this.response != undefined) {
            var dimGrid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
            var data = [];
            var modelObject = JSON.parse(this.attributeModelObject);
            var attrName = modelObject.name;
            var dimensions = {
              "locales": this._selectedLocales,
              "channels": this._selectedChannels,
              "sources": this._selectedSources
            };

            if (this.response && this.response.content && this.response.content.entities) {
              var entity = this.response.content.entities[0];
              if (entity) {
                DataTransformHelper.transformEntityForDimensionGrid(entity, dimensions, modelObject);
                var currentContexts = entity.data.contexts;
                var selfAttributes = entity.data.attributes;

                if (selfAttributes && selfAttributes[attrName]) {
                  var values = selfAttributes[attrName].values;
                  if (values) {
                    values.forEach(function (valueItem) {
                      var record = {};
                      record[attrName] = valueItem.value;
                      record.Locale = valueItem.locale;
                      record.Source = valueItem.source;
                      record.Channel = "";
                      data.push(record);
                    }, this);
                  }
                }

                if (currentContexts) {
                  currentContexts.forEach(function (item) {

                    var attributes = item.attributes;

                    if (attributes) {
                      var values = attributes[attrName].values;
                      if (values) {
                        values.forEach(function (valueItem) {
                          var record = {};
                          record[attrName] = valueItem.value;
                          record.Locale = valueItem.locale;
                          record.Source = valueItem.source;
                          record.Channel = item.context.list;
                          data.push(record);
                        }, this);
                      }
                    }
                  }, this);
                }
              }

              if (data) {
                var grid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
                grid.data = data;
                if (grid._getIronDataTable()) {
                  grid._getIronDataTable()._sizeChanged(data.length, 0);
                  grid.reRenderGrid();
                }
              }
            }
          }
        },

        _initDimensionGrid: function () {
          if (!_.isEmpty(this.contextData)) {
            var dataContexts = this.getDataContexts();
            var valueContexts = this.getValueContexts();



            var locales = [];
            var sources = [];
            var channels = [];
            var taxonomy = [];
            var classifications = [];

            var selectedLocales = [];
            var selectedSources = [];
            var selectedChannels = [];
            var selectedTaxonomy = [];
            var selectedClassifications = [];

            if (!_.isEmpty(dataContexts)) {
              channels = [...new Set(dataContexts.map((obj) => obj.channel))];
              taxonomy = [...new Set(dataContexts.map((obj) => obj.taxonomy))];
              classifications = [...new Set(dataContexts.map((obj) => obj.classification))];
            }

            if (!_.isEmpty(valueContexts)) {
              locales = [...new Set(valueContexts.map((obj) => obj.locale))];
              sources = [...new Set(valueContexts.map((obj) => obj.source))];
            }

            if (!_.isEmpty(locales)) {
              locales.forEach(function (locale) {
                selectedLocales.push({
                  "id": locale,
                  "title": locale
                });
              }, this);
            }

            if (!_.isEmpty(channels)) {
              channels.forEach(function (channel) {
                selectedChannels.push({
                  "id": channel,
                  "title": channel
                });
              }, this);
            }

            if (!_.isEmpty(sources)) {
              sources.forEach(function (source) {
                selectedSources.push({
                  "id": source,
                  "title": source
                });
              }, this);
            }

            if (!_.isEmpty(taxonomy)) {
              taxonomy.forEach(function (_taxonomy) {
                selectedTaxonomy.push({
                  "id": _taxonomy,
                  "title": _taxonomy,
                  "type": _taxonomy
                });
              }, this);
            }

            if (!_.isEmpty(classifications)) {
              classifications.forEach(function (classification) {
                selectedClassifications.push({
                  "id": classification,
                  "title": classification,
                  "type": classification
                });
              }, this);
            }

            this._selectedLocales = selectedLocales;
            this._selectedChannels = selectedChannels;
            this._selectedSources = selectedSources;
            this._selectedTaxonomy = selectedTaxonomy;
            this._selectedClassifications = selectedClassifications;

            this._gridConfig = undefined;
            this._gridConfig = this._getGridConfig();

            var attrModels = {};
            var modelObject = JSON.parse(this.attributeModelObject);
            attrModels[modelObject.name] = modelObject;

            this.gridAttributeModel = undefined;
            this.gridAttributeModel = attrModels;

            this._setDimensionSelection();
          }
        },

        _getIdsFromObject: function (arrayObject) {
          var ids = [];
          if (arrayObject) {
            arrayObject.forEach(function (item) {
              ids.push(item.id);
            }, this);
          }
          return ids;
        },

        _compareRequestType: function (dataRequestType, entityTypeInfo) {
          return dataRequestType === entityTypeInfo;
        },

        _setInitDimensions: function () {
          var repeat = Polymer.dom(this).node.shadowRoot.querySelector("dom-repeat");
          if (repeat) {
            repeat.addEventListener("dom-change", function (event) {
              this._initDimensionGrid();
            }.bind(this));
          }
        },

        _setDimensionSelection: function () {

          for (const dataContext in this._dataContextModelObjects) {
            if (this._dataContextModelObjects.hasOwnProperty(dataContext)) {
              var lovElement = this.shadowRoot.querySelector("#"+dataContext);
              if(lovElement){
                lovElement.selectedItems = this._dataContextModelObjects[dataContext].selectedItems;
              }
            }
          }

          for (const valueContext in this._valueContextModelObjects) {
            if (this._valueContextModelObjects.hasOwnProperty(valueContext)) {
              var lovElement = this.shadowRoot.querySelector("#"+valueContext);
              if(lovElement){
                lovElement.selectedItems = this._valueContextModelObjects[valueContext].selectedItems;
              }
            }
          }

          
          // var domIfs = this.$.dimensionFilters.querySelectorAll("dom-if");
          // if (domIfs) {
          //   domIfs.forEach(function (domIf) {
          //     domIf.addEventListener("dom-change", function (event) {
          //       if (event.currentTarget.id == "locale") {
          //         var localeLov = this.shadowRoot.querySelector('rock-entity-model-lov[id="locale"]');

          //         if (localeLov) {
          //           localeLov.selectedItems = this._selectedLocales;
          //         }
          //       }
          //       else if (event.currentTarget.id == "source") {
          //         var sourceLov = this.shadowRoot.querySelector('rock-entity-model-lov[id="source"]');

          //         if (sourceLov) {
          //           sourceLov.selectedItems = this._selectedSources;
          //         }
          //       }
          //       else if (event.currentTarget.id == "channel") {
          //         var channelLov = this.shadowRoot.querySelector('rock-entity-lov[id="channel"]');

          //         if (localeLov) {
          //           channelLov.selectedItems = this._selectedChannels;
          //         }
          //       }
          //       else if (event.currentTarget.id == "taxonomy") {
          //         var taxonomyLov = this.shadowRoot.querySelector('rock-context-lov[id="taxonomy"]');

          //         if (taxonomyLov) {
          //           taxonomyLov.selectedItems = this._selectedTaxonomy;
          //         }
          //       }
          //       else if (event.currentTarget.id == "classification") {
          //         var classificationLov = this.shadowRoot.querySelector('rock-context-lov[id="classification"]');

          //         if (classificationLov) {
          //           classificationLov.selectedItems = this._selectedClassifications;
          //         }
          //       }
          //     }.bind(this));
          //   }, this);
          // }
        },

        _getGridConfig: function () {
          var config = this.getParentAppConfig('rock-dimension-grid', '', 'dimension-gridConfig');

          if (!_.isEmpty(config)) {
            var columns = config.tabular.columns;
            var modelObject = JSON.parse(this.attributeModelObject);
            if (!_.isEmpty(columns)) {
              for (var i = 0; i < columns.length; i++) {
                if (columns[i].header.toLowerCase() == "value") {
                  columns[i].name = modelObject.name;
                }
              }
            }
          }

          return config;
        }
      });
    })();
  </script>
</dom-module>