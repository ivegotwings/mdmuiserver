<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../pebble-grid/pebble-grid.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../pebble-lov/pebble-lov.html">
<link rel="import" href="../rock-layout/rock-layout.html">
<link rel="import" href="../rock-layout/rock-titlebar/rock-titlebar.html">
<link rel="import" href="../pebble-accordion/pebble-accordion.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../liquid-entity-getdata/liquid-entity-getdata.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<!--
`rock-dimension-grid` component is used for veiw dimension value of given attribute as well update or add current and future value for that attribute.

It will display dimensions like locale, source, context, time.
User can select any dimension among listed above, 
where locae, source, and context will be multiselect LOVs and time will be date time picker where user can select time range to list attribute's history and future value if added any.

Bsed on selected dimensions from left panel grid will render data.
User can see past data but can not modify it, only current and future value can be added or updated.

@demo demo/index.html
-->

<dom-module id="rock-dimension-grid">
	<template>
		<style include="pebble-styles-shared">
      #dimensionGridContainer {
        display: flex;
        width: 1000px;
        padding-top: 10px;
      }

      #dimensionFilters {
        width: 25%;
        flex-direction: column;
        padding-left: 10px;
      }

      #dimensionGrid {
        width: 75%;
        padding-left: 15px;
        padding-right: 10px;
        flex-direction: column;
        display: flex;
      }

      pebble-button {
        float: right;
      }

      pebble-lov {
        width: 100%;
        position: static !important;
      }

       .action-container {
            display: inline-flex;
            float: right;
        }

        pebble-button {
          vertical-align: -webkit-baseline-middle;
          vertical-align: -moz-baseline-middle;
          vertical-align: baseline-middle;
          --pebble-button: {
              height: 30px;
              padding: 0.5em 0em 0.5em 0em;
              min-width: 2.14em;
              margin: 0px;
          }
          --pebble-button-iron-icon: {
              height: 20px;
              width: 20px;
              color: #7d8690;
          }
      }

      pebble-button.pageRange::shadow paper-button {
          line-height: var(--border-btn-height,24px);
          height: var(--border-btn-height,24px);
          box-shadow: none;
          font-family: var(--default-font-family);
      }

      pebble-lov {
        --pebble-lov-height: 100px;
      }

      pebble-accordion {
        --accordion-header: {
          height: 30px;
        }
      }

    </style>
    <iron-ajax auto url="demo/dimension-grid-config.json" handle-as="json" last-response="{{gridConfig}}"></iron-ajax>
    <div id="dimensionGridContainer">
        <div id="dimensionFilters">
              <pebble-accordion header-text="Locale" default-icon="expand-less" open-icon="expand-more">
                <pebble-lov id="locale" items="{{locales}}" multi-selection="true" show-image="true" on-selection-changed="onDimensionChage"></pebble-lov>
              </pebble-accordion>
              <pebble-accordion header-text="Context" default-icon="expand-less" open-icon="expand-more">
                <pebble-lov id="context" items="{{contexts}}" multi-selection="true" show-image="true" on-selection-changed="onDimensionChage"></pebble-lov>                
              </pebble-accordion>
              <pebble-accordion header-text="Source" default-icon="expand-less" open-icon="expand-more">
                <pebble-lov id="source" items="{{sources}}" multi-selection="true" show-image="true" on-selection-changed="onDimensionChage"></pebble-lov>                
              </pebble-accordion>
              <pebble-accordion header-text="Time" default-icon="expand-less" open-icon="expand-more">
              </pebble-accordion>
        </div>
        <div id="dimensionGrid">
          <div>
          <pebble-button icon="pebble-icons:Create" class="icon-text-button" button-text="Action" on-click=""></pebble-button>
          </div>
          <pebble-grid config="{{gridConfig}}" page-size="10" data="{{gridData}}"></pebble-grid>
           <div class="action-container" hidden = [[!isEditMode]]>
              <pebble-button class="pageRange btn-with-border" button-text="Cancel" on-tap="cancelAction" noink raised></pebble-button>
              <pebble-button class="pageRange btn-with-border" button-text="Save" on-tap="saveAction" noink raised></pebble-button>
          </div>
        </div>
    </div>
    <liquid-entity-getdata auto verbose name="attributeGetDataService" operation="getentities" 
            request-data="{{_request}}" last-response="{{response}}"></liquid-entity-getdata>
		<!--<liquid-entity-savedata verbose name="attributeSaveDataService" operation="updateentities" 
            request-data="{{saveRequest}}" last-response="{{saveResponse}}" on-response="onSaveResponse"></liquid-entity-savedata>-->
	</template>
<script> 
	(function () {
		'use strict';

		Polymer({
			is: 'rock-dimension-grid',
      properties: {
        /*
        * Indicates entity identification.
        */
        dataId: {
          type: String,
          notify: true
        },

        /*
        * Indicates array of locales for dimension panel.
        */
        locales: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates array of contexts for dimension panel.
        */
        contexts: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates array of sorces for dimension panel.
        */
        sources: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates attribute name of given entity identification for what dimension values needs to be rendered.
        */
        attributeName: {
          type: String,
          value: function() {
            return {};
          }
        },

        /*
        * Indicates current selected locales in dimension grid.
        */
        _selectedLocales: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates current selected contexts in dimension grid.
        */
        _selectedContexts: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates current selected sources in dimension grid.
        */
        _selectedSources: {
          type: Array,
          value: function() {
            return [];
          }
        },

        /*
        * Indicates request object based on current selected dimension objects.
        */
        _request: {
          type: Object,
          value: function() {
            return {};
          }
        }
      },

      observers: [
        '_onSelctionChange(_selectedLocales, _selectedContexts, _selectedSources)',
        '_entityGet(response)',
        '_initDimensionGrid(dataContext)'
      ],

      behaviors: [
        RUFBehaviors.UIBehavior
      ],

      onDimensionChage: function(e) {
        if(e.currentTarget.selectedItem){
          var selectedItemId = e.currentTarget.selectedItem.id;
          if(lovElement) {
            if(e.currenttarget.id == "locale") {
              this.locales.forEach(function(item) {
                if(item.id == selectedItemId){
                  this._selectedLocales.push(item.title);
                }
              }, this);
            }
            else if(e.currenttarget.id == "source") {
              this.sources.forEach(function(item) {
                if(item.id == selectedItemId){
                  this._selectedSources.push(item.title);
                }
              }, this);
            } 
            else if(e.currenttarget.id == "context") {
              this.contexts.forEach(function(item) {
                if(item.id == selectedItemId){
                  this._selectedContexts.push(item.title);
                }
              }, this);
            }
          }
        }
      },

      _onSelctionChange: function() {
        if(this.dataId) {
          var attributeNames = [];
          var valCtx = [];

          attributeNames.push(this.attributeName);        
          if(this._selectedLocales && this._selectedSources)
          {
            this._selectedSources.forEach(function(sourceItem) {
              this._selectedLocales.forEach(function(localeItem) {
                valCtx.push({
                  "source": sourceItem,
                  "locale": localeItem
                });
              }, this);
            }, this);
          }

          var req = {
            "data": {
              "query": {
                "ctx": [{
                  "classification": "nivea/niveaBodyCare/niveaBody/nbodyEssential/nbody/ess/nourishingMilkDry",
                  "list" : "productMaster"
                }],
                "valCtx": valCtx,
                "id": this.dataId
              },
              "fields": {
                "ctxTypes": [
                  "properties"
                ],
                "attributes": attributeNames
              }
            } 
          };

          this.set("_request", req);
        }
      },

      saveAction : function(e) {
        //TO-DO: Needs to be done as Date Time picker integration.
      },

      cancelAction : function(e) {
        Polymer.dom(this).node.parentElement.close();
        Polymer.dom(this).node.parentElement.removeChild(this);
      },

      _entityGet: function() {
        var dimGrid =  Polymer.dom(this).node.$$('pebble-grid');

        if(this.response && this.response.content) {
          var entity = this.response.content.entities[this.dataId];
          var ctxInfo = entity.data.ctxInfo;
          var containerInfoKeys = Object.keys(ctxInfo);

          containerInfoKeys.forEach(function(item){
            var data = [];
            var attributes = ctxInfo[item].attributes;
            if(attributes) {
              var values = attributes[this.attributeName].values;
              if(values) {
                values.forEach(function(valueItem){
                  var record = {};
                  record.Value = valueItem.value;
                  record.Locale = valueItem.locale;
                  record.Source = valueItem.source;
                  data.push(record);
                }, this);
              }
            }
            if(data.length > 0)
            {
              this.gridData = data;
            }
          }, this);
        }
      },

      _initDimensionGrid: function() {
        if(this.dataContext) 
        {
          this._selectedLocales = this.dataContext.selectedLocales;
          this._selectedContexts = this.dataContext.selectedContexts;
          this._selectedSources = this.dataContext.selectedSources;
          
          var selectedLocaleIds = [];
          var selectedSourceIds = [];
          var selectedContextIds = [];

          if(this._selectedLocales) {
            this.locales.forEach(function(item) {
              this._selectedLocales.forEach(function(selectedItem) {
                if(item.title == selectedItem) {
                  selectedLocaleIds.push(item.id);
                }
              }, this);
            }, this);
          }

          if(this._selectedContexts) {
             this.contexts.forEach(function(item) {
              this._selectedContexts.forEach(function(selectedItem) {
                if(item.title == selectedItem) {
                  selectedContextIds.push(item.id);
                }
              }, this);
            }, this);
          }

          if(this._selectedSources) {
             this.sources.forEach(function(item) {
              this._selectedSources.forEach(function(selectedItem) {
                if(item.title == selectedItem) {
                  selectedSourceIds.push(item.id);
                }
              }, this);
            }, this);
          }
          
          Polymer.dom(this).node.$$("pebble-lov[id='locale']").selectedItemIds = selectedLocaleIds;
          Polymer.dom(this).node.$$("pebble-lov[id='source']").selectedItemIds = selectedSourceIds;
          Polymer.dom(this).node.$$("pebble-lov[id='context']").selectedItemIds = selectedContextIds;
        }
      }
		});
	})();
</script>
</dom-module>