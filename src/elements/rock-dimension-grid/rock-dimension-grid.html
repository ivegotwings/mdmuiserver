<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../rock-grid-data-sources/entity-dimension-grid-datasource.html">

<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-accordion/pebble-accordion.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../pebble-lov/pebble-lov.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-layout/rock-layout.html">
<link rel="import" href="../rock-layout/rock-titlebar/rock-titlebar.html">
<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-context-lov/rock-context-lov.html">
<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">
<link rel="import" href="../rock-component-config-behavior/rock-component-config-behavior.html">

<!--
`rock-dimension-grid` Represents a component that displays the dimension value of the given attribute.
It also updates or adds the current and future value for that attribute.

It displays dimensions like locale, source, context, and time.
The user can select any dimension where locale, source, and context is shown in "multiselect LOVs". 
The time is displayed in the "date-time-picker" control. The user can select the time range to list the attribute's 
history and future value.

The grid renders the data based on the selected dimensions from the left panel.
The user can view the past data but cannot modify it. However he/she can add or update the current and future value.

@demo demo/index.html
-->

<dom-module id="rock-dimension-grid">
  <template>
    <style include="bedrock-styles-scroll-bar">
      :host {
        --pebble-grid-container: {
          margin-top:0px;
          margin-bottom:0px;
        };
        --pebble-grid-container-header: {
          padding-right: 0;
          padding-left: 0;
        };
        --rock-grid-actions:{
          display:none;
        }
      }
      #dimensionGridContainer {
        height: 100%;
      }

      #dimensionFilters {
        width: 310px;
        float: left;
        height: 100%;
        padding-right: 10px;
        overflow: auto;
        @apply --dimension-filters;
      }

      #dimensionGrid {
        width: calc(100% - 320px);
        float: right;
      }
      
      pebble-lov {
        width: 100%;
        position: static !important;
      }

      .action-container {
        text-align: center;
      }

      pebble-lov {
        --pebble-lov-height: 125px;
      }

      pebble-checkbox {
        margin-top: 3px;
      }
    </style>
    <div id="dimensionGridContainer">
      <div id="dimensionFilters">
        <template is="dom-repeat" items="[[_updatedDimensionConfigs]]" as="configDataItem" notify-dom-change>
          <pebble-accordion header-text="[[configDataItem.title]]" default-icon="pebble-icon:action-scope-take-selection" open-icon="pebble-icon:action-expand">
            <template is="dom-if" if="[[_compareRequestType(configDataItem.dataRequestType, 'entity-context')]]">
              <rock-context-lov id="[[configDataItem.id]]" entity-id="[[entityId]]" entity-type="[[entityType]]"
                context-name="[[configDataItem.id]]" config-data-item-id="[[configDataItem.id]]" on-selection-changed="_onDimensionChange" 
                multi-select no-sub-title></rock-context-lov>
            </template>
            <template is="dom-if" if="[[_compareRequestType(configDataItem.dataRequestType, 'entity')]]">
              <rock-entity-lov id="[[configDataItem.id]]" r-data="[[configDataItem]]" config-data-item-id="[[configDataItem.id]]" id-field="[[configDataItem.dataMappings.id]]"
                title-pattern="[[configDataItem.dataMappings.title]]" request-data="[[configDataItem.dataRequest]]"
                type-field="[[configDataItem.dataMappings.type]]" sort-field="[[configDataItem.dataMappings.sort]]" external-data-formatter="[[_entityExternalDataFormatter]]"
                on-selection-changed="_onDimensionChange" multi-select no-sub-title></rock-entity-lov>
              </template>
          </pebble-accordion>
        </template>        
      </div>
      <div id="dimensionGrid">
        <div class="clearfix"></div>
        <rock-grid  config="[[_gridConfig]]" 
                    page-size="{{totalCount}}" 
                    attribute-models="[[gridAttributeModel]]" 
                    total-count="{{totalCount}}"
                    context-data="[[_gridContextData]]"></rock-grid>
      </div>
      <div class="clearfix"></div>
    </div>
    <entity-dimension-grid-datasource id="searchGridDatasource" context-data="[[contextData]]" value-contexts="{{_valueContexts}}" contexts="{{_contexts}}"
        request="{{_request}}" r-data-source="{{rDataSource}}" total-count="{{totalCount}}"></entity-dimension-grid-datasource>
    <liquid-entity-model-get id="userModelGet" operation="getbyids" on-response="_onUserModelGetResponse"></liquid-entity-model-get>
  </template>
  <script>
    (function () {
      'use strict';

      Polymer({
        is: 'rock-dimension-grid',
        properties: {
          contextData: {
            type: Object,
            value: function() {
              return {};
            },
            observer: "_onContextDataChange"
          },
          /*
           * Indicates an identifier for an entity.
           */
          dataId: {
            type: String,
            notify: true,
            value: ""
          },
          /*
           * Indicates an attribute model object of the given entity 
           * for which dimension values are rendered.
           */
          attributeModelObject: {
            type: String,
            value: function () {
              return {};
            }
          },

          /**
           * Indicates dimensions configuration
           */
          dimensionConfigs: {
            type: Array,
            value: function() {
              return [];
            }
          },
          _updatedDimensionConfigs: {
            type: Array,
            value: function() {
              return [];
            }
          },
          rDataSource:{
            type:Function
          },
          totalCount:{
            type:Number,
            value:100
          },
          entityId: {
            type: String,
            value: ""
          },
          entityType: {
            type: String,
            value: ""
          },
          _valueContexts:{
              type:Array,
              value:function(){
                  return []
              }
          },
          _contexts:{
              type:Array,
              value:function(){
                  return []
              }
          },
          _dataContextModelObjects:{
            type:Object,
            value: function(){
              return {}
            }
          },
          _valueContextModelObjects:{
            type:Object,
            value: function(){
              return {}
            }
          },
          /*
           * Indicates request object based on current selected dimension objects.
           */
          _request: {
            type: Object,
            value: function () {
              return {};
            }
          },

          /*
           * Indicates save request object based on current selected dimension objects.
           */
          _saveRequest: {
            type: Object,
            value: function () {
              return {};
            }
          },

          _gridConfig: {
            type: Object,
            value: function () {
              return {};
            }
          },

          _gridData: {
              type: Array,
              value: function () {
                  return [];
              }
          },
          appName: {
              type: String,
              value: ""
          },
          dataType: {
            type: String,
            value: ""
          },
          _gridContextData: {
            type: Object,
            value: function () {
              return {};
            }
          }
        },
        behaviors: [
          RUFBehaviors.UIBehavior,
          RUFBehaviors.ComponentContextBehavior,
          RUFBehaviors.ComponentConfigBehavior
        ],

        _onContextDataChange: function() {
          var context = DataHelper.cloneObject(this.contextData);
          context[ContextHelper.CONTEXT_TYPE_APP] = [{
            "app": this.appName
          }];

          if (!_.isEmpty(context)) {
            this.requestConfig('rock-dimension-grid', context);
          }
        },

        onConfigLoaded: function(componentConfig) {
            if(componentConfig && componentConfig.config) {
              this._gridConfig = componentConfig.config.gridConfig;
              this.dimensionConfigs = DataHelper.convertObjectToArray(componentConfig.config.dimensionsConfig);
              this.triggerSetup();
            }
        },

        /**
          * <b><i>Content development is under progress... </b></i> 
          */
        triggerSetup: function () {
          this.entityId = DataHelper.getParamValue('id');
          this.entityType = DataHelper.getParamValue('type');

          if(this.dimensionConfigs){
              var arrayToObj = {}
              for (let i = 0; i < this.dimensionConfigs.length; i++) {
                const dimension = this.dimensionConfigs[i];
                if(dimension){
                  arrayToObj[dimension.id] = dimension;
                  if(dimension.dimensionType === "data"){
                    this._dataContextModelObjects[dimension.id] = dimension;
                    this._dataContextModelObjects[dimension.id]["selectedItems"] = [];
                  }
                }
              }
          
              if (!_.isEmpty(this.contextData) && !_.isEmpty(arrayToObj)) {
                var dataContexts = this.getDataContexts();
                var valueContexts = this.getValueContexts();

                dataContexts.forEach(function(contextObj){
                    var selectedItems = [];
                    for (const contextKey in contextObj) {
                      if (contextObj.hasOwnProperty(contextKey) && arrayToObj[contextKey]) {
                          var _obj = {
                            id:contextObj[contextKey],
                            title:contextObj[contextKey],
                            type:contextKey
                          }
                          if(this._dataContextModelObjects[contextKey]){
                            this._dataContextModelObjects[contextKey]["selectedItems"].push(_obj);
                          }else{
                            this._dataContextModelObjects[contextKey] = arrayToObj[contextKey];
                            this._dataContextModelObjects[contextKey]["selectedItems"] = [ _obj ];
                          }
                      }
                    }
                }.bind(this));
                
                valueContexts.forEach(function(valueContextObj){
                    for (const valueContextKey in valueContextObj) {
                      if (valueContextObj.hasOwnProperty(valueContextKey) && arrayToObj[valueContextKey]) {
                          var _obj = {
                            id:valueContextObj[valueContextKey],
                            // title:valueContextObj[valueContextKey],
                            type:valueContextKey
                          }
                          var reqData = {
                              "params": {
                                  "query": {
                                      "filters": {
                                          "typesCriterion": [valueContextKey]
                                      }
                                  }
                              }
                          };
                          if(this._valueContextModelObjects[valueContextKey]){
                            this._valueContextModelObjects[valueContextKey]["selectedItems"].push( _obj );
                          }else{
                            this._valueContextModelObjects[valueContextKey] = arrayToObj[valueContextKey];
                            this._valueContextModelObjects[valueContextKey]["selectedItems"] = [ _obj ];
                          }
                          this._valueContextModelObjects[valueContextKey]["dataRequest"] = reqData;

                          this._valueContextModelObjects[valueContextKey]["dataMappings"]["id"] = "id";
                          this._valueContextModelObjects[valueContextKey]["dataMappings"]["title"] = "externalname";
                          // this._valueContextModelObjects[valueContextKey]["dataMappings"]["titlePattern"] = "{entity.attributes.externalname}";
                      }
                    }
                }.bind(this));

              }

          }

          this.set("_updatedDimensionConfigs", this.dimensionConfigs);

          var fields = this._gridConfig.itemConfig.fields;
          var modelObject = JSON.parse(this.attributeModelObject);
          if (!_.isEmpty(fields)) {
            for (var key in fields) {
              if (fields[key].header.toLowerCase() == "value") {
                fields[key].name = modelObject.name;
                if(modelObject.dataType === "nested") {
                  fields[key].isNested = true;
                }
              }
            }
          }

          var attrModels = {};
          var modelObject = JSON.parse(this.attributeModelObject);
          attrModels[modelObject.name] = modelObject;

          this.gridAttributeModel = undefined;
          this.gridAttributeModel = attrModels;

          setTimeout(() => {
            this._setDimensionSelection();
            this._onSelectionChange();
          }, 0)
        },
        _compareRequestType: function (dataRequestType, entityTypeInfo) {
          return dataRequestType === entityTypeInfo;
        },
        _entityExternalDataFormatter: function (data) {
            if(data && data.length > 0){
              var localeManager = ComponentHelper.getLocaleManager();
              data.forEach(function(element){
                  if(element && !_.isEmpty(element)){
                    if(element.title){
                      var title = element.title;
                      element.id = title.charAt(0).toLowerCase() + title.slice(1);
                    }
                    if(element.type == "locale"){
                      var localeObj = localeManager.getByName(element.id);
                      if (!_.isEmpty(localeObj) && localeObj.externalName) {
                        element.title = localeObj.externalName;
                      }
                    }
                  }
                }.bind(this))
            }
            return data;
        },

        _onDimensionChange: function (e) {
          if (e.currentTarget.selectedItems) {
            this._onSelectionChange();
          }
        },

        _onSelectionChange: async function () {
          if (this.dataId) {
              var attributeNames = [];
              var modelObject = JSON.parse(this.attributeModelObject);
              attributeNames.push(modelObject.name);

              var newDimensions = {};

              for (const valueContext in this._valueContextModelObjects) {
                if(this._valueContextModelObjects[valueContext]){
                  var selectedItems = this._valueContextModelObjects[valueContext].selectedItems;
                  var values = [];
                  if(selectedItems.length > 0) {
                    selectedItems.forEach(function(selectedItem) {
                      values.push(selectedItem.id);
                    });
                    newDimensions[valueContext] = values;
                  }
                }
              }
              for (const context in this._dataContextModelObjects) {
                if(this._dataContextModelObjects[context]){
                  var selectedItems = this._dataContextModelObjects[context].selectedItems;
                  var values = [];
                  if(selectedItems.length > 0) {
                    selectedItems.forEach(function(selectedItem) {
                      values.push(selectedItem.id);
                    });
                    newDimensions[context] = values;
                  }
                }
              }

              var contextData = {};
              ContextHelper.updateContextData(contextData, newDimensions);
              this.set("_gridContextData", contextData);
              var dataContexts = ContextHelper.getDataContexts(contextData);
              var valueContexts = ContextHelper.getValueContexts(contextData);

              if(modelObject.properties && modelObject.properties.contextCoalesce) {
                for(var i=0; i<dataContexts.length; i++) {
                  var context = dataContexts[0];
                  var additionalContexts = [];
                  var contextModel = await ContextModelManager.getContextModelByEntityTypeAndDataContext(this.dataType, context);
                  if (contextModel) {
                      additionalContexts = contextModel.properties ? contextModel.properties.additionalcontexts : undefined;
                  }
                  if(!_.isEmpty(additionalContexts) && !DataTransformHelper.isAdditionalContexts(additionalContexts, modelObject.properties.contextCoalesce, "context")) {
                    additionalContexts.forEach(function(ctxKey) {
                      delete context[ctxKey];
                    });
                  }
                }

                dataContexts = dataContexts.filter(ctx => !_.isEmpty(ctx));
              }

              this.set("_valueContexts", valueContexts);
              this.set("_contexts", dataContexts);

              var req = {
                "params": {
                  "query": {
                    "filters": {
                      "typesCriterion": [
                        "entitymanageevent"
                      ],
                      "attributesCriterion": [
                        {
                          "entityId": {
                            "exact": this.dataId
                          }
                        },
                        {
                        "eventType":{
                            "exact":"NoChange",
                            "not":true
                          }
                        }
                      ]
              
                    }
                  },
                  "sort": {
                    "properties": [
                      {
                        "modifiedDate": "_DESC",
                        "sortType": "_DATETIME"
                      }
                    ]
                  }

                }
              };

              var relationshipName = modelObject.relationshipName;
              if(relationshipName){
                req.params.fields = {
                  "relationships": [relationshipName],
                  "relationshipAttributes":attributeNames
                }
              }else{
                req.params.fields = {
                  "attributes": attributeNames,
                }
              }
              this._request = req;
             this.rDataSource({page: 0, pageSize: this.totalCount, resetSearch:true}, this._onAttributesGetResponse.bind(this), this._onAttributesGetErrorResponse.bind(this))
            }
        },
        
        _onAttributesGetResponse:function(res){
            if (res && res.status && (res.status == "success")) {
              var data = [];
              var modelObject = JSON.parse(this.attributeModelObject);
              var relationshipName = modelObject.relationshipName;
              var attrName = modelObject.name;
              var userIdList = [];
              var localeManager = ComponentHelper.getLocaleManager();

              if (res.content && res.content.events && res.content.events.length > 0) {
                var events = res.content.events;
                var columns = DataHelper.convertObjectToArray(this._gridConfig.itemConfig.fields);
                var _self = this;
                events.forEach(function (eventObj) {
                  if(_self._contexts.length > 0) {
                    for(let ctxIdx = 0; ctxIdx < _self._contexts.length; ctxIdx++) {
                      var context = _self._contexts[ctxIdx];
                      var _attribute = _self._getAttribute(eventObj, relationshipName, attrName, context);
                      
                      if(_attribute && _attribute.values && _attribute.values.length > 0){
                        _self._updateData(data, userIdList, eventObj, columns, _attribute, localeManager, attrName, modelObject, _self);
                      }
                    }
                  } else {
                    var _attribute = _self._getAttribute(eventObj, relationshipName, attrName);
                    if(_attribute && ((_attribute.values && _attribute.values.length > 0) || (_attribute.group && _attribute.group.length > 0))) {
                      _self._updateData(data, userIdList, eventObj, columns, _attribute, localeManager, attrName, modelObject,  _self);
                    }
                  }
                });
                this._gridData = data;
                if(userIdList.length > 0){
                    this._getUserList(userIdList);
                } else{
                    this._populateGrid();
                }
              }
            }
        },

        _getAttribute: function(entity, relationshipName, attributeName, context) {
          var _attribute;
          var isSelfContext = !_.isEmpty(context) ? false : true;
          if(relationshipName){
            var _relationshipDataArray;
            var relationships;

            relationships = EntityHelper.getRelationshipsBasedOnContext(entity, context, isSelfContext);

            if(relationships) {
              _relationshipDataArray = relationships[relationshipName];
            }
            
            if(_relationshipDataArray && _relationshipDataArray.length > 0){
              var relAttributes = _relationshipDataArray[0].attributes;
              if(relAttributes && relAttributes[attrName]){
                  _attribute = relAttributes[attrName];
                  var relProperties = _relationshipDataArray[0].properties;
                  if(_attribute && relProperties){
                    _attribute.properties = relProperties;
                  }
              }
            }
          }else{
            _attribute = EntityHelper.getattributeBasedOnContext(entity, attributeName, context);
          }

          return _attribute;
        },

        _updateData: function(data, userIdList, eventObj, columns, _attribute, localeManager, attributeName, attributeModel, self) {
          var firstValue, record, attrKey, attrValue, temporalDivElement;
          for(let valCtxIdx = 0; valCtxIdx < self._valueContexts.length; valCtxIdx++) {
            var valCtx = self._valueContexts[valCtxIdx];
            if(!_.isEmpty(_attribute.values)) {
              firstValue = AttributeHelper.getCurrentValue(_attribute.values, valCtx, attributeModel);
            } else if(!_.isEmpty(_attribute.group)) {
              let values = _attribute.group.filter(item => item.locale === valCtx.locale)
              if(!_.isEmpty(values)) {
                firstValue = {
                  "value": values
                }
                AttributeHelper.populateValueContext(firstValue, valCtx);
              }
            }
            
            if(!_.isEmpty(firstValue)) {
              record = {};
              for (let i = 0; i < columns.length; i++) {
                const column = columns[i];
                attrKey = column.name.toLowerCase();
                if(firstValue[attrKey]){
                  record[column.name] = firstValue[attrKey];
                  if(attrKey == "locale"){
                    var localeObj = localeManager.getByName(firstValue[attrKey]);
                    if (!_.isEmpty(localeObj) && localeObj.externalName) {
                      record[column.name] = localeObj.externalName;
                    }
                  }
                }
              }
              attrValue = "";
              if(firstValue.value){
                attrValue = firstValue.value;
              }
              
              switch(attributeModel.displayType) {
                case "richtexteditor": 
                  // TO-DO: Need to replace with rich text editor
                  // temporary solution - stipe html tags from value and display only text
                  temporalDivElement = document.createElement("div");
                  temporalDivElement.innerHTML = attrValue;
                  attrValue = temporalDivElement.textContent || temporalDivElement.innerText || "";
                  temporalDivElement = null;
                  break;
                default:
                  attrValue = attrValue;
              }
              record[attributeName] = attrValue;
              
              if(_attribute.properties){
                if(_attribute.properties.changeType){
                    var changeType = _attribute.properties.changeType;
                    if((changeType == "addAttributeToContext") 
                        || (changeType == "addValueToAttribute")
                        || (changeType == "addContext") 
                        || (changeType == "addAttributeToRelationship")){
                        record.icon = "pebble-icon:action-add";
                    }else if((changeType == "deleteAttributeValuesFromContext") || (changeType == "deleteAttributeFromContext")){
                        record.icon = 'pebble-icon:action-delete';
                        record[attributeName] = "";
                    }else{
                        record.icon = 'pebble-icon:action-edit';
                    }
                }
              }
              if(eventObj.properties && eventObj.properties.modifiedDate){
                record.Time = FormatHelper.convertFromISODateTimeToClientFormat(eventObj.properties.modifiedDate, 'datetime');
              }
              if(eventObj.properties && eventObj.properties.modifiedBy){
                var userId = eventObj.properties.modifiedBy;
                if(userIdList.indexOf(userId) == -1){
                  userIdList.push(userId);
                }
                record.userId = userId; 
              }
              data.push(record);
            }
          }
        },

        _getUserList:function(userIdList){
          var req = {
                "params": {
                  "query": {
                      "ids": userIdList,
                      "filters": {
                          "typesCriterion": [
                              "user"
                          ]
                      }
                  },
                  "fields": {
                    "properties":[
                      "firstName","lastName"
                    ],
                    // attributes are added to get the properties
                    "attributes": [
                        "_ALL"
                    ]
                  }
              }
          };
          var liqUserModelsGet = this.$$("#userModelGet");
          if (liqUserModelsGet) {
            liqUserModelsGet.requestData = req;
            liqUserModelsGet.generateRequest();
          }
        },

        _onAttributesGetErrorResponse: function(e){
          console.error(e);
        },
        _onSelectAll: function (e) {
          const target = e.currentTarget;
          
          const entityType = target.id;
          
          let nodeId;
          let objectKey;
          
          switch(entityType) {
            case 'localeChk':
              nodeId = 'locale';
              objectKey = '_selectedLocales';
              break;
            case 'sourceChk':
              nodeId = 'source';
              objectKey = '_selectedSources';
              break;
            case 'channelChk':
              nodeId = 'channel';
              objectKey = '_selectedChannels';
              break;
            default:
              throw new Error(`Unsupported entity type: ${entityType}`);
          }

          const node = Polymer.dom(this).node.shadowRoot.querySelector(`rock-entity-model-lov[id=${nodeId}]`);

          node.selectedItems = target.checked ? this._getAllItemsOfLov(node): [];

          this[objectKey] = node.selectedItems;
        },

        _getAllItemsOfLov: function (lovElement) {
          var items = [];

          if (lovElement) {
            var pebbleLov = Polymer.dom(lovElement).node.shadowRoot.querySelector('pebble-lov');
            if (pebbleLov) {
              items = pebbleLov.$.selector.items;
            }
          }

          return items;
        },

        _saveAction: function (e) {
          var attributesJSON = {};
          var grid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
          var modelObject = JSON.parse(this.attributeModelObject);
          var attrName = modelObject.name;

          if (grid) {
            var data = grid.data;

            var entityData = {};
            if (this.response && this.response.content && this.response.content.entities) {
              var entities = DataHelper.cloneObject(this.response.content.entities);
              if (!_.isEmpty(entities)) {
                entityData = entities[0];
              }
            }

            if (!_.isEmpty(entityData)) {

              data.forEach(function (item) {
                item.Channel = _.isEmpty(item.Channel) ? item.Channel = 'self' : item.Channel;
                if (attributesJSON[item.Channel] == undefined) {
                  attributesJSON[item.Channel] = {};
                  attributesJSON[item.Channel][attrName] = {};
                  attributesJSON[item.Channel][attrName].values = [];
                }

                if (attributesJSON[item.Channel][attrName]) {
                  attributesJSON[item.Channel][attrName].values.push({
                    "value": item[attrName],
                    "source": item.Source,
                    "locale": item.Locale
                  })
                }
              }, this);

              if (this.dataId == entityData.id) {
                if (entityData.data) {
                  if (!_.isEmpty(entityData.data.contexts)) {
                    entityData.data.contexts.forEach(function (item) {
                      if (attributesJSON[item.context.channel]) {
                        item.attributes = attributesJSON[item.context.channel];
                      }
                    }, this);
                  }

                  if (!_.isEmpty(entityData.data.attributes)) {
                    entityData.data.attributes = attributesJSON['self'];
                  }
                }

              }

              //set requestObject for save liquid
              this._saveRequest = {
                "entities": entityData
              };

              var liquidSave = this.shadowRoot.querySelector("[name=attributeSaveDataService]");
              if (liquidSave) {
                liquidSave.generateRequest();
              }
            }
          }
        },

        _cancelAction: function (e) {
          var dimGrid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
          var pebbleDialog = this._getParentPebbleDialog(Polymer.dom(this).node.parentElement);

          if (dimGrid) {
            dimGrid.changeToReadMode();
          }

          if (pebbleDialog) {
            pebbleDialog._close();
          }
          Polymer.dom(this).node.parentElement.removeChild(this);
        },

        _getParentPebbleDialog: function (element) {
          if (element) {
            if (element.is == "pebble-dialog") {
              return element;
            } else {
              return this._getParentPebbleDialog(element.parentNode);
            }
          }
          return undefined;
        },

        _onSaveResponse: function () {
          RUFUtilities.appCommon.toastText = this.saveResponse.content.msg;
          var toastElement = RUFUtilities.pebbleAppToast;
          toastElement.toastType = "success";
          toastElement.heading = "Success";
          toastElement.autoClose = true;

          toastElement.show();
          this._cancelAction();
        },

        _entityGet: function () {
          if (this.response != undefined) {
            var dimGrid = Polymer.dom(this).node.shadowRoot.querySelector('rock-grid');
            var data = [];
            var modelObject = JSON.parse(this.attributeModelObject);
            var attrName = modelObject.name;
            var dimensions = {
              "locales": this._selectedLocales,
              "channels": this._selectedChannels,
              "sources": this._selectedSources
            };

            if (this.response && this.response.content && this.response.content.entities) {
              var entity = this.response.content.entities[0];
              if (entity) {
                DataTransformHelper.transformEntityForDimensionGrid(entity, dimensions, modelObject);
                var currentContexts = entity.data.contexts;
                var selfAttributes = entity.data.attributes;

                if (selfAttributes && selfAttributes[attrName]) {
                  var values = selfAttributes[attrName].values;
                  if (values) {
                    values.forEach(function (valueItem) {
                      var record = {};
                      record[attrName] = valueItem.value;
                      record.Locale = valueItem.locale;
                      record.Source = valueItem.source;
                      record.Channel = "";
                      data.push(record);
                    }, this);
                  }
                }

                if (currentContexts) {
                  currentContexts.forEach(function (item) {

                    var attributes = item.attributes;

                    if (attributes) {
                      var values = attributes[attrName].values;
                      if (values) {
                        values.forEach(function (valueItem) {
                          var record = {};
                          record[attrName] = valueItem.value;
                          record.Locale = valueItem.locale;
                          record.Source = valueItem.source;
                          record.Channel = item.context.list;
                          data.push(record);
                        }, this);
                      }
                    }
                  }, this);
                }
              }

              if (data) {
                dimGrid.data = data;
                if (dimGrid._getIronDataTable()) {
                  dimGrid._getIronDataTable()._sizeChanged(data.length, 0);
                  dimGrid.reRenderGrid();
                }
              }
            }
          }
        },

        _getIdsFromObject: function (arrayObject) {
          var ids = [];
          if (arrayObject) {
            arrayObject.forEach(function (item) {
              ids.push(item.id);
            }, this);
          }
          return ids;
        },

        _setDimensionSelection: function () {

          for (const dataContext in this._dataContextModelObjects) {
            if (this._dataContextModelObjects.hasOwnProperty(dataContext)) {
              var contextLovElement = this.shadowRoot.querySelector("#"+dataContext);
              if(contextLovElement){
                contextLovElement.selectedItems = this._dataContextModelObjects[dataContext].selectedItems;
              }
            }
          }

          for (const valueContext in this._valueContextModelObjects) {
            if (this._valueContextModelObjects.hasOwnProperty(valueContext)) {
              var entityLovElement = this.shadowRoot.querySelector("#"+valueContext);
              if(entityLovElement){
                entityLovElement.selectedItems = this._valueContextModelObjects[valueContext].selectedItems;
              }
            }
          }
        },

        _onUserModelGetResponse: function(e){
          var response = e.detail.response;
          if(DataHelper.validateGetModelsResponse(response)){
            var isUserFound = false;
            const userModels = response.content.entityModels;            
            this._gridData.forEach(function(item){    
              if(item.userId) {            
                for(let index = 0; index < userModels.length; index++){
                  if(item.userId == userModels[index].id){
                    item.user = userModels[index].properties.firstName + ' ' + userModels[index].properties.lastName;
                    isUserFound = true;
                    break;
                  }
                }
                if(!isUserFound){
                  item.user = item.userId.replace(/_user$/, "");
                }
              }
            });  
          }
          this._populateGrid(); 
        },

        _populateGrid: function(){
          if (this._gridData) {
            var dimGrid = this.shadowRoot.querySelector('rock-grid');
            dimGrid.data = this._gridData;
            if (dimGrid._getIronDataTable()) {
              dimGrid._getIronDataTable()._sizeChanged(this._gridData.length, 0);
              dimGrid.reRenderGrid();
            }
          }
        }
      });
    })();
  </script>
</dom-module>
