<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-accordion/pebble-accordion.html">

<link rel="import" href="../rock-attribute/rock-attribute.html">
<!--
`rock-attribute-list` Represents the attribute-list component in the framework.
It renders the list of attributes based on the specified parameters.

@demo demo/index.html 
-->
<dom-module id="rock-attribute-list">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            :host {
                @apply --rock-attribute-list;
            }

            .group-name {
                font-weight: var(--font-bold, bold);
                font-family: var(--default-font-family);
                clear: both;
                margin: 0px;
                font-size: var(--font-size-md, 16px);
                color: var(--title-text-color, #191e22);
            }

            .group-container {
                margin-bottom: 20px;
            }

            .group-name-container {
                clear: left;
                @apply --layout-horizontal;
                background: var(--palette-pale-grey-four, #eff4f8);
                padding: 6px;
                border-radius: 3px;
            }

            .group-line-box {
                margin-top: 16px;
                margin-left: 8px;
                margin-right: 8px;
                @apply --layout-flex;
            }

            .group-line-container {
                float: right;
                border-bottom: 1px solid var(--border-black, #000);
            }

            .attribute-box {
                display: inline-block;
                padding: 0 20px;
                vertical-align: bottom;
            }

            .attribute-wrapper {
                margin: 0 -30px;
            }

            .attribute-box-1 {
                width: 100%;
            }

            .attribute-box-2 {
                width: calc(50% - 2px);
            }

            .attribute-box-3 {
                width: 33%;
            }

            .attribute-box-4 {
                width: 24%;
            }

            pebble-horizontal-divider {
                border-top: 1px dotted var(--default-border-color, #c1cad4);
            }

            .content {
                height: 100%;
                padding-bottom: 25px;
                overflow-x:hidden;
                overflow-y: scroll;
                max-height: calc(85vh - 170px);
                @apply --rock-attribute-list-content;
            }
            /* IE edge specific fix for horizontal scroll */
            
            _:-ms-lang(x),
            _:-webkit-full-screen,
            .content {
                overflow-x:hidden;
                overflow-y:auto;
            }

            paper-spinner-lite {
                margin: 0 auto;
                display: none;
            }

            paper-spinner-lite[active] {
                display: block;
            }

        </style>
        <div class="content">
            <div class="attribute-list-container">
                <template is="dom-if" if="displayedAttributesChunks.length">
                    <template is="dom-repeat" items="[[displayedAttributesChunks]]" as="chunk">
                        <template is="dom-repeat" items="[[chunk]]" as="attribute">
                            <template is="dom-if" if="[[_checkRenderGroupBar(attribute, 0)]]">
                                <pebble-accordion header-text="[[groupName]]" default-icon="pebble-icon:action-scope-take-selection" open-icon="pebble-icon:action-expand">
                                    <div class="attribute-wrapper">
                            </template>
    
                            <div class$="[[_getAttributeClass(noOfColumns, attribute)]]" name$="[[attribute.name]]">
                                <rock-attribute 
                                context-data="[[contextData]]" 
                                mode="[[mode]]" 
                                readonly="[[readonly]]" 
                                errors="{{attribute.errors}}" 
                                server-errors="[[_getAttributeMessage(attribute,attributeMessages)]]"
                                attribute-model-object="[[_getAttributeModel(attributeModels, attribute)]]" 
                                attribute-object="{{attribute}}"
                                original-attribute-object="[[_cloneObject(attribute)]]" 
                                tabindex="[[_getTabIndex(attribute)]]" 
                                on-attribute-value-changed="updateDependentAttributesAndResetErrors"
                                show-delete-icon="[[showDeleteIcon]]" 
                                dependent-attribute-objects="[[_getDependentAttributes(attribute)]]"
                                dependent-attribute-model-objects="[[_getDependentAttributeModels(attribute)]]"
                                on-attribute-mode-changed="_onModeChange"
                                apply-locale-coalesce="[[applyLocaleCoalesce]]">
                                </rock-attribute>
                            </div>
    
                            <template is="dom-if" if="[[_checkRenderGroupBar(attribute, 1)]]">
                                </div>
                                </pebble-accordion>
                            </template>
                            <bedrock-pubsub event-name="attribute-delete" handler="_ondeletingAttribute" target-id=""></bedrock-pubsub>
                        </template>
                    </template>
                </template>
            </div>
            <paper-spinner-lite active="[[loading]]"></paper-spinner-lite>
        </div>
    </template>
    <script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute-list',
                created: function () {
                    this.displatedAttributesChunkIndex = 1;
                    this.displayedAttributesChunks = [];

                    this.loading = true;

                    this._onScrollListDebounce = _.debounce(this._onScrollList.bind(this), 300);
                },

                attached() {
                    this.scrollContainer.addEventListener('scroll', this._onScrollListDebounce);
                },

                detached() {
                    this.scrollContainer.removeEventListener('scroll', this._onScrollListDebounce)
                },

                get scrollContainer() {
                    this._scrollContainer = this._scrollContainer || this.shadowRoot.querySelector('.content');
                    return this._scrollContainer;
                },

                properties: {
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    /**
                     * If set as true , it indicates the component is in read only mode
                     */
                    readonly: {
                        type: Boolean,
                        value: false
                    },

                    /**
                     * Indicates whether the attribute is rendered in edit mode or view mode. 
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                     * Indicates the number of columns in which the attributes are rendered. Possible values are 1, 2 and 3.
                     */
                    noOfColumns: {
                        type: Number,
                        value: 1
                    },
                    /**
                     * Indicates the attribute model objects which renders the attributes.
                     * JSON sample to be added here.
                     */
                    attributeModels: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the attribute value objects which renders the attributes.
                     * JSON sample to be added here.
                     */
                    attributeValues: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates the attribute value objects which renders the attributes.
                     * JSON sample to be added here.
                     */
                    attributeMessages: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        observer: '_onAttributeMessagesChange'
                    },
                    /**
                     * Indictaes the locale dimension for which the attribute list is used.
                     */
                    locale: {
                        type: String
                    },
                    /**
                     * Indictaes the list for which the attribute list is used.
                     */
                    list: {
                        type: String
                    },
                    /**
                     * Indictaes the source dimension for which the attribute list is used.
                     */
                    source: {
                        type: String
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    showGroupName: {
                        type: Boolean,
                        value: false
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    groupName: {
                        type: String,
                        value: "My Attributes"
                    },
                    _runningTabIndex: {
                        type: Number,
                        value: 1
                    },
                    _previousViewName: {
                        type: String,
                        value: ""
                    },
                    showDeleteIcon: {
                        type: Boolean,
                        value: false
                    },
                    attributesChunkLength: {
                        type: Number,
                        value: 0
                    },
                    _lazyLoad: {
                        type: Boolean,
                        value: false
                    },
                    applyLocaleCoalesce: {
                        type: Boolean,
                        value: false
                    },
                },
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                observers: [
                    '_onAttributeValuesChange(attributeValues.*)',
                    '_onAttributeModelsChange(attributeModels.*)'
                ],

                get hasScroll() {
                    const { scrollHeight, offsetHeight } = this.scrollContainer;

                    return scrollHeight > offsetHeight;
                },

                get isLoadFinished() {
                    return this.displayedAttributesChunks.length === this.attributesChunks.length;
                },

                _onScrollList(activeContent) {
                    if(!this._lazyLoad) return;

                    const { scrollHeight, scrollTop, offsetHeight } = this.scrollContainer;

                    const scrollDiff = scrollHeight - offsetHeight - scrollTop;

                    const PRELOAD_HEIGHT = 100;

                    if(this.isLoadFinished) {
                        this.loading = false;
                        return;
                    }

                    if (scrollTop && scrollDiff <= PRELOAD_HEIGHT)
                        return this._loadMoreAttributes();
                },

                _loadMoreAttributes() {
                    const itemsToPush = this.attributesChunks.slice(this.displatedAttributesChunkIndex, ++this.displatedAttributesChunkIndex);

                    if (!itemsToPush.length) {
                        this.loading = false;
                        return;
                    }

                    this.loading = true;

                    window.requestAnimationFrame(()=> {
                        const displayedAttributesChunks = this.displayedAttributesChunks.concat(itemsToPush);
                        this.set('displayedAttributesChunks', displayedAttributesChunks);
                    });
                },

                _onAttributeValuesChange: function (changeRecord) {
                    this._previousViewName = "";
                    this.loading = true;

                    const isValidPath = ['attributeValues', 'attributeValues.length'].indexOf(changeRecord.path) !== -1;

                    if (!isValidPath || !this.attributeValues.length) {
                        this.loading = false;
                        return;
                    }
                    this._lazyLoad = !!this.attributesChunkLength;

                    this._calculateErrorLength(this.attributeValues);

                    Polymer.Async.microTask.run(() => {
                        this.attributesChunks = this.attributeValues.reduce((res, item) => {
                            const chunkIndex = res.length;

                            const currentChunk = res[chunkIndex - 1];

                            if (chunkIndex && currentChunk && currentChunk.length < this.attributesChunkLength)
                                currentChunk.push(item);
                            else
                                res.push([item]);

                            return res;
                        }, []);

                        if(!this._lazyLoad) {
                            this.loading = false;
                            this.set('displayedAttributesChunks', this.attributesChunks);
                            return;
                        }

                        const displayedAttributesChunks = this.attributesChunks.slice(0, this.displatedAttributesChunkIndex);
                        
                        this.set('displayedAttributesChunks', displayedAttributesChunks);

                        if(this.isLoadFinished) {
                            this.loading = false;
                            return;
                        }

                        //after rendering initial attributes need to check if container has scroll
                        //in case it doesn't have, need to trigger loading next chunk manually
                        setTimeout(()=> {
                            if(!this.hasScroll)
                                this._loadMoreAttributes();
                        }, 0);
                    });
                },

                _onAttributeModelsChange(changeRecord) {
                    const isValidPath = ['attributeModels'].indexOf(changeRecord.path) !== -1;

                    if (!isValidPath || _.isEmpty(this.attributeModels)) return;

                    this.uniqueGroups = Object.keys(this.attributeModels).reduce((res, attributeName) => {
                        const groupName = this.attributeModels[attributeName].groupName;

                        if(!~res.indexOf(groupName)) 
                            res.push(groupName);

                        return res;
                    }, []);
                },
                
                _getAttributeClass: function (n, attribute) {
                    var model = this._getAttributeModel(this.attributeModels, attribute);
                    var displayType = model && model.displayType ? model.displayType.toLowerCase() : "";
                    if(displayType === "textarea" || displayType === "richtexteditor" || displayType === "nestedgrid") {
                        n = 1;
                    }
                    return "attribute-box attribute-box-" + n;
                },
                _getAttributeModel: function (attributeModels, attribute) {
                    var model;
                    if (attributeModels) {
                        if (attribute.name in attributeModels) {
                            model = attributeModels[attribute.name];
                        }
                    }

                    if (_.isEmpty(model)) {
                        //set default model as textbox
                        //TODO: find a better way for getting default model
                        model = {
                            "name": attribute.name,
                            "longName": attribute.name,
                            "displayType": "textbox",
                            "viewName": "Other Attributes"
                        };
                    }

                    if (_.isEmpty(model.dataType)) {
                        model.dataType = 'string';
                    }

                    if (_.isEmpty(model.displayType)) {
                        var dataType = model.dataType ? model.dataType.toLowerCase() : model.dataType;
                        model.displayType = this._getDisplayType(dataType);
                    }

                    return model;
                },
                _getDisplayType: function (dataType) {
                    var displayType = 'textbox';

                    switch (dataType) {
                        case 'boolean':
                            {
                                displayType = 'boolean';
                                break;
                            }
                        case 'date':
                            {
                                displayType = 'date';
                                break;
                            }
                        case 'datetime':
                            {
                                displayType = 'datetime';
                                break;
                            }
                        case 'decimal':
                            {
                                displayType = 'textbox';
                                break;
                            }
                    }

                    return displayType;
                },
                /**
                * Can be used to get all the attribute objects that are changed in the attribute-list.
                */
                getChangedAttributeElements: function () {
                    var node = Polymer.dom(this).node;
                    var changedAttributeElements = Polymer.dom(this).node.querySelectorAll('rock-attribute[changed]');
                    if (changedAttributeElements == undefined || changedAttributeElements.length == 0) {
                        changedAttributeElements = Polymer.dom(this).node.root.querySelectorAll('rock-attribute[changed]');
                    }
                    return changedAttributeElements;
                },
                /**
                * Can be used to get all the attribute objects that are changed in the attribute-list.
                */
                getDependentAttributeElements: function(currentAttribute) {
                    var node = Polymer.dom(this).node;
                    var allAttributeElements = Polymer.dom(this).node.querySelectorAll('rock-attribute');
                    if(allAttributeElements == undefined || allAttributeElements.length == 0) {
                        allAttributeElements = Polymer.dom(this).node.root.querySelectorAll('rock-attribute');
                    }

                    return DataHelper.getDependentAttributesOfAttribute(allAttributeElements, currentAttribute);
                },

                /**
                 * Can be used to reset all the changed attribute objects to their original object values.
                 */
                resetChanged: function () {
                    var changedAttributeElements = this.getChangedAttributeElements();
                    for (var i = 0; i < changedAttributeElements.length; i++) {
                        var attributeElement = changedAttributeElements[i];
                        attributeElement.changed = false;
                    }
                },
                /**
                 * Can be used to reset all the changed attribute objects to their original object values and switch
                 * the mode from "edit" to "view".
                 */
                revertAll: function () {
                    var changedAttributeElements = this.getChangedAttributeElements();
                    for (var i = 0; i < changedAttributeElements.length; i++) {
                        var attributeElement = changedAttributeElements[i];
                        attributeElement.attributeObject = this._cloneObject(attributeElement.originalAttributeObject);
                        this._updateDependentAttributes(attributeElement, true);
                        attributeElement.changed = false;
                    }
                    this.mode = "view";
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                /**
                 * <b><i>Content development is under progress... </b></i> 
                 */
                updateDependentAttributesAndResetErrors: function (e) {
                    if(e) {
                        var attribute = e.currentTarget || e.sourceElement;
                        var isRevertClicked = e.detail.revertClicked;
                        this._updateDependentAttributes(attribute, isRevertClicked);
                    }

                    this._calculateErrorLength(this.attributeValues);
                },

                _updateDependentAttributes: function(currentAttribute, isRevertButtonClicked) {
                    var dependentAttributeElements = this.getDependentAttributeElements(currentAttribute);
                    DataHelper.updateDependentAttributeElements(dependentAttributeElements, currentAttribute, isRevertButtonClicked);
                },

                _calculateErrorLength: function (attributeValues) {
                    var errorCount = 0;
                    for (var i = 0; i < attributeValues.length; i++) {
                        var att = attributeValues[i];
                        if (att.errors && att.errors.length > 0) {
                            errorCount++;
                        }
                    }

                    this.fireBedrockEvent("error-length-changed", errorCount, {
                        ignoreId: true
                    });
                },
                //On messages change re-calculate tab error length
                _onAttributeMessagesChange: function () {
                    if (this.attributeValues && this.attributeMessages) {
                        for (var i = 0; i < this.attributeValues.length; i++) {
                            var _currentAttribute = this.attributeValues[i];
                            if (this.attributeMessages[_currentAttribute.name]) {
                                if (!_currentAttribute["errors"] || _currentAttribute["errors"].length == 0) {
                                    _currentAttribute["errors"] = this.attributeMessages[_currentAttribute.name];
                                }
                            }
                        }
                    }
                },
                _onModeChange(e) {
                    const mode = e.detail.mode;
                    
                    if(!mode) return;

                    this.mode = mode;

                    this.dispatchEvent(new CustomEvent("list-mode-changed", {
                        detail: { mode }, 
                        bubbles: true, 
                        composed: true
                    }));
                },
                /**
                 * Can be used to get the elements if they are dirty.
                 */
                getIsDirty: function () {
                    var changedAttributeElements = this.getChangedAttributeElements();
                    return !!(changedAttributeElements && changedAttributeElements.length);
                },
                /**
                * Can be used to get the controls if they are dirty.
                */
                getControlIsDirty: function () {
                    return this.mode == "edit";
                },
                _checkRenderGroupBar: function (attribute, saveAsPrevious) {
                    var result = false;

                    if (this._previousViewName != this.groupName) {
                        result = true;
                    }
                    if (saveAsPrevious) {
                        this._previousViewName = this.groupName;
                    }

                    return !!(result && this.uniqueGroups && this.uniqueGroups.length > 1);
                },
                _getAttributeMessage: function (attribute) {
                    if (attribute && this.attributeMessages) {
                        var messages = this.attributeMessages[attribute.name];
                        if (messages && messages.length) {
                            return messages;
                        }
                    }
                    return [];
                },
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                hasModelErrors: function () {
                    var _attributes = Polymer.dom(this).node.querySelectorAll('rock-attribute');
                    if (_attributes == undefined || _attributes.length == 0) {
                        _attributes = Polymer.dom(this).node.root.querySelectorAll('rock-attribute');
                    }
                    for (var i = 0; i < _attributes.length; i++) {
                        if (_attributes[i].hasModelErrors()) {
                            return true;
                        }
                    }
                    return false;
                },
                _getTabIndex: function(attribute) {
                    return this._runningTabIndex++;
                },
                getAttributeValues: function() {
                    return this.attributeValues;
                },
                _ondeletingAttribute: function(e, detail) {
                    var attributeModelObject = detail.data;
                    var attribute = this.attributeValues.find(obj => obj.name === attributeModelObject.name);
                    if(attribute) {
                        var index = this.attributeValues.indexOf(attribute);
                        this.splice("attributeValues", index, 1);
                        this.fireBedrockEvent("attribute-control-delete", { data: attribute }, { ignoreId: true });
                    }
                },
                _getDependentAttributes: function(currentAttribute) {
                    var dependentAttributeModels = DataHelper.getDependentAttributeModels(this.attributeModels, currentAttribute);
                    var dependentAttributeValues = [];

                    if(this.attributeValues) {
                        for(let i = 0; i < dependentAttributeModels.length; i++) {

                            var dependentAttributeModel = dependentAttributeModels[i]
                            for(let j = 0; j < this.attributeValues.length; j++) {
                                if(dependentAttributeModel.name === this.attributeValues[j].name) {
                                    dependentAttributeValues.push(this.attributeValues[j]);
                                    break;
                                }
                            }
                        }
                    }

                    return dependentAttributeValues
                },
                _getDependentAttributeModels: function(currentAttribute) {
                    return DataHelper.getDependentAttributeModels(this.attributeModels, currentAttribute);
                }                
            });
        })();
    </script>
</dom-module>