<script>
    window.RUFBehaviors = window.RUFBehaviors || {};
    RUFBehaviors.elements = RUFBehaviors.elements || {};
    RUFBehaviors.elements.pebblelookup = RUFBehaviors.elements.pebblelookup || {};

    /** @polymerBehavior RUFBehaviors.elements.pebblelookup.PebbleLookupDropdownBehavior */
    RUFBehaviors.elements.pebblelookup.PebbleLookupDropdownBehavior = {
        properties: {
            /**
             * True if the dropdown is open, false otherwise.
             */
            opened: {
                type: Boolean,
                notify: true,
                value: false,
                reflectToAttribute: true,
                observer: '_openedChanged'
            },

            /**
             * Set to true to disable this element.
             */
            disabled: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            },

            /**
             * When present, it specifies that the element field is read-only.
             */
            readonly: {
                type: Boolean,
                value: false,
                reflectToAttribute: true
            }
        },

        created: function () {
            console.log("pebble-lookup-dropdown-behavior: created");
        },

        ready: function () {
            console.log("pebble-lookup-dropdown-behavior: ready");
        },

        attached: function () {
            console.log("pebble-lookup-dropdown-behavior: attached");
        },

        detached: function () {
            console.log("pebble-lookup-dropdown-behavior: detached");
        },

        /**
         * Fired after the `pebble-lookup-dropdown` opens.
         *
         * @event pebble-lookup-dropdown-opened
         */
        /**
         * Fired after the `pebble-lookup-dropdown` closes.
         *
         * @event pebble-lookup-dropdown-closed
         */

        /**
         * Opens the dropdown list.
         */
        open: function () {
            console.log("pebble-lookup-dropdown-behavior: ready");
            // Prevent _open() being called when input is disabled or read-only
            if (!this.disabled && !this.readonly) {
                this.opened = true;
            }
        },

        /**
         * Closes the dropdown list.
         */
        close: function () {
            console.log("pebble-lookup-dropdown-behavior: close");
            this.opened = false;
        },

        detached: function () {
            console.log("pebble-lookup-dropdown-behavior: detached");
            // Making sure the overlay is closed and removed from DOM after detaching the dropdown.
            this.close();
        },

        _openedChanged: function (value, old) {
            console.log("pebble-lookup-dropdown-behavior: _openedChanged");
            // Prevent _close() being called when opened is set to its default value (false).
            if (old === undefined) {
                return;
            }

            if (this.opened) {
                this._open();
            } else {
                this._close();
            }
        },

        _open: function () {
            console.log("pebble-lookup-dropdown-behavior: _open");
            this.$.overlay._moveTo(document.body);

            this._addOutsideClickListener();

            // For touch devices, we don't want to popup virtual keyboard on touch devices unless input
            // is explicitly focused by the user.
            if (!this.$.overlay.touchDevice) {
                // If the inputElement is a paper-input, it would trigger an
                // unnecessary blur event on focus. Check to see if there is a
                // focused property and if it's already true.
                // See also https://github.com/PolymerElements/paper-input/issues/341
                if (!this.inputElement.focused) {
                    this.inputElement.focus();
                }
            }

            this.fire('pebble-lookup-dropdown-opened');
        },

        _close: function () {
            console.log("pebble-lookup-dropdown-behavior: _close");
            this.$.overlay._moveTo(this.root);

            this._removeOutsideClickListener();

            this.fire('pebble-lookup-dropdown-closed');
        },

        // We need to listen on 'click' / 'tap' event and capture it and close the overlay before
        // propagating the event to the listener in the button. Otherwise, if the clicked button would call
        // open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
        _outsideClickListener: function (event) {
            console.log("pebble-lookup-dropdown-behavior: _outsideClickListener");
            var eventPath = Polymer.dom(event).path;
            if (!this.$.overlay._multiSelectionBoolean) {
                if ((eventPath.indexOf(this) === -1 && eventPath.indexOf(this.$.overlay.$.searchbox) < 1) ||
                    (eventPath.indexOf(this) === -1 && eventPath.indexOf(this.$.overlay) < 1)) {
                    this.close();
                }
            } else {

            }
        },

        _addOutsideClickListener: function () {
            console.log("pebble-lookup-dropdown-behavior: _addOutsideClickListener");
            // With desktop mouse, 'click' will make Polymer to fire 'tap' event.
            // With touch devices, 'touchend' will make Polymer to fire 'tap' event, but browser will also fire 'click'.
            // So, 'click' and 'tap' can come in any order and we need to make sure that the first one fired will close the overlay.
            if (this.$.overlay.touchDevice) {
                Polymer.Gestures.add(document, 'tap', null);
                document.addEventListener('tap', this._outsideClickListener.bind(this), true);
            } else {
                document.addEventListener('click', this._outsideClickListener.bind(this), true);
            }
        },

        _removeOutsideClickListener: function () {
            console.log("pebble-lookup-dropdown-behavior: _removeOutsideClickListener");
            if (this.$.overlay.touchDevice) {
                // Not sure if this is a good idea to remove this Gesture globally, but that's how the iron-overlay-behavior does it.
                Polymer.Gestures.remove(document, 'tap', null);
                document.removeEventListener('tap', this._outsideClickListener.bind(this), true);
            } else {
                document.removeEventListener('click', this._outsideClickListener.bind(this), true);
            }
        }
    };
</script>