<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-externalref-underscore/bedrock-externalref-underscore.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<link rel="import" href="../rock-context-lov/rock-context-lov.html">
<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">
<link rel="import" href="../rock-component-config-behavior/rock-component-config-behavior.html">

<!--
`<rock-dimension-selector>` Represents a component to hold a container, source, date, and locale information.
The elements inside this component are dynamically loaded based on the "config json".

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--dimesion-selector-container-popover` | Mixin applied to container selector dropdown | `{}`
`--dimesion-selector-source-popover` | Mixin applied to source selector dropdown | `{}`
`--dimesion-selector-locale-popover` | Mixin applied to locale selector dropdown | `{}`

@group rock Elements
@element rock-dimension-selector
@demo demo/index.html
-->
<dom-module id="rock-dimension-selector">
    <template>    
        <style include="bedrock-style-common iron-flex">
            :host {
                display:block;
                width: 100%;
                --item-length-overflow: {
                    word-break: break-word;
                }
            }

            #listPopover {
                @apply --dimesion-selector-container-popover;
            }

            #sourcePopover {
                @apply --dimesion-selector-source-popover;
            }

            #localePopover {
                @apply --dimesion-selector-locale-popover;
            }

            pebble-popover {
                --pebble-popover-width: 260px;
            }

            .btn.dropdownText {
                display: flex;
                align-items: center;
                --pebble-button: {
                    font-weight: var(--font-medium, 500);
                    color: var(--palette-cerulean-two, #026bc3);
                    padding-top: 0px;
                    padding-right: 0px;
                    padding-bottom: 0px;
                    padding-left: 0px;
                    width: 100%;
                }
                --pebble-button-right-icon: {
                    margin-right: 5px;
                }
                --pebble-icon-color: {
                    fill: var(--palette-cerulean-two, #026bc3);
                }
            }
            .dimension-wrap{
                display: flex;
                justify-content: flex-end;
                flex: 1;
            }
            .widget-item-wrap{
                min-width: 100px;
                max-width: 50%;
            }
            pebble-button{
                width:100%;
                --paper-button-text:{
                    max-width:100%;
                }
            }
            .buttonContainer-static pebble-button{
                width:auto;
            }
        </style>
        <div class="dimension-wrap">
            <template is="dom-repeat" items="[[_contextToBeRendered]]" as="ctx">
                <div id="[[ctx.id]]" hidden$="[[ctx.hidden]]" class="widget-item-wrap">
                    <div>
                        <pebble-button id="[[ctx.id]]-toggle-button" popover="[[ctx.id]]-popover" lov="[[ctx.id]]-lov" icon="[[ctx.icon]]" button-text="[[ctx.title]]"
                            class="dropdownText dropdownIcon btn dropdown tooltip-bottom" noink raised no-overlap vertical-offset="-211"
                            horizontal-offset="11" dropdown-icon on-tap="_onToggleButtonTap" disabled$="[[ctx.readonly]]">
                        </pebble-button>
                    </div>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity')]]">
                        <template is="dom-if" if="[[!_isDialogType(ctx.displayType)]]">
                            <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                                <rock-entity-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly=[[readonly]] config-data-item-id="[[ctx.id]]" id-field="[[ctx.dataMappings.id]]"
                                    title-pattern="[[ctx.dataMappings.title]]" request-data="[[ctx.dataRequest]]" selected-items="[[_getSelectedItems(ctx.selectedItem, _contextToBeRendered)]]"
                                    selected-item="[[_getSelectedItem(ctx.selectedItem, _contextToBeRendered)]]" external-data-formatter="[[_entityExternalDataFormatter]]"
                                    type-field="[[ctx.dataMappings.type]]" sort-field="[[ctx.dataMappings.sort]]" multi-select="[[!allSingleSelect]]"
                                    show-action-buttons></rock-entity-lov>
                            </pebble-popover>
                            <bedrock-pubsub event-name="entity-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                            <bedrock-pubsub event-name="entity-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        </template>
                        <template is="dom-if" if="[[_isDialogType(ctx.displayType)]]">
                            <pebble-dialog id="[[ctx.id]]-popover" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                                <div id="classificationContent" style="height:85vh">
                                    <div id="categoryTreeContainer" title="[[ctx.title]]" class="button-siblings">
                                        <rock-classification-tree id="[[ctx.id]]-contextTree" taxonomy="[[_getClassificationTaxonomy(ctx.selectedItemInfo.taxonomy, classificationTaxonomy)]]"
                                            context-data="[[contextData]]" multi-select="[[!allSingleSelect]]"></rock-classification-tree>
                                    </div>
                                    <div id="exportActions" class="buttonContainer-static" align="center">
                                        <pebble-button class="btn btn-secondary m-r-5" id="cancel" button-text="Cancel" raised on-tap="_onCancelClassificationSelection"></pebble-button>
                                        <pebble-button class="btn btn-success" id="download" button-text="Select" raised on-tap="_selectClassification"></pebble-button>
                                    </div>
                                </div>
                            </pebble-dialog>
                        </template>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-context')]]">
                        <template is="dom-if" if="[[!_isDialogType(ctx.displayType)]]">
                            <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                                <rock-context-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly=[[readonly]] data-object-type="[[ctx.dataObjectType]]" entity-id="[[entityId]]"
                                    entity-type="[[entityType]]" context-name="[[ctx.id]]" config-data-item-id="[[ctx.id]]" request-data="[[ctx.dataRequest]]"
                                    selected-items="[[_getSelectedItems(ctx.selectedItem, _contextToBeRendered)]]" selected-item="[[_getSelectedItem(ctx.selectedItem, _contextToBeRendered)]]"
                                    external-data-formatter="[[_entityContextExternalDataFormatter]]" selected-item-info=[[ctx.selectedItemInfo]]
                                    multi-select="[[!allSingleSelect]]" show-action-buttons></rock-context-lov>
                            </pebble-popover>
                        </template>
                        <template is="dom-if" if="[[_isDialogType(ctx.displayType)]]">
                            <pebble-dialog id="[[ctx.id]]-popover" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                                <div id="classificationContent" style="height:85vh">
                                    <div id="categoryTreeContainer" title="[[ctx.title]]" class="button-siblings">
                                        <rock-classification-tree id="[[ctx.id]]-contextTree" taxonomy="[[_getClassificationTaxonomy(ctx.selectedItemInfo.taxonomy, classificationTaxonomy)]]"
                                            context-data="[[contextData]]" multi-select="[[!allSingleSelect]]" disable-child-node="[[disableChildNode]]"></rock-classification-tree>
                                    </div>
                                    <div id="exportActions" class="buttonContainer-static" align="center">
                                        <pebble-button class="btn btn-secondary m-r-5" id="cancel" button-text="Cancel" raised on-tap="_onCancelClassificationSelection"></pebble-button>
                                        <pebble-button class="btn btn-success" id="download" button-text="Select" raised on-tap="_selectClassification"></pebble-button>
                                    </div>
                                </div>
                            </pebble-dialog>
                        </template>
                        <bedrock-pubsub event-name="context-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-selected-info-applied" handler="_onContextLovSelectedInfoApplied" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-model')]]">
                        <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                            <rock-entity-model-lov id="[[ctx.id]]-lov" readonly=[[readonly]] config-data-item-id="[[ctx.id]]" id-field="[[ctx.dataMappings.id]]"
                                title-pattern="[[ctx.dataMappings.title]]" type-field="[[ctx.dataMappings.type]]" request-data="[[ctx.dataRequest]]"
                                selected-items="[[_getSelectedItems(ctx.selectedItem)]]" multi-select="[[!allSingleSelect]]"
                                no-sub-title show-action-buttons></rock-entity-model-lov>
                        </pebble-popover>
                        <bedrock-pubsub event-name="entity-model-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="entity-model-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                </div>
            </template>
        </div>
        <pebble-dialog id="confirmation-dialog" dialog-title="Confirmation" modal alert-box show-cancel show-ok no-cancel-on-outside-click
            no-cancel-on-esc-key>
            <p>[[confirmationMessage]]</p>
        </pebble-dialog>
        <bedrock-pubsub event-name="refresh-dimension-selector" handler="refresh"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-buttonok-clicked" handler="_onTapConfirmationOK" target-id="confirmation-dialog"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-buttoncancel-clicked" handler="_onTapConfirmationCancel" target-id="confirmation-dialog"></bedrock-pubsub>
        <liquid-rest id="contextModelGet" url="/data/pass-through/entitymodelservice/getcontext" method="POST" request-data="{{_contextModelGetReq}}"
            on-liquid-response="_onContextModelGetResponse" on-liquid-error="_onContextModelGetFailed"></liquid-rest>
        <liquid-rest id="entityModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_entityModelRequest}}"
            on-liquid-response="_onEntityModelGetResponse" on-liquid-error="_onEntityModelGetError"></liquid-rest>
        <liquid-rest id="entityContextGet" url="/data/pass-through/entityservice/getcontext" method="POST" request-data="{{_entityContextRequest}}"
            on-liquid-response="_onEntityContextGetResponse" on-liquid-error="_onEntityContextGetError" exclude-in-progress>
        <liquid-rest id="preselectedContextGet"  url="/data/pass-through/entityservice/get" method="POST" request-data="{{_preselectedContextRequest}}" 
            on-liquid-response="_onPreselectedContextGetResponse" on-liquid-error="_onPreselectedContextGetGetError" exclude-in-progress></liquid-entity-data-get>
        </liquid-rest>
    </template>
    <script>
         class RockDimensionSelector extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior,RUFBehaviors.ComponentConfigBehavior],Polymer.OptionalMutableData(Polymer.Element)){
            static get is() {
                return "rock-dimension-selector";
            }
            static get properties() {
                return {
                    /**
                     * Indicates the app name
                     */
                    appName: {
                        type: String,
                        value: ""
                    },

                    domain: {
                        type: String,
                        value: ""
                    },

                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the list of items which you must place in the dimension selector component.
                     */
                    configData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                    * If set as true , it indicates the component is in read only mode
                    */
                    readonly: {
                        type: Boolean,
                        value: false
                    },

                    /**
                    * Indicates the selected values of all dimensions in the dimension selector.
                    */
                    selectedDimensions: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                    * <b><i>Content development is under progress... </b></i>
                    */
                    allMultiSelect: {
                        type: Boolean,
                        value: false
                    },
                    allSingleSelect: {
                        type: Boolean,
                        value: false
                    },
                    entityId: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    entityType: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    horizontalAlign: {
                        type: String,
                        value: "right"
                    },
                    classificationTaxonomy: {
                        type: String,
                        value: ""
                    },
                    hideContexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    components: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    dynamicDimensionsConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    confirmationMessage: {
                        type: String,
                        value: "Do you want to update selection?"
                    },
                    showConfirmation: {
                        type: Boolean,
                        value: false
                    },
                    _default: {
                        type: Array,
                        value: [{
                            "id": "default",
                            "title": "default",
                            "type": "default"
                        }]
                    },
                    _contextModelGetReq: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _contexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _isDynamic: {
                        type: Boolean,
                        value: false
                    },
                    _contextToBeRendered: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _parsedContexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _entityModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _contextHierarchy: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _entityContextRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _entityContexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _currentContexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _previousRootCtxValue: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _isConfigLoaded: {
                        type: Boolean,
                        value: false
                    },
                    _isContextLoad: {
                        type: Boolean,
                        value: false
                    },
                    _currentDimensionSelector: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    selectedDimensionsDetail: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return {};
                        },
                        observer: "selectedDimensionsDetailChanged"
                    },
                    _selectedClassificationsConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    disableChildNode: {
                        type: Boolean,
                        value: false
                    },
                    _preselectedContextRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    navigationData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    dimensionSelectorRefresh : {
                        type: Boolean,
                        value: false
                    }
                }
            }
            static get observers(){
                return [
                '_configChanged(configData, entityType, domain)',
                '_prepareContext(appName, domain, entityType)'
                ]
            }
            selectedDimensionsDetailChanged(dimensionData) {
                let _contextToBeRendered = this._contextToBeRendered;
                if (!_.isEmpty(dimensionData)) {
                    _contextToBeRendered.forEach(element => {
                        if (!_.isEmpty(element)) {
                            let itemId = this._getItemId(element);
                            if (!_.isEmpty(dimensionData[itemId])) {
                                if (itemId === "classification") {
                                    element.selectedItem.classifications = [dimensionData[itemId][0].classification];
                                    element.selectedItem.path = dimensionData[itemId][0].path;
                                } else {
                                    let selectedItem = {
                                        "id": dimensionData[itemId][0].id,
                                        "title": dimensionData[itemId][0].title,
                                        "type": dimensionData[itemId][0].type
                                    }
                                    element.selectedItem = selectedItem;
                                }
                            }
                        }
                    });
                    this._contextToBeRendered = [];
                    this.set("_contextToBeRendered", _contextToBeRendered);
                    this._updateSelectedDimensions();
                }
            }

            async onConfigLoaded(componentConfig) {
                if (componentConfig && componentConfig.config) {
                    let configData = DataHelper.convertObjectToArray(componentConfig.config);

                    if (!_.isEmpty(this.dynamicDimensionsConfig)) {
                        configData = this._prepareConfigForDynamicDimensions(configData);
                    }
                    let localeManager = ComponentHelper.getLocaleManager();
                    let defaultLocale = DataHelper.getDefaultValContext();
                    if (defaultLocale && defaultLocale.locale) {
                        await localeManager.getByNameAsync(defaultLocale.locale);
                    }
                    this.configData = {};
                    this.set('configData', configData);
                } else {
                    this.logError(this.appName + "-Dimension Selector - config is not available for rock-dimension-selector", componentConfig, true);
                }
            }

            get confirmationDialog() {
                this._confirmationDialog = this._confirmationDialog || this.shadowRoot.querySelector("#confirmation-dialog");
                return this._confirmationDialog;
            }

            getDimensionSelectorConfig() {
                return this.configData;
            }
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            refresh() {
                this._createContextGetRequest(this.entityId, this.entityType);
            }

            refreshDimensionData() {
                if (typeof (this.configData) !== "undefined") {
                    for (let i = 0; i < this.configData.length; i++) {
                        let configDataItem = this.configData[i];
                        let rockLov = undefined;
                        let lovContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                        if (lovContainer) {
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                                rockLov = lovContainer.querySelector("rock-entity-lov");
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                                rockLov = lovContainer.querySelector("rock-context-lov");
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                                rockLov = lovContainer.querySelector("rock-entity-model-lov");
                            }

                            if (rockLov) {
                                rockLov.reset();
                            }
                        }
                    }
                }
            }
            _createContextGetRequest(entityId, entityType) {
                if (!_.isEmpty(entityId)) {
                    this._entityContextRequest = DataRequestHelper.createEntityContextGetRequest(entityId, entityType);
                    let liquidElement = this.$$('#entityContextGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    } else {
                        this.logError(this.appName + "-Dimension Selector - Liquid for entity context get is not found");
                    }
                }
            }
            clearClassificationSelection() {
                if (typeof (this.configData) !== "undefined") {
                    for (let i = 0; i < this.configData.length; i++) {
                        let configDataItem = this.configData[i];
                        let rockClassification = undefined;
                        let rockContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                        if (rockContainer) {
                            if (configDataItem.dataMappings.type.indexOf("classification") != -1) {
                                rockClassification = rockContainer.querySelector("rock-classification-tree");
                            }

                            if (rockClassification) {
                                rockClassification.selectedClassifications = [];
                                this.selectedDimensions["classification"] = [];
                                let currentDimensionButtonId = rockClassification.id.replace("-contextTree", "-toggle-button");
                                let currentButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                                if (currentButton) {
                                    currentButton.buttonText = rockClassification.parentElement.title;
                                    currentButton.setAttribute("data-tooltip", rockClassification.parentElement.title);
                                }
                            }
                        }
                    }
                }
            }

            _configChanged(configData, entityType, domain) {
                this.entityType = entityType;
                if (configData && configData.length) {
                    if (!this._isContextLoad) {
                        configData.forEach(function (item) {
                            if (item && item.useContextModel) {
                                this._isContextLoad = true;
                            }
                        }, this);
                    }

                    if (this._isContextLoad) {
                        if (!_.isEmpty(entityType)) {
                            this._entityTypeChanged(entityType);
                        } else if (domain) {
                            this._domainChanged(domain);
                        }
                    } else {
                        this._loadConfigBasedDimensions();
                    }
                }
            }
            
            disconnectedCallback() {
                super.disconnectedCallback();
                this.dimensionSelectorRefresh = false;
            }
            connectedCallback() {
                super.connectedCallback();  
                this.dimensionSelectorRefresh = true; 
            }

            _prepareContext() {

                let context = DataHelper.cloneObject(this.contextData);

                if (!_.isEmpty(this.entityType)) {
                    context[ContextHelper.CONTEXT_TYPE_ITEM] = [{
                        "type": this.entityType
                    }];
                }

                if (!_.isEmpty(this.appName) && !_.isEmpty(this.domain)) {
                    context[ContextHelper.CONTEXT_TYPE_APP] = [{
                        "app": this.appName
                    }];

                    context[ContextHelper.CONTEXT_TYPE_DOMAIN] = [{
                        "domain": this.domain
                    }];

                    if (!_.isEmpty(context)) {
                        this.requestConfig('rock-dimension-selector', context);
                    }
                }
            }

            _prepareConfigForDynamicDimensions(configData) {
                if (this.dynamicDimensionsConfig) {
                    let selectedDimensions = this.dynamicDimensionsConfig.selectedDimensions;
                    let readonlyDimensions = this.dynamicDimensionsConfig.readonlyDimensions;
                    let contextDimensions = this.dynamicDimensionsConfig.contextDimensions;

                    for (let i = 0; i < configData.length; i++) {
                        if (configData[i].dataMappings && configData[i].dataMappings.type &&
                            configData[i].dataMappings.type.length) {
                            //Attribute mappings selected dimensions
                            if (selectedDimensions) {
                                let selectedDimension = selectedDimensions[configData[i].dataMappings.type[0]];
                                if (!_.isEmpty(selectedDimension)) {
                                    if (configData[i].displayType != "dialog") {
                                        configData[i].selectedItem = {
                                            "id": selectedDimension[0],
                                            "title": selectedDimension[0],
                                            "type": configData[i].dataMappings.type[0]
                                        }
                                    } else {
                                        let selectedClassificationsConfig = {
                                            "classifications": [selectedDimension[0].split(">>")],
                                            "path": selectedDimension[0]
                                        };
                                        this._selectedClassificationsConfig[configData[i].id] = configData[i].selectedItem = selectedClassificationsConfig;
                                    }
                                }
                            }

                            //Readonly dimensions
                            if (readonlyDimensions.indexOf(configData[i].dataMappings.type[0]) != -1) {
                                configData[i].readonly = true;
                            }
                        }
                    }

                    //Additional dimensions
                    if (contextDimensions) {
                        for (let i = 0; i < contextDimensions.length; i++) {
                            configData.push(this._prepareDimensionTemplate(contextDimensions[i]));
                        }
                    }
                }

                return configData
            }

            _prepareDimensionTemplate(dimension) {
                return {
                    "id": dimension,
                    "title": dimension,
                    "icon": "pebble-icon:hierarchy",
                    "visible": true,
                    "hidden": false,
                    "dimensionType": "data",
                    "dataRequestType": "entity",
                    "dataMappings": {
                        "id": "name",
                        "title": "name",
                        "subtitle": "",
                        "image": "",
                        "icon": "",
                        "type": [
                            dimension
                        ]
                    },
                    "default": ""
                }
            }

            _compareRequestType(dataRequestType, entityTypeInfo) {
                return dataRequestType === entityTypeInfo;
            }

            _getSelectedItems(selectedItem) {
                // Todo.. This is not a correct code lov must support selectedid

                if (!_.isEmpty(selectedItem)) {
                    let formattedSelectedItems = [];
                    let formattedSelectedItem = {};

                    formattedSelectedItem["id"] = selectedItem.id ? selectedItem.id : this._default.id;
                    formattedSelectedItem["title"] = selectedItem.title ? selectedItem.title : this._default.title;
                    formattedSelectedItem["type"] = selectedItem.type ? selectedItem.type : this._default.type;
                    if(selectedItem.relTo) {
                        formattedSelectedItem["relTo"] = selectedItem.relTo;
                    }

                    if (selectedItem.type == "locale") {
                        let _localeObj = ComponentHelper.getLocaleManager().getByName(selectedItem.id);
                        if (!_.isEmpty(_localeObj) && _localeObj.externalName) {
                            formattedSelectedItem["title"] = _localeObj.externalName;
                        }
                    }

                    formattedSelectedItems.push(formattedSelectedItem);

                    return formattedSelectedItems
                }
            }

            _getSelectedItem(selectedItem) {
                if (this.allSingleSelect) {
                    let selectedItems = this._getSelectedItems(selectedItem);
                    if (!_.isEmpty(selectedItems)) {
                        return selectedItems[0];
                    }
                }

                return {};
            }

            _onToggleButtonTap(event) {
                if (typeof (event.currentTarget) !== "undefined") {
                    if (event.currentTarget.disabled == true) {
                        return;
                    }
                    this._currentDimensionSelector = event.currentTarget;
                    if (event.model.ctx.displayType != "dialog") {
                        this._toggleLovPopover(this._currentDimensionSelector.popover);
                    } else {
                        if (!this.classificationTaxonomy && event.model.ctx.displayType == "dialog") {
                            this.showWarningToast("No classification available. Select taxonomy.");
                            return;
                        }
                        this._classificationDialogOpen();
                    }
                }
            }

            _onEntityLovConfirmButtonTapped(event) {
                this._isClassificationSelectionTriggered = false;
                this._currentLovEvent = event;
                if (this.showConfirmation) {
                    if (this.confirmationDialog) {
                        this.confirmationDialog.open();
                    }
                    return;
                }
                this._triggerLovConfirmButtonTapped();
            }

            _triggerLovConfirmButtonTapped(togglePopover = true) {
                if (!this.allMultiSelect) {
                    let currentLovId = this._currentLovEvent.detail.data.id;
                    let currentRockLov = this.shadowRoot.querySelector("#" + currentLovId);
                    let switchToMultiSelect = true;

                    if (currentRockLov.multiSelect) {
                        if (currentRockLov.selectedItems.length > 1) {
                            switchToMultiSelect = !currentRockLov.multiSelect;
                        }

                        for (let i = 0; i < this._contextToBeRendered.length; i++) {
                            let configDataItem = this._contextToBeRendered[i];
                            let rockLov = undefined;
                            let lovContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                            if(lovContainer) {
                                if (configDataItem.dataRequestType == "entity") {
                                    rockLov = lovContainer.querySelector("rock-entity-lov");
                                }
                                if (configDataItem.dataRequestType == "entity-context") {
                                    rockLov = lovContainer.querySelector("rock-context-lov");
                                }

                                if (configDataItem.dataRequestType == "entity-model") {
                                    rockLov = lovContainer.querySelector("rock-entity-model-lov");
                                }
                            }

                            if (typeof (rockLov) !== "undefined" && rockLov && rockLov.id !== currentLovId && rockLov.multiSelect !== switchToMultiSelect && (typeof (configDataItem.multiSelect) == "undefined" || configDataItem.multiSelect)) {
                                this._toggleLovSelectionMode(rockLov, switchToMultiSelect);
                            }
                        }
                    }
                }

                this._updateSelectedDimensions();
                if (togglePopover) {
                    this._toggleLovPopover(this._currentDimensionSelector.popover);
                }
            }

            _onContextLovSelectedInfoApplied() {
                this._setSelectedDimensions();
            }

            _toggleLovSelectionMode(rockLov, switchToMultiSelect) {
                if (switchToMultiSelect) {
                    let selectedItem = rockLov.selectedItem;
                    rockLov.multiSelect = switchToMultiSelect;

                    if (typeof (selectedItem) !== "undefined" && !_.isEmpty(selectedItem)) {
                        rockLov.push("selectedItems", selectedItem);
                    }

                    rockLov.refershTemplate();
                } else {
                    let selectedItems = rockLov.selectedItems
                    rockLov.multiSelect = switchToMultiSelect;

                    if (typeof (selectedItems) !== "undefined" && selectedItems.length > 0) {
                        rockLov.selectedItem = selectedItems[0];
                    } else {
                        rockLov.selectedItem = {};
                    }

                    rockLov.refershTemplate();
                }
            }

            _onEntityLovCloseButtonTapped() {
                this._toggleLovPopover(this._currentDimensionSelector.popover);
            }

            _toggleLovPopover(popoverId) {
                let currentPopover = this.shadowRoot.querySelector("#" + popoverId);
                if (!_.isEmpty(currentPopover)) {
                    if (!currentPopover.opened) {
                        currentPopover.show();
                    } else {
                        currentPopover.hide();
                    }
                }
            }

            _updateToggleButtonText(configDataItem, rockLov) {
                let buttonContainer = this.shadowRoot.querySelector("#" + configDataItem.id);
                let toggleButton;
                if(buttonContainer) {
                    toggleButton = buttonContainer.querySelector("pebble-button");
                }
                let buttonText = configDataItem.title;

                if (!rockLov.multiSelect) {
                    // Ask Jimmy.... What should be label field for selected dimension
                    buttonText = rockLov.selectedItem.id
                } else {
                    buttonText = rockLov.selectedItems.length + "" + configDataItem.title + "s " +
                        "Selected";
                }

                if(toggleButton) {
                    toggleButton.buttonText = buttonText;
                }
            }

            _getSelectedItemsInfo(dimensionSelector) {
                let dimensionSelectedItem;
                let dimensionSelectedItems = [];

                if (dimensionSelector.lov.multiSelect) {
                    if (dimensionSelector.lov.selectedItems.length > 0) {
                        dimensionSelectedItem = dimensionSelector.lov.selectedItems[0];
                        dimensionSelectedItems = dimensionSelector.lov.selectedItems;
                    }
                } else {
                    if (dimensionSelector.lov.selectedItem) {
                        dimensionSelectedItems.push(dimensionSelector.lov.selectedItem);
                        dimensionSelectedItem = dimensionSelector.lov.selectedItem;
                    }
                }

                return {
                    multiSelect: dimensionSelector.lov.multiSelect,
                    selectedItem: dimensionSelectedItem,
                    selectedItems: dimensionSelectedItems,
                }
            }

            _getSelectedValue(data, selectedItems) {
                if (data != undefined && data != null) {
                    for (let i = 0; i < data.length; i++) {
                        if (this._indexOfItem(selectedItems, data[i])) {
                            return data[i].value;
                        }
                    }
                }
            }

            _indexOfItem(selectedItems, selectedItemToCompare) {
                let isSelected = false;

                selectedItems.forEach(function (item) {
                    if (item.id == selectedItemToCompare.id) {
                        isSelected = true;
                    }
                }, this);

                return isSelected;
            }

            _setSelectedDimension() {
                this.selectedDimensions = undefined;
                this.selectedDimensions = {
                    "lists": this.listSelector.selectedItems,
                    "sources": this.sourceSelector.selectedItems,
                    "locales": this.localeSelector.selectedItems
                };
            }

            _getItemsIdsByType(items, type) {
                let itemsIds = [];
                if (items) {
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type === type) {
                            let itemId = this._getItemId(items[i]);
                            if (!_.isEmpty(itemId)) {
                                itemsIds.push(itemId);
                            }
                        }
                    }
                }
                return itemsIds;
            }

            _getItemId(item) {
                if (item) {
                    let itemId = this.get("id", item);

                    if (itemId === undefined || itemId === null) {
                        itemId = ""; // Could be -1 or ""?
                    }

                    return itemId;
                }
            }

            _getClassificationValuePath(classification) {
                let valuePath = "";
                if (classification && classification.valuePath) {
                    let categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                    valuePath = classification.valuePath.replace(/#@#/g, categoryPathSeperator);
                }

                return valuePath;
            }

            _setClassificationTitle(currentClassification) {
                if (!currentClassification) {
                    return;
                }

                let currentDimensionButtonId = currentClassification.id.replace("-contextTree", "-toggle-button");
                let buttonText = "";
                let toolTip = "";
                if (!_.isEmpty(currentClassification.selectedClassifications)) {
                    for (let i = 0; i < currentClassification.selectedClassifications.length; i++) {
                        let valuePath = this._getClassificationValuePath(currentClassification.selectedClassifications[i]);
                        if (buttonText) {
                            buttonText = buttonText + ", " + valuePath;
                        } else {
                            buttonText = valuePath;
                        }
                    }
                    toolTip = buttonText; //Set tooltip
                    if (!buttonText) {
                        let configClassificationId = currentClassification.id.replace("-contextTree", "");
                        if (this._selectedClassificationsConfig[configClassificationId]) {
                            buttonText = toolTip = this._selectedClassificationsConfig[configClassificationId].path;
                        } else {
                            buttonText = toolTip = currentClassification.parentElement.title;
                        }
                    }
                    if (currentClassification.selectedClassifications.length > 1) {
                        buttonText = currentClassification.selectedClassifications.length + " " + buttonText;
                    }
                    let currentButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                    if (currentButton) {
                        currentButton.buttonText = buttonText;
                        currentButton.setAttribute("data-tooltip", toolTip);
                    }
                }
            }

            _isDialogType(displayType) {
                if (displayType == "dialog") {
                    return true;
                }

                return false;
            }

            _classificationDialogOpen() {
                let classificationDialog = this.shadowRoot.querySelector("#" + this._currentDimensionSelector.popover);
                let currentValuePath = "";
                let selectedClassifications = [];

                let currentContextId = this._currentDimensionSelector.id.replace("-toggle-button", "-contextTree");
                let contextTree = this.shadowRoot.querySelector("#" + currentContextId);
                //selectedClassifications = this._getPathsForClassificationTree(contextTree.selectedClassifications);
                if (this.selectedDimensions && this.selectedDimensions["classification"] && this.selectedDimensions["classification"].length) {
                    selectedClassifications = [this.selectedDimensions["classification"][0].split(">>")];
                }
                //If refresh needs every time on dialog open, then remove >> selectedClassifications.length == 0
                if (contextTree) {
                    let configClassificationId = this._currentDimensionSelector.id.replace("-toggle-button", "");
                    if (this._selectedClassificationsConfig[configClassificationId]) {
                        selectedClassifications = this._selectedClassificationsConfig[configClassificationId].classifications;
                    }
                    contextTree.selectedClassifications = selectedClassifications;
                    contextTree.generateRequest();
                }

                if (classificationDialog) {
                    classificationDialog.dialogTitle = "Select Classification";
                    classificationDialog.open();
                }
            }

            _getPathsForClassificationTree(selectedClassifications) {
                let classificationPaths = [];
                let valuePathSeperator = "#@#";
                if (!_.isEmpty(selectedClassifications)) {
                    for (let i = 0; i < selectedClassifications.length; i++) {
                        if (selectedClassifications[i] && selectedClassifications[i].valuePath) {
                            let paths = selectedClassifications[i].valuePath.split(valuePathSeperator)
                            classificationPaths.push(paths);
                        }
                    }
                }

                return classificationPaths;
            }

            _onCancelClassificationSelection() {
                let classificationDialog = this.shadowRoot.querySelector("#" + this._currentDimensionSelector.popover);
                if (classificationDialog) {
                    classificationDialog.close();
                }
            }

            _selectClassification(e) {
                this._isClassificationSelectionTriggered = true;
                if (this.showClassificationConfirmation) {
                    if (this.confirmationDialog) {
                        this.confirmationDialog.open();
                    }
                    return;
                }
                this._triggerClassificationChange();
            }

            _onTapConfirmationOK(event) {
                if (this._isClassificationSelectionTriggered) {
                    this._triggerClassificationChange();
                } else {
                    this._triggerLovConfirmButtonTapped(false);
                }
                this.fireBedrockEvent("dimension-selector-confirmation-ok", event);
            }

            _onTapConfirmationCancel(event) {
                if (this._isClassificationSelectionTriggered) {
                    this._onCancelClassificationSelection();
                }

                this.fireBedrockEvent("dimension-selector-confirmation-cancel", event);
            }

            _triggerClassificationChange() {
                let currentContextId = this._currentDimensionSelector.id.replace("-toggle-button", "-contextTree");
                let contextTree = this.$$("#" + currentContextId);
                if (contextTree) {
                    if (contextTree.selectedClassifications && contextTree.selectedClassifications.length > 0) {
                        this._updateSelectedDimensions();
                    }
                }
                this._onCancelClassificationSelection();
            }

            _getClassificationTaxonomy(configTaxonomy, taxonomy) {
                let selectedClassifications = this.selectedDimensions["classification"];
                this.clearClassificationSelection(); //Clear classification on taxonomy change
                if(!_.isEmpty(selectedClassifications)) {
                    this._updateSelectedDimensions();
                }
                if (taxonomy) {
                    return taxonomy
                }
                return configTaxonomy;
            }

            _entityTypeChanged(entityType) {
                if (!_.isEmpty(entityType)) {

                    this._contextModelGetReq = DataRequestHelper.createContextModelGetRequest(entityType);

                    let liquidElement = this.$$('#contextModelGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    } else {
                        this.logError(this.appName + "-Dimension Selector - Liquid for context model get is not found");
                    }
                    this._createContextGetRequest(this.entityId, entityType);
                }
            }

            _domainChanged(domain) {
                if (!_.isEmpty(domain)) {

                    this._contextModelGetReq = DataRequestHelper.createContextModelGetRequest(domain);

                    let liquidElement = this.$$('#contextModelGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    } else {
                        this.logError(this.appName + "-Dimension Selector - Liquid for context model get is not found");
                    }
                }
            }

            _onContextModelGetResponse(e) {
                let response = e.detail.response.response;

                if (response) {
                    let entityModels = response.entityModels;

                    if (!_.isEmpty(entityModels)) {
                        let entityModel = entityModels[0];
                        let contexts = "data" in entityModel ? entityModel.data.contexts : undefined;
                        let _ctxKeys = [];

                        let globalCoalescePath = DataHelper.isValidObjectPath(entityModel, "properties.globalCoalescePath") && entityModel.properties.globalCoalescePath;
                        this._contextHierarchyInfo = DataHelper.isValidObjectPath(entityModel, "properties.globalCoalesceInfo") && entityModel.properties.globalCoalesceInfo;

                        if (!_.isEmpty(globalCoalescePath)) {
                            this._contextHierarchy = globalCoalescePath.split(">>");
                        } else {
                            this.logError("Dimension Selector:- Global coalesce path is not defined in:" + entityModel.id, e.detail, true);
                        }

                        if (contexts) {
                            let _contexts = [];
                            contexts.forEach(function (context) {
                                _contexts.push(context.context);

                                let ctxKeys = Object.keys(context.context);
                                if (ctxKeys && ctxKeys.length) {
                                    ctxKeys.forEach(function (ctxKey) {
                                        if (_ctxKeys.indexOf(ctxKey) < 0) {
                                            _ctxKeys.push(ctxKey);
                                        }
                                    }, this);
                                }

                                if (context.properties && context.properties.dataCoalescePath) {
                                    let dataCoalescePath = context.properties.dataCoalescePath;
                                    let paths = dataCoalescePath.split(">>");

                                    for (let idx = 0; idx < this._contextHierarchyInfo.length; idx++) {
                                        let ctxHeirarchy = this._contextHierarchyInfo[idx];
                                        let dataIdx = paths.indexOf(ctxHeirarchy.contextKey);
                                        if (dataIdx > 0 && !ctxHeirarchy.relTo) {
                                            let relName = paths[dataIdx - 1];
                                            let relType = relName && relName.indexOf("belongsto") > -1 ? relName.substring("belongsto".length, relName.length) : undefined;
                                            ctxHeirarchy.relTo = relType;
                                        }
                                    }
                                }
                            }, this);

                            this._contexts = _contexts;
                        }

                        let _ctxIds = [];
                        if (_ctxKeys && _ctxKeys.length) {
                            _ctxKeys.forEach(function (item) {
                                if (item) {
                                    _ctxIds.push(item);
                                }
                            }, this);
                        }

                        let ctxIds = [];
                        let missingContextModel = [];
                        if (this.configData && this.configData.length) {
                            this.configData.forEach(function (item) {
                                if (!item.useContextModel) {
                                    if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                                        let type = item.dataMappings.type[0];

                                        if (type) {
                                            if (item.dataRequestType != "entity-context") {
                                                ctxIds.push(type + "_entityManageModel");
                                            }

                                            if (this._contextHierarchy.indexOf(type) < 0) {
                                                this._contextHierarchy.push(type);
                                            }
                                        }
                                    }
                                } else if (item.useContextModel) {
                                    if (_ctxIds.indexOf(item.id) > -1) {
                                        if (item.dataRequestType != "entity-context") {
                                            ctxIds.push(item.id + "_entityManageModel");
                                        }
                                    } else {
                                        missingContextModel.push(item.id);
                                    }
                                }
                            }, this);
                        }

                        if (missingContextModel && missingContextModel.length) {
                            let message = "Dimension(s): " + missingContextModel.join(", ") + " are configured but not present in context model for entity type: " + this.entityType;
                            this.logError(message, e.detail);
                        }

                        if (ctxIds && ctxIds.length) {
                            this._entityModelRequest = {
                                "params": {
                                    "query": {
                                        "ids": ctxIds,
                                        "filters": {
                                            "typesCriterion": [
                                                "entityManageModel"
                                            ]
                                        }
                                    },
                                    "fields": {
                                        "attributes": [
                                            "_ALL"
                                        ],
                                        "relationships": [
                                            "_ALL"
                                        ],
                                        "relationshipAttributes": [
                                            "_ALL"
                                        ]
                                    }
                                }
                            };

                            let entityModelGetComponent = this.$$("#entityModelGet");

                            if (entityModelGetComponent) {
                                entityModelGetComponent.generateRequest();
                            } else {
                                this.logError(this.appName + "-Dimension Selector - Entity model get liquid not found");
                            }
                        }
                    } else {
                        this.logError(this.appName + "-Dimension Selector - There are no context models available", e.detail);
                    }
                } else {
                    this.logError(this.appName + "-Dimension Selector - There is some problem with contextModel get response", e.detail);
                }
            }

            _onContextModelGetFailed(e) {
                this.logError(this.appName + "-Dimension Selector - contextModel get exception", e.detail);
            }

            _loadConfigBasedDimensions() {
                let ctxIds = [];
                if (this.configData && this.configData.length) {
                    this.configData.forEach(function (item) {
                        if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                            let type = item.dataMappings.type[0];

                            if (type) {
                                if (item.dataRequestType != "entity-context") {
                                    ctxIds.push(type + "_entityManageModel");
                                }

                                if (this._contextHierarchy.indexOf(type) < 0) {
                                    this._contextHierarchy.push(type);
                                }
                            }
                        }
                    }, this);
                }

                if (ctxIds && ctxIds.length) {
                    this._entityModelRequest = {
                        "params": {
                            "query": {
                                "ids": ctxIds,
                                "filters": {
                                    "typesCriterion": [
                                        "entityManageModel"
                                    ]
                                }
                            },
                            "fields": {
                                "attributes": [
                                    "_ALL"
                                ]
                            }
                        }
                    };

                    let entityModelGetComponent = this.$$("#entityModelGet");

                    if (entityModelGetComponent) {
                        entityModelGetComponent.generateRequest();
                    }
                }
            }

            _onEntityModelGetResponse(e) {
                let response = e.detail.response.response;
                if (response && !_.isEmpty(response.entityModels)) {
                    this._prepareDynamicConfigBasedOnModelForContextsToBeRendered(response.entityModels);
                } else {
                    this.logError(this.appName + "-Dimension Selector - Entity Model get response exception", e.detail, true);
                }
            }

            _onEntityModelGetError(e) {
                this.logError(this.appName + "-Dimension Selector - Entity Model get exception", e.detail, true);
            }

            _prepareDynamicConfigBasedOnModelForContextsToBeRendered(entityModels) {
                if (entityModels && entityModels.length) {
                    let ctxs = {};
                    entityModels.forEach(function (entityModel) {
                        let ctxKey = entityModel.name;
                        let reqData = {
                            "params": {
                                "query": {
                                    "filters": {
                                        "typesCriterion": [
                                            ctxKey
                                        ]
                                    },
                                    "valueContexts": []
                                },
                                "fields": {
                                    "attributes": ['_ALL']
                                }
                            }
                        };

                        reqData.params.query.valueContexts.push(DataHelper.getDefaultValContext());

                        let ctxToBeLoaded = this._contextDataToBeLoaded(ctxKey);
                        let ctxExtName = ctxKey;
                        let externalAttrName = undefined;
                        let externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);

                        if (externalNameAndExternalNameAttr) {
                            externalAttrName = externalNameAndExternalNameAttr.externalNameAttr;
                            ctxExtName = !_.isEmpty(externalNameAndExternalNameAttr.externalName) ? externalNameAndExternalNameAttr.externalName : ctxKey;
                        } else {
                            this.logError(this.appName + "-Dimension Selector - None of the attributes in the model " + entityModel.id + " marked with 'isExternalName' flag", entityModel);
                        }

                        if (ctxToBeLoaded && ctxToBeLoaded.length && (ctxToBeLoaded.length == 1 && ctxToBeLoaded[0] != "_ALL")) {
                            let attributesCriterion = [];
                            if (externalAttrName) {
                                let attrCriterion = {};
                                attrCriterion[externalAttrName] = {
                                    "exacts": ctxToBeLoaded
                                }
                                attributesCriterion.push(attrCriterion);
                                reqData.params.query.filters.attributesCriterion = attributesCriterion;
                            }
                        }

                        let titlePattern = "{entity.attributes." + externalAttrName + "}";
                        let mappedValueContexts = this._getMappedValueContextsBasedOnCtxType(ctxKey);

                        if (mappedValueContexts) {
                            let dependentRelationships = mappedValueContexts.map(v => v.valueContextRelationship);

                            if (dependentRelationships) {
                                reqData.params.fields.relationships = dependentRelationships;
                                reqData.params.fields.relationshipAttributes = [this._getDefaultSelectedAttrName()];
                            }
                        }

                        ctxs[ctxKey] = {
                            "id": ctxKey,
                            "title": ctxExtName,
                            "ctxName": ctxKey,
                            "externalAttrName": externalAttrName,
                            "dataRequestType": "entity",
                            "dataRequest": reqData,
                            "mappedValueContexts": mappedValueContexts,
                            "dataMappings": {
                                "id": "name",
                                "title": titlePattern,
                                "type": [ctxKey]
                            }
                        };

                    }, this);

                    this._mergeConfigAndDynamicConfigForContextRender(ctxs);
                }
            }

            _mergeConfigAndDynamicConfigForContextRender(ctxs) {
                this.configData.forEach(function (item) {
                    if (item) {

                        let ctx = ctxs[item.id];

                        if (ctx) {
                            let mergedCtx = undefined;

                            if (item.dataRequestType == "entity-model" && "dataRequest" in ctx) {
                                delete ctx.dataRequest.params.query.valueContexts;
                            }

                            ctx = { "config": ctx };

                            // Deleting external dataMappings id and title coming from config
                            // Because assumption is for any entity-lov iExternalName attribute will be title of it.
                            if ("dataMappings" in item) {
                                delete item.dataMappings.title;
                            }

                            item = { "config": item };

                            mergedCtx = SharedUtils.DataObjectFalcorUtil.mergeObjectsNoOverride(ctx, item, true);

                            if (mergedCtx && mergedCtx.config) {
                                ctx = mergedCtx.config;
                            }
                        } else {
                            if (item.dimensionType == "data" && item.dataRequestType == "entity-context") {
                                ctx = item;
                                ctx.dataMappings = {
                                    "id": "name",
                                    "title": "name",
                                    "type": [
                                        item.id
                                    ]
                                }
                                ctxs[item.id] = ctx;
                            } else if (!this._isContextLoad) {
                                ctxs[item.id] = item;
                            }
                        }
                    }
                }, this);

                let parsedContexts = [];
                this._contextHierarchy.forEach(function (ctxKey) {
                    if (ctxs[ctxKey]) {
                        parsedContexts.push(ctxs[ctxKey]);
                    }
                }, this);

                if(this._checkPreselectedContextOnLoad(parsedContexts)) {
                    this._parsedContexts = parsedContexts;
                } else {
                    this._contextToBeRendered = undefined;
                    this._contextToBeRendered = parsedContexts;
                    this._updateSelectedDimensions();
                }
            }

            _checkPreselectedContextOnLoad(parsedContexts){
                if(parsedContexts && parsedContexts.length){
                    let firstContext = parsedContexts[0];
                    if(firstContext && firstContext.mappedValueContexts 
                        && firstContext.selectedItem && firstContext.selectedItem.title){
                        //generate request.
                        let firstContextRequest = DataHelper.cloneObject(firstContext.dataRequest);
                        firstContextRequest.params.query.name = firstContext.selectedItem.title;
                        delete firstContextRequest.params.query.filters.attributesCriterion;
                        firstContextRequest.params.query.filters.excludeNonContextual = true;
                        this.set("_preselectedContextRequest", firstContextRequest);
                        let preselectedContextGet = this.shadowRoot.querySelector("#preselectedContextGet")
                        if(preselectedContextGet){
                            preselectedContextGet.generateRequest();
                            return true;
                        }
                    }
                }

                return false;
            }

            _updateSelectedDimensions() {
                this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(100), () => {
                    this._setSelectedDimensions();
                    if (this._isContextLoad) {
                        this._updateCurrentContextState();
                    }
                    this.dimensionSelectorRefresh = false;
                });
            }

            _setSelectedDimensions() {
                //On page refresh set from navigationData
                let defaultDimensions = [];
                if(this.dimensionSelectorRefresh) {
                    if(!_.isEmpty(this.navigationData)){
                        defaultDimensions = this.navigationData;                       
                    }                   
                }

                let selectedDimensions = {};
                let configData = this._contextToBeRendered;
                let _taxonomyTitle = "";
                let _isPrimaryContext = false;
                if (typeof (configData) !== "undefined") {
                    for (let i = 0; i < configData.length; i++) {
                        let configDataItem = configData[i];
                        let rockLov = undefined;
                        let rockClassification = undefined;
                        let rockContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                        if (rockContainer) {
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                                if (configDataItem.displayType != "dialog") {
                                    rockLov = rockContainer.querySelector("rock-entity-lov");
                                } else {
                                    rockClassification = rockContainer.querySelector("rock-classification-tree");
                                }
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                                if (configDataItem.displayType != "dialog") {
                                    rockLov = rockContainer.querySelector("rock-context-lov");
                                } else {
                                    rockClassification = rockContainer.querySelector("rock-classification-tree");
                                }
                            }

                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                                rockLov = rockContainer.querySelector("rock-entity-model-lov");
                            }

                            if (rockLov || rockClassification) { //typeof (rockLov) !== "undefined"
                                const { dataMappings } = configDataItem;
                                let entityTypes = dataMappings && dataMappings.type;

                                if (entityTypes) {
                                    for (let j = 0; j < entityTypes.length; j++) {
                                        if (configDataItem.displayType != "dialog") {
                                            let ctxKey = !_.isEmpty(configDataItem.contextKeyName) ? configDataItem.contextKeyName : entityTypes[j];
                                            if (!rockLov.multiSelect) {
                                                if(!_.isEmpty(defaultDimensions) && defaultDimensions[ctxKey]){
                                                    if(defaultDimensions[ctxKey].length > 1){
                                                        rockLov.selectedItems = defaultDimensions[ctxKey][0];
                                                    } else {
                                                        rockLov.selectedItem = defaultDimensions[ctxKey][0];
                                                    }
                                                }
                                                let selectedItem = !_.isEmpty(rockLov.selectedItem) ? rockLov.selectedItem : undefined;
                                                let selectedItems = !_.isEmpty(rockLov.selectedItems) ? rockLov.selectedItems : undefined;
                                                if (selectedItems) {
                                                    rockLov.selectedItem = selectedItem ? selectedItem : selectedItems[0];
                                                }
                                                if (entityTypes[j] === "taxonomy") {
                                                    if (rockLov.selectedItem) {
                                                        _taxonomyTitle = rockLov.selectedItem.title;
                                                        if(rockLov.selectedItem.value) {
                                                            this.classificationTaxonomy = rockLov.selectedItem.value;
                                                        }
                                                    } else {
                                                        this.classificationTaxonomy = "";
                                                    }
                                                }
                                                if (this._compareRequestType(configDataItem.dataRequestType, 'entity') && !_.isEmpty(rockLov.selectedItem) && configDataItem.ctxName != "locale" && configDataItem.ctxName != "source") {
                                                    _isPrimaryContext = true;
                                                }

                                                let itemId = this._getItemId(rockLov.selectedItem);
                                                selectedDimensions[ctxKey] = itemId ? [itemId] : [];
                                                this.selectedDimensionsDetail[ctxKey] = !_.isEmpty(rockLov.selectedItem) ? [rockLov.selectedItem] : [];
                                            } else {
                                                //Set from navigationData
                                                if(!_.isEmpty(defaultDimensions) && defaultDimensions[ctxKey] && !_.isEmpty(defaultDimensions[ctxKey])){
                                                    rockLov.selectedItems = this._getDefaultSelectedItems(ctxKey,defaultDimensions,rockLov.selectedItems);
                                                }
                                                selectedDimensions[ctxKey] = this._getItemsIdsByType(
                                                    rockLov.selectedItems, entityTypes[j]);
                                                this.selectedDimensionsDetail[ctxKey] = rockLov.selectedItems;
                                            }
                                        } else {
                                            let selectedItems = [];
                                            let ctxKey = !_.isEmpty(configDataItem.contextKeyName) ? configDataItem.contextKeyName : entityTypes[j];
                                            if (rockClassification && rockClassification.selectedClassifications && 
                                                rockClassification.selectedClassifications.length > 0) {
                                                if (!rockClassification.multiSelect) {
                                                    if (rockClassification.selectedClassifications[0]) {
                                                        let valuePath = this._getClassificationValuePath(rockClassification.selectedClassifications[0]);
                                                        if (valuePath) {
                                                            selectedItems.push(valuePath);
                                                        }
                                                        this.selectedDimensionsDetail[ctxKey] = [{
                                                            "path": valuePath,
                                                            "classification": { "valuePath": rockClassification.selectedClassifications[0].valuePath }
                                                        }];                                                        
                                                    }
                                                } else {
                                                    this.selectedDimensionsDetail[ctxKey] = [];
                                                    for (let k = 0; k < rockClassification.selectedClassifications.length; k++) {
                                                        let valuePath = this._getClassificationValuePath(rockClassification.selectedClassifications[k]);
                                                        if (valuePath) {
                                                            selectedItems.push(valuePath);
                                                        }                                                       
                                                        let classificationObj = {
                                                            "path": valuePath,
                                                            "classification": { "valuePath": rockClassification.selectedClassifications[k].valuePath }
                                                        }
                                                        this.selectedDimensionsDetail[ctxKey].push(classificationObj);                                                        
                                                    }
                                                }
                                            }

                                            //Apply selectedItems from config
                                            if (!selectedItems || selectedItems.length == 0 && !_.isEmpty(configDataItem.selectedItem)) {
                                                rockClassification.selectedClassifications = configDataItem.selectedItem.classifications;
                                                selectedItems.push(configDataItem.selectedItem.path);
                                            }
                                            
                                            selectedDimensions[entityTypes[j]] = selectedItems;
                                        }
                                    }
                                }

                                if (configDataItem.displayType != "dialog") {
                                    this._setLovTitle(rockLov);
                                } else {
                                    this._setClassificationTitle(rockClassification);
                                }
                            }
                        }
                        // this._updateToggleButtonText(configDataItem, rockLov);
                    }

                    let eventDetail = {
                        'dimensions': selectedDimensions
                    };
                    if (DataHelper.isValidObjectPath(this._currentLovEvent, "detail.data.id")) {
                        eventDetail.currentLovId = this._currentLovEvent.detail.data.id;
                    }
                    if (this._isClassificationSelectionTriggered) {
                        eventDetail.currentLovId = "classification-dialog";
                    }

                    eventDetail.isPrimaryContext = _isPrimaryContext
                    eventDetail.taxonomyTitle = _taxonomyTitle;
                    eventDetail.selectedDimensionsDetail = this.selectedDimensionsDetail;

                    if (this.selectedDimensions && selectedDimensions) {
                        if (DataHelper.compareObjects(this.selectedDimensions, selectedDimensions)) {
                            return true;
                        }
                    }
                    this.set("selectedDimensions", selectedDimensions);
                    Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(500), () => {
                        this.fireBedrockEvent("dimension-selector-data-changed", eventDetail);
                    });
                }
            }

            /**
             * Function to set the default dimension-selector values
             * - If the defaultDimensions are empty/not set, use the availableSelectedItems
             * - If the defaultDimensions are set, and matches with the availableSelectedItems, make that availableSelectedItem as selectedItem
            */ 
            _getDefaultSelectedItems(ctxKey,defaultDimensions,availableSelectedItems) {
                let selectedItems = [];
                if(ctxKey && defaultDimensions[ctxKey]) {
                    if(availableSelectedItems && availableSelectedItems.length > 0) {
                        //If the availableSelectedItems and defaultDimensions are same, set them as selectedItems
                        for(let availableSelectedItemIndex=0; availableSelectedItemIndex < availableSelectedItems.length; availableSelectedItemIndex++) {
                            for(let defaultDimensionIndex=0; defaultDimensionIndex < defaultDimensions[ctxKey].length; defaultDimensionIndex++) {
                                let availableSelectedItem = availableSelectedItems[availableSelectedItemIndex]; 
                                let defaultDimensionItem = defaultDimensions[ctxKey][defaultDimensionIndex];
                                if(ctxKey != "classification") {
                                    if(availableSelectedItem.id && defaultDimensionItem.id && availableSelectedItem.id == defaultDimensionItem.id) {
                                        selectedItems.push(availableSelectedItem);
                                    }
                                } else {
                                    if((availableSelectedItem.id && defaultDimensionItem.path || defaultDimensionItem.id) && (availableSelectedItem.id == defaultDimensionItem.path) || (defaultDimensionItem.path=="" && availableSelectedItem.id!="") || (defaultDimensionItem.id==availableSelectedItem.id)) {
                                        selectedItems.push(availableSelectedItem);
                                    }
                                }
                            }
                        }
                    } else {
                        //If the availableSelectedItems are empty, set selectedItems as defaultDimensions
                        let defaultClassification = defaultDimensions["classification"];
                        if(ctxKey != "classification" || (ctxKey == "classification" && defaultClassification && defaultClassification[0] && defaultClassification[0].id)) {                     
                            selectedItems = defaultDimensions[ctxKey];
                        } else {
                            selectedItems = [];
                        }
                    } 
                }

                return selectedItems;
            }

            _updateCurrentContextState() {
                if (!_.isEmpty(this.selectedDimensions)) {

                    // Get context(s) based on selected dimension
                    let isRootContextChanged = this._isRootContextChanged();
                    let filteredCtx = this._getContextsBasedOnSelectedDimension(isRootContextChanged);

                    if (filteredCtx && filteredCtx.length) {

                        // Get flattened structure of filtered contexts
                        let flattenedCtx = this._getFlattenedContexts(filteredCtx, true);
                        this._currentContexts = flattenedCtx;

                        // Set filtered context to dimension and reset dimensions
                        if (flattenedCtx) {
                            let flattenedCtxKeys = Object.keys(flattenedCtx);
                            let dependentLovRelationships = {};

                            this._contextHierarchy.forEach(function (item) {
                                let lovElement = this.$$('#' + item + '-lov');
                                let itemIdx = this._contextHierarchy.indexOf(item);

                                if (lovElement) {
                                    let ctxData = lovElement.rData;
                                    let selectedItems = this.selectedDimensionsDetail[item];
                                    let ctxHierarchy = this._contextHierarchyInfo.find(v => v.contextKey === item);
                                    if (ctxHierarchy && ctxHierarchy.relTo && itemIdx > 0
                                        && this._contextHierarchy[itemIdx - 1].indexOf(ctxHierarchy.relTo) > -1
                                        && _.isEmpty(this.selectedDimensionsDetail[this._contextHierarchy[itemIdx - 1]])) {
                                        selectedItems = [];
                                        flattenedCtx[item] = ["_ALL"]
                                    }

                                    //Prepare list of dependent lov's and it's relationships based on selected dimension.
                                    // This list will be used when dependent lov will get reset with related entities which are mapped to current context as relationship.
                                    this._setDependentValCtxLovRelationships(ctxData, selectedItems, dependentLovRelationships);

                                    if (ctxData) {
                                        if (ctxData.dataRequestType == "entity-context") {
                                            lovElement.selectedItems = _.isEmpty(selectedItems) && !_.isEmpty(this.selectedDimensionsDetail[item]) ? selectedItems : this._getSelectedCtxItems(item);
                                            lovElement.items = [];
                                            lovElement.selectedItemInfo = _.isEmpty(selectedItems) && !_.isEmpty(this.selectedDimensionsDetail[item]) ? undefined : lovElement.selectedItemInfo;
                                            if(isRootContextChanged && ctxData.selectedItemInfo) {
                                                lovElement.selectedItemInfo = ctxData.selectedItemInfo;
                                            }
                                            lovElement.reset();
                                        } else if(ctxData.dimensionType !== "value") {
                                            let reqData = ctxData.dataRequest;
                                            let ctxToBeLoaded = flattenedCtx[item];

                                            if (reqData) {
                                                if (ctxToBeLoaded && ctxToBeLoaded.length && ctxToBeLoaded.indexOf('_ALL') < 0 && ctxData.externalAttrName) {
                                                    let attributesCriterion = [];
                                                    let attrCriterion = {};
                                                    attrCriterion[ctxData.externalAttrName] = {
                                                        "exacts": ctxToBeLoaded
                                                    }

                                                    attributesCriterion.push(attrCriterion);
                                                    reqData.params.query.filters.attributesCriterion = attributesCriterion;
                                                    selectedItems = this._getSelectedCtxItems(item, ctxToBeLoaded);
                                                } else {
                                                    delete reqData.params.query.filters.attributesCriterion;
                                                }

                                                lovElement.selectedItems = selectedItems;
                                                lovElement.selectedItem = !_.isEmpty(selectedItems) ? selectedItems[0] : {};
                                                lovElement.requestData = reqData;
                                                lovElement.reset();
                                            }
                                        }
                                    }
                                }
                            }, this);

                            // if dimension is "value" type then need to check for "dependentLovRelationships" if this dimension is mapped as dependent Lov.
                            let valueTypeDimensions = this.configData.filter(v => v.dimensionType == "value");
                            if (valueTypeDimensions) {
                                for (let valueTypeDimension of valueTypeDimensions) {
                                    let ctxType = valueTypeDimension.id;
                                    let ctxToBeLoaded = flattenedCtx[ctxType];
                                    let lovElement = this.$$('#' + ctxType + '-lov');

                                    if (lovElement) {
                                        let ctxData = lovElement.rData;
                                        let selectedItems = this.selectedDimensionsDetail[ctxType];

                                        if (ctxData) {
                                            let reqData = ctxData.dataRequest;
                                            if (reqData) {
                                                if (ctxToBeLoaded && ctxToBeLoaded.length && ctxToBeLoaded.indexOf('_ALL') < 0 && ctxData.externalAttrName) {
                                                    let attributesCriterion = [];
                                                    let attrCriterion = {};
                                                    attrCriterion[ctxData.externalAttrName] = {
                                                        "exacts": ctxToBeLoaded
                                                    }

                                                    attributesCriterion.push(attrCriterion);
                                                    reqData.params.query.filters.attributesCriterion = attributesCriterion;
                                                    selectedItems = this._getSelectedCtxItems(ctxType, ctxToBeLoaded);
                                                } else {
                                                    delete reqData.params.query.filters.attributesCriterion;
                                                }
                                                if (!_.isEmpty(dependentLovRelationships[ctxType])) {
                                                    reqData.params.query.ids = dependentLovRelationships[ctxType];
                                                } else {
                                                    delete reqData.params.query.ids;
                                                }

                                                lovElement.selectedItems = selectedItems;
                                                lovElement.selectedItem = !_.isEmpty(selectedItems) ? selectedItems[0] : {};
                                                lovElement.requestData = reqData;
                                                lovElement.reset();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this._setSelectedDimensions();
                }
            }

            _getMappedValueContextsBasedOnCtxType(currentContextType) {
                if (currentContextType) {
                    let globalCtxInfo = this._contextHierarchyInfo && this._contextHierarchyInfo.find(v => v.contextKey == currentContextType);
                    if (globalCtxInfo && globalCtxInfo.mappedValueContexts) {
                        return globalCtxInfo.mappedValueContexts
                    }
                }
            }

            _contextDataToBeLoaded(contextKey) {
                let ctxValue = [];
                if (contextKey) {
                    for (let i = 0; i <= this._contexts.length; i++) {
                        if (this._contexts[i] && this._contexts[i][contextKey]) {
                            let ctx = this._contexts[i][contextKey];
                            if (Array.isArray(ctx)) {
                                ctx.forEach(function (item) {
                                    if (ctxValue.indexOf(item) < 0) {
                                        ctxValue.push(item);
                                    }
                                }, this);
                            } else {
                                if (ctx.toLowerCase() == "_all") {
                                    ctxValue = ["_ALL"];
                                    break;
                                } else {
                                    if (ctxValue.indexOf(ctx) < 0) {
                                        ctxValue.push(ctx);
                                    }
                                }
                            }
                        }
                    }
                }
                return ctxValue;
            }

            _setDependentValCtxLovRelationships(elementInfo, selectedItems, dependentLovRelationships) {
                if (elementInfo && !_.isEmpty(selectedItems)) {
                    let mappedValueContexts = this._getMappedValueContextsBasedOnCtxType(elementInfo.id);

                    if (mappedValueContexts) {
                        let dependentCtxs = mappedValueContexts.map(a => a.valueContext);

                        if (dependentCtxs) {
                            for (let dctxs of dependentCtxs) {
                                if (!dependentLovRelationships[dctxs]) {
                                    dependentLovRelationships[dctxs] = [];
                                }

                                for (let selectedItem of selectedItems) {
                                    if (selectedItem.relTo) {
                                        let relIds = selectedItem.relTo.map(function (rel) {
                                            if (rel.relTo.type == dctxs) {
                                                return rel.relTo.id;
                                            }
                                        });

                                        if (!_.isEmpty(relIds)) {
                                            dependentLovRelationships[dctxs] = dependentLovRelationships[dctxs].concat(relIds);
                                        } else {
                                            delete dependentLovRelationships[dctxs];
                                            break;
                                        }
                                    } else {
                                        delete dependentLovRelationships[dctxs];
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _onEntityContextGetResponse(e) {
                let response = e.detail.response.response;

                if (response) {
                    if (response.entities && response.entities.length) {
                        let entity = response.entities[0];

                        if (entity && entity.data && entity.data.contexts) {
                            let _entityContexts = [];

                            entity.data.contexts.forEach(function (ctx) {
                                _entityContexts.push(ctx.context)
                            }, this);

                            this._entityContexts = _entityContexts;
                        }
                    }
                    this.refreshDimensionData();
                } else {
                    this.logError(this.appName + "-Dimension Selector - Entity Context get response exception", e.detail, true);
                }
            }

            _onEntityContextGetError(e) {
                this.logError(this.appName + "-Dimension Selector - Entity Context get exception", e.detail);
            }

            _onPreselectedContextGetResponse(ev) {
                if(DataHelper.isValidObjectPath(ev, 'detail.response.response.entities.0')) {
                    let entity = ev.detail.response.response.entities[0];
                    if(entity && !_.isEmpty(this._parsedContexts) ) {
                        for(let idx=0; idx<this._parsedContexts.length; idx++) {
                            if(this._parsedContexts[idx].ctxName === entity.type) {
                                let _selectedItemData = this._entityExternalDataFormatter([this._parsedContexts[idx].selectedItem], [entity], this._parsedContexts[idx]);
                                if(!_.isEmpty(_selectedItemData)) {
                                    this._parsedContexts[idx].selectedItem = _selectedItemData[0];
                                }
                                break;
                            }
                        }
                    }
                } else {
                    this.logError(this.appName + "-Dimension Selector - Entity Pre selected Context get exception", ev.detail);
                }

                this._contextToBeRendered = undefined;
                this._contextToBeRendered = this._parsedContexts;
                this._updateSelectedDimensions();
            }

            _onPreselectedContextGetGetError(ev) {
                this.logError(this.appName + "-Dimension Selector - Entity Pre selected Context get exception", ev.detail);
                this._contextToBeRendered = undefined;
                this._contextToBeRendered = this._parsedContexts;
                this._updateSelectedDimensions();
            }

            _entityExternalDataFormatter(formattedData, data, _rData) {
                if (formattedData && formattedData.length) {
                    let elementInfo = _rData ? _rData : this.rData;

                    if (elementInfo) {
                        let ctxType = elementInfo.id;

                        // Add relationship detail into formatted item if entity has dependent relationship
                        // If entity has dependent relationship then check for "isDefault" relationship attribute to get preselected dependent value for current entity.
                        let _domHost = _rData ? this : this.domHost;
                        _domHost._setDepenedencyRelationshipAndPreSelectedItems(data, formattedData, elementInfo);

                        if (elementInfo.dimensionType.toLowerCase() == "value" && DataHelper.isValidObjectPath(this.requestData, "params.query.ids")) {
                            let selectedItemIds = this.selectedItems.map(v => v.id);
                            let selectedItems = [];
                            if (selectedItemIds) {
                                formattedData.forEach(function (item) {
                                    if (selectedItemIds.indexOf(item.id) > -1) {
                                        selectedItems.push(item);
                                    }
                                }, this);

                                if (!_.isEmpty(selectedItems)) {
                                    if (!DataHelper.areEqualArrays(this.selectedItems, selectedItems)) {
                                        this.selectedItems = selectedItems;
                                        _domHost._setSelectedDimensions();
                                    }
                                } else {
                                    let preSelectedItems = _domHost.selectedDimensionsDetail["PreSelectedItems"] && _domHost.selectedDimensionsDetail["PreSelectedItems"][ctxType];
                                    if (!_.isEmpty(preSelectedItems)) {
                                        //var preselctedItem = data.find(v => v.id == preSelectedItemId);
                                        let preselctedItem = data.find(v => preSelectedItems.find(u => u === v.id));

                                        if (preselctedItem) {
                                            let name = preselctedItem.data.attributes[elementInfo.externalAttrName].values[0].value;
                                            let item = formattedData.find(v => v.title == name);

                                            if (item) {
                                                this.selectedItems = [item];
                                                _domHost._setSelectedDimensions();
                                            }
                                        }
                                    } else {
                                        this.selectedItems = [];
                                        _domHost._setSelectedDimensions();
                                    }
                                }
                            }
                        }

                        let filteredCtx = undefined;;
                        if (_domHost) {
                            filteredCtx = _domHost._getExistingContextsOfEntity();
                        }

                        if (filteredCtx && filteredCtx.length) {
                            let flattenedCtx = _domHost._getFlattenedContexts(filteredCtx, false);

                            if (flattenedCtx && flattenedCtx[ctxType]) {
                                let existingContext = flattenedCtx[ctxType];

                                if (existingContext && existingContext.length) {
                                    formattedData.forEach(function (item) {
                                        if (existingContext.indexOf(item.title) >= 0) {
                                            item.subtitle = "Existing";
                                        }
                                    }, this);
                                }
                            }
                        }
                    }
                }

                return formattedData;
            }

            _entityContextExternalDataFormatter(data) {

                let filteredData = [];
                if (data && data.length) {
                    let elementInfo = this.rData;
                    let domHost = this.domHost;
                    if (elementInfo && domHost) {
                        if (elementInfo.useContextModel) {
                            let currentContextType = elementInfo.id;
                            let filteredCtx = domHost._getExistingContextsOfEntityContext(domHost._entityContexts, domHost.selectedDimensions, currentContextType);

                            if (filteredCtx && filteredCtx.length) {
                                let resetRootDimension = true;
                                if(currentContextType === domHost._contextHierarchy[0]) {
                                    resetRootDimension = false;
                                }
                                let flattenedCtx = domHost._getFlattenedContexts(filteredCtx, resetRootDimension);

                                if (flattenedCtx && flattenedCtx[currentContextType]) {
                                    let existingContext = flattenedCtx[currentContextType];

                                    if (existingContext && existingContext.length) {
                                        data.forEach(function (item) {
                                            if (existingContext.indexOf(item.title) >= 0) {
                                                item.subtitle = "Existing";
                                                filteredData.push(item);
                                            }
                                        }, this);
                                    }
                                }
                            }
                        } else {
                            filteredData = data;
                        }
                    }
                }

                return filteredData;
            }

            _setDepenedencyRelationshipAndPreSelectedItems(data, formattedData, elementInfo) {
                let mappedValueContexts = elementInfo && elementInfo.mappedValueContexts;

                if (mappedValueContexts && data && formattedData) {
                    this.selectedDimensionsDetail["PreSelectedItems"] = {};
                    for (let d of data) {
                        if (d.data && d.data.relationships) {
                            for (let rel in d.data.relationships) {
                                if (d.data.relationships[rel] && d.data.attributes[elementInfo.externalAttrName]) {
                                    let name = d.data.attributes[elementInfo.externalAttrName].values[0].value;
                                    let item = formattedData.find(v => v.id == name);

                                    if (item && !item.relTo) {
                                        item.relTo = [];
                                    }

                                    let mappedValueContext = mappedValueContexts.find(v => v.valueContextRelationship == rel);

                                    for (let r of d.data.relationships[rel]) {
                                        item.relTo.push(r);
                                        if (r.attributes && mappedValueContext) {
                                            let relAttr = r.attributes[this._getDefaultSelectedAttrName()];

                                            if (DataHelper.isValidObjectPath(relAttr, "values.0.value") && relAttr.values[0].value.toString() == "true") {
                                                if (!this.selectedDimensionsDetail["PreSelectedItems"]) {
                                                    this.selectedDimensionsDetail["PreSelectedItems"] = {};
                                                }

                                                if (_.isEmpty(this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext])) {
                                                    this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext] = [];
                                                }

                                                if(this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext].indexOf(r.relTo.id) === -1) {
                                                    this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext].push(r.relTo.id);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            _getContextsBasedOnSelectedDimension(isRootContextChanged) {
                let filteredCtx = [];

                let selectedDimensions = undefined;

                if (isRootContextChanged) {
                    selectedDimensions = {};
                    this._contextHierarchy.forEach(function (ctx, index) {
                        if (index == 0 || ctx === "taxonomy") {
                            selectedDimensions[ctx] = this.selectedDimensions[ctx];
                        } else {
                            selectedDimensions[ctx] = [];
                        }
                    }, this);
                } else {
                    selectedDimensions = this.selectedDimensions;
                }

                filteredCtx = this._findContextModelMatchForCurrentSelctedDimension(selectedDimensions);

                // Reset dimensions if selcted dimension context will not be identified in context model
                if (!filteredCtx.length) {
                    this._contextHierarchy.forEach(function (ctxKey, index) {
                        let ctx = {};
                        ctx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                        filteredCtx.push(ctx);
                    }, this);
                }

                return filteredCtx;
            }

            _findContextModelMatchForCurrentSelctedDimension(selectedDimensions) {
                let filteredCtx = [];
                if (this._contexts && selectedDimensions) {
                    // Get context(s) based on selected dimension
                    for (let ctxIndex = 0; ctxIndex <= this._contexts.length; ctxIndex++) {
                        let ctx = this._contexts[ctxIndex];
                        let isMatch = false;
                        let isPartialMatch = false;
                        if (ctx) {

                            for (let hierarchyIndex = 0; hierarchyIndex <= this._contextHierarchy.length; hierarchyIndex++) {
                                let sdv = selectedDimensions[this._contextHierarchy[hierarchyIndex]];
                                let ctxv = ctx[this._contextHierarchy[hierarchyIndex]];

                                if (ctxv) {
                                    if (sdv && sdv.length) {
                                        if (sdv.indexOf(ctxv) >= 0) {
                                            if (!isPartialMatch) {
                                                isMatch = true;
                                            }
                                        } else {
                                            if (isMatch) {
                                                isPartialMatch = true
                                            } else {
                                                isMatch = isPartialMatch = false;
                                                break;
                                            }
                                        }
                                    } else {
                                        if (isMatch) {
                                            isPartialMatch = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            if (isMatch || isPartialMatch) {
                                filteredCtx.push(ctx);
                            }

                        }
                    }
                }
                return filteredCtx;
            }

            _getExistingContextsOfEntity() {
                let filteredCtx = [];
                if (this._entityContexts && this._currentContexts) {
                    for (let ctxIndex = 0; ctxIndex <= this._entityContexts.length; ctxIndex++) {
                        let ctx = this._entityContexts[ctxIndex];
                        let isMatch = false;

                        if (ctx) {
                            let sortedCtxKeys = [];
                            let entityCtxKeys = Object.keys(ctx);
                            this._contextHierarchy.forEach(function (item) {
                                if (entityCtxKeys.indexOf(item) > -1) {
                                    sortedCtxKeys.push(item);
                                }
                            }, this);

                            for (let hierarchyIndex = 0; hierarchyIndex <= sortedCtxKeys.length; hierarchyIndex++) {
                                let ctxKey = sortedCtxKeys[hierarchyIndex];
                                let sdv = this._currentContexts[ctxKey];
                                let ctxv = ctx[ctxKey];

                                if (ctxv) {
                                    if (sdv && sdv.length) {
                                        if (sdv.indexOf(ctxv) >= 0 || sdv.indexOf("_ALL") >= 0) {
                                            isMatch = true;
                                        } else {
                                            isMatch = false;
                                            break;
                                        }
                                    } else {
                                        isMatch = false;
                                        break;
                                    }
                                }
                            }
                        }

                        if (isMatch) {
                            filteredCtx.push(ctx);
                        }
                    }
                }

                return filteredCtx;
            }

            _getExistingContextsOfEntityContext(entityContexts, currentSelectedContexts, currentContextType) {
                let filteredCtx = [];
                if (entityContexts) {
                    let partialContext = this._getPartialContextForEntityContext(currentSelectedContexts, currentContextType);

                    for (let ctxIndex = 0; ctxIndex <= entityContexts.length; ctxIndex++) {
                        let ctx = entityContexts[ctxIndex];
                        let isMatch = false;

                        if (ctx) {
                            let filter = false;
                            let partialContextKeys = undefined;
                            if(_.isEmpty(partialContext)) {
                                partialContextKeys = Object.keys(ctx);
                            } else {
                                partialContextKeys = Object.keys(partialContext);
                            }
                            if (!_.isEmpty(partialContextKeys)) {
                                if (!(partialContextKeys.length == 1 && partialContextKeys.includes("taxonomy"))) {
                                    filter = true;
                                }
                            }

                            if (filter) {
                                let matched = _.every(partialContext, function (val, key) {
                                    if (_.isArray(val)) {
                                        return _.some(val, function (v) {
                                            return _.isEqual(v, ctx[key]);
                                        });
                                    } else {
                                        return _.isEqual(val, ctx[key]);
                                    }
                                });

                                if (matched) {
                                    filteredCtx.push(ctx);
                                }
                            } else {
                                let ctxKeys = Object.keys(ctx);
                                if (ctxKeys.length == 2 && ctxKeys.includes("taxonomy", "classification")) {
                                    filteredCtx.push(ctx);
                                }
                            }
                        }
                    }
                }

                return filteredCtx;
            }

            _getFlattenedContexts(contexts, resetRootDimension) {
                let flattenedCtx = {};

                if (contexts && contexts.length)
                    contexts.forEach(function (ctx) {
                        let ctxKeys = Object.keys(ctx);

                        for (let i = 0; i <= ctxKeys.length; i++) {
                            let ctxKey = ctxKeys[i];

                            if (!flattenedCtx[ctxKey]) {
                                flattenedCtx[ctxKey] = [];
                            }

                            if (Array.isArray(ctx[ctxKey])) {
                                ctx[ctxKey].forEach(function (item) {
                                    if (flattenedCtx[ctxKey].indexOf(item) < 0) {
                                        flattenedCtx[ctxKey].push(item);
                                    }
                                }, this);
                            } else {
                                if (flattenedCtx[ctxKey].indexOf(ctx[ctxKey]) < 0) {
                                    flattenedCtx[ctxKey].push(ctx[ctxKey]);
                                }
                            }

                            if (ctxKey == this._contextHierarchy[0] && resetRootDimension) {
                                flattenedCtx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                            }
                        }
                    }, this);

                return flattenedCtx;
            }

            _isRootContextChanged() {
                let isRootCtxhanged = false;
                let _selectedDim = this.selectedDimensions[this._contextHierarchy[0]];
                this._previousRootCtxValue = this._previousRootCtxValue || [];
                if(_selectedDim) {
                    if(_selectedDim.length == this._previousRootCtxValue.length) {
                        _selectedDim.forEach(function (val) {
                            if (this._previousRootCtxValue.indexOf(val) < 0) {
                                isRootCtxhanged = true;
                            }
                        }, this);
                    } else {
                        isRootCtxhanged = true;
                    }
                    this._previousRootCtxValue = DataHelper.cloneObject(_selectedDim);
                }
                return isRootCtxhanged;
            }

            _getSelectedCtxItems(ctxKey, ctxToBeLoaded) {
                let selectedItems = [];

                if (this.selectedDimensions && this.selectedDimensions[ctxKey]) {

                    if (ctxToBeLoaded) {
                        this.selectedDimensions[ctxKey].forEach(function (dim) {
                            if (ctxToBeLoaded.indexOf(dim) >= 0) {
                                selectedItems.push({
                                    "id": dim,
                                    "title": dim,
                                    "type": ctxKey
                                });
                            }
                        }, this);
                    } else {
                        this.selectedDimensions[ctxKey].forEach(function (dim) {
                            let ctxObj = {
                                "id": dim,
                                "title": dim,
                                "type": ctxKey
                            }
                            if (ctxKey == "locale") {
                                let _localeObj = ComponentHelper.getLocaleManager().getByName(dim);
                                if (!_.isEmpty(_localeObj)) {
                                    ctxObj.title = _localeObj.externalName ? _localeObj.externalName : dim;
                                }
                            }
                            selectedItems.push(ctxObj);
                        }, this);
                    }
                }

                return selectedItems;
            }

            _setLovTitle(currentRockLov) {
                if (!currentRockLov) {
                    return;
                }

                let currentDimensionButtonId = currentRockLov.id.replace("-lov", "-toggle-button");

                if (currentDimensionButtonId) {
                    let currentDimensionButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                    let buttonText = "";
                    let toolTip = "";
                    if (currentDimensionButton) {
                        if (currentRockLov.multiSelect) {
                            if (!_.isEmpty(currentRockLov.selectedItems)) {
                                if (currentRockLov.selectedItems.length > 1) {
                                    buttonText = currentRockLov.selectedItems.length + " " + DataHelper.getPluralLabel(currentRockLov.parentElement.title);
                                    currentRockLov.selectedItems.forEach(function (item) {
                                        if (_.isEmpty(toolTip)) {
                                            toolTip = item.title;
                                        } else {
                                            toolTip = toolTip + ", " + item.title;
                                        }
                                    }, this);
                                    toolTip = toolTip.trim(',');
                                } else {
                                    buttonText = toolTip = currentRockLov.selectedItems[0].title;
                                }
                            } else {
                                buttonText = toolTip = currentRockLov.parentElement.title;
                            }
                        } else {
                            if (!_.isEmpty(currentRockLov.selectedItem)) {
                                buttonText = toolTip = currentRockLov.selectedItem.title;
                            } else {
                                buttonText = toolTip = currentRockLov.parentElement.title;
                            }
                        }
                    }

                    currentDimensionButton.buttonText = buttonText;
                    currentDimensionButton.setAttribute("data-tooltip", toolTip);
                }
            }

            _getPartialContextForEntityContext(dataContext, ctxType) {
                let partialContext = {};
                if (!_.isEmpty(dataContext)) {
                    for (let item of this._contextHierarchy) {
                        if (item == ctxType) {
                            break;
                        }

                        if (item.toLowerCase() != "locale" && item.toLowerCase() != "source") {
                            if (!_.isEmpty(dataContext[item])) {
                                partialContext[item] = dataContext[item];
                            }
                        }
                    }
                }
                return partialContext;
            }

            _getDefaultSelectedAttrName() {
                return "isDefault";
            }

            _isMultiSelect(item) {
                if (typeof (item.multiSelect) == "undefined") {
                    return true;
                } else {
                    return item.multiSelect;
                }
            }
        }
        customElements.define(RockDimensionSelector.is, RockDimensionSelector);
        
    </script>
</dom-module>