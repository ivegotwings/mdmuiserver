<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-externalref-underscore/bedrock-externalref-underscore.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<link rel="import" href="../rock-context-lov/rock-context-lov.html">
<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">
<link rel="import" href="../rock-component-config-behavior/rock-component-config-behavior.html">

<!--
`<rock-dimension-selector>` Represents a component to hold a container, source, date, and locale information.
The elements inside this component are dynamically loaded based on the "config json".

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--dimesion-selector-container-popover` | Mixin applied to container selector dropdown | `{}`
`--dimesion-selector-source-popover` | Mixin applied to source selector dropdown | `{}`
`--dimesion-selector-locale-popover` | Mixin applied to locale selector dropdown | `{}`

@group rock Elements
@element rock-dimension-selector
@demo demo/index.html
-->
<dom-module id="rock-dimension-selector">
    <template>
        <style include="bedrock-style-common"></style>
        <style include="iron-flex"></style>
        <style>
            :host {
                display: inline-block;
                --item-length-overflow: {
                    word-break: break-word;
                }
            }

            #listPopover {
                @apply --dimesion-selector-container-popover;
            }

            #sourcePopover {
                @apply --dimesion-selector-source-popover;
            }

            #localePopover {
                @apply --dimesion-selector-locale-popover;
            }

            pebble-popover {
                --pebble-popover-width: 260px;
            }
            .button-siblings{
                height:calc(100% - 40px);
            }

            .btn.dropdownText {
                display: flex;
                align-items: center;
                --pebble-button: {
                    font-weight: var(--font-medium, 500);
                    color: var(--palette-cerulean-two, #026bc3);
                    padding-top: 0px;
                    padding-right: 0px;
                    padding-bottom: 0px;
                    padding-left: 0px;
                    width: 120px;
                }
                --pebble-button-right-icon: {
                    margin-right: 5px;
                }
                --pebble-icon-color: {
                    fill: var(--palette-cerulean-two, #026bc3);
                }
            }
        </style>
        <div class="horizontal layout container">
            <template is="dom-repeat" items="[[_contextToBeRendered]]" as="ctx">
                <div id="[[ctx.id]]" hidden$="[[ctx.hidden]]">
                    <div>
                        <pebble-button id="[[ctx.id]]-toggle-button" popover="[[ctx.id]]-popover" lov="[[ctx.id]]-lov" icon="[[ctx.icon]]" button-text="[[ctx.title]]"
                            class="dropdownText dropdownIcon btn dropdown tooltip-bottom" noink raised no-overlap vertical-offset="-211"
                            horizontal-offset="11" dropdown-icon on-tap="_onToggleButtonTap" disabled$="[[ctx.readonly]]">
                        </pebble-button>
                    </div>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity')]]">
                        <template is="dom-if" if="[[!_isDialogType(ctx.displayType)]]">
                            <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                                <rock-entity-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly=[[readonly]] config-data-item-id="[[ctx.id]]" id-field="[[ctx.dataMappings.id]]"
                                    title-pattern="[[ctx.dataMappings.title]]" request-data="[[ctx.dataRequest]]" 
                                    selected-items="[[_getSelectedItems(ctx.selectedItem, _contextToBeRendered)]]" selected-item="[[_getSelectedItem(ctx.selectedItem, _contextToBeRendered)]]"
                                    external-data-formatter="[[_entityExternalDataFormatter]]" type-field="[[ctx.dataMappings.type]]"
                                    sort-field="[[ctx.dataMappings.sort]]" multi-select="[[!allSingleSelect]]" show-action-buttons></rock-entity-lov>
                            </pebble-popover>
                            <bedrock-pubsub event-name="entity-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                            <bedrock-pubsub event-name="entity-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        </template>
                        <template is="dom-if" if="[[_isDialogType(ctx.displayType)]]">
                            <pebble-dialog id="[[ctx.id]]-popover" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                                <div id="classificationContent" style="height:85vh">
                                    <div id="categoryTreeContainer" title="[[ctx.title]]" class="button-siblings">
                                        <rock-classification-tree id="[[ctx.id]]-contextTree" taxonomy="[[_getClassificationTaxonomy(ctx.selectedItemInfo.taxonomy, classificationTaxonomy)]]"
                                            context-data="[[contextData]]" multi-select="[[!allSingleSelect]]"></rock-classification-tree>
                                    </div>
                                    <div id="exportActions" class="m-t-10" align="center">
                                        <pebble-button class="btn btn-secondary m-r-5" id="cancel" button-text="Cancel" raised on-tap="_onCancelClassificationSelection"></pebble-button>
                                        <pebble-button class="btn btn-success" id="download" button-text="Select" raised on-tap="_selectClassification"></pebble-button>
                                    </div>
                                </div>
                            </pebble-dialog>
                        </template>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-context')]]">
                        <template is="dom-if" if="[[!_isDialogType(ctx.displayType)]]">
                            <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                                <rock-context-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly=[[readonly]] data-object-type="[[ctx.dataObjectType]]" entity-id="[[entityId]]"
                                    entity-type="[[entityType]]" context-name="[[ctx.id]]" config-data-item-id="[[ctx.id]]" request-data="[[ctx.dataRequest]]"
                                    selected-items="[[_getSelectedItems(ctx.selectedItem, _contextToBeRendered)]]" selected-item="[[_getSelectedItem(ctx.selectedItem, _contextToBeRendered)]]"
                                    external-data-formatter="[[_entityContextExternalDataFormatter]]"
                                    selected-item-info=[[ctx.selectedItemInfo]] multi-select="[[!allSingleSelect]]" show-action-buttons></rock-context-lov>
                            </pebble-popover>
                        </template>
                        <template is="dom-if" if="[[_isDialogType(ctx.displayType)]]">
                            <pebble-dialog id="[[ctx.id]]-popover" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                                <div id="classificationContent" style="height:85vh">
                                    <div id="categoryTreeContainer" title="[[ctx.title]]" class="button-siblings">
                                        <rock-classification-tree id="[[ctx.id]]-contextTree" taxonomy="[[_getClassificationTaxonomy(ctx.selectedItemInfo.taxonomy, classificationTaxonomy)]]"
                                            context-data="[[contextData]]" multi-select="[[!allSingleSelect]]" disable-child-node="[[disableChildNode]]"></rock-classification-tree>
                                    </div>
                                    <div id="exportActions" class="m-t-10" align="center">
                                        <pebble-button class="btn btn-secondary m-r-5" id="cancel" button-text="Cancel" raised on-tap="_onCancelClassificationSelection"></pebble-button>
                                        <pebble-button class="btn btn-success" id="download" button-text="Select" raised on-tap="_selectClassification"></pebble-button>
                                    </div>
                                </div>
                            </pebble-dialog>
                        </template>
                        <bedrock-pubsub event-name="context-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-selected-info-applied" handler="_onContextLovSelectedInfoApplied" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-model')]]">
                        <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap horizontal-align="[[horizontalAlign]]">
                            <rock-entity-model-lov id="[[ctx.id]]-lov" readonly=[[readonly]] config-data-item-id="[[ctx.id]]" id-field="[[ctx.dataMappings.id]]"
                                title-pattern="[[ctx.dataMappings.title]]" type-field="[[ctx.dataMappings.type]]" request-data="[[ctx.dataRequest]]"
                                selected-items="[[_getSelectedItems(ctx.selectedItem)]]" multi-select="[[!allSingleSelect]]"
                                no-sub-title show-action-buttons></rock-entity-model-lov>
                        </pebble-popover>
                        <bedrock-pubsub event-name="entity-model-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="entity-model-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                </div>
            </template>
        </div>
        <pebble-dialog id="confirmation-dialog" dialog-title="Confirmation" modal alert-box show-cancel show-ok no-cancel-on-outside-click
            no-cancel-on-esc-key>
            <p>[[confirmationMessage]]</p>
        </pebble-dialog>
        <bedrock-pubsub event-name="refresh-dimension-selector" handler="refresh"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-buttonok-clicked" handler="_onTapConfirmationOK" target-id="confirmation-dialog"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-buttoncancel-clicked" handler="_onTapConfirmationCancel" target-id="confirmation-dialog"></bedrock-pubsub>
        <liquid-rest id="contextModelGet" url="/data/pass-through/entitymodelservice/getcontext" method="POST" request-data="{{_contextModelGetReq}}"
            on-liquid-response="_onContextModelGetResponse" on-liquid-error="_onContextModelGetFailed"></liquid-rest>
        <liquid-rest id="entityModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_entityModelRequest}}"
            on-liquid-response="_onEntityModelGetResponse"></liquid-rest>
        <liquid-rest id="entityContextGet" url="/data/pass-through/entityservice/getcontext" method="POST" request-data="{{_entityContextRequest}}"
            on-liquid-response="_onEntityContextGetResponse" exclude-in-progress>
        </liquid-rest>
    </template>
    <script>
        Polymer({
            is: "rock-dimension-selector",
            properties: {
                /**
                 * Indicates the app name
                 */
                appName: {
                    type: String,
                    value: ""
                },

                domain: {
                    type: String,
                    value: ""
                },

                contextData: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                /**
                 * Indicates the list of items which you must place in the dimension selector component.
                 */
                configData: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                /**
                * If set as true , it indicates the component is in read only mode
                */
                readonly: {
                    type: Boolean,
                    value: false
                },

                /**
                * Indicates the selected values of all dimensions in the dimension selector.
                */
                selectedDimensions: {
                    type: Object,
                    notify: true,
                    value: function () {
                        return {};
                    }
                },
                /**
                * <b><i>Content development is under progress... </b></i>
                */
                allMultiSelect: {
                    type: Boolean,
                    value: false
                },
                allSingleSelect: {
                    type: Boolean,
                    value: false
                },
                entityId: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                entityType: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                horizontalAlign: {
                    type: String,
                    value: "right"
                },
                classificationTaxonomy: {
                    type: String,
                    value: ""
                },
                hideContexts: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                components: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                dynamicDimensionsConfig: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                confirmationMessage: {
                    type: String,
                    value: "Do you want to update selection?"
                },
                showConfirmation: {
                    type: Boolean,
                    value: false
                },
                _default: {
                    type: Array,
                    value: [{
                        "id": "default",
                        "title": "default",
                        "type": "default"
                    }]
                },
                _contextModelGetReq: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _contexts: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _isDynamic: {
                    type: Boolean,
                    value: false
                },
                _contextToBeRendered: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _entityModelRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _contextHierarchy: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _entityContextRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _entityContexts: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _currentContexts: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _previousRootCtxValue: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _isConfigLoaded: {
                    type: Boolean,
                    value: false
                },
                _isContextLoad: {
                    type: Boolean,
                    value: false
                },
                _currentDimensionSelector: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                selectedDimensionsDetail: {
                    type: Object,
                    notify: true,
                    value: function () {
                        return {};
                    },
                    observer:"selectedDimensionsDetailChanged"
                },
                _selectedClassificationsConfig: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                disableChildNode:{
                    type: Boolean,
                    value: false
                }
            },

            behaviors: [
                RUFBehaviors.UIBehavior,
                RUFBehaviors.ComponentConfigBehavior
            ],

            observers: [
                '_configChanged(configData, entityType)',
                '_prepareContext(appName, domain, entityType)'
            ],

            selectedDimensionsDetailChanged: function(dimensionData){
                var _contextToBeRendered = this._contextToBeRendered;
                if(!_.isEmpty(dimensionData)){
                    _contextToBeRendered.forEach(element => {
                        if(!_.isEmpty(element)){
                            var itemId = this._getItemId(element);
                            if(!_.isEmpty(dimensionData[itemId])) {
                                if(itemId === "classification"){
                                    element.selectedItem.classifications = [dimensionData[itemId][0].classification];
                                    element.selectedItem.path = dimensionData[itemId][0].path;
                                } else {
                                    var selectedItem = {
                                        "id": dimensionData[itemId][0].id,
                                        "title": dimensionData[itemId][0].title,
                                        "type": dimensionData[itemId][0].type
                                    }
                                    element.selectedItem = selectedItem;
                                }
                            }
                        }
                    });
                    this._contextToBeRendered = [];
                    this.set("_contextToBeRendered",_contextToBeRendered);
                    this._updateSelectedDimensions();
                }
            },

            onConfigLoaded: async function (componentConfig) {
                if (componentConfig && componentConfig.config) {
                    var configData = DataHelper.convertObjectToArray(componentConfig.config);

                    if (!_.isEmpty(this.dynamicDimensionsConfig)) {
                        configData = this._prepareConfigForDynamicDimensions(configData);
                    }
                    var localeManager = ComponentHelper.getLocaleManager();
                    var defaultLocale = DataHelper.getDefaultValContext();
                    if (defaultLocale && defaultLocale.locale) {
                        await localeManager.getByNameAsync(defaultLocale.locale);
                    }
                    this.configData = {};
                    this.set('configData', configData);
                }
            },

            get confirmationDialog() {
                this._confirmationDialog = this._confirmationDialog || this.shadowRoot.querySelector("#confirmation-dialog");
                return this._confirmationDialog;
            },

            getDimensionSelectorConfig: function () {
                return this.configData;
            },

            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            refresh: function () {
                this._createContextGetRequest(this.entityId, this.entityType);               
            }, 

            refreshDimensionData: function () {
                if (typeof (this.configData) !== "undefined") {
                    for (var i = 0; i < this.configData.length; i++) {
                        var configDataItem = this.configData[i];
                        var rockLov;
                        var lovContainer = this.shadowRoot.querySelector("#" + configDataItem.id);
                        if(lovContainer) {
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                                rockLov = lovContainer.querySelector("rock-entity-lov");
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                                rockLov = lovContainer.querySelector("rock-context-lov");
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                                rockLov = lovContainer.querySelector("rock-entity-model-lov");
                            }
                            if (rockLov) {
                                rockLov.reset();
                            }
                        }
                    }
                }
            },
            _createContextGetRequest:function(entityId,entityType){
                if (!_.isEmpty(entityId)) {
                    this._entityContextRequest = DataRequestHelper.createEntityContextGetRequest(entityId, entityType);
                    var liquidElement = this.$$('#entityContextGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    }
                }
            },
            clearClassificationSelection: function () {
                if (typeof (this.configData) !== "undefined") {
                    for (var i = 0; i < this.configData.length; i++) {
                        var configDataItem = this.configData[i];
                        var rockClassification;
                        var rockContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                        if (rockContainer) {
                            if (configDataItem.dataMappings.type.indexOf("classification") != -1) {
                                rockClassification = rockContainer.querySelector("rock-classification-tree");
                            }

                            if (rockClassification) {
                                rockClassification.selectedClassifications = [];
                                this.selectedDimensions["classification"] = [];
                                var currentDimensionButtonId = rockClassification.id.replace("-contextTree", "-toggle-button");
                                var currentButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                                if (currentButton) {
                                    currentButton.buttonText = rockClassification.parentElement.title;
                                    currentButton.setAttribute("data-tooltip", rockClassification.parentElement.title);
                                }
                            }
                        }
                    }
                }
            },

            _configChanged: function (configData, entityType) {
                this.entityType = entityType;
                if (configData && configData.length) {
                    if (!this._isContextLoad) {
                        configData.forEach(function (item) {
                            if (item && item.useContextModel) {
                                this._isContextLoad = true;
                            }
                        }, this);
                    }

                    if (this._isContextLoad) {
                        if (entityType) {
                            this._entityTypeChanged(entityType);
                        }
                    } else {
                        this._loadConfigBasedDimensions();
                    }
                }
            },

            _prepareContext: function () {

                var context = DataHelper.cloneObject(this.contextData);

                if (!_.isEmpty(this.entityType)) {
                    context[ContextHelper.CONTEXT_TYPE_ITEM] = [{
                        "type": this.entityType
                    }];
                }

                if (!_.isEmpty(this.appName) && !_.isEmpty(this.domain)) {
                    context[ContextHelper.CONTEXT_TYPE_APP] = [{
                        "app": this.appName
                    }];

                    context[ContextHelper.CONTEXT_TYPE_DOMAIN] = [{
                        "domain": this.domain
                    }];

                    if (!_.isEmpty(context)) {
                        this.requestConfig('rock-dimension-selector', context);
                    }
                }
            },

            _prepareConfigForDynamicDimensions: function (configData) {
                if (this.dynamicDimensionsConfig) {
                    var selectedDimensions = this.dynamicDimensionsConfig.selectedDimensions;
                    var readonlyDimensions = this.dynamicDimensionsConfig.readonlyDimensions;
                    var contextDimensions = this.dynamicDimensionsConfig.contextDimensions;

                    for (var i = 0; i < configData.length; i++) {
                        if (configData[i].dataMappings && configData[i].dataMappings.type &&
                            configData[i].dataMappings.type.length) {
                            //Attribute mappings selected dimensions
                            if (selectedDimensions) {
                                var selectedDimension = selectedDimensions[configData[i].dataMappings.type[0]];
                                if (!_.isEmpty(selectedDimension)) {
                                    if (configData[i].displayType != "dialog") {
                                        configData[i].selectedItem = {
                                            "id": selectedDimension[0],
                                            "title": selectedDimension[0],
                                            "type": configData[i].dataMappings.type[0]
                                        }
                                    } else {
                                        var selectedClassificationsConfig = {
                                            "classifications": [selectedDimension[0].split(">>")],
                                            "path": selectedDimension[0]
                                        };
                                        this._selectedClassificationsConfig[configData[i].id] = configData[i].selectedItem = selectedClassificationsConfig;
                                    }
                                }
                            }

                            //Readonly dimensions
                            if (readonlyDimensions.indexOf(configData[i].dataMappings.type[0]) != -1) {
                                configData[i].readonly = true;
                            }
                        }
                    }

                    //Additional dimensions
                    if (contextDimensions) {
                        for (var i = 0; i < contextDimensions.length; i++) {
                            configData.push(this._prepareDimensionTemplate(contextDimensions[i]));
                        }
                    }
                }

                return configData
            },

            _prepareDimensionTemplate: function (dimension) {
                return {
                    "id": dimension,
                    "title": dimension,
                    "icon": "pebble-icon:hierarchy",
                    "visible": true,
                    "hidden": false,
                    "dimensionType": "data",
                    "dataRequestType": "entity",
                    "dataMappings": {
                        "id": "name",
                        "title": "name",
                        "subtitle": "",
                        "image": "",
                        "icon": "",
                        "type": [
                            dimension
                        ]
                    },
                    "default": ""
                }
            },

            _compareRequestType: function (dataRequestType, entityTypeInfo) {
                return dataRequestType === entityTypeInfo;
            },

            _getSelectedItems: function (selectedItem) {
                // Todo.. This is not a correct code lov must support selectedid

                if (!_.isEmpty(selectedItem)) {
                    var formattedSelectedItems = [];
                    var formattedSelectedItem = {};

                    formattedSelectedItem["id"] = selectedItem.id ? selectedItem.id : this._default.id;
                    formattedSelectedItem["title"] = selectedItem.title ? selectedItem.title : this._default.title;
                    formattedSelectedItem["type"] = selectedItem.type ? selectedItem.type : this._default.type;

                    if (selectedItem.type == "locale") {
                        var _localeObj = ComponentHelper.getLocaleManager().getByName(selectedItem.id);
                        if (!_.isEmpty(_localeObj) && _localeObj.externalName) {
                            formattedSelectedItem["title"] = _localeObj.externalName;
                        }
                    }

                    formattedSelectedItems.push(formattedSelectedItem);

                    return formattedSelectedItems
                }
            },

            _getSelectedItem: function(selectedItem) {
                if(this.allSingleSelect) {
                    var selectedItems = this._getSelectedItems(selectedItem);
                    if(!_.isEmpty(selectedItems)) {
                        return selectedItems[0];
                    }
                }

                return {};
            },

            _onToggleButtonTap: function (event) {
                if (event.currentTarget.disabled == true) {
                    return;
                }
                if (typeof (event.currentTarget) !== "undefined") {
                    this._currentDimensionSelector = event.currentTarget;
                    if (event.model.ctx.displayType != "dialog") {
                        this._toggleLovPopover(this._currentDimensionSelector.popover);
                    } else {
                        if(!this.classificationTaxonomy && event.model.ctx.displayType == "dialog"){
                            this.showErrorToast("No classification available. Please select taxonomy.");
                            return;
                        }
                        this._classificationDialogOpen();
                    }
                }
            },

            _onEntityLovConfirmButtonTapped: function (event) {
                this._isClassificationSelectionTriggered = false;
                this._currentLovEvent = event;
                if (this.showConfirmation) {
                    if (this.confirmationDialog) {
                        this.confirmationDialog.open();
                    }
                    return;
                }
                this._triggerLovConfirmButtonTapped();
            },

            _triggerLovConfirmButtonTapped: function (togglePopover = true) {
                if (!this.allMultiSelect) {
                    var currentLovId = this._currentLovEvent.detail.data.id;
                    var currentRockLov = this.shadowRoot.querySelector("#" + currentLovId);
                    var switchToMultiSelect = true;

                    if (currentRockLov.multiSelect) {
                        if (currentRockLov.selectedItems.length > 1) {
                            switchToMultiSelect = !currentRockLov.multiSelect;
                        }

                        for (var i = 0; i < this._contextToBeRendered.length; i++) {
                            var configDataItem = this._contextToBeRendered[i];
                            var rockLov;

                            if (configDataItem.dataRequestType == "entity") {
                                rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-lov");
                            }
                            if (configDataItem.dataRequestType == "entity-context") {
                                rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-context-lov");
                            }

                            if (configDataItem.dataRequestType == "entity-model") {
                                rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-model-lov");
                            }

                            if (typeof (rockLov) !== "undefined" && rockLov && rockLov.id !== currentLovId && rockLov.multiSelect !== switchToMultiSelect && (typeof (configDataItem.multiSelect) == "undefined" || configDataItem.multiSelect)) {
                                this._toggleLovSelectionMode(rockLov, switchToMultiSelect);
                            }
                        }
                    }
                }

                this._updateSelectedDimensions();
                if (togglePopover) {
                    this._toggleLovPopover(this._currentDimensionSelector.popover);
                }
            },

            _onContextLovSelectedInfoApplied: function () {
                this._setSelectedDimensions();
            },

            _toggleLovSelectionMode: function (rockLov, switchToMultiSelect) {
                if (switchToMultiSelect) {
                    var selectedItem = rockLov.selectedItem;
                    rockLov.multiSelect = switchToMultiSelect;

                    if (typeof (selectedItem) !== "undefined" && !_.isEmpty(selectedItem)) {
                        rockLov.push("selectedItems", selectedItem);
                    }

                    rockLov.refershTemplate();
                } else {
                    var selectedItems = rockLov.selectedItems
                    rockLov.multiSelect = switchToMultiSelect;

                    if (typeof (selectedItems) !== "undefined" && selectedItems.length > 0) {
                        rockLov.selectedItem = selectedItems[0];
                    } else {
                        rockLov.selectedItem = {};
                    }

                    rockLov.refershTemplate();
                }
            },

            _onEntityLovCloseButtonTapped: function () {
                this._toggleLovPopover(this._currentDimensionSelector.popover);
            },

            _toggleLovPopover: function (popoverId) {
                var currentPopover = this.shadowRoot.querySelector("#" + popoverId);
                if (!_.isEmpty(currentPopover)) {
                    if (!currentPopover.opened) {
                        currentPopover.show();
                    } else {
                        currentPopover.hide();
                    }
                }
            },

            _updateToggleButtonText: function (configDataItem, rockLov) {
                var toggleButton = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("pebble-button");
                var buttonText = configDataItem.title;

                if (!rockLov.multiSelect) {
                    // Ask Jimmy.... What should be label field for selected dimension
                    buttonText = rockLov.selectedItem.id
                } else {
                    buttonText = rockLov.selectedItems.length + "" + configDataItem.title + "s " +
                        "Selected";
                }

                toggleButton.buttonText = buttonText;
            },

            _getSelectedItemsInfo: function (dimensionSelector) {
                var dimensionSelectedItem;
                var dimensionSelectedItems = [];

                if (dimensionSelector.lov.multiSelect) {
                    if (dimensionSelector.lov.selectedItems.length > 0) {
                        dimensionSelectedItem = dimensionSelector.lov.selectedItems[0];
                        dimensionSelectedItems = dimensionSelector.lov.selectedItems;
                    }
                } else {
                    if (dimensionSelector.lov.selectedItem) {
                        dimensionSelectedItems.push(dimensionSelector.lov.selectedItem);
                        dimensionSelectedItem = dimensionSelector.lov.selectedItem;
                    }
                }

                return {
                    multiSelect: dimensionSelector.lov.multiSelect,
                    selectedItem: dimensionSelectedItem,
                    selectedItems: dimensionSelectedItems,
                }
            },

            _getSelectedValue: function (data, selectedItems) {
                if (data != undefined && data != null) {
                    for (var i = 0; i < data.length; i++) {
                        if (this._indexOfItem(selectedItems, data[i])) {
                            return data[i].value;
                        }
                    }
                }
            },

            _indexOfItem: function (selectedItems, selectedItemToCompare) {
                var isSelected = false;

                selectedItems.forEach(function (item) {
                    if (item.id == selectedItemToCompare.id) {
                        isSelected = true;
                    }
                }, this);

                return isSelected;
            },

            _setSelectedDimension: function () {
                this.selectedDimensions = undefined;
                this.selectedDimensions = {
                    "lists": this.listSelector.selectedItems,
                    "sources": this.sourceSelector.selectedItems,
                    "locales": this.localeSelector.selectedItems
                };
            },

            _getItemsIdsByType: function (items, type) {
                var itemsIds = [];
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        if (items[i].type === type) {
                            var itemId = this._getItemId(items[i]);
                            if (!_.isEmpty(itemId)) {
                                itemsIds.push(itemId);
                            }
                        }
                    }
                }
                return itemsIds;
            },

            _getItemId: function (item) {
                if (item) {
                    var itemId = this.get("id", item);

                    if (typeof (itemId) == "undefined" || typeof (itemId) == "null") {
                        itemId = ""; // Could be -1 or ""?
                    }

                    return itemId;
                }
            },

            _getClassificationValuePath: function (classification) {
                var valuePath = "";
                if (classification && classification.valuePath) {
                    var categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                    var valuePath = classification.valuePath.replace(/#@#/g, categoryPathSeperator);
                }

                return valuePath;
            },

            _setClassificationTitle: function (currentClassification) {
                if (!currentClassification) {
                    return;
                }

                var currentDimensionButtonId = currentClassification.id.replace("-contextTree", "-toggle-button");
                var buttonText = "";
                var toolTip = "";
                if (currentClassification.selectedClassifications && currentClassification.selectedClassifications.length > 0) {
                    for (var i = 0; i < currentClassification.selectedClassifications.length; i++) {
                        var valuePath = this._getClassificationValuePath(currentClassification.selectedClassifications[i]);
                        if (buttonText) {
                            buttonText = buttonText + ", " + valuePath;
                        } else {
                            buttonText = valuePath;
                        }
                    }
                    toolTip = buttonText; //Set tooltip
                    if (!buttonText) {
                        var configClassificationId = currentClassification.id.replace("-contextTree", "");
                        if (this._selectedClassificationsConfig[configClassificationId]) {
                            buttonText = toolTip = this._selectedClassificationsConfig[configClassificationId].path;
                        } else {
                            buttonText = toolTip = currentClassification.parentElement.title;
                        }
                    }
                    if (currentClassification.selectedClassifications.length > 1) {
                        buttonText = currentClassification.selectedClassifications.length + " " + buttonText;
                    }
                    var currentButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                    if (currentButton) {
                        currentButton.buttonText = buttonText;
                        currentButton.setAttribute("data-tooltip", toolTip);
                    }
                }
            },

            _isDialogType: function (displayType) {
                if (displayType == "dialog") {
                    return true;
                }

                return false;
            },

            _classificationDialogOpen: function () {
                var classificationDialog = this.shadowRoot.querySelector("#" + this._currentDimensionSelector.popover);
                var currentValuePath = "";
                var selectedClassifications = [];

                var currentContextId = this._currentDimensionSelector.id.replace("-toggle-button", "-contextTree");
                var contextTree = this.shadowRoot.querySelector("#" + currentContextId);
                //selectedClassifications = this._getPathsForClassificationTree(contextTree.selectedClassifications);
                if (this.selectedDimensions && this.selectedDimensions["classification"] && this.selectedDimensions["classification"].length) {
                    selectedClassifications = [this.selectedDimensions["classification"][0].split(">>")];
                }
                //If refresh needs every time on dialog open, then remove >> selectedClassifications.length == 0
                if (contextTree) {
                    var configClassificationId = this._currentDimensionSelector.id.replace("-toggle-button", "");
                    if (this._selectedClassificationsConfig[configClassificationId]) {
                        selectedClassifications = this._selectedClassificationsConfig[configClassificationId].classifications;
                    }
                    contextTree.selectedClassifications = selectedClassifications;
                    contextTree.generateRequest();
                }

                if (classificationDialog) {
                    classificationDialog.dialogTitle = "Select Classification";
                    classificationDialog.open();
                }
            },

            _getPathsForClassificationTree: function (selectedClassifications) {
                var classificationPaths = [];
                var valuePathSeperator = "#@#";
                if (selectedClassifications && selectedClassifications.length > 0) {
                    for (var i = 0; i < selectedClassifications.length; i++) {
                        if (selectedClassifications[i] && selectedClassifications[i].valuePath) {
                            var paths = selectedClassifications[i].valuePath.split(valuePathSeperator)
                            classificationPaths.push(paths);
                        }
                    }
                }

                return classificationPaths;
            },

            _onCancelClassificationSelection: function () {
                var classificationDialog = this.shadowRoot.querySelector("#" + this._currentDimensionSelector.popover);
                if (classificationDialog) {
                    classificationDialog.close();
                }
            },

            _selectClassification: function (e) {
                this._isClassificationSelectionTriggered = true;
                if (this.showClassificationConfirmation) {
                    if (this.confirmationDialog) {
                        this.confirmationDialog.open();
                    }
                    return;
                }
                this._triggerClassificationChange();
            },

            _onTapConfirmationOK: function (event) {
                if (this._isClassificationSelectionTriggered) {
                    this._triggerClassificationChange();
                } else {
                    this._triggerLovConfirmButtonTapped(false);
                }
                this.fireBedrockEvent("dimension-selector-confirmation-ok", event);
            },

            _onTapConfirmationCancel: function (event) {
                if (this._isClassificationSelectionTriggered) {
                    this._onCancelClassificationSelection();
                }

                this.fireBedrockEvent("dimension-selector-confirmation-cancel", event);
            },

            _triggerClassificationChange: function () {
                var currentContextId = this._currentDimensionSelector.id.replace("-toggle-button", "-contextTree");
                var contextTree = this.$$("#" + currentContextId);
                if (contextTree) {
                    if (contextTree.selectedClassifications && contextTree.selectedClassifications.length > 0) {
                        this._updateSelectedDimensions();
                    }
                }
                this._onCancelClassificationSelection();
            },

            _getClassificationTaxonomy: function (configTaxonomy, taxonomy) {
                this.clearClassificationSelection(); //Clear classification on taxonomy change
                this._updateSelectedDimensions();
                if (taxonomy) {
                    return taxonomy
                }
                return configTaxonomy;
            },

            _entityTypeChanged: function (entityType) {
                if (!_.isEmpty(entityType)) {

                    this._contextModelGetReq = DataRequestHelper.createContextModelGetRequest(entityType);

                    var liquidElement = this.$$('#contextModelGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    }
                    this._createContextGetRequest(this.entityId, entityType);                   
                }
            },

            _onContextModelGetResponse: function (e) {
                var response = e.detail.response.response;

                if (response) {
                    var entityModels = response.entityModels;

                    if (!_.isEmpty(entityModels)) {
                        var entityModel = entityModels[0];
                        var contexts = "data" in entityModel ? entityModel.data.contexts : undefined;
                        var _ctxKeys = [];

                        var globalCoalescePath = DataHelper.isValidObjectPath(entityModel, "properties.globalCoalescePath") && entityModel.properties.globalCoalescePath;
                        this._contextHierarchyInfo = DataHelper.isValidObjectPath(entityModel, "properties.globalCoalesceInfo") && entityModel.properties.globalCoalesceInfo;

                        if (!_.isEmpty(globalCoalescePath)) {
                            this._contextHierarchy = globalCoalescePath.split(">>");
                        } else {
                            this.showErrorToast("Global coalesce path is not defined in:" + entityModel.id);
                        }

                        if (contexts) {
                            var _contexts = [];
                            contexts.forEach(function (context) {
                                _contexts.push(context.context);

                                var ctxKeys = Object.keys(context.context);
                                if (ctxKeys && ctxKeys.length) {
                                    ctxKeys.forEach(function (ctxKey) {
                                        if (_ctxKeys.indexOf(ctxKey) < 0) {
                                            _ctxKeys.push(ctxKey);
                                        }
                                    }, this);
                                }

                                if(context.properties && context.properties.dataCoalescePath) {
                                    var dataCoalescePath = context.properties.dataCoalescePath;
                                    var paths = dataCoalescePath.split(">>");

                                    for(let idx = 0; idx < this._contextHierarchyInfo.length; idx++) {
                                        var ctxHeirarchy = this._contextHierarchyInfo[idx];
                                        var dataIdx = paths.indexOf(ctxHeirarchy.contextKey);
                                        if(dataIdx > 0 && !ctxHeirarchy.relTo) {
                                            var relName = paths[dataIdx - 1];
                                            var relType = relName && relName.indexOf("belongsto") > -1 ? relName.substring("belongsto".length, relName.length) : undefined;
                                            ctxHeirarchy.relTo = relType;
                                        }
                                    }
                                }
                            }, this);

                            this._contexts = _contexts;
                        }

                        var _ctxIds = [];
                        if (_ctxKeys && _ctxKeys.length) {
                            _ctxKeys.forEach(function (item) {
                                if (item) {
                                    _ctxIds.push(item);
                                }
                            }, this);
                        }

                        var ctxIds = [];
                        var missingContextModel = [];
                        if (this.configData && this.configData.length) {
                            this.configData.forEach(function (item) {
                                if (!item.useContextModel) {
                                    if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                                        var type = item.dataMappings.type[0];

                                        if (type) {
                                            if (item.dataRequestType != "entity-context") {
                                                ctxIds.push(type + "_entityManageModel");
                                            }

                                            if (this._contextHierarchy.indexOf(type) < 0) {
                                                this._contextHierarchy.push(type);
                                            }
                                        }
                                    }
                                } else if (item.useContextModel) {
                                    if (_ctxIds.indexOf(item.id) > -1) {
                                        if (item.dataRequestType != "entity-context") {
                                            ctxIds.push(item.id + "_entityManageModel");
                                        }
                                    } else {
                                        missingContextModel.push(item.id);
                                    }
                                }
                            }, this);
                        }

                        if (missingContextModel && missingContextModel.length) {
                            var message = "Dimension(s): " + missingContextModel.join(", ") + " are configured but not present in context model for entity type: " + this.entityType;
                            this.showErrorToast(message, 5000);
                        }

                        if (ctxIds && ctxIds.length) {
                            this._entityModelRequest = {
                                "params": {
                                    "query": {
                                        "ids": ctxIds,
                                        "filters": {
                                            "typesCriterion": [
                                                "entityManageModel"
                                            ]
                                        }
                                    },
                                    "fields": {
                                        "attributes": [
                                            "_ALL"
                                        ],
                                        "relationships": [
                                            "_ALL"
                                        ],
                                        "relationshipAttributes": [
                                            "_ALL"
                                        ]
                                    }
                                }
                            };

                            var entityModelGetComponent = this.$$("#entityModelGet");

                            if (entityModelGetComponent) {
                                entityModelGetComponent.generateRequest();
                            }
                        }
                    }
                }
            },

            _onContextModelGetFailed: function (e) {
                // Error msg . . .
            },

            _loadConfigBasedDimensions: function () {
                var ctxIds = [];
                if (this.configData && this.configData.length) {
                    this.configData.forEach(function (item) {
                        if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                            var type = item.dataMappings.type[0];

                            if (type) {
                                if (item.dataRequestType != "entity-context") {
                                    ctxIds.push(type + "_entityManageModel");
                                }

                                if (this._contextHierarchy.indexOf(type) < 0) {
                                    this._contextHierarchy.push(type);
                                }
                            }
                        }
                    }, this);
                }

                if (ctxIds && ctxIds.length) {
                    this._entityModelRequest = {
                        "params": {
                            "query": {
                                "ids": ctxIds,
                                "filters": {
                                    "typesCriterion": [
                                        "entityManageModel"
                                    ]
                                }
                            },
                            "fields": {
                                "attributes": [
                                    "_ALL"
                                ]
                            }
                        }
                    };

                    var entityModelGetComponent = this.$$("#entityModelGet");

                    if (entityModelGetComponent) {
                        entityModelGetComponent.generateRequest();
                    }
                }
            },

            _onEntityModelGetResponse: function (e) {
                var response = e.detail.response.response;
                if (response && response.entityModels) {
                    this._prepareDynamicConfigBasedOnModelForContextsToBeRendered(response.entityModels);
                    this._updateSelectedDimensions();
                }
            },

            _prepareDynamicConfigBasedOnModelForContextsToBeRendered: function (entityModels) {
                if (entityModels && entityModels.length) {
                    var ctxs = {};
                    entityModels.forEach(function (entityModel) {
                        var ctxKey = entityModel.name;
                        var reqData = {
                            "params": {
                                "query": {
                                    "filters": {
                                        "typesCriterion": [
                                            ctxKey
                                        ]
                                    },
                                    "valueContexts": []
                                },
                                "fields": {
                                    "attributes": ['_ALL']
                                }
                            }
                        };

                        reqData.params.query.valueContexts.push(DataHelper.getDefaultValContext());

                        var ctxToBeLoaded = this._contextDataToBeLoaded(ctxKey);
                        var ctxExtName = ctxKey;
                        var externalAttrName = undefined;
                        var externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);

                        if (externalNameAndExternalNameAttr) {
                            externalAttrName = externalNameAndExternalNameAttr.externalNameAttr;
                            ctxExtName = !_.isEmpty(externalNameAndExternalNameAttr.externalName) ? externalNameAndExternalNameAttr.externalName : ctxKey;
                        }

                        if (ctxToBeLoaded && ctxToBeLoaded.length && (ctxToBeLoaded.length == 1 && ctxToBeLoaded[0] != "_ALL")) {
                            var attributesCriterion = [];
                            if (externalAttrName) {
                                var attrCriterion = {};
                                attrCriterion[externalAttrName] = {
                                    "exacts": ctxToBeLoaded
                                }
                                attributesCriterion.push(attrCriterion);
                                reqData.params.query.filters.attributesCriterion = attributesCriterion;
                            }
                        }

                        var titlePattern = "{entity.attributes." + externalAttrName + "}";
                        var mappedValueContexts = this._getMappedValueContextsBasedOnCtxType(ctxKey);

                        if (mappedValueContexts) {
                            var dependentRelationships = mappedValueContexts.map(v => v.valueContextRelationship);

                            if (dependentRelationships) {
                                reqData.params.fields.relationships = dependentRelationships;
                                reqData.params.fields.relationshipAttributes = [this._getDefaultSelectedAttrName()];
                            }
                        }

                        ctxs[ctxKey] = {
                            "id": ctxKey,
                            "title": ctxExtName,
                            "ctxName": ctxKey,
                            "externalAttrName": externalAttrName,
                            "dataRequestType": "entity",
                            "dataRequest": reqData,
                            "mappedValueContexts": mappedValueContexts,
                            "dataMappings": {
                                "id": "name",
                                "title": titlePattern,
                                "type": [ctxKey]
                            }
                        };

                    }, this);

                    this._mergeConfigAndDynamicConfigForContextRender(ctxs);
                }
            },

            _mergeConfigAndDynamicConfigForContextRender: function (ctxs) {
                this.configData.forEach(function (item) {
                    if (item) {

                        var ctx = ctxs[item.id];

                        if (ctx) {
                            var mergedCtx = undefined;

                            if (item.dataRequestType == "entity-model" && "dataRequest" in ctx) {
                                delete ctx.dataRequest.params.query.valueContexts;
                            }

                            ctx = { "config": ctx };

                            // Deleting external dataMappings id and title coming from config
                            // Because assumption is for any entity-lov iExternalName attribute will be title of it.
                            if ("dataMappings" in item) {
                                delete item.dataMappings.title;
                            }

                            item = { "config": item };

                            mergedCtx = SharedUtils.DataObjectFalcorUtil.mergeObjectsNoOverride(ctx, item, true);

                            if (mergedCtx && mergedCtx.config) {
                                ctx = mergedCtx.config;
                            }
                        } else {
                            if (item.dimensionType == "data" && item.dataRequestType == "entity-context") {
                                ctx = item;
                                ctx.dataMappings = {
                                    "id": "name",
                                    "title": "name",
                                    "type": [
                                        item.id
                                    ]
                                }
                                ctxs[item.id] = ctx;
                            } else if (!this._isContextLoad) {
                                ctxs[item.id] = item;
                            }
                        }
                    }
                }, this);

                var parsedContexts = [];
                this._contextHierarchy.forEach(function (ctxKey) {
                    if (ctxs[ctxKey]) {
                        parsedContexts.push(ctxs[ctxKey]);
                    }
                }, this);

                this._contextToBeRendered = undefined;
                this._contextToBeRendered = parsedContexts;
            },

            _updateSelectedDimensions: function () {
                this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(100), () => {
                    this._setSelectedDimensions();
                    if (this._isContextLoad) {
                        this._updateCurrentContextState();
                    }
                });
            },

            _setSelectedDimensions: function () {
                var selectedDimensions = {};
                var configData = this._contextToBeRendered;
                var _taxonomyTitle = "";
                var _isPrimaryContext = false;
                if (typeof (configData) !== "undefined") {
                    for (var i = 0; i < configData.length; i++) {
                        var configDataItem = configData[i];
                        var rockLov, rockClassification;
                        var rockContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                        if (rockContainer) {
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                                if (configDataItem.displayType != "dialog") {
                                    rockLov = rockContainer.querySelector("rock-entity-lov");
                                } else {
                                    rockClassification = rockContainer.querySelector("rock-classification-tree");
                                }
                            }
                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                                if (configDataItem.displayType != "dialog") {
                                    rockLov = rockContainer.querySelector("rock-context-lov");
                                } else {
                                    rockClassification = rockContainer.querySelector("rock-classification-tree");
                                }
                            }

                            if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                                rockLov = rockContainer.querySelector("rock-entity-model-lov");
                            }

                            if (rockLov || rockClassification) { //typeof (rockLov) !== "undefined"
                                const { dataMappings } = configDataItem;
                                var entityTypes = dataMappings && dataMappings.type;

                                if (entityTypes) {
                                    for (var j = 0; j < entityTypes.length; j++) {
                                        if (configDataItem.displayType != "dialog") {
                                            var ctxKey = !_.isEmpty(configDataItem.contextKeyName) ? configDataItem.contextKeyName : entityTypes[j];
                                            if (!rockLov.multiSelect) {
                                                var selectedItem = !_.isEmpty(rockLov.selectedItem) ? rockLov.selectedItem : undefined;
                                                var selectedItems = !_.isEmpty(rockLov.selectedItems) ? rockLov.selectedItems : undefined;
                                                if (selectedItems) {
                                                    rockLov.selectedItem = selectedItem ? selectedItem : selectedItems[0];
                                                }
                                                if(entityTypes[j] === "taxonomy"){
                                                    if(rockLov.selectedItem){
                                                        _taxonomyTitle = rockLov.selectedItem.title;
                                                        this.classificationTaxonomy = rockLov.selectedItem.id
                                                    }else{
                                                        this.classificationTaxonomy = "";
                                                    }
                                                }
                                                if(this._compareRequestType(configDataItem.dataRequestType, 'entity') && !_.isEmpty(rockLov.selectedItem) && configDataItem.ctxName != "locale" && configDataItem.ctxName != "source"){
                                                    _isPrimaryContext = true;
                                                }

                                                var itemId = this._getItemId(rockLov.selectedItem);
                                                selectedDimensions[ctxKey] = itemId ? [itemId] : [];
                                                this.selectedDimensionsDetail[ctxKey] = !_.isEmpty(rockLov.selectedItem) ? [rockLov.selectedItem] : [];
                                            } else {
                                                selectedDimensions[ctxKey] = this._getItemsIdsByType(
                                                    rockLov.selectedItems, entityTypes[j]);
                                                this.selectedDimensionsDetail[ctxKey] = rockLov.selectedItems;
                                            }
                                        } else {
                                            var selectedItems = [];
                                            var ctxKey = !_.isEmpty(configDataItem.contextKeyName) ? configDataItem.contextKeyName : entityTypes[j];
                                            if (rockClassification && rockClassification.selectedClassifications &&
                                                rockClassification.selectedClassifications.length > 0) {
                                                if (!rockClassification.multiSelect) {
                                                    if (rockClassification.selectedClassifications[0]) {
                                                        var valuePath = this._getClassificationValuePath(rockClassification.selectedClassifications[0]);
                                                        if (valuePath) {
                                                            selectedItems.push(valuePath);
                                                        }
                                                        this.selectedDimensionsDetail[ctxKey] = [{
                                                            "path": valuePath,
                                                            "classification": { "valuePath" : rockClassification.selectedClassifications[0].valuePath }
                                                        }];
                                                    }
                                                } else {
                                                    this.selectedDimensionsDetail[ctxKey] = [];
                                                    for (var k = 0; k < rockClassification.selectedClassifications.length; k++) {
                                                        var valuePath = this._getClassificationValuePath(rockClassification.selectedClassifications[k]);
                                                        if (valuePath) {
                                                            selectedItems.push(valuePath);
                                                        }
                                                        var classificationObj = {
                                                            "path": valuePath,
                                                            "classification": { "valuePath" : rockClassification.selectedClassifications[k].valuePath }
                                                        }
                                                        this.selectedDimensionsDetail[ctxKey].push(classificationObj);
                                                    }
                                                }
                                            }

                                            //Apply selectedItems from config
                                            if (!selectedItems || selectedItems.length == 0 && !_.isEmpty(configDataItem.selectedItem)) {
                                                rockClassification.selectedClassifications = configDataItem.selectedItem.classifications;
                                                selectedItems.push(configDataItem.selectedItem.path);
                                            }

                                            selectedDimensions[entityTypes[j]] = selectedItems;
                                        }
                                    }
                                }

                                if (configDataItem.displayType != "dialog") {
                                    this._setLovTitle(rockLov);
                                } else {
                                    this._setClassificationTitle(rockClassification);
                                }
                            }
                        }
                        // this._updateToggleButtonText(configDataItem, rockLov);
                    }
                    

                    var eventDetail = {
                        'dimensions': selectedDimensions
                    };
                    if(DataHelper.isValidObjectPath(this._currentLovEvent,"detail.data.id")){
                        eventDetail.currentLovId = this._currentLovEvent.detail.data.id;
                    }
                    if(this._isClassificationSelectionTriggered){
                        eventDetail.currentLovId = "classification-dialog";
                    }
                    eventDetail.isPrimaryContext = _isPrimaryContext
                    eventDetail.taxonomyTitle = _taxonomyTitle;
                    if(this.selectedDimensions && selectedDimensions){
                        if(DataHelper.compareObjects(this.selectedDimensions, selectedDimensions)) {
                            return true;
                        }
                    }
                    this.set("selectedDimensions", selectedDimensions);
                    Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(500), () => {
                        this.fireBedrockEvent("dimension-selector-data-changed", eventDetail);
                    });
                }
            },

            _updateCurrentContextState: function () {
                if (!_.isEmpty(this.selectedDimensions)) {

                    // Get context(s) based on selected dimension
                    var filteredCtx = this._getContextsBasedOnSelectedDimension();

                    if (filteredCtx && filteredCtx.length) {

                        // Get flattened structure of filtered contexts
                        var flattenedCtx = this._getFlattenedContexts(filteredCtx, true);
                        this._currentContexts = flattenedCtx;


                        // Set filtered context to dimension and reset dimensions
                        if (flattenedCtx) {
                            var flattenedCtxKeys = Object.keys(flattenedCtx);
                            var dependentLovRelationships = {};

                            this._contextHierarchy.forEach(function (item) {
                                var lovElement = this.$$('#' + item + '-lov');
                                var itemIdx = this._contextHierarchy.indexOf(item);

                                if (lovElement) {
                                    ctxData = lovElement.rData;
                                    var selectedItems = this.selectedDimensionsDetail[item];
                                    var ctxHierarchy = this._contextHierarchyInfo.find(v => v.contextKey === item);
                                    if(ctxData && ctxData.dataRequestType !== "entity-context" 
                                        && ctxHierarchy && ctxHierarchy.relTo && itemIdx > 0 
                                        && this._contextHierarchy[itemIdx-1].indexOf(ctxHierarchy.relTo) > -1 
                                        && _.isEmpty(this.selectedDimensionsDetail[this._contextHierarchy[itemIdx-1]])) {
                                            selectedItems = [];
                                    }

                                    //Prepare list of dependent lov's and it's relationships based on selected dimension.
                                    // This list will be used when dependent lov will get reset with related entities which are mapped to current context as relationship.
                                    this._setDependentValCtxLovRelationships(ctxData, selectedItems, dependentLovRelationships);

                                    if (ctxData) {
                                        if (ctxData.dataRequestType == "entity-context") {
                                            lovElement.selectedItems = this._getSelectedCtxItems(item);
                                            lovElement.items = [];
                                            lovElement.reset();
                                        } else {
                                            var reqData = ctxData.dataRequest;
                                            var ctxToBeLoaded = flattenedCtx[item];

                                            if (reqData) {
                                                if (ctxToBeLoaded && ctxToBeLoaded.length && ctxToBeLoaded.indexOf('_ALL') < 0 && ctxData.externalAttrName) {
                                                    var attributesCriterion = [];
                                                    var attrCriterion = {};
                                                    attrCriterion[ctxData.externalAttrName] = {
                                                        "exacts": ctxToBeLoaded
                                                    }

                                                    attributesCriterion.push(attrCriterion);
                                                    reqData.params.query.filters.attributesCriterion = attributesCriterion;
                                                    selectedItems = this._getSelectedCtxItems(item, ctxToBeLoaded);
                                                } else {
                                                    delete reqData.params.query.filters.attributesCriterion;
                                                }

                                                lovElement.selectedItems = selectedItems;
                                                lovElement.selectedItem = !_.isEmpty(selectedItems) ? selectedItems[0] : {};
                                                lovElement.requestData = reqData;
                                                lovElement.reset();
                                            }
                                        }
                                    }
                                }
                            }, this);

                            // if dimension is "value" type then need to check for "dependentLovRelationships" if this dimension is mapped as dependent Lov.
                            var valueTypeDimensions = this.configData.filter(v => v.dimensionType == "value");
                            if (valueTypeDimensions) {
                                for (let valueTypeDimension of valueTypeDimensions) {
                                    var ctxType = valueTypeDimension.id;
                                    var lovElement = this.$$('#' + ctxType + '-lov');

                                    if (lovElement) {
                                        var ctxData = lovElement.rData;
                                        var selectedItems = this.selectedDimensionsDetail[ctxType];
                                        if (ctxData) {
                                            var reqData = ctxData.dataRequest;
                                            if (reqData) {
                                                if (!_.isEmpty(dependentLovRelationships[ctxType])) {
                                                    reqData.params.query.ids = dependentLovRelationships[ctxType];
                                                } else {
                                                    delete reqData.params.query.ids;
                                                }
                                            }
                                        }

                                        lovElement.selectedItems = selectedItems;
                                        lovElement.requestData = reqData;
                                        lovElement.reset();
                                    }
                                }
                            }
                        }
                    }
                    this._setSelectedDimensions();
                }
            },

            _getMappedValueContextsBasedOnCtxType: function (currentContextType) {
                if (currentContextType) {
                    var globalCtxInfo = this._contextHierarchyInfo && this._contextHierarchyInfo.find(v => v.contextKey == currentContextType);
                    if (globalCtxInfo && globalCtxInfo.mappedValueContexts) {
                        return globalCtxInfo.mappedValueContexts
                    }
                }
            },

            _contextDataToBeLoaded: function (contextKey) {
                var ctxValue = [];
                if (contextKey) {
                    for (var i = 0; i <= this._contexts.length; i++) {
                        if (this._contexts[i] && this._contexts[i][contextKey]) {
                            var ctx = this._contexts[i][contextKey];
                            if (Array.isArray(ctx)) {
                                ctx.forEach(function (item) {
                                    if (ctxValue.indexOf(item) < 0) {
                                        ctxValue.push(item);
                                    }
                                }, this);
                            } else {
                                if (ctx.toLowerCase() == "_all") {
                                    ctxValue = ["_ALL"];
                                    break;
                                } else {
                                    if (ctxValue.indexOf(ctx) < 0) {
                                        ctxValue.push(ctx);
                                    }
                                }
                            }
                        }
                    }
                }
                return ctxValue;
            },

            _setDependentValCtxLovRelationships: function (elementInfo, selectedItems, dependentLovRelationships) {
                if (elementInfo && !_.isEmpty(selectedItems)) {
                    var mappedValueContexts = this._getMappedValueContextsBasedOnCtxType(elementInfo.id);

                    if (mappedValueContexts) {
                        var dependentCtxs = mappedValueContexts.map(a => a.valueContext);

                        if (dependentCtxs) {
                            for (let dctxs of dependentCtxs) {
                                if (!dependentLovRelationships[dctxs]) {
                                    dependentLovRelationships[dctxs] = [];
                                }

                                for (let selectedItem of selectedItems) {
                                    if (selectedItem.relTo) {
                                        var relIds = selectedItem.relTo.map(function (rel) {
                                            if (rel.relTo.type == dctxs) {
                                                return rel.relTo.id;
                                            }
                                        });

                                        if (!_.isEmpty(relIds)) {
                                            dependentLovRelationships[dctxs] = dependentLovRelationships[dctxs].concat(relIds);
                                        } else {
                                            delete dependentLovRelationships[dctxs];
                                            break;
                                        }
                                    } else {
                                        delete dependentLovRelationships[dctxs];
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            },

            _onEntityContextGetResponse: function (e) {
                var response = e.detail.response.response;

                if (response) {
                    if (response.entities && response.entities.length) {
                        var entity = response.entities[0];

                        if (entity && entity.data && entity.data.contexts) {
                            var _entityContexts = [];

                            entity.data.contexts.forEach(function (ctx) {
                                _entityContexts.push(ctx.context)
                            }, this);

                            this._entityContexts = _entityContexts;
                        }
                    }
                    this.refreshDimensionData();
                }
            },

            _entityExternalDataFormatter: function (formattedData, data) {
                if (formattedData && formattedData.length) {
                    var elementInfo = this.rData;

                    if (elementInfo) {
                        var ctxType = elementInfo.id;

                        // Add relationship detail into formatted item if entity has dependent relationship
                        // If entity has dependent relationship then check for "isDefault" relationship attribute to get preselected dependent value for current entity.
                        this.domHost._setDepenedencyRelationshipAndPreSelectedItems(data, formattedData, elementInfo);

                        if (elementInfo.dimensionType.toLowerCase() == "value" && DataHelper.isValidObjectPath(this.requestData, "params.query.ids")) {
                            var selectedItemIds = this.selectedItems.map(v => v.id);
                            var selectedItems = [];
                            if (selectedItemIds) {
                                formattedData.forEach(function (item) {
                                    if (selectedItemIds.indexOf(item.id) > -1) {
                                        selectedItems.push(item);
                                    }
                                }, this);

                                if (!_.isEmpty(selectedItems)) {
                                    if (!DataHelper.areEqualArrays(this.selectedItems, selectedItems)) {
                                        this.selectedItems = selectedItems;
                                        this.domHost._setSelectedDimensions();
                                    }
                                } else {
                                    var preSelectedItemId = this.domHost.selectedDimensionsDetail["PreSelectedItems"] && this.domHost.selectedDimensionsDetail["PreSelectedItems"][ctxType];
                                    if (preSelectedItemId) {
                                        var preselctedItem = data.find(v => v.id == preSelectedItemId);

                                        if (preselctedItem) {
                                            var name = preselctedItem.data.attributes[elementInfo.externalAttrName].values[0].value;
                                            var item = formattedData.find(v => v.title == name);

                                            if (item) {
                                                this.selectedItems = [item];
                                                this.domHost._setSelectedDimensions();
                                            }
                                        }
                                    } else {
                                        this.selectedItems = [];
                                        this.domHost._setSelectedDimensions();
                                    }
                                }
                            }
                        }

                        if (this.domHost) {
                            var filteredCtx = this.domHost._getExistingContextsOfEntity();
                        }

                        if (filteredCtx && filteredCtx.length) {
                            var flattenedCtx = this.domHost._getFlattenedContexts(filteredCtx, false);

                            if (flattenedCtx && flattenedCtx[ctxType]) {
                                var existingContext = flattenedCtx[ctxType];

                                if (existingContext && existingContext.length) {
                                    formattedData.forEach(function (item) {
                                        if (existingContext.indexOf(item.title) >= 0) {
                                            item.subtitle = "Existing";
                                        }
                                    }, this);
                                }
                            }
                        }
                    }
                }

                return formattedData;
            },

            _entityContextExternalDataFormatter: function (data) {

                var filteredData = [];
                if (data && data.length) {
                    var elementInfo = this.rData;
                    var domHost = this.domHost;
                    if (elementInfo && domHost) {
                        if (elementInfo.useContextModel) {
                            var currentContextType = elementInfo.id;
                            var filteredCtx = domHost._getExistingContextsOfEntityContext(domHost._entityContexts, domHost.selectedDimensions, currentContextType);

                            if (filteredCtx && filteredCtx.length) {
                                var flattenedCtx = domHost._getFlattenedContexts(filteredCtx, true);

                                if (flattenedCtx && flattenedCtx[currentContextType]) {
                                    var existingContext = flattenedCtx[currentContextType];

                                    if (existingContext && existingContext.length) {
                                        data.forEach(function (item) {
                                            if (existingContext.indexOf(item.title) >= 0) {
                                                item.subtitle = "Existing";
                                                filteredData.push(item);
                                            }
                                        }, this);
                                    }
                                }
                            }
                        } else {
                            filteredData = data;
                        }
                    }
                }

                return filteredData;
            },

            _setDepenedencyRelationshipAndPreSelectedItems: function (data, formattedData, elementInfo) {
                var mappedValueContexts = elementInfo && elementInfo.mappedValueContexts;

                if (mappedValueContexts && data && formattedData) {
                    for (let d of data) {
                        if (d.data && d.data.relationships) {
                            for (let rel in d.data.relationships) {
                                if (d.data.relationships[rel] && d.data.attributes[elementInfo.externalAttrName]) {
                                    var name = d.data.attributes[elementInfo.externalAttrName].values[0].value;
                                    var item = formattedData.find(v => v.id == name);

                                    if (!item.relTo) {
                                        item.relTo = [];
                                    }

                                    var mappedValueContext = mappedValueContexts.find(v => v.valueContextRelationship == rel);

                                    for (let r of d.data.relationships[rel]) {
                                        item.relTo.push(r);
                                        if (r.attributes && mappedValueContext) {
                                            var relAttr = r.attributes[this._getDefaultSelectedAttrName()];

                                            if (relAttr && relAttr.values && relAttr.values[0].value == "true") {
                                                if (!this.selectedDimensionsDetail["PreSelectedItems"]) {
                                                    this.selectedDimensionsDetail["PreSelectedItems"] = {};
                                                }

                                                if (_.isEmpty(this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext])) {
                                                    this.selectedDimensionsDetail["PreSelectedItems"][mappedValueContext.valueContext] = r.relTo.id;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },

            _getContextsBasedOnSelectedDimension: function () {
                var filteredCtx = [];

                var selectedDimensions = undefined;

                if (this._isRootContextChanged()) {
                    selectedDimensions = {};
                    this._contextHierarchy.forEach(function (ctx, index) {
                        if (index == 0) {
                            selectedDimensions[ctx] = this.selectedDimensions[ctx];
                        } else {
                            selectedDimensions[ctx] = [];
                        }
                    }, this);
                } else {
                    selectedDimensions = this.selectedDimensions;
                }

                filteredCtx = this._findContextModelMatchForCurrentSelctedDimension(selectedDimensions);

                // Reset dimensions if selcted dimension context will not be identified in context model
                if (!filteredCtx.length) {
                    this._contextHierarchy.forEach(function (ctxKey, index) {
                        var ctx = {};
                        ctx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                        filteredCtx.push(ctx);
                    }, this);
                }

                return filteredCtx;
            },

            _findContextModelMatchForCurrentSelctedDimension: function (selectedDimensions) {
                let filteredCtx = [];
                if (this._contexts && selectedDimensions) {
                    // Get context(s) based on selected dimension
                    for (var ctxIndex = 0; ctxIndex <= this._contexts.length; ctxIndex++) {
                        var ctx = this._contexts[ctxIndex];
                        var isMatch = false;
                        var isPartialMatch = false;
                        if (ctx) {

                            for (var hierarchyIndex = 0; hierarchyIndex <= this._contextHierarchy.length; hierarchyIndex++) {
                                var sdv = selectedDimensions[this._contextHierarchy[hierarchyIndex]];
                                var ctxv = ctx[this._contextHierarchy[hierarchyIndex]];

                                if (ctxv) {
                                    if (sdv && sdv.length) {
                                        if (sdv.indexOf(ctxv) >= 0) {
                                            if (!isPartialMatch) {
                                                isMatch = true;
                                            }
                                        } else {
                                            if (isMatch) {
                                                isPartialMatch = true
                                            } else {
                                                isMatch = isPartialMatch = false;
                                                break;
                                            }
                                        }
                                    } else {
                                        if (isMatch) {
                                            isPartialMatch = true;
                                        }
                                        else {
                                            break;
                                        }
                                    }
                                }
                            }
                            if (isMatch || isPartialMatch) {
                                filteredCtx.push(ctx);
                            }

                        }
                    }
                }
                return filteredCtx;
            },

            _getExistingContextsOfEntity: function () {
                var filteredCtx = [];
                if (this._entityContexts && this._currentContexts) {
                    for (var ctxIndex = 0; ctxIndex <= this._entityContexts.length; ctxIndex++) {
                        var ctx = this._entityContexts[ctxIndex];
                        var isMatch = false;

                        if (ctx) {
                            var sortedCtxKeys = [];
                            var entityCtxKeys = Object.keys(ctx);
                            this._contextHierarchy.forEach(function (item) {
                                if (entityCtxKeys.indexOf(item) > -1) {
                                    sortedCtxKeys.push(item);
                                }
                            }, this);

                            for (var hierarchyIndex = 0; hierarchyIndex <= sortedCtxKeys.length; hierarchyIndex++) {
                                var ctxKey = sortedCtxKeys[hierarchyIndex];
                                var sdv = this._currentContexts[ctxKey];
                                var ctxv = ctx[ctxKey];

                                if (ctxv) {
                                    if (sdv && sdv.length) {
                                        if (sdv.indexOf(ctxv) >= 0 || sdv.indexOf("_ALL") >= 0) {
                                            isMatch = true;
                                        } else {
                                            isMatch = false;
                                            break;
                                        }
                                    } else {
                                        isMatch = false;
                                        break;
                                    }
                                }
                            }
                        }

                        if (isMatch) {
                            filteredCtx.push(ctx);
                        }
                    }
                }

                return filteredCtx;
            },

            _getExistingContextsOfEntityContext: function (entityContexts, currentSelectedContexts, currentContextType) {
                var filteredCtx = [];
                if (entityContexts) {
                    var partialContext = this._getPartialContextForEntityContext(currentSelectedContexts, currentContextType);

                    for (var ctxIndex = 0; ctxIndex <= entityContexts.length; ctxIndex++) {
                        var ctx = entityContexts[ctxIndex];
                        var isMatch = false;

                        if (ctx) {
                            if (!_.isEmpty(partialContext)) {
                                var matched = _.every(partialContext, function (val, key) {
                                    if (_.isArray(val)) {
                                        return _.some(val, function (v) {
                                            return _.isEqual(v, ctx[key]);
                                        });
                                    } else {
                                        return _.isEqual(val, ctx[key]);
                                    }
                                });

                                if (matched) {
                                    filteredCtx.push(ctx);
                                }
                            } else {
                                filteredCtx.push(ctx);
                            }
                        }
                    }
                }

                return filteredCtx;
            },

            _getFlattenedContexts: function (contexts, resetRootDimension) {
                flattenedCtx = {};

                if (contexts && contexts.length)
                    contexts.forEach(function (ctx) {
                        var ctxKeys = Object.keys(ctx);

                        for (var i = 0; i <= ctxKeys.length; i++) {
                            var ctxKey = ctxKeys[i];

                            if (!flattenedCtx[ctxKey]) {
                                flattenedCtx[ctxKey] = [];
                            }

                            if (Array.isArray(ctx[ctxKey])) {
                                ctx[ctxKey].forEach(function (item) {
                                    if (flattenedCtx[ctxKey].indexOf(item) < 0) {
                                        flattenedCtx[ctxKey].push(item);
                                    }
                                }, this);
                            } else {
                                if (flattenedCtx[ctxKey].indexOf(ctx[ctxKey]) < 0) {
                                    flattenedCtx[ctxKey].push(ctx[ctxKey]);
                                }
                            }

                            if (ctxKey == this._contextHierarchy[0] && resetRootDimension) {
                                flattenedCtx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                            }
                        }
                    }, this);

                return flattenedCtx;
            },

            _isRootContextChanged: function () {
                var isRootCtxhanged = false;
                if (this._previousRootCtxValue && this._previousRootCtxValue.length) {
                    var _selectedDim = this.selectedDimensions[this._contextHierarchy[0]];

                    if (_selectedDim && _selectedDim.length == this._previousRootCtxValue.length) {
                        _selectedDim.forEach(function (val) {
                            if (this._previousRootCtxValue.indexOf(val) < 0) {
                                isRootCtxhanged = true;
                                this._previousRootCtxValue = _selectedDim;
                            }
                        }, this);
                    }
                } else {
                    this._previousRootCtxValue = this.selectedDimensions[this._contextHierarchy[0]];
                }
                return isRootCtxhanged;
            },

            _getSelectedCtxItems: function (ctxKey, ctxToBeLoaded) {
                var selectedItems = [];

                if (this.selectedDimensions && this.selectedDimensions[ctxKey]) {

                    if (ctxToBeLoaded) {
                        this.selectedDimensions[ctxKey].forEach(function (dim) {
                            if (ctxToBeLoaded.indexOf(dim) >= 0) {
                                selectedItems.push({
                                    "id": dim,
                                    "title": dim,
                                    "type": ctxKey
                                });
                            }
                        }, this);
                    } else {
                        this.selectedDimensions[ctxKey].forEach(function (dim) {
                            var ctxObj = {
                                "id": dim,
                                "title": dim,
                                "type": ctxKey
                            }
                            if (ctxKey == "locale") {
                                var _localeObj = ComponentHelper.getLocaleManager().getByName(dim);
                                if (!_.isEmpty(_localeObj)) {
                                    ctxObj.title = _localeObj.externalName ? _localeObj.externalName : dim;
                                }
                            }
                            selectedItems.push(ctxObj);
                        }, this);
                    }
                }

                return selectedItems;
            },

            _setLovTitle: function (currentRockLov) {
                if (!currentRockLov) {
                    return;
                }

                var currentDimensionButtonId = currentRockLov.id.replace("-lov", "-toggle-button");

                if (currentDimensionButtonId) {
                    var currentDimensionButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                    var buttonText = "";
                    var toolTip = "";
                    if (currentDimensionButton) {
                        if (currentRockLov.multiSelect) {
                            if (!_.isEmpty(currentRockLov.selectedItems)) {
                                if (currentRockLov.selectedItems.length > 1) {
                                    buttonText = currentRockLov.selectedItems.length + " " + DataHelper.getPluralLabel(currentRockLov.parentElement.title);
                                    currentRockLov.selectedItems.forEach(function (item) {
                                        if (_.isEmpty(toolTip)) {
                                            toolTip = item.title;
                                        } else {
                                            toolTip = toolTip + ", " + item.title;
                                        }
                                    }, this);
                                    toolTip = toolTip.trim(',');
                                } else {
                                    buttonText = toolTip = currentRockLov.selectedItems[0].title;
                                }
                            } else {
                                buttonText = toolTip = currentRockLov.parentElement.title;
                            }
                        } else {
                            if (!_.isEmpty(currentRockLov.selectedItem)) {
                                buttonText = toolTip = currentRockLov.selectedItem.title;
                            } else {
                                buttonText = toolTip = currentRockLov.parentElement.title;
                            }
                        }
                    }

                    currentDimensionButton.buttonText = buttonText;
                    currentDimensionButton.setAttribute("data-tooltip", toolTip);
                }
            },

            _getPartialContextForEntityContext: function (dataContext, ctxType) {
                var partialContext = {};
                if (!_.isEmpty(dataContext)) {
                    for (let item of this._contextHierarchy) {
                        if (item == ctxType) {
                            break;
                        }

                        if (item.toLowerCase() != "locale" && item.toLowerCase() != "source") {
                            if (!_.isEmpty(dataContext[item])) {
                                partialContext[item] = dataContext[item];
                            }
                        }
                    }
                }
                return partialContext;
            },

            _getDefaultSelectedAttrName: function () {
                return "isDefault";
            },

            _isMultiSelect: function (item) {
                if(typeof (item.multiSelect) == "undefined") {
                    return true;
                } else {
                    return item.multiSelect;
                }
            }
        });
    </script>
</dom-module>