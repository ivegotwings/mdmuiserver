<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/iron-icons/device-icons.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html" />
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/elements/custom-style.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-externalref-underscore/bedrock-externalref-underscore.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">

<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-context-lov/rock-context-lov.html">
<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">
<link rel="import" href="../rock-component-config-behavior/rock-component-config-behavior.html">

<!--
`<rock-dimension-selector>` Represents a component to hold a container, source, date, and locale information.
The elements inside this component are dynamically loaded based on the "config json".

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--dimesion-selector-container-popover` | Mixin applied to container selector dropdown | `{}`
`--dimesion-selector-source-popover` | Mixin applied to source selector dropdown | `{}`
`--dimesion-selector-locale-popover` | Mixin applied to locale selector dropdown | `{}`

@group rock Elements
@element rock-dimension-selector
@demo demo/index.html
-->
<dom-module id="rock-dimension-selector">
    <template>
        <style include="bedrock-style-common"></style>
        <style include="iron-flex"></style>
        <!--<custom-style>-->
        <style>
            :host {
                display: inline-block;
                --item-length-overflow: {
                    word-break: break-word;
                }
            }

            #listPopover {
                @apply --dimesion-selector-container-popover;
            }

            #sourcePopover {
                @apply --dimesion-selector-source-popover;
            }

            #localePopover {
                @apply --dimesion-selector-locale-popover;
            }

            pebble-popover {
                --pebble-popover-width: 260px;
            }

            .btn.dropdownText {
                display: flex;
                align-items: center;
                --pebble-button: {
                    font-weight: var(--font-medium, 500);
                    color: var(--palette-cerulean-two, #026bc3);
                    padding-top: 0px;
                    padding-right: 0px;
                    padding-bottom: 0px;
                    padding-left: 0px;
                };
            }

            .btn.dropdownText {
                --pebble-icon-color: {
                    fill: var(--palette-cerulean-two, #026bc3);
                };
            }

            pebble-button {
                margin: 0px 5px;

                --pebble-simple-button: {
                    width: 100px;
                };
            }
        </style>
        <div class="horizontal layout container">
            <template is="dom-repeat" items="[[_contextToBeRendered]]" as="ctx">
                <div id="[[ctx.id]]" hidden$="[[ctx.hidden]]">
                    <div>
                        <pebble-button id="[[ctx.id]]-toggle-button" popover="[[ctx.id]]-popover" lov="[[ctx.id]]-lov" icon="[[ctx.icon]]" button-text="[[ctx.title]]"
                            class="dropdownText dropdownIcon btn dropdown tooltip-bottom" noink raised no-overlap vertical-offset="-211"
                            horizontal-offset="11" dropdown-icon on-tap="_onToggleButtonTap">
                        </pebble-button>
                    </div>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity')]]">
                        <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap
                            horizontal-align="right">
                            <rock-entity-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly$=[[readonly]] config-data-item-id="[[ctx.id]]" id-field="[[ctx.dataMappings.id]]"
                                title-pattern="[[ctx.dataMappings.title]]" request-data="[[ctx.dataRequest]]" selected-items="[[_getSelectedItems(ctx.selectedItem)]]"
                                external-data-formatter="[[_entityExternalDataFormatter]]" type-field="[[ctx.dataMappings.type]]"
                                sort-field="[[ctx.dataMappings.sort]]" multi-select="[[!allSingleSelect]]" show-action-buttons></rock-entity-lov>
                        </pebble-popover>
                        <bedrock-pubsub event-name="entity-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="entity-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-context')]]">
                        <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap
                            horizontal-align="right">
                            <rock-context-lov id="[[ctx.id]]-lov" r-data="[[ctx]]" readonly$=[[readonly]] entity-id="[[entityId]]" entity-type="[[entityType]]"
                                context-name="[[ctx.id]]" config-data-item-id="[[ctx.id]]" request-data="[[ctx.dataRequest]]"
                                selected-items="[[_getSelectedItems(ctx.selectedItem)]]" external-data-formatter="[[_entityContextExternalDataFormatter]]"
                                selected-item-info=[[ctx.selectedItemInfo]] multi-select="[[!allSingleSelect]]" show-action-buttons></rock-context-lov>
                        </pebble-popover>
                        <bedrock-pubsub event-name="context-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                        <bedrock-pubsub event-name="context-lov-selected-info-applied" handler="_onContextLovSelectedInfoApplied" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                    <template is="dom-if" if="[[_compareRequestType(ctx.dataRequestType, 'entity-model')]]">
                             <pebble-popover title="[[ctx.title]]" id="[[ctx.id]]-popover" for="[[ctx.id]]-toggle-button" no-overlap
                                 horizontal-align="right">
                                 <rock-entity-model-lov id="[[ctx.id]]-lov" readonly$=[[readonly]] config-data-item-id="[[ctx.id]]"
                                     id-field="[[ctx.dataMappings.id]]" title-pattern="[[ctx.dataMappings.title]]"
                                     type-field="[[ctx.dataMappings.type]]" request-data="[[ctx.dataRequest]]"
                                     selected-items="[[_getSelectedItems(ctx.selectedItem)]]" multi-select="[[!allSingleSelect]]" no-sub-title
                                     show-action-buttons></rock-entity-model-lov>
                             </pebble-popover>
                             <bedrock-pubsub event-name="entity-model-lov-confirm-button-tap" handler="_onEntityLovConfirmButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                             <bedrock-pubsub event-name="entity-model-lov-close-button-tap" handler="_onEntityLovCloseButtonTapped" target-id="[[ctx.id]]-lov"></bedrock-pubsub>
                    </template>
                </div>
            </template>
        </div>
        <liquid-rest id="contextModelGet" url="/data/pass-through/entitymodelservice/getcontext" method="POST" request-data="{{_contextModelGetReq}}"
            on-liquid-response="_onContextModelGetResponse" on-liquid-error="_onContextModelGetFailed"></liquid-rest>
        <liquid-rest id="entityModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_entityModelRequest}}"
            on-liquid-response="_onEntityModelGetResponse"></liquid-rest>
        <liquid-rest id="entityContextGet" url="/data/pass-through/entityservice/getcontext" method="POST" request-data="{{_entityContextRequest}}"
            on-liquid-response="_onEntityContextGetResponse" exclude-in-progress>
        </liquid-rest>
    </template>
</dom-module>
<script>
    Polymer({
        is: "rock-dimension-selector",
        properties: {
            /**
             * Indicates the app name
             */
            appName: {
                type: String
            },

            contextData: {
                type: Object,
                value: function() {
                    return {};
                }
            },
            /**
             * Indicates the list of items which you must place in the dimension selector component.
             */
            configData: {
                type: Array,
                value: function (){
                    return [];
                }
            },
            /**
            * If set as true , it indicates the component is in read only mode
            */
            readonly: {
                type: Boolean,
                value: false
            },

            /**
            * Indicates the selected values of all dimensions in the dimension selector.
            */
            selectedDimensions: {
                type: Object,
                notify: true,
                value: function () {
                    return {};
                }
            },
            /**
            * <b><i>Content development is under progress... </b></i>
            */
            allMultiSelect: {
                type: Boolean,
                value: false
            },
            allSingleSelect: {
                type: Boolean,
                value: false
            },

            _currentDimensionSelector: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            entityId: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            entityType: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            _default: {
                type: Array,
                value: [{
                    "id": "default",
                    "title": "default",
                    "type": "default"
                }]
            },
            _contextModelGetReq: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            _contexts: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _isDynamic: {
                type: Boolean,
                value: false
            },
            _contextToBeRendered: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _entityModelRequest: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            _contextHierarchy: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _entityContextRequest: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            _entityContexts: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _currentContexts: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _previousRootCtxValue: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            _isConfigLoaded: {
                type: Boolean,
                value: false
            },
            _isContextLoad: {
                type: Boolean,
                value: false
            }
        },

        behaviors: [
            RUFBehaviors.UIBehavior,
            RUFBehaviors.ComponentConfigBehavior
        ],

        observers: [
            '_configChanged(configData, entityType)',
            '_prepareContext(appName, entityType)'
        ],

        _prepareContext: function() {
            var context = DataHelper.cloneObject(this.contextData);
            context[ContextHelper.CONTEXT_TYPE_APP] = [{
                "app": this.appName
            }];

            if(!_.isEmpty(this.entityType)) {
                context[ContextHelper.CONTEXT_TYPE_ITEM] = [{
                    "type": this.entityType
                }];
            }

            if(!_.isEmpty(context)) {
                this.requestConfig('rock-dimension-selector', context);
            }
        },

        onConfigLoaded: function(componentConfig) {
            if(componentConfig && componentConfig.config) {
                var configData = DataHelper.convertObjectToArray(componentConfig.config);

                this.configData = {};
                this.set('configData', configData);
            }
        },

        getDimensionSelectorConfig: function() {
            return this.configData;
        },

        _configChanged: function (configData, entityType) {
            if (configData && configData.length) {
                if (!this._isContextLoad) {
                    configData.forEach(function (item) {
                        if (item && item.useContextModel) {
                            this._isContextLoad = true;
                        }
                    }, this);
                }

                if (this._isContextLoad) {
                    if (entityType) {
                        this._entityTypeChanged(entityType);
                    }
                } else {
                    this._loadConfigBasedDimensions();
                }
            }
        },

        /**
          * <b><i>Content development is under progress... </b></i> 
          */
        refresh: function () {
            //Temporary fix until we decide how refresh has to be.
            var configData = this.configData;
            this.configData = undefined;
            this.configData = configData;
        },

        _compareRequestType: function (dataRequestType, entityTypeInfo) {
            return dataRequestType === entityTypeInfo;
        },

        _getSelectedItems: function (selectedItem) {
            // Todo.. This is not a correct code lov must support selectedid

            if (!_.isEmpty(selectedItem)) {
                var formattedSelectedItems = [];
                var formattedSelectedItem = {};

                formattedSelectedItem["id"] = selectedItem.id ? selectedItem.id : this._default.id;
                formattedSelectedItem["title"] = selectedItem.title ? selectedItem.title : this._default.title;
                formattedSelectedItem["type"] = selectedItem.type ? selectedItem.type : this._default.type;

                formattedSelectedItems.push(formattedSelectedItem);

                return formattedSelectedItems
            }
        },

        _onToggleButtonTap: function (event) {
            if (event.currentTarget.disabled == true) {
                return;
            }
            if (typeof (event.currentTarget) !== "undefined") {
                this._currentDimensionSelector = event.currentTarget;
                this._toggleLovPopover(this._currentDimensionSelector.popover);
            }
        },

        _onEntityLovConfirmButtonTapped: function (event) {
            if (!this.allMultiSelect) {
                var currentLovId = event.detail.data.id;
                var currentRockLov = this.shadowRoot.querySelector("#" + currentLovId);
                var switchToMultiSelect = true;

                if (currentRockLov.multiSelect) {
                    if (currentRockLov.selectedItems.length > 1) {
                        switchToMultiSelect = !currentRockLov.multiSelect;
                    }

                    for (var i = 0; i < this._contextToBeRendered.length; i++) {
                        var configDataItem = this._contextToBeRendered[i];
                        var rockLov;

                        if (configDataItem.dataRequestType == "entity") {
                            rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-lov");
                        }
                        if (configDataItem.dataRequestType == "entity-context") {
                            rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-context-lov");
                        }

                        if (configDataItem.dataRequestType == "entity-model") {
                            rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-model-lov");
                        }

                        if (typeof (rockLov) !== "undefined" && rockLov.id !== currentLovId && rockLov.multiSelect !== switchToMultiSelect) {
                            this._toggleLovSelectionMode(rockLov, switchToMultiSelect);
                        }
                    }
                }
            }

            this._updateSelectedDimensions();
            this._toggleLovPopover(this._currentDimensionSelector.popover);
        },

        _onContextLovSelectedInfoApplied: function () {
            this._updateSelectedDimensions();
        },

        _toggleLovSelectionMode: function (rockLov, switchToMultiSelect) {
            if (switchToMultiSelect) {
                var selectedItem = rockLov.selectedItem;
                rockLov.multiSelect = switchToMultiSelect;

                if (typeof (selectedItem) !== "undefined" && !_.isEmpty(selectedItem)) {
                    rockLov.push("selectedItems", selectedItem);
                }

                rockLov.refershTemplate();
            } else {
                var selectedItems = rockLov.selectedItems
                rockLov.multiSelect = switchToMultiSelect;

                if (typeof (selectedItems) !== "undefined" && selectedItems.length > 0) {
                    rockLov.selectedItem = selectedItems[0];
                } else {
                    rockLov.selectedItem = {};
                }

                rockLov.refershTemplate();
            }
        },

        _onEntityLovCloseButtonTapped: function () {
            this._toggleLovPopover(this._currentDimensionSelector.popover);
        },

        _updateSelectedDimensions: function () {
            this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(100), () => {
                this._setSelectedDimensions();
                if (this._isContextLoad) {
                    this._updateCurrentContextState();
                }
            });
        },

        refreshDimensionData: function () {
            if (typeof (this.configData) !== "undefined") {
                for (var i = 0; i < this.configData.length; i++) {
                    var configDataItem = this.configData[i];
                    var rockLov;
                    if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                        rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-lov");
                    }
                    if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                        rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-context-lov");
                    }
                    if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                        rockLov = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("rock-entity-model-lov");
                    }
                    if (rockLov) {
                        rockLov.reset();
                    }
                }
            }
        },

        _setSelectedDimensions: function () {
            var selectedDimensions = {};
            var configData = this._contextToBeRendered;

            if (typeof (configData) !== "undefined") {
                for (var i = 0; i < configData.length; i++) {
                    var configDataItem = configData[i];
                    var rockLov;
                    var rockContainer = this.shadowRoot.querySelector("#" + configDataItem.id);

                    if (rockContainer) {
                        if (this._compareRequestType(configDataItem.dataRequestType, 'entity')) {
                            rockLov = rockContainer.querySelector("rock-entity-lov");
                        }
                        if (this._compareRequestType(configDataItem.dataRequestType, 'entity-context')) {
                            rockLov = rockContainer.querySelector("rock-context-lov");
                        }

                        if (this._compareRequestType(configDataItem.dataRequestType, 'entity-model')) {
                            rockLov = rockContainer.querySelector("rock-entity-model-lov");
                        }

                        if (rockLov) { //typeof (rockLov) !== "undefined"
                            const { dataMappings } = configDataItem;
                            var entityTypes = dataMappings && dataMappings.type;

                            if (entityTypes) {
                                for (var j = 0; j < entityTypes.length; j++) {
                                    if (!rockLov.multiSelect) {
                                        var selectedItem = !_.isEmpty(rockLov.selectedItem) ? rockLov.selectedItem : undefined;
                                        var selectedItems = !_.isEmpty(rockLov.selectedItems) ? rockLov.selectedItems : undefined;
                                        if (selectedItems) {
                                            rockLov.selectedItem = selectedItem ? selectedItem : selectedItems[0];
                                        }
                                        var itemId = this._getItemId(rockLov.selectedItem);
                                        selectedDimensions[entityTypes[j]] = itemId ? [itemId] : [];
                                    } else {
                                        selectedDimensions[entityTypes[j]] = this._getItemsIdsByType(
                                        rockLov.selectedItems, entityTypes[j]);
                                    }
                                }
                            }

                            this._setLovTitle(rockLov);
                        }
                    }

                    // this._updateToggleButtonText(configDataItem, rockLov);
                }

                this.set("selectedDimensions", selectedDimensions);

                var eventDetail = {
                    'dimensions': selectedDimensions
                };
                this.fireBedrockEvent("dimension-selector-data-changed", eventDetail);
            }
        },

        _toggleLovPopover: function (popoverId) {
            var currentPopover = this.shadowRoot.querySelector("#" + popoverId);
            if (!_.isEmpty(currentPopover)) {
                if (!currentPopover.opened) {
                    currentPopover.show();
                } else {
                    currentPopover.hide();
                }
            }
        },

        _updateToggleButtonText: function (configDataItem, rockLov) {
            var toggleButton = this.shadowRoot.querySelector("#" + configDataItem.id).querySelector("pebble-button");
            var buttonText = configDataItem.title;

            if (!rockLov.multiSelect) {
                // Ask Jimmy.... What should be label field for selected dimension
                buttonText = rockLov.selectedItem.id
            } else {
                buttonText = rockLov.selectedItems.length + "" + configDataItem.title + "s " +
                    "Selected";
            }

            toggleButton.buttonText = buttonText;
        },

        _getSelectedItemsInfo: function (dimensionSelector) {
            var dimensionSelectedItem;
            var dimensionSelectedItems = [];

            if (dimensionSelector.lov.multiSelect) {
                if (dimensionSelector.lov.selectedItems.length > 0) {
                    dimensionSelectedItem = dimensionSelector.lov.selectedItems[0];
                    dimensionSelectedItems = dimensionSelector.lov.selectedItems;
                }
            } else {
                if (dimensionSelector.lov.selectedItem) {
                    dimensionSelectedItems.push(dimensionSelector.lov.selectedItem);
                    dimensionSelectedItem = dimensionSelector.lov.selectedItem;
                }
            }

            return {
                multiSelect: dimensionSelector.lov.multiSelect,
                selectedItem: dimensionSelectedItem,
                selectedItems: dimensionSelectedItems,
            }
        },
        /**
        * <b><i>Content development is under progress... </b></i>
        */
        getSelectedDimensions: function () {
            // Todo.. DimensionSelector Grid will be affected
            // var dimensionData = {};

            // dimensionData.selectedContexts = [this._getSelectedValue(this.configData.catalogSelector.catalogItems,
            // this.configData.catalogSelector.selectedCatalogItems)];
            // dimensionData.selectedSources = [this._getSelectedValue(this.configData.sourceSelector.sourceItems,
            // this.configData.sourceSelector.selectedSourceItems)];
            // dimensionData.selectedLocales = [this._getSelectedValue(this.configData.localeSelector.localeItems,
            // this.configData.localeSelector.selectedLocaleItems)];

            // return dimensionData;
        },

        _getSelectedValue: function (data, selectedItems) {
            if (data != undefined && data != null) {
                for (var i = 0; i < data.length; i++) {
                    if (this._indexOfItem(selectedItems, data[i])) {
                        return data[i].value;
                    }
                }
            }
        },

        _indexOfItem: function (selectedItems, selectedItemToCompare) {
            var isSelected = false;

            selectedItems.forEach(function (item) {
                if (item.id == selectedItemToCompare.id) {
                    isSelected = true;
                }
            }, this);

            return isSelected;
        },

        _setSelectedDimension: function () {
            this.selectedDimensions = undefined;
            this.selectedDimensions = {
                "lists": this.listSelector.selectedItems,
                "sources": this.sourceSelector.selectedItems,
                "locales": this.localeSelector.selectedItems
            };
        },

        _getItemsIdsByType: function (items, type) {
            var itemsIds = [];
            if (items) {
                for (var i = 0; i < items.length; i++) {
                    if (items[i].type === type) {
                        var itemId = this._getItemId(items[i]);
                        if (!_.isEmpty(itemId)) {
                            itemsIds.push(itemId);
                        }
                    }
                }
            }
            return itemsIds;
        },

        _getItemId: function (item) {
            if (item) {
                var itemId = this.get("id", item);

                if (typeof (itemId) == "undefined" || typeof (itemId) == "null") {
                    itemId = ""; // Could be -1 or ""?
                }

                return itemId;
            }
        },

        // Dynamic conxtext loading . . .
        _entityTypeChanged: function (entityType) {
            if (!_.isEmpty(entityType)) {

                this._contextModelGetReq = DataRequestHelper.createContextModelGetRequest(entityType);

                var liquidElement = this.$$('#contextModelGet');
                if (liquidElement) {
                    liquidElement.generateRequest();
                }


                if (!_.isEmpty(this.entityId)) {
                    this._entityContextRequest = DataRequestHelper.createEntityContextGetRequest(this.entityId, entityType);

                    var liquidElement = this.$$('#entityContextGet');
                    if (liquidElement) {
                        liquidElement.generateRequest();
                    }
                }
            }
        },

        _onContextModelGetResponse: function (e) {
            var response = e.detail.response.response;

            if (response) {
                var entityModels = response.entityModels;

                if (entityModels && entityModels.length) {
                    var contexts = entityModels[0].data ? entityModels[0].data.contexts : undefined;
                    var _ctxKeys = [];

                    if (contexts) {
                        var _contexts = [];
                        contexts.forEach(function (context) {
                            _contexts.push(context.context);

                            var ctxKeys = Object.keys(context.context);
                            if (ctxKeys && ctxKeys.length) {
                                ctxKeys.forEach(function (ctxKey) {
                                    if (_ctxKeys.indexOf(ctxKey) < 0) {
                                        _ctxKeys.push(ctxKey);
                                    }
                                }, this);
                            }
                        }, this);

                        this._contexts = _contexts;
                    }

                    var _ctxIds = [];
                    if (_ctxKeys && _ctxKeys.length) {
                        //TODO: Nikhil has to provide full colase path in context model and it has to applied as _contextHierarchy.
                        this._contextHierarchy = ["dcountry", "dchannel", "taxonomy", "classification"];//_ctxKeys;
                        _ctxKeys.forEach(function (item) {
                            if (item) {
                                _ctxIds.push(item);
                            }
                        }, this);
                    }

                    var ctxIds = [];
                    var missingContextModel = [];
                    if (this.configData && this.configData.length) {
                        this.configData.forEach(function (item) {
                            if (!item.useContextModel) {
                                if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                                    var type = item.dataMappings.type[0];

                                    if (type) {
                                        if (item.dataRequestType != "entity-context") {
                                            ctxIds.push(type + "_entityManageModel");
                                        }

                                        if (this._contextHierarchy.indexOf(type) < 0) {
                                            this._contextHierarchy.push(type);
                                        }
                                    }
                                }
                            } else if (item.useContextModel) {
                                if (_ctxIds.indexOf(item.id) > -1) {
                                    if (item.dataRequestType != "entity-context") {
                                        ctxIds.push(item.id + "_entityManageModel");
                                    }
                                } else {
                                    missingContextModel.push(item.id);
                                }
                            }
                        }, this);
                    }

                    if (missingContextModel && missingContextModel.length) {
                        var message = "Dimension(s): " + missingContextModel.join(", ") + " are configured but not present in context model for entity type: " + this.entityType;
                        this.showErrorToast(message, 5000);
                    }

                    if (ctxIds && ctxIds.length) {
                        this._entityModelRequest = {
                            "params": {
                                "query": {
                                    "ids": ctxIds,
                                    "filters": {
                                        "typesCriterion": [
                                            "entityManageModel"
                                        ]
                                    }
                                },
                                "fields": {
                                    "attributes": [
                                        "_ALL"
                                    ]
                                }
                            }
                        };

                        var entityModelGetComponent = this.$$("#entityModelGet");

                        if (entityModelGetComponent) {
                            entityModelGetComponent.generateRequest();
                        }
                    }
                }
            }
        },

        _onContextModelGetFailed: function (e) {
            // Error msg . . .
        },

        _loadConfigBasedDimensions: function () {
            var ctxIds = [];
            if (this.configData && this.configData.length) {
                this.configData.forEach(function (item) {
                    if (item.dataMappings && item.dataMappings.type && item.dataMappings.type) {
                        var type = item.dataMappings.type[0];

                        if (type) {
                            if (item.dataRequestType != "entity-context") {
                                ctxIds.push(type + "_entityManageModel");
                            }

                            if (this._contextHierarchy.indexOf(type) < 0) {
                                this._contextHierarchy.push(type);
                            }
                        }
                    }
                }, this);
            }

            if (ctxIds && ctxIds.length) {
                this._entityModelRequest = {
                    "params": {
                        "query": {
                            "ids": ctxIds,
                            "filters": {
                                "typesCriterion": [
                                    "entityManageModel"
                                ]
                            }
                        },
                        "fields": {
                            "attributes": [
                                "_ALL"
                            ]
                        }
                    }
                };

                var entityModelGetComponent = this.$$("#entityModelGet");

                if (entityModelGetComponent) {
                    entityModelGetComponent.generateRequest();
                }
            }
        },

        _onEntityModelGetResponse: function (e) {
            var response = e.detail.response.response;
            if (response && response.entityModels) {
                this._prepareModelBasedContexts(response.entityModels);
                this._updateSelectedDimensions();
            }
        },

        _prepareModelBasedContexts: function (entityModels) {
            if (entityModels && entityModels.length) {
                var ctxs = {};
                entityModels.forEach(function (entityModel) {
                    var ctxKey = entityModel.name;
                    var reqData = {
                        "params": {
                            "query": {
                                "filters": {
                                    "typesCriterion": [
                                        ctxKey
                                    ]
                                }
                            },
                            "fields": {
                                "attributes": ['_ALL']
                            }
                        }
                    };

                    var ctxToBeLoaded = this._contextDataToBeLoaded(ctxKey);
                    var ctxExtName = ctxKey;
                    var externalAttrName = undefined;
                    var externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);

                    if (externalNameAndExternalNameAttr) {
                        externalAttrName = externalNameAndExternalNameAttr.externalNameAttr;
                        ctxExtName = !_.isEmpty(externalNameAndExternalNameAttr.externalName) ? externalNameAndExternalNameAttr.externalName : ctxKey;
                    }

                    if (ctxToBeLoaded && ctxToBeLoaded.length || (ctxToBeLoaded.length == 1 && ctxToBeLoaded[0] != "_ALL")) {
                        var attributesCriterion = [];
                        if (externalAttrName) {
                            var attrCriterion = {};
                            attrCriterion[externalAttrName] = {
                                "exacts": ctxToBeLoaded
                            }
                            attributesCriterion.push(attrCriterion);
                            reqData.params.query.filters.attributesCriterion = attributesCriterion;
                        }
                    }

                    var titlePattern = "{entity.attributes." + externalAttrName + "}";

                    ctxs[ctxKey] = {
                        "id": ctxKey,
                        "title": ctxExtName,
                        "ctxName": ctxKey,
                        "externalAttrName": externalAttrName,
                        "dataRequestType": "entity",
                        "dataRequest": reqData,
                        "dataMappings": {
                            "id": "name",
                            "title": titlePattern,
                            "type": [ctxKey]
                        }
                    };

                }, this);

                this.configData.forEach(function (item) {
                    if (item) {

                        var ctx = ctxs[item.id];

                        if (ctx) {
                            var mergedCtx = undefined;

                            ctx = { "config": ctx };

                            // Deleting external dataMappings id and title coming from config
                            // Because assumption is for any entity-lov iExternalName attribute will be title of it.
                            delete item.dataMappings.id;
                            delete item.dataMappings.title;

                            item = { "config": item };

                            mergedCtx = SharedUtils.DataObjectFalcorUtil.mergeObjectsNoOverride(ctx, item, true);

                            if (mergedCtx && mergedCtx.config) {
                                ctx = mergedCtx.config;
                            }
                        } else {
                            if (item.dimensionType == "data" && item.dataRequestType == "entity-context") {
                                ctx = item;
                                ctx.dataMappings = {
                                    "id": "name",
                                    "title": "name",
                                    "type": [
                                        item.id
                                    ]
                                }
                                ctxs[item.id] = ctx;
                            } else if (!this._isContextLoad) {
                                ctxs[item.id] = item;
                            }
                        }
                    }
                }, this);

                var parsedContexts = [];
                this._contextHierarchy.forEach(function (ctxKey) {
                    if (ctxs[ctxKey]) {
                        parsedContexts.push(ctxs[ctxKey]);
                    }
                }, this);

                this._contextToBeRendered = undefined;
                this._contextToBeRendered = parsedContexts;
            }
        },

        _contextDataToBeLoaded: function (contextKey) {
            var ctxValue = [];
            if (contextKey) {
                for (var i = 0; i <= this._contexts.length; i++) {
                    if (this._contexts[i] && this._contexts[i][contextKey]) {
                        var ctx = this._contexts[i][contextKey];
                        if (Array.isArray(ctx)) {
                            ctx.forEach(function (item) {
                                if (ctxValue.indexOf(item) < 0) {
                                    ctxValue.push(item);
                                }
                            }, this);
                        } else {
                            if (ctx.toLowerCase() == "_all") {
                                ctxValue = ["_ALL"];
                                break;
                            } else {
                                if (ctxValue.indexOf(ctx) < 0) {
                                    ctxValue.push(ctx);
                                }
                            }
                        }
                    }
                }
            }
            return ctxValue;
        },

        _updateCurrentContextState: function () {

            if (!_.isEmpty(this.selectedDimensions)) {

                // Get context(s) based on selected dimension
                var filteredCtx = this._getContextsBasedOnSelectedDimension();

                if (filteredCtx && filteredCtx.length) {

                    // Get flattened structure of filtered contexts
                    var flattenedCtx = this._getFlattenedContexts(filteredCtx, true);
                    this._currentContexts = flattenedCtx;


                    // Set filtered context to dimension and reset dimensions
                    if (flattenedCtx) {
                        var flattenedCtxKeys = Object.keys(flattenedCtx);

                        this._contextHierarchy.forEach(function (item) {
                            var lovElement = this.$$('#' + item + '-lov');

                            if (lovElement) {
                                ctxData = lovElement.rData;

                                if (ctxData) {
                                    if (ctxData.dataRequestType == "entity-context") {
                                        lovElement.selectedItems = this._getSelectedCtxItems(item);
                                        lovElement.items = [];
                                        lovElement.reset();
                                    } else {
                                        var externalAttrName = ctxData.externalAttrName;
                                        var reqData = ctxData.dataRequest;
                                        var ctxToBeLoaded = flattenedCtx[item];

                                        if (reqData && externalAttrName) {
                                            var selectedItems = [];
                                            if (ctxToBeLoaded && ctxToBeLoaded.length && ctxToBeLoaded.indexOf('_ALL') < 0) {
                                                var attributesCriterion = [];
                                                var attrCriterion = {};
                                                attrCriterion[externalAttrName] = {
                                                    "exacts": ctxToBeLoaded
                                                }

                                                attributesCriterion.push(attrCriterion);
                                                reqData.params.query.filters.attributesCriterion = attributesCriterion;
                                                selectedItems = this._getSelectedCtxItems(item, ctxToBeLoaded);
                                            } else {
                                                selectedItems = this._getSelectedCtxItems(item);
                                                delete reqData.params.query.filters.attributesCriterion;
                                            }

                                            lovElement.selectedItems = selectedItems;
                                            lovElement.requestData = reqData;
                                            lovElement.reset();
                                        }
                                    }
                                }
                            }
                        }, this);
                    }
                }
               this._setSelectedDimensions();
            }
        },

        _onEntityContextGetResponse: function (e) {
            var response = e.detail.response.response;

            if (response) {
                if (response.entities && response.entities.length) {
                    var entity = response.entities[0];

                    if (entity && entity.data && entity.data.contexts) {
                        var _entityContexts = [];

                        entity.data.contexts.forEach(function (ctx) {
                            _entityContexts.push(ctx.context)
                        }, this);

                        this._entityContexts = _entityContexts;
                    }
                }
            }
        },

        _entityExternalDataFormatter: function (data) {
            if (data && data.length) {
                var elementInfo = this.rData;

                if (elementInfo) {
                    var ctxType = elementInfo.id;
                    if(this.domHost) {
                        var filteredCtx = this.domHost._getContextsBasedOnEntityContexts();
                    }

                    if (filteredCtx && filteredCtx.length) {
                        var flattenedCtx = this.domHost._getFlattenedContexts(filteredCtx, false);

                        if (flattenedCtx && flattenedCtx[ctxType]) {
                            var existingContext = flattenedCtx[ctxType];

                            if (existingContext && existingContext.length) {
                                data.forEach(function (item) {
                                    if (existingContext.indexOf(item.title) >= 0) {
                                        item.subtitle = "Existing";
                                    }
                                }, this);
                            }
                        }
                    }
                }
            }

            return data;
        },

        _entityContextExternalDataFormatter: function (data) {

            var filteredData = [];
            if (data && data.length) {
                var elementInfo = this.rData;

                if (elementInfo) {

                    if (elementInfo.useContextModel) {
                        var ctxType = elementInfo.id;
                        var filteredCtx = this.domHost._getContextsBasedOnEntityContexts();

                        if (filteredCtx && filteredCtx.length) {
                            var flattenedCtx = this.domHost._getFlattenedContexts(filteredCtx, true);

                            if (flattenedCtx && flattenedCtx[ctxType]) {
                                var existingContext = flattenedCtx[ctxType];

                                if (existingContext && existingContext.length) {
                                    data.forEach(function (item) {
                                        if (existingContext.indexOf(item.title) >= 0) {
                                            item.subtitle = "Existing";
                                            filteredData.push(item);
                                        }
                                    }, this);
                                }
                            }
                        }
                    } else {
                        filteredData = data;
                    }
                } else {
                    filteredData = data;
                }
            }

            return filteredData;
        },

        _getContextsBasedOnSelectedDimension: function () {
            var filteredCtx = [];

            var filteredSelectedDimensions = undefined;

            if (this._isRootContextChanged()) {
                filteredSelectedDimensions = {};
                this._contextHierarchy.forEach(function (ctx, index) {
                    if (index == 0) {
                        filteredSelectedDimensions[ctx] = this.selectedDimensions[ctx];
                    } else {
                        filteredSelectedDimensions[ctx] = [];
                    }
                }, this);
            } else {
                filteredSelectedDimensions = this.selectedDimensions;
            }


            if (this._contexts && filteredSelectedDimensions) {
                // Get context(s) based on selected dimension
                for (var ctxIndex = 0; ctxIndex <= this._contexts.length; ctxIndex++) {
                    var ctx = this._contexts[ctxIndex];
                    var isMatch = false;
                    var isPartialMatch = false;
                    if (ctx) {
                        for (var hierarchyIndex = 0; hierarchyIndex <= this._contextHierarchy.length; hierarchyIndex++) {
                            var sdv = filteredSelectedDimensions[this._contextHierarchy[hierarchyIndex]];
                            var ctxv = ctx[this._contextHierarchy[hierarchyIndex]];

                            if (ctxv) {
                                if (sdv && sdv.length) {
                                    if (sdv.indexOf(ctxv) >= 0) {
                                        if (!isPartialMatch) {
                                            isMatch = true;
                                        }
                                    } else {
                                        if (isMatch) {
                                            isPartialMatch = true
                                        } else {
                                            isMatch = isPartialMatch = false;
                                            break;
                                        }
                                    }
                                } else {
                                    if (isMatch) {
                                        isPartialMatch = true;
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                        }
                    }


                    if (isMatch || isPartialMatch) {
                        filteredCtx.push(ctx);
                    }
                }
            }

            // Reset dimensions if selcted dimension context will not be identified in context model
            if (!filteredCtx.length) {
                this._contextHierarchy.forEach(function (ctxKey, index) {
                    var ctx = {};
                    ctx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                    filteredCtx.push(ctx);
                }, this);
            }

            return filteredCtx;
        },

        _getContextsBasedOnEntityContexts: function () {
            var filteredCtx = [];
            if (this._entityContexts && this._currentContexts) {

                for (var ctxIndex = 0; ctxIndex <= this._entityContexts.length; ctxIndex++) {
                    var ctx = this._entityContexts[ctxIndex];
                    var isMatch = false;

                    if (ctx) {
                        var sortedCtxKeys = [];
                        var entityCtxKeys = Object.keys(ctx);
                        this._contextHierarchy.forEach(function (item) {
                            if (entityCtxKeys.indexOf(item) > -1) {
                                sortedCtxKeys.push(item);
                            }
                        }, this);

                        for (var hierarchyIndex = 0; hierarchyIndex <= sortedCtxKeys.length; hierarchyIndex++) {
                            var ctxKey = sortedCtxKeys[hierarchyIndex];
                            var sdv = this._currentContexts[ctxKey];
                            var ctxv = ctx[ctxKey];

                            if (ctxv) {
                                if (sdv && sdv.length) {
                                    if (sdv.indexOf(ctxv) >= 0 || sdv.indexOf("_ALL") >= 0) {
                                        isMatch = true;
                                    } else {
                                        isMatch = false;
                                        break;
                                    }
                                } else {
                                    isMatch = false;
                                    break;
                                }
                            }
                        }
                    }

                    if (isMatch) {
                        filteredCtx.push(ctx);
                    }
                }
            }

            return filteredCtx;
        },

        _getFlattenedContexts: function (contexts, resetRootDimension) {
            flattenedCtx = {};

            if (contexts && contexts.length)
                contexts.forEach(function (ctx) {
                    var ctxKeys = Object.keys(ctx);

                    for (var i = 0; i <= ctxKeys.length; i++) {
                        var ctxKey = ctxKeys[i];

                        if (!flattenedCtx[ctxKey]) {
                            flattenedCtx[ctxKey] = [];
                        }

                        if (Array.isArray(ctx[ctxKey])) {
                            ctx[ctxKey].forEach(function (item) {
                                if (flattenedCtx[ctxKey].indexOf(item) < 0) {
                                    flattenedCtx[ctxKey].push(item);
                                }
                            }, this);
                        } else {
                            if (flattenedCtx[ctxKey].indexOf(ctx[ctxKey]) < 0) {
                                flattenedCtx[ctxKey].push(ctx[ctxKey]);
                            }
                        }

                        if (ctxKey == this._contextHierarchy[0] && resetRootDimension) {
                            flattenedCtx[ctxKey] = this._contextDataToBeLoaded(ctxKey);
                        }
                    }
                }, this);

            return flattenedCtx;
        },

        _isRootContextChanged: function () {
            var isRootCtxhanged = false;
            if (this._previousRootCtxValue && this._previousRootCtxValue.length) {
                var _selectedDim = this.selectedDimensions[this._contextHierarchy[0]];

                if (_selectedDim && _selectedDim.length == this._previousRootCtxValue.length) {
                    _selectedDim.forEach(function (val) {
                        if (this._previousRootCtxValue.indexOf(val) < 0) {
                            isRootCtxhanged = true;
                            this._previousRootCtxValue = _selectedDim;
                        }
                    }, this);
                }
            } else {
                this._previousRootCtxValue = this.selectedDimensions[this._contextHierarchy[0]];
            }
            return isRootCtxhanged;
        },

        _getSelectedCtxItems: function (ctxKey, ctxToBeLoaded) {
            var selectedItems = [];

            if (this.selectedDimensions && this.selectedDimensions[ctxKey]) {

                if (ctxToBeLoaded) {
                    this.selectedDimensions[ctxKey].forEach(function (dim) {
                        if (ctxToBeLoaded.indexOf(dim) >= 0) {
                            selectedItems.push({
                                "id": dim,
                                "title": dim,
                                "type": ctxKey
                            });
                        }
                    }, this);
                } else {
                    this.selectedDimensions[ctxKey].forEach(function (dim) {
                        selectedItems.push({
                            "id": dim,
                            "title": dim,
                            "type": ctxKey
                        });
                    }, this);
                }

            }

            return selectedItems;
        },

        _setLovTitle: function (currentRockLov) {
            if (!currentRockLov) {
                return;
            }

            var currentDimensionButtonId = currentRockLov.id.replace("-lov", "-toggle-button");

            if (currentDimensionButtonId) {
                var currentDimensionButton = this.shadowRoot.querySelector("#" + currentDimensionButtonId);
                var buttonText = "";
                var toolTip = "";
                if (currentDimensionButton) {
                    if (currentRockLov.multiSelect) {
                        if (!_.isEmpty(currentRockLov.selectedItems)) {
                            if (currentRockLov.selectedItems.length > 1) {
                                buttonText = currentRockLov.selectedItems.length + " " + DataHelper.getPluralLabel(currentRockLov.parentElement.title);
                                currentRockLov.selectedItems.forEach(function (item) {
                                    if (_.isEmpty(toolTip)) {
                                        toolTip = item.title;
                                    } else {
                                        toolTip = toolTip + ", " + item.title;
                                    }
                                }, this);
                                toolTip = toolTip.trim(',');
                            } else {
                                buttonText = toolTip = currentRockLov.selectedItems[0].title;
                            }
                        } else {
                            buttonText = toolTip = currentRockLov.parentElement.title;
                        }
                    } else {
                        if (!_.isEmpty(currentRockLov.selectedItem)) {
                            buttonText = toolTip = currentRockLov.selectedItem.title;
                        } else {
                            buttonText = toolTip = currentRockLov.parentElement.title;
                        }
                    }
                }

                currentDimensionButton.buttonText = buttonText;
                currentDimensionButton.setAttribute("data-tooltip", toolTip);
            }
        }
    });
</script>