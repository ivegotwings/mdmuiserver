<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../liquid-behavior/liquid-behavior.html">

<!--
`liquid-entity-savedata`
Boolean control

@demo demo/index.html
-->
<dom-module id="liquid-entity-savedata">
    <template>
    </template>
    <script>
    (function() {
      'use strict';

      Polymer({
        is: 'liquid-entity-savedata',
        behaviors: [RUFBehaviors.LiquidBehavior],
        attached: function() {
        },
        ready: function(){
        },
        properties: {
            _dataChannelName: {
                type: String,
                value: "entityDataChannel",
                readonly: true
            }
        },
        _executeRequest: function (model, request) {
            var op = request.operation,
                reqData = request.requestData;

            if (op === 'createentities') {
                return this._callCreateEntities(model, reqData);
            }
            else if (op === 'updateentities') {
                return this._callUpdateEntities(model, reqData);
            }
            else {
                throw 'exception: operation ' + op + ' is not supported in ' + this.is + ' element.';
            }
        },
        _formatResponse: function(request, rawResponsePkg){
            var op = request.operation;

            if (op === 'updateentities') {
                var statusResponse = rawResponsePkg;

                if(!rawResponsePkg.status){
                    statusResponse = {'msg': "entity submitted for save successfully", 'reqTrackingId':100};
                }

                if(this.verbose){
                    console.log('save entity call raw response ', rawResponsePkg);
                    var model = RUFBehaviors.DataChannel.getModel(this._dataChannelName);
                    console.log('model cache after save call', model.getCache());
                }

                return statusResponse;
            }
            else if (op === "createentities") {
                var statusResponse = rawResponsePkg;
                
                if(!rawResponsePkg.status){
                    statusResponse = {'msg': "entities submitted for save successfully", 'reqTrackingId':100};
                }

                if(this.verbose){
                    console.log('save entity call raw response ', rawResponsePkg);
                    var model = RUFBehaviors.DataChannel.getModel(this._dataChannelName);
                    console.log('model cache after save call', model.getCache());
                }

                return statusResponse;
            }
            else {
                return rawResponsePkg;
            }
        },
        _callCreateEntities: function(model, reqData){
            if(reqData === undefined || !Object.keys(reqData["entities"]).length) {
                return {};
            }

            var entities = reqData["entities"];

            if(this.verbose) {
                console.log('Request for save entities call...entities: ', entities);
            }

            var pathRootKey = "entitiesById";
            var entitiesJsonEnvelope = {'json': {'entitiesById': {}}};
            var entityIds = Object.keys(entities);
            
            if(entityIds.length == 0){
                var reason = {'status':'error', 'msg': 'No entities found for save'};
                return reason;
            }

            for(var i in entityIds){
                var entityId = entityIds[i];
                var entity = entities[entityId];    
                //delete entity.id; //todo: why id field cannot be updated...
                entitiesJsonEnvelope.json.entitiesById[entityId] = this._boxEntityData(entity);
            }

            if(this.verbose){
                console.log('entities json envelope', entitiesJsonEnvelope);
                console.log('model cache before save call', model.getCache());
            }

            return model.call([pathRootKey, "createEntities"], [entitiesJsonEnvelope], [], []);
        },
        _callUpdateEntities: function(model, reqData){
            if(reqData === undefined || !Object.keys(reqData["entities"]).length) {
                return {};
            }

            var entities = reqData["entities"];

            if(this.verbose) {
                console.log('Request for save entities call...entities: ', entities);
            }

            var pathRootKey = "entitiesById";
            var entitiesJsonEnvelope = {'json': {'entitiesById': {}}};
            var entityIds = Object.keys(entities);
            
            if(entityIds.length == 0){
                var reason = {'status':'error', 'msg': 'No entities found for save'};
                return reason;
            }

            for(var i in entityIds){
                var entityId = entityIds[i];
                var entity = entities[entityId];    
                entitiesJsonEnvelope.json.entitiesById[entityId] = this._boxEntityData(entity);
            }

            if(this.verbose){
                console.log('entities json envelope', entitiesJsonEnvelope);
                console.log('model cache before save call', model.getCache());
            }

            return model.call([pathRootKey, entityIds, "updateEntities"], [entitiesJsonEnvelope], [], []);
        },
        _boxEntityData: function(entity){
            var boxedEntity = {};
            boxedEntity.id = this._boxJsonObject(entity.id);
            boxedEntity.systemInfo = this._boxJsonObject(entity.systemInfo);
            boxedEntity.dataObjectInfo = this._boxJsonObject(entity.dataObjectInfo);
            boxedEntity.properties = this._boxJsonObject(entity.properties);

            for(var ctxKey in entity.data.ctxInfo){
                var attrs = entity.data.ctxInfo[ctxKey].attributes;
                for(var attrId in attrs){
                    var attr = attrs[attrId];

                    for(var valIndex in attr.values) {
                        var val = attr.values[valIndex];
                        
                        if(val && val.name !== undefined){
                            delete val.name; // if name is coming as field inside val
                        }
                    }

                    attr.values = this._boxJsonObject(attr.values);
                }
            }
            
            boxedEntity.data = entity.data;

            return boxedEntity;
        },
        _boxJsonObject: function(obj){
            return {'$type': "atom", 'value': obj };
        }
      });
    })();
  </script>
</dom-module>