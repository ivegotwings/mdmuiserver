<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-lov/pebble-lov.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-combo-box/pebble-combo-box.html">
<link rel="import" href="../pebble-tags/pebble-tags.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../rock-entity-combo-box/rock-entity-combo-box.html">


<!--
`rock-variants-option-select`

@demo demo/index.html
-->
<dom-module id="rock-variants-option-select">
    <template>
        <style include="pebble-styles-app"></style>
        <style>
            p {
                text-align: center;
            }
            
            .flexbox-container {
                display: -ms-flex;
                display: -webkit-flex;
                display: flex;
                padding: 20px 10px 20px 10px;
            }
            
            .box1 {
                width: 12%;
            }
            
            .box2 {
                margin-right: 10px;
                width: 40%;
            }
            
            .box3 {
                margin-left: 10px;
                width: 40%;
            }
            
            pebble-button.removeButton {
                color: #C1CAD4;
                --pebble-button: {
                    min-width: 40px;
                    height: 40px;
                }
            }
            
            pebble-button.addButton {
                color: #09C021;
                --pebble-button: {
                    min-width: 40px;
                    height: 40px;
                }
            }
            
            .optionButton {
                float: right;
                /*--pebble-button: {*/
                /*border-bottom: 1px solid #036BC3;*/
                /*}*/
            }
            
            pebble-horizontal-divider {
                --pebble-horizontal-divider-color: #ccc;
                float: left;
                width: calc(100% - 20px);
            }
            
            .label {
                color: #C1CAD4;
            }
        </style>
        <div>
            <p>You can select multiple <b>Options</b> to create <b>SKUs</b></p>
        </div>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="{{attributeModelRequest}}" on-response="_onCompositeModelGetResponse" ></liquid-entity-model-composite-get>
        <liquid-entity-data-get  id="getData" operation="getbyids" request-data="[[_request]]" last-response="{{remoteData}}"
            on-response="_onResponse">
        </liquid-entity-data-get>
        <liquid-entity-data-save name="attributeSaveDataService" operation="update" request-data="{{_saveRequest}}" last-response="{{_saveResponse}}"
            on-response="_onSaveResponse"></liquid-entity-data-save>
        <template is="dom-repeat" items="{{selectedOptions}}">
            <div class="flexbox-container" id="row[[index]]">
                <div class="box1">
                    <pebble-button class="removeButton" icon="pebble-icons:RemoveCircle" item="[[item]]" on-tap="_removeOption"></pebble-button>
                    <span style="vertical-align: super;">[[_getSerialNumber(index)]]</span>
                </div>
                <div class="box2">
                    <div class="label">OPTION</div>
                    <pebble-combo-box items="[[options]]" selected-id="{{item.option}}" index="[[index]]" on-selection-changed="_optionLovSelectionChanged"></pebble-combo-box>
                </div>
                <div class="box3">
                    <div class="label">VALUES</div>
                    <rock-entity-combo-box item-id="id" item-title="id"
                                           multi-select
                                           context='[]'
                                           value-context='[]'
                                           entity-types='[[_getAttributeReferenceEntityTypes(item.option)]]'
                                           selected-ids="{{item.values}}" >
                    </rock-entity-combo-box>
                </div>
            </div>
        </template>
        <div class="flexbox-container">
            <div class="box1">
                <pebble-button class="addButton" icon="icons:add-circle" on-tap="_addNewRow"></pebble-button>
            </div>
        </div>
        <div id="content-actions" align="center">
            <pebble-button class="action-button btn btn-secondary" id="skip" button-text="Cancel" raised on-tap="_onCancelTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>

    </template>
    <script>
        Polymer({
            is: 'rock-variants-option-select',
            properties: {
                /**
                 * List of attributes
                 */
                attributesList: {
                    type: Array
                },
                selectedOptions: {
                    type: Array,
                    value: function () {
                        return [];
                    },
                    notify: true
                },
                _reupdateOptions: {
                    type: Boolean,
                    value: false
                },
                options: {
                    type: Array,
                    computed: '_getOptions(variantDefinition, selectedOptions,_attributeModels,_reupdateOptions)',
                    notify: true
                },
                /**
                 * Indictaes the identification of the entity for which the attributes are managed.
                 */
                entityId: {
                    type: String
                },
                entityType: {
                    type: String
                },
                /**
                 * Indicates the locale dimension for which the attributes are managed.
                 */
                locale: {
                    type: String
                },
                /**
                 * Indictaes the list for which the attributes are managed.
                 */
                list: {
                    type: String
                },
                /**
                 * Indictaes the classification for which the attributes are managed.
                 */
                classification: {
                    type: String,
                    value: "_ALL"
                },
                /**
                 * Indictaes the source dimension for which the attributes are managed.
                 */
                source: {
                    type: String
                },
                variantDefinition: {
                    type: Object,
                    observer:'_onVariantDefinitionGet'
                },
                _saveRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _request:{
                    type:Object
                },
                /**
                 * Indicates the request object that is passed to the data element to retrive the attribute model data.
                 */
                attributeModelRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _attributeModels: {
                    type: Object
                },
                _ctx:{
                    type:Array,
                    computed:'_getCtx(list,classification)'
                },
                _valCtx:{
                    type:Array,
                    computed:'_getValCtx(source,locale)'
                }
            },
            behaviors: [
                RUFBehaviors.UIBehavior
            ],
            observers:[
                '_optionLovSelectionChanged(selectedOptions,selectedOptions.*)'
            ],
            attached:function () {
                this.variantDefinition=this.getParentAppConfig('rock-entity-variant', '', 'variantDefinitionUI');
            },
            _getCtx:function (list,classification) {
              return[{
                  "list":list,
                  "classification":classification
              }] ;
            },
            _getValCtx:function (source,locale) {
                return[{
                    "source":source,
                    "locale":locale
                }] ;
            },
            _onVariantDefinitionGet:function (variantDefinition) {
                if (!variantDefinition || !Object.keys(variantDefinition).length) {
                    return;
                }
                var attrNames = [];
                var attributesList = [];
                variantDefinition.levels.forEach(function (level) {
                    for (var i = 0; i < level.dimensionAttributes.length; i++) {
                        attrNames.push(level.dimensionAttributes[i].sourceAttribute);
                        attributesList.push({ "name": level.dimensionAttributes[i].sourceAttribute, "optional": level.dimensionAttributes[i].optional });
                    }
                });
                this.attributesList = attributesList;
                this.attributeNames = attrNames;
                var req = {
                    "params": {
                            "query": {
                                "contexts": [{
                                    "list": this.list,
                                    "classification": this.classification
                                    }
                                ],
                                "locale": this.locale,
                                "name": this.entityType,
                                "filters": {
                                    "typesCriterion": [this.entityType]
                                }
                            },
                            "fields": {
                                "ctxTypes": [
                                    "properties"
                                ],
                                "attributes": attrNames
                            }
                    }
                };
                this.set("attributeModelRequest", req);
                var liquidModelGet = this.$$("[name=compositeAttributeModelGet]");
                if (liquidModelGet) {
                    liquidModelGet.generateRequest();
                }
            },
            _onCompositeModelGetResponse: function (e) {
                if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                    var contexts = {
                        "list": this.list,
                        "classification": this.classification
                    };
                    this._attributeModels = DataHelper.transformAttributeModelsToUIFormat(e.detail.response.content.entityModels[0], contexts);
                    var liquidGet = this.$.getData;
                    liquidGet.requestData=this._getRequest(this.variantDefinition);
                    if (liquidGet) {
                        liquidGet.generateRequest();
                    }
                }
            },
            _getRequest: function (variantDefinition) {
                var req = {
                    "params": {
                        "query": {
                            "contexts": [{
                                "list": this.list,
                                "classification": this.classification
                            }],
                            "valueContexts": [{
                                "source": this.source,
                                "locale": this.locale
                            }],
                            "id": this.entityId,
                            "filters": {
                                "typesCriterion": [this.entityType]
                            }
                        },
                        "fields": {
                            "ctxTypes": [
                                "properties"
                            ],
                            "attributes": []
                        },
                        "options": {
                            "totalRecords": 10,
                            "includeRequest": false
                        }
                    }
                };
                req.params.fields.attributes = this.attributeNames;
                return req;
            },
            _onResponse: function () {
                var data = this.remoteData;
                if (data && data.content) {
                    this.selectedOptions=[];
                    var entities = data.content.entities;
                    if (entities) {
                        var dataContext = {
                            "list": this.list,
                            "classification": this.classification,
                            "source": this.source,
                            "time": "now",
                            "locale": this.locale
                        };
                        var entity = entities[0];
                        this.originalEntity = entity;
                        if (entity.data) {
                            var contexts = DataHelper.prepareCtx(dataContext);
                            var valueContexts = DataHelper.prepareValCtx(dataContext);
                            var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity, contexts);
                            for(var i in attributes){
                                var attribute = attributes[i];
                                if (attribute && attribute.values) {
                                    var values =  DataHelper.getAttributeValues(attribute.values, valueContexts);
                                    this.push('selectedOptions', {
                                        "option":i,
                                        "values": values
                                    });
                                }
                            }
                        }
                    }
                }
            },
            _addNewRow: function () {
                var newOption = { "option": "", "values": [] };
                this.push('selectedOptions', newOption);
                //TODO open lov for option
                var newOptionIndex = this.selectedOptions.length - 1;
            },
            _getSerialNumber: function (index) {
                return index + 1;
            },
            _removeOption: function (e) {
                var item = e.target.item;
                var index = this.selectedOptions.indexOf(item);
                this.splice('selectedOptions', index, 1);
            },
            _onCancelTap: function (e) {
                //raise event with name given for onbackAction in configuration
                var eventName = "onCancel";
                var eventDetail = {
                    name: eventName
                };
                this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
            },
            _onSaveTap: function (e) {
                if (this.selectedOptions.length == 0) {
                    alert("Please select at least 1 option");
                    return;
                }
                var selectedOptions = this.selectedOptions;
                var attrNames = selectedOptions.map(function (selectedItem) {
                    if (selectedItem.option && selectedItem.values && selectedItem.values.length > 0) {
                        return selectedItem.option;
                    }
                });
                for (i = 0; i < this.attributesList.length; i++) {
                    var attribute = this.attributesList[i];
                    if (!attribute.optional) {
                        if (attrNames.indexOf(attribute.name) == -1) {
                            alert("Adding values for " + attribute.name + " is compulsary");
                            return;
                        }
                    }
                }
                var attributes = {};
                var source=this.source;
                var locale=this.locale;
                for (var i = 0; i < selectedOptions.length; i++) {
                    if (selectedOptions[i].option && selectedOptions[i].values && selectedOptions[i].values.length > 0) {
                        var values = selectedOptions[i].values.map(function (valueJson) {
                           return {
                                "value": valueJson,
                                "source": source,
                                "locale": locale
                            };
                        });
                        attributes[selectedOptions[i].option] = { "values": values };
                    }
                }
                var entityData = this.originalEntity;
                var contextualData = {};
                contextualData.contexts = [];
                var ctxItem = {};
                ctxItem.context = { "list": this.list, "classification": this.classification };
                ctxItem.attributes = attributes;
                contextualData.contexts.push(ctxItem);
                entityData["data"] = contextualData;

                if (!_.isEmpty(entityData)) {
                    this._saveRequest = {
                        "entities": [entityData]
                    };
                    var liquidSave = this.$$("[name=attributeSaveDataService]");
                    if (liquidSave) {
                        liquidSave.generateRequest();
                    }
                }
            },
            _onSaveResponse: function () {
                var eventName = "onSave";
                var eventDetail = {
                    name: eventName,
                    data: { "entity-id": this.entityId,"entity-type": this.entityType, "source": this.source, "locale": this.locale, "list": this.list }
                };
                this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
            },
            _openOptionPopover: function (e) {
                var index = e.currentTarget.index;
                this.$$("#optionPopover" + index).open();
                this.$$('#lov' + index).activate();
            },
            _openValuesPopover: function (e) {
                var index = e.currentTarget.index;
                this.$$("#valuesPopover" + index).open();
                this.$$('#vLov' + index).activate();
            },
            _getOptions: function (variantDefinition, selectedOptions,attributeModels) {
                var options = [];
                if(variantDefinition && Object.keys(variantDefinition).length) {
                    variantDefinition.levels.forEach(function (level) {
                        for (var i = 0; i < level.dimensionAttributes.length; i++) {
                            options.push(level.dimensionAttributes[i].sourceAttribute);
                        }
                    });
                }
                for (var i = 0; i < this.selectedOptions.length; i++) {
                    var index = options.indexOf(this.selectedOptions[i].option);
                    if (index > -1) {
                        delete options[index];
                    }
                }
                var lovOptions = [];
                options.forEach(function (option) {
                    var name=attributeModels[option].externalName;
                    if(!name){
                        name=option;
                    }
                    lovOptions.push({ "id": option, "title": name });
                });
                return lovOptions;
            },
            _optionLovSelectionChanged: function (e) {
                this._reupdateOptions = !this._reupdateOptions;
            },
            _getAttributeReferenceEntityTypes:function(option){
                if(!option || this._attributeModels[option]==undefined){
                    return [];
                }
                var types=this._attributeModels[option].referenceEntityInfo.map(function (info) {
                   return info.refEntityType;
                });
                if(!types){
                    types=[];
                }
                return types;
            }

        });
    </script>
</dom-module>