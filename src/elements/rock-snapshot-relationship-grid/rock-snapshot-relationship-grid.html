<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-helpers/data-merge-helper.html">

<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-config-get/liquid-config-get.html">

<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-context-mappings/rock-context-mappings-grid.html">

<dom-module id="rock-snapshot-relationship-grid">
    <template>
        <style include="bedrock-style-common">
            :host {
                display: block;
                height: 100%;
                --pebble-data-table: {
                    height: 100%;
                }
            }
        </style>

        <rock-grid config="[[_gridConfig]]" data="[[gridData]]" multi-selection="false" page-size="20"></rock-grid>

        <liquid-entity-data-get id="getRelEntities" operation="getbyids" data-index="entityData" data-sub-index="data" on-response="_onEntityGetResponse"></liquid-entity-data-get>
        <liquid-entity-data-get id="getRelAttributes" operation="getbyids" data-index="entityData" data-sub-index="data" on-response="_onRelAttrsResponse"></liquid-entity-data-get>
        <liquid-entity-model-composite-get name="liquidModelGet" request-data={{relationshipRequest}} on-entity-model-composite-get-response="_onModelReceived"
            on-error="_onModelGetFailed" exclude-in-progress></liquid-entity-model-composite-get>

    </template>
    <script>
        'use strict';

        class RockSnapshotRelationshipGrid
        extends Polymer.mixinBehaviors([
            RUFBehaviors.UIBehavior,
            RUFBehaviors.ComponentContextBehavior,
            RUFBehaviors.ComponentConfigBehavior
        ], Polymer.Element) {
            static get is() {
                return 'rock-snapshot-relationship-grid'
            }

            static get properties() {
                return {
                    _gridConfig: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },
                    _attributes: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },
                    entityReqData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    entityType: {
                        type: String,
                        value: ""
                    },
                    relationshipRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _relationshipModels: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _contextsObj: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _contexts: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _isAdditionalContextPresent: {
                        type: Boolean,
                        value: false
                    },
                    gridData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _entityData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _rowsModel: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _relationshipType: {
                        type: String,
                        value: ""
                    },
                    _entityAttributes: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _relationshipAttributes: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _ids: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    }
                }

            }

            connectedCallback() {
                super.connectedCallback();
                let context = DataHelper.cloneObject(this.contextData);
                let appName = ComponentHelper.getCurrentActiveAppName();
                if (appName) {
                    context[ContextHelper.CONTEXT_TYPE_APP] = [{
                        "app": appName
                    }];
                }
                let _relationshipType = this._getRelationshipType();
                this.set('_relationshipType', _relationshipType);
                context.ItemContexts[0].relationship = this._relationshipType;
                this.requestConfig('rock-entity-relationship-search-result', context);

                //forming ids array for liquid call
                if (this.entityReqData.length > 0) {
                    let ids = this.entityReqData.map(elm => {
                        return elm.relTo.id
                    })
                    this._ids = ids;
                }

                //composite Model Call
                this._getCompositeModel()
            }

            _getCompositeModel() {
                let entityContextData = DataHelper.cloneObject(this.contextData);
                entityContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [{
                    'type': this.contextData.ItemContexts[0].type,
                    'relationships': [this._relationshipType],
                }];

                let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(
                    entityContextData);
                this.set("relationshipRequest", compositeModelGetRequest);
                let liquidModelGet = this.shadowRoot.querySelector("[name=liquidModelGet]");
                if (liquidModelGet && compositeModelGetRequest) {
                    liquidModelGet.generateRequest();
                }

            }

            _onModelReceived(e) {
                let itemContext = this.getFirstItemContext();
                if (e && e.detail && DataHelper.validateGetModelsResponse(e.detail.response)) {
                    let compositeModel = e.detail.response.content.entityModels[0];
                    if (DataHelper.isValidObjectPath(compositeModel, 'data.relationships')) {
                        this._relationshipModels = compositeModel.data.relationships[this._relationshipType];
                        // this._relationshipModels = DataTransformHelper.transformRelationshipModels(compositeModel, this._entityContextData);
                    }
                }
            }

            _getRelationshipType() {
                let entityType;
                if (!_.isEmpty(this.entityReqData) && DataHelper.isValidObjectPath(this.entityReqData[0],
                        'properties.relationshipType')) {
                    return this.entityReqData[0].properties.relationshipType;
                } else if (!_.isEmpty(this.entityReqData) && DataHelper.isValidObjectPath(this.entityReqData[0],
                        'relTo.type')) {
                    let relType = this.entityReqData[0].relTo.type;
                    let relToTypesArr = this.entityReqData.relToRelationshipTypes;

                    relToTypesArr.forEach(relItem => {
                        if (relItem.relEntityType == relType) {
                            entityType = relItem.relEntityId;
                        }
                    });
                    return entityType;
                } else {
                    this.showWarningToast("RelationshipType does not exist contact your administrator");
                }
            }

            onConfigLoaded(componentConfig) {
                let gridConfig = componentConfig.config.gridConfig;
                gridConfig.schemaType = "simple"
                gridConfig.advanceSelectionEnabled = false;
                gridConfig.itemConfig.isMultiSelect = false;
                gridConfig.itemConfig.selectionEnabled = false;
                //to disable navigation from compare screen to the entity being displayed
                delete gridConfig.itemConfig.linkTemplate;
                this.set('_gridConfig', gridConfig);

                let attributes = this._getEntityAttributes();
                this._attributes = attributes;
                this._entityAttributes = [...attributes.relatedEntityAttributes, ...attributes.relationshipAttributes];
                this._relationshipAttributes = attributes.relationshipAttributes;
                this._rowsModel = this._getRowModel(componentConfig.config);
                this.getEntityData();
            }

            _getEntityAttributes() {
                let _attrs = [];
                let _relAttrs = [];
                let fields = this._gridConfig.itemConfig.fields;
                for (let prop in fields) {
                    //remove link template
                    delete fields[prop].linkTemplate;
                    if (fields[prop].isRelatedEntityAttribute == true) {
                        _attrs.push(fields[prop].name);
                    } else {
                        _relAttrs.push(fields[prop].name);
                    }
                }

                if (this._gridConfig.viewMode !== 'Tabular') {
                    let itemConfig = this._gridConfig.itemConfig;
                    _attrs.push(itemConfig.image);
                    _attrs.push(itemConfig.thumbnailId);
                    _attrs.push(itemConfig.title);
                    _attrs.push(itemConfig.subtitle);
                    _attrs.push(itemConfig.id);
                    _attrs.push("property_objectkey");
                }

                let attributes = {
                    relatedEntityAttributes: _attrs,
                    relationshipAttributes: _relAttrs
                }
                return attributes;

            }
            _getRowModel(config) {
                let rows = [];

                this._entityAttributes.forEach(attr => {
                    let row = {
                        header: attr,
                        name: attr,
                        isFrozen: false
                    }
                    rows.push(row);
                });
                return rows;
            }

            getEntityData() {
                let req = DataRequestHelper.createEntityGetRequest(this.contextData);
                let liqDataElement = this.shadowRoot.querySelector("#getRelEntities");
                req.params.query.ids = this._ids;
                delete req.params.query.id;
                req.params.fields.attributes = this._entityAttributes;
                req.params.query.filters.typesCriterion = [this.entityType];
                req.params.fields.relationship = this._relationshipType;
                liqDataElement.requestData = req;
                liqDataElement.generateRequest();
            }

            async _getPrimaryAndFullContexts() {
                let dataContexts = [];
                this._contextsObj = await this._getPrimaryAndAdditionalContexts();

                if (this._contextsObj) {
                    if (!_.isEmpty(this._contextsObj.primaryContexts) && this._contextsObj.primaryContexts
                        .indexOf('self') !== -1) {
                        this._isAdditionalContextPresent = false;
                    } else if (!_.isEmpty(this._contextsObj.additionalContexts)) {
                        this._isAdditionalContextPresent = true;
                    }
                }

                let firstDataContext = ContextHelper.getFirstDataContext(this.contextData);
                if (this._isAdditionalContextPresent && this._contextsObj && this._contextsObj.primaryContexts) {
                    let primaryContext = _.pick(firstDataContext, this._contextsObj.primaryContexts);
                    dataContexts.push(primaryContext);
                }

                if (!_.isEmpty(dataContexts)) {
                    dataContexts.push(firstDataContext);
                    return dataContexts;
                }
                return null;
            }

            async _getPrimaryAndAdditionalContexts() {
                let mergedContexts = undefined;

                if (!_.isEmpty(this.contextData)) {
                    let entityType = undefined;
                    let contextModel = undefined;

                    if (DataHelper.isValidObjectPath(this.contextData, 'ItemContexts.0')) {
                        entityType = this.contextData.ItemContexts[0].type;
                    }

                    if (DataHelper.isValidObjectPath(this.contextData, 'Contexts.0') && entityType) {
                        contextModel = await ContextModelManager.getContextModelByEntityTypeAndDataContext(entityType, this.contextData.Contexts[0]);
                    }

                    let additionalContexts = undefined;
                    let primaryContexts = undefined;

                    if (contextModel) {
                        additionalContexts = contextModel.properties ? contextModel.properties.additionalcontexts : undefined;
                        primaryContexts = DataTransformHelper.getPrimaryContextKeysFromContextModel(contextModel, additionalContexts);
                    }

                    mergedContexts = {
                        "additionalContexts": additionalContexts,
                        "primaryContexts": primaryContexts
                    }
                }

                return mergedContexts;
            }

            //call to get the relationshipAttributes like order and isPrimary.
            async getRelationshipAttributes(relationshipAttributes) {
                let req = DataRequestHelper.createEntityGetRequest(this.contextData);
                let liqDataElement = this.shadowRoot.querySelector("#getRelAttributes");
                this._contexts = await this._getPrimaryAndFullContexts();

                if (this._isAdditionalContextPresent && this._contexts.length == 2) {
                    req.params.query.contexts = this._contexts;
                }
                req.params.query.id = this.contextData.ItemContexts[0].id;
                req.params.fields.relationships = [this._relationshipType];
                req.params.fields.relationshipAttributes = relationshipAttributes;
                liqDataElement.requestData = req;
                liqDataElement.generateRequest();
            }
            _onEntityGetResponse(e, detail) {
                let data = detail.response.content.entities;
                this._entityData = data;
                if (this.entityReqData.isSnapshot) {
                    this.getRelationshipAttributes(this._attributes.relationshipAttributes);
                } else {
                    this._prepareGridColumnData(this._entityData);
                }
            }

            async snapshotTransformRelationships(entity, relationshipModels, contextData, outputSchema, applySort) {
                let firstDataContext = ContextHelper.getFirstDataContext(contextData);
                let activeAdditionalCtx;
                let activePrimaryCtx;

                let mergedRelationships = {};

                let sortedAttributeModels = relationshipModels;
                if (applySort) {
                    sortedAttributeModels = this.sortAttributeModels(relationshipModels);
                }

                if (firstDataContext) {
                    let dataContexts = [];

                    if (this._isAdditionalContextPresent && this._contextsObj && this._contextsObj.primaryContexts) {
                        let primaryContext = _.pick(firstDataContext, this._contextsObj.primaryContexts);
                        dataContexts.push(primaryContext);
                    } else if (!_.isEmpty(this._contextsObj.primaryContexts) && this._contextsObj.primaryContexts[
                            0] == "self") {
                        mergedRelationships = entity.data.relationships;
                    }
                    dataContexts.push(firstDataContext);

                    for (let dataContext of dataContexts) {
                        if (dataContext) {
                            let ctxRelationships = SharedUtils.DataObjectFalcorUtil.getRelationshipsByCtx(
                                entity, dataContext);

                            if (!_.isEmpty(ctxRelationships)) {
                                Object.keys(ctxRelationships).forEach((relName) => {
                                    mergedRelationships[relName] = DataHelper.cloneObject(ctxRelationships[relName]);
                                });
                            }
                        }
                    }

                } else {
                    //taking self
                    mergedRelationships = entity.data.relationships;
                }

                let outputData = undefined;

                if (outputSchema == "array") {
                    //manage returns output as array...instead of keyed attributes
                    outputData = _.map(mergedRelationships, function (value, index) {
                        return value;
                    });
                } else {
                    outputData = mergedRelationships;
                }

                return outputData;
            };

            async _onRelAttrsResponse(e, detail) {
                let relAttributeData = undefined;

                if (DataHelper.isValidObjectPath(detail, 'response.content.entities')) {
                    relAttributeData = detail.response.content.entities;
                }

                //get primary and secondary context
                if (this._relationshipModels && this._relationshipModels.length) {
                    let compositeModel = DataHelper.cloneObject(this._relationshipModels[0]);
                }
                this._contextsObj = await this._getPrimaryAndAdditionalContexts();
                if (this._contextsObj) {
                    if (!_.isEmpty(this._contextsObj.primaryContexts) && this._contextsObj.primaryContexts
                        .indexOf('self') !== -1) {
                        this._isAdditionalContextPresent = false;
                    } else if (!_.isEmpty(this._contextsObj.additionalContexts)) {
                        this._isAdditionalContextPresent = true;
                    }
                }

                if (!_.isEmpty(relAttributeData)) {
                    let rels = await this.snapshotTransformRelationships(relAttributeData[0], this._relationshipModels, this.contextData, this._contextsObj);
                    this._updateEntDataAttrsWithRelAttributes(rels);
                    if (!_.isEmpty(this._entityData)) {
                        this._prepareGridColumnData(this._entityData);
                    }
                }
            }

            //updating _entityData to have relationshiAttributes and it's values. This is then directly used to prepare grid
            _updateEntDataAttrsWithRelAttributes(relationshipAttributes) {
                relationshipAttributes[this._relationshipType].forEach(elm => {
                    if (!_.isEmpty(elm.attributes)) {
                        this._entityData.forEach(entity => {
                            if (elm.id.includes(entity.id)) {
                                // entity.data.attributes = {...entity.data.attributes, ...elm.attributes};
                                DataMergeHelper.mergeAttributes(entity.data.attributes, elm.attributes,
                                    true);
                            }
                        })
                    }
                });
            }
            _prepareGridColumnData(entities) {
                let items = [];
                let rowModel = this._rowsModel;
                entities.forEach(function (relItem) {
                    if (relItem) {
                        let record = {};
                        let lovItem = {};
                        if (relItem.data.attributes) {
                            rowModel.forEach(function (row) {
                                if (row && relItem.data.attributes[row.name]) {
                                    let valueObjs = relItem.data.attributes[row.name].values;
                                    if (!_.isEmpty(valueObjs)) {
                                        if (valueObjs.length > 1) {
                                            let values = [];
                                            for (let valueIndex = 0; valueIndex < valueObjs.length; valueIndex++) {
                                                values.push(valueObjs[valueIndex].value);
                                            }
                                            record[row.name] = values;
                                        } else {
                                            record[row.name] = valueObjs[0].value;
                                        }
                                    }
                                } else {
                                    record[row.name] = "";
                                }
                            }, this);
                        }
                        //If navigation to displayed entity is needed in future un-comment this and enable linkTemplate in config
                        // record.id=relItem.id;
                        // record.type = relItem.type;
                        items.push(record);
                    }
                })

                this.set('gridData', items);
            }
        }

        customElements.define(RockSnapshotRelationshipGrid.is, RockSnapshotRelationshipGrid);
    </script>
</dom-module>