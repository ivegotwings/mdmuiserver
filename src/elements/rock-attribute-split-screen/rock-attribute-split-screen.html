<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="../rock-attribute-manage/rock-attribute-manage.html">
<link rel="import" href="attribute-tab-menu-provider.html">
<!--
	`rock-attribute-split-screen` Represents component to render the manage attributes screen based on the 
	dimensions selected from the `rock-dimension-selector`. If multiple values are selected for any of the 
	dimensions, then the screen splits into number of dimension 
	values selected.
-->

<dom-module id="rock-attribute-split-screen">
	<template>
		<style include="pebble-styles-shared"></style>
		<style>
			.attribute-list {
				display: inline-flex;
				display: -webkit-inline-flex;
				padding: 20px;
				/*border: 1px solid black;*/
			}

			.attribute-list-1 {
				width: 100%;
			}

			.attribute-list-2 {
				width: 44%;
			}

			.attribute-list-3 {
				width: 33%;
			}

			.attribute-list-4 {
				width: 24%;
			}

			.dimension {
				width: 100%;
				@apply(--layout);
				@apply(--layout-horizontal);
				border-bottom: 1px solid var(--palette-cloudy-blue, #c1cad4);
				height: 30px;
				line-height: 30px;
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 14px);
				color: var(--palette-cerulean, #036bc3);
			}

			#actions {
				--pebble-button: {
					height: 30px;
					padding: 1em 0em 1em 0.2em;
					color: #212121;
					border: 1px solid #C1CAD4;
					font-size: small;
					margin-left: -3px;
				}
			}

			#dimensionValueContainer {
				margin-left: 20px;
				margin-top: auto;
			}

			pebble-icon {
				padding-left: 10px;
				padding-right: 10px;
			}

			.divider {
				width: 2%;
			}

			pebble-vertical-divider {
				--pebble-vertical-divider-color: var(--pagelevel-divider, #bacedf);
				height: 100%;
				border: 0px;
				min-height: 0px;
			}

			.actionButton {
				float: right;
			}

			.attribute-manage-container {
				width: 100%;
				overflow: hidden;
			}
		</style>

		<template is="dom-if" if="[[_showContextTitles]]">
			<div class="dimension" style$="[[_getStyle(noOfScreens)]]">
				<template is="dom-repeat" items="[[_contexts]]" as="context">
					<div id="sourceDimensionValueContainer" class$="[[_getAttributeListClass(noOfScreens)]]">
						<pebble-icon icon="pebble-icons:Language"></pebble-icon>
						[[context.value]]
					</div>
				</template>
			</div>
			<!-- <div class="m-t-10 p-r-10 actionButton">
				<pebble-button id="actions" class="btn btn-success" icon="pebble-icons:Done" button-text="Actions" noink elevation="2" dropdown-icon on-tap="_onActionsTap"></pebble-button>
			</div> -->
		</template>
		<template is="dom-if" if="[[_showContexts]]">
			<template is="dom-repeat" items="[[_contexts]]" as="context">
				<div class$="[[_getAttributeListClass(noOfScreens)]]">
					<div class="attribute-manage-container">
						<rock-attribute-manage show-group-name mode="[[mode]]" context-data="[[_getContextData(context)]]" config-context="[[configContext]]"
						 no-of-columns="[[noOfColumns]]" allow-save-on-error$="[[allowSaveOnError]]" do-sync-validation$="[[doSyncValidation]]"></rock-attribute-manage>
					</div>
					<div class="divider" style$="[[_getStyle(noOfScreens)]]" align="right">
						<pebble-vertical-divider></pebble-vertical-divider>
					</div>
				</div>
			</template>
		</template>
	</template>
	<script>
		Polymer({
			is: "rock-attribute-split-screen",
			/**
			  * <b><i>Content development is under progress... </b></i> 
			  */
			created: function () {
				if (this.verbose)
					this.logInfo("SplitScreenCreated");
			},
			/**
			  * <b><i>Content development is under progress... </b></i> 
			  */
			attached: function () {
				this.logInfo("SplitScreenAttached");
			},
			/**
			  * <b><i>Content development is under progress... </b></i> 
			  */
			ready: function () {
				this.logInfo("SplitScreenReady");
			},
			properties: {
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				contextData: {
					type: Object,
					value: function () {
						return {};
					}
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				configContext: {
					type: Object,
					value: function () {
						return {};
					}
				},
				/**
				 * Indicates whether the attribute is rendered in the edit mode or view mode. 
				 * The two possible values are <b>view</b> and <b>edit</b>.
				 */
				mode: {
					type: String,
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				noOfScreens: {
					type: Number,
					value: 0
				},
				/**
				 * Indicates the number of columns in which the attributes are rendered. Possible values are 
				 * one, two, and three.
				 */
				noOfColumns: {
					type: Number,
					value: 3,
					computed: '_computeColumns(noOfScreens)'
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				allowSaveOnError: {
					type: Boolean,
					value: false
				},
				/**
				  * <b><i>Content development is under progress... </b></i> 
				  */
				doSyncValidation: {
					type: Boolean,
					value: false
				},
				_contexts: {
					type: Array,
					value: function () {
						return [];
					}
				},

				_showContexts: {
					type: Boolean,
					value: false
				},

				_showContextTitles: {
					type: Boolean,
					value: false
				},

				/**
				 * Indicates whether or not to write the logs.
				 */
				verbose: {
					type: Boolean,
					value: false
				}
			},

			behaviors: [
				RUFBehaviors.ComponentContextBehavior,
				RUFBehaviors.UIBehavior
			],

			observers: [
				'_computeScreens(contextData, configContext)'
			],
			/**
			  * <b><i>Content development is under progress... </b></i> 
			  */
			refresh: function () {
				this._computeScreens(this.contextData, this.configContext);
			},
			/**
			 * Can be used to get the elements if they are dirty.
			 */
			getIsDirty: function () {
				var attributeManage = this.$$("rock-attribute-manage");
				if (attributeManage && attributeManage.getIsDirty) {
					return attributeManage.getIsDirty();
				}
			},
			_getStyle: function (n) {
				if (n == 1) {
					return "display: none";
				} else {
					return "";
				}
			},
			_getAttributeListClass: function (n) {
				return "attribute-list attribute-list-" + n;
			},
			_computeScreens: function (contextData, configContext) {
				if (!(_.isEmpty(contextData) || _.isEmpty(configContext))) {
					var valContexts = this.getValueContexts();
					var dataContexts = this.getDataContexts();

					var tempContexts = {};
					this._prepareFlatContext(valContexts, tempContexts, "value");
					this._prepareFlatContext(dataContexts, tempContexts, "data");
					
					this._contexts = [];
					this.noOfScreens = 1;

					Object.keys(tempContexts).forEach(function (item) {
						if (tempContexts[item] && tempContexts[item].length > 1) {
							this.push('_contexts', ...tempContexts[item]);
							this.noOfScreens = tempContexts[item].length;
						}
					}, this);

					if (this._contexts && this._contexts.length == 0) {
						this._contexts.push(tempContexts[Object.keys(tempContexts)[0]]);
					}

					this._showContexts = true;
					this._showContextTitles = true;
				}
			},
			_computeColumns: function (noOfScreens) {
				if (noOfScreens > 1) {
					return 1;
				} else {
					return this.noOfColumns;
				}
			},
			_getStyle: function (n) {
				if (n == 1) {
					return "display: none";
				} else {
					return "";
				}
			},
			_isHidden: function (item) {
				var index = this.locales.indexOf(item);
				if (index == this.noOfScreens - 1) {
					return true;
				}
				return false;
			},
			_onActionsTap: function () {
				alert("actions tapped");
			},
			_getContextData(context) {
				var ctxData = {};
				var dataContexts = DataHelper.cloneObject(this.getDataContexts());
				var valContexts = DataHelper.cloneObject(this.getValueContexts());
				var itemContext = DataHelper.cloneObject(this.getFirstItemContext());

				if (itemContext) {
					itemContext.attributeNames = this.configContext.attributeNames;
					ctxData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
					ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
					ctxData[ContextHelper.CONTEXT_TYPE_DATA] = [];

					if (context.type == "value") {
						ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;

						if (valContexts && valContexts.length) {
							valContexts.forEach(function (valCtx) {
								if (valCtx[context.name] == context.value) {
									ctxData[ContextHelper.CONTEXT_TYPE_VALUE].push(valCtx);
								}
							}, this);
						}
					} else if (context.type == "data") {
						ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;

						if (dataContexts && dataContexts.length) {
							dataContexts.forEach(function (dataCtx) {
								if (dataCtx[context.name] == context.value) {
									ctxData[ContextHelper.CONTEXT_TYPE_DATA].push(dataCtx);
								}
							}, this);
						}
					} else {
						ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;
						ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;
					}
				}

				return ctxData;
			},
			_prepareFlatContext: function (contexts, formattedContext, contextType) {
				if (contexts && contexts.length) {
					contexts.forEach(function (dataCtx) {
						Object.keys(dataCtx).forEach(function (item) {
							if (!_.contains(Object.keys(formattedContext), item)) {
								formattedContext[item] = []
							}

							if (!this._isContextExist(formattedContext[item], dataCtx[item])) {
								formattedContext[item].push(
									{
										"type": contextType,
										"name": item,
										"value": dataCtx[item]
									}
								);
							}
						}, this);
					}, this);
				}
			},
			_isContextExist: function(contexts, context) {
				var filteredContexts = contexts.filter(function (ctx) { 
					if (ctx.value == context) 
					{ 
						return ctx; 
					} 
				});

				if(filteredContexts && filteredContexts.length) {
					return true;
				} 

				return false;
			}
		});
	</script>
</dom-module>