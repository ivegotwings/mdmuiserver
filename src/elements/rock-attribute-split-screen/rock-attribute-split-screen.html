<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../rock-attribute-manage/rock-attribute-manage.html">
<link rel="import" href="attribute-tab-menu-provider.html">
<!--
	`rock-attribute-split-screen` Represents component to render the manage attributes screen based on the 
	dimensions selected from the `rock-dimension-selector`. If multiple values are selected for any of the 
	dimensions, then the screen splits into number of dimension 
	values selected.
-->

<dom-module id="rock-attribute-split-screen">
	<template>
		<style include="bedrock-style-common"></style>
		<style>
			.attribute-list {
				display: inline-block;
				float: left;
				width: 50%;
				flex: none;
				-webkit-flex: none;
				padding: 22px 20px;
			}

			.attribute-list-1 {
				height: calc(100% - 37px);
				width: 100%;
			}

			.attribute-list-2,
			.attribute-list-3,
			.attribute-list-4 {
				height: calc(100% - 70px);
			}

			.attribute-list-2 {
				width: 50%;
			}

			.attribute-list-3 {
				width: 33%;
			}

			.attribute-list-4 {
				width: 24%;
			}

			.dimension {
				width: 100%;
				@apply --layout;
				@apply --layout-horizontal;
				line-height: 30px;
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 14px);
				color: var(--palette-cerulean, #036bc3);
			}

			#dimensionValueContainer {
				margin-left: 20px;
				margin-top: auto;
			}

			.divider {
				width: 2%;
				height: auto;
			}

			pebble-vertical-divider {
				--pebble-vertical-divider-color: var(--pagelevel-divider, #bacedf);
				height: 100%;
				border: 0px;
				min-height: 0px;
			}

			.actionButton {
				float: right;
			}

			.attribute-manage-container {
				width: 100%;
				height: 100%;
				position: relative;
			}

			.attribute-split-screen-container {
				height: 100%;
			}

			.attribute-split-screen-title-container .attribute-list {
				padding: 10px 0 0 20px;
			}

			.attribute-split-screen-title-container {
				display: flex;
				flex-flow: row;
			}
		</style>

		<div class="attribute-split-screen-container">
			<div id="split-screen-container" class="attribute-split-screen-title-container">
				<template is="dom-if" if="[[_contexts.length]]">
					<div class="dimension" style$="[[_getStyle(noOfScreens)]]">
						<template is="dom-repeat" items="[[_contexts]]" as="context">
							<div id="sourceDimensionValueContainer" class$="[[_getDimensionTitleClass(noOfScreens)]]">
								<pebble-icon-updated icon="pebble-icon:Language" class="pebble-icon-size-16 m-r-10"></pebble-icon-updated>
								[[context.value]]
							</div>
						</template>
					</div>
					<!-- <div class="m-t-10 p-r-10 actionButton">
						<pebble-button id="actions" class="btn btn-success" icon="pebble-icons:Done" button-text="Actions" noink elevation="2" dropdown-icon on-tap="_onActionsTap"></pebble-button>
					</div> -->
				</template>
			</div>
			<template is="dom-if" if="[[_contexts.length]]">
				<template is="dom-repeat" items="[[_contexts]]" as="context" initial-count="1">
					<div class$="[[_getAttributeListClass()]]">
						<div class="attribute-manage-container">
							<rock-attribute-manage readonly$="[[readonly]]" show-group-name mode="[[mode]]"
							context-data="[[_getContextData(context)]]" config-context="[[configContext]]" no-of-columns="[[noOfColumns]]" allow-save-on-error$="[[allowSaveOnError]]"
							do-sync-validation$="[[doSyncValidation]]" apply-context-coalesce="[[applyContextCoalesce]]" apply-locale-coalesce="[[applyLocaleCoalesce]]"
							attributes-chunk-length="[[attributesChunkLength]]">
							</rock-attribute-manage>
						</div>
						<div class="divider" style$="[[_getStyle(noOfScreens)]]" align="right">
							<pebble-vertical-divider></pebble-vertical-divider>
						</div>
					</div>
				</template>

				<bedrock-pubsub event-name="global-edit" handler="_onGlobalEdit"></bedrock-pubsub>
			</template>
		</div>
	</template>
	<script>
		Polymer({
			is: "rock-attribute-split-screen",
			/**
			 * <b><i>Content development is under progress... </b></i>
			 */
			created: function () {
				if (this.verbose)
					this.logInfo("SplitScreenCreated");
			},
			/**
			 * If set as true , it indicates the component is in read only mode
			 */
			readonly: {
				type: Boolean,
				value: false
			},
			/**
			 * <b><i>Content development is under progress... </b></i>
			 */
			attached: function () {
				this.logInfo("SplitScreenAttached");
			},
			/**
			 * <b><i>Content development is under progress... </b></i>
			 */
			ready: function () {
				this.logInfo("SplitScreenReady");
			},
			properties: {
				/**
				 * <b><i>Content development is under progress... </b></i>
				 */
				contextData: {
					type: Object,
					value: function () {
						return {};
					}
				},
				/**
				 * <b><i>Content development is under progress... </b></i>
				 */
				configContext: {
					type: Object,
					value: function () {
						return {};
					}
				},
				/**
				 * Indicates whether the attribute is rendered in the edit mode or view mode.
				 * The two possible values are <b>view</b> and <b>edit</b>.
				 */
				mode: {
					type: String,
				},
				/**
				 * <b><i>Content development is under progress... </b></i>
				 */
				noOfScreens: {
					type: Number,
					value: 0
				},

				attributesChunkLength: {
					type: Number,
					value: 20
				},
				/**
				 * Indicates the number of columns in which the attributes are rendered. Possible values are
				 * one, two, and three.
				 */
				noOfColumns: {
					type: Number,
					value: 3,
					computed: '_computeColumns(noOfScreens)'
				},
				/**
				 * <b><i>Content development is under progress... </b></i>
				 */
				allowSaveOnError: {
					type: Boolean,
					value: false
				},
				/**
				 * <b><i>Content development is under progress... </b></i>
				 */
				doSyncValidation: {
					type: Boolean,
					value: false
				},
				applyLocaleCoalesce: {
					type: Boolean,
					value: false
				},

				applyContextCoalesce: {
					type: Boolean,
					value: false
				},

				_contexts: {
					type: Array,
					value: function () {
						return [];
					}
				},

				/**
				 * Indicates whether or not to write the logs.
				 */
				verbose: {
					type: Boolean,
					value: false
				},
			},

			behaviors: [
				RUFBehaviors.ComponentContextBehavior,
				RUFBehaviors.UIBehavior
			],

			observers: [
				'_computeScreens(contextData, configContext)'
			],
			/**
			 * <b><i>Content development is under progress... </b></i>
			 */
			refresh: function () {
				//this._computeScreens(this.contextData, this.configContext);
				var attributeManage = this.$$("rock-attribute-manage");
				if (attributeManage && attributeManage.refresh) {
					return attributeManage.refresh();
				}
			},
			/**
			 * Can be used to get the elements if they are dirty.
			 */
			getIsDirty: function () {
				var attributeManage = this.shadowRoot.querySelector("rock-attribute-manage");
				if (attributeManage && attributeManage.getIsDirty) {
					return attributeManage.getIsDirty();
				}
			},
			getControlIsDirty: function () {
				var attributeManage = this.$$("rock-attribute-manage");
				if (attributeManage && attributeManage.getControlIsDirty) {
					return attributeManage.getControlIsDirty();
				}
			},
			_getStyle: function (n) {
				return n == 1 ? 'display: none' : '';
			},
			_getAttributeListClass() {
				return `attribute-list attribute-list-${this.noOfScreens}`;
			},
			_getDimensionTitleClass: function (n) {
				return "attribute-list attribute-list-" + n;
			},
			_computeScreens: function (contextData, configContext) {
				if (_.isEmpty(contextData) || _.isEmpty(configContext)) return;
				
				var valContexts = this.getValueContexts();
				var dataContexts = this.getDataContexts();

				var allContexts = {};
				this._prepareFlatContext(valContexts, allContexts, "value");
				this._prepareFlatContext(dataContexts, allContexts, "data");

				const _contexts = Object.keys(allContexts).reduce((res, key, i) => {
					const ctx = allContexts[key];

					if(ctx.length > 1) res.push(...ctx);

					return res;
				}, []);

				this._contexts = _contexts.length ? _contexts : allContexts[Object.keys(allContexts)[0]];
				this.noOfScreens = this._contexts.length;

				this.attributesChunkLength = this._contexts.length > 1 ? 10 : this.attributesChunkLength;
			},
			_computeColumns: function (noOfScreens) {
				return noOfScreens > 1 ? 1 : this.noOfColumns;
			},
			_isHidden: function (item) {
				var index = this.locales.indexOf(item);

				return index === (this.noOfScreens - 1);
			},
			_onActionsTap: function () {
				alert("actions tapped");
			},
			_getContextData(context) {
				var ctxData = {};
				
				var itemContext = DataHelper.cloneObject(this.getFirstItemContext());

				if (!itemContext) return ctxData;

				var dataContexts = DataHelper.cloneObject(this.getDataContexts());
				var valContexts = DataHelper.cloneObject(this.getValueContexts());
				
				itemContext.attributeNames = this.configContext.attributeNames;
				ctxData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
				ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
				ctxData[ContextHelper.CONTEXT_TYPE_DATA] = [];

				if (context.type == "value") {
					ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;

					if (valContexts && valContexts.length) {
						valContexts.forEach(function (valCtx) {
							if (valCtx[context.name] == context.value) {
								ctxData[ContextHelper.CONTEXT_TYPE_VALUE].push(valCtx);
							}
						});
					}
				} else if (context.type == "data") {
					ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;

					if (dataContexts && dataContexts.length) {
						dataContexts.forEach(function (dataCtx) {
							if (dataCtx[context.name] == context.value) {
								ctxData[ContextHelper.CONTEXT_TYPE_DATA].push(dataCtx);
							}
						});
					}
				} else {
					ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;
					ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;
				}

				return ctxData;
			},
			_prepareFlatContext: function (contexts, formattedContext, contextType) {
				if (!contexts || !contexts.length) return;
				
				contexts.forEach(dataCtx => Object.keys(dataCtx).forEach(item => {
					const contextValue = dataCtx[item];

					let formattedContextItem = formattedContext[item];

					if (!formattedContextItem) {
						formattedContextItem = formattedContext[item] = [];
					}

					const _isContextExist = this._isContextExist(formattedContextItem, contextValue);

					if (!contextValue || _isContextExist) return;
					
					formattedContextItem.push({
						"type": contextType,
						"name": item,
						"value": contextValue
					});
				}));
			},
			_isContextExist: function (contexts, context) {
				if (!contexts || !context) return false;
				
				return !!contexts.filter(ctx => ctx.value == context).length;
			},

			_onGlobalEdit: function (e) {
				if (!e || !e.detail) return;
				
        var attrsWritePermissions = [];
				var rockAttributeManageList = this.shadowRoot.querySelectorAll("rock-attribute-manage");

				if (rockAttributeManageList.length > 0) {
					for (var i = 0; i < rockAttributeManageList.length; i++) {
						var rockAttributeManage = rockAttributeManageList[i];

						if (rockAttributeManage.areAttributesEditable) {
              rockAttributeManage.globalEdit = true;
						}

            attrsWritePermissions.push(rockAttributeManage.areAttributesEditable);
					}

					// if no attributes are editable
					if (!attrsWritePermissions.some(function (attr) { return attr === true; })) {
						 this.showWarningToast("No editable attributes available");
					}
				}
			}
		});
	</script>
</dom-module>