<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/component-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">

<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-file-upload/pebble-file-upload.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">

<link rel="import" href="../rock-grid/rock-grid.html">

<dom-module id="rock-entity-create-import">
    <template>
        <style include="pebble-styles-shared">
            .placeHolder {
                width: 880px;
                height: 400px;
                margin: 0 auto;
                box-shadow: 0 0 10px 0 var(--cloudy-blue-color, #c1cad4);
                position: relative;
            }
            
            #multiEntityUpperGrid::shadow iron-data-table {
                height: 135px;
            }
            
            #upperGridHeader {
                font-size: 12px;
                margin: 10px;
            }

            #content-actions {
                padding-top: 30px;
                position: fixed;
                bottom: 0;
                background: rgba(255, 255, 255, 0.80);                
                text-align: center;
                width: 100%;
                z-index: 9999;
            }

            #content-label {
                box-shadow: 0 1px 7px 0 #c1cad4;
                padding: 15px;
                margin: 10px;
            }

            #image-container {
                width: 30px;
                height: 35px;
                vertical-align: middle;
            }

            import-log {
                vertical-align: middle;
            }

            .title {
                font-size: var(--default-font-size, 14px);		                  
                text-align: center;
                color:var(--palette-steel-grey, #75808b);
            }
            pebble-button[disabled] {
                pointer-events: none;
                color: #c1cad4;
                background-color: #c1cad4;
                border-color: #c1cad4;
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <iron-ajax auto url="config\gridConfig.json" handle-as="json" last-response="{{_gridConfig}}"></iron-ajax>
        <liquid-rest id="copTransform" url="/cop/transform" 
            method="POST" request-data={{_copTransformRequest}} on-liquid-response="_onTransformSuccess" on-liquid-error="_onTransformFailure"></liquid-rest>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="[[attributeModelRequest]]" 
            on-response="_onCompositeModelResponse"></liquid-entity-model-composite-get>
        <liquid-entity-data-save name="entitiesSaveDataService" operation="create" request-data="{{_saveRequest}}" on-response="_onSaveResponse"></liquid-entity-data-save>
        <div id="content-entity-import" hidden>
            <div class="placeHolder p-10">
                <p class="title"><a href="#" class="btn-link" on-tap="_selectFile">Download</a> a system template or just upload an existing data file</p>
                <!-- screen for import -->
                <pebble-file-upload accept="application/msword, application/vnd.ms-excel, application/vnd.ms-powerpoint,
                    text/plain, application/pdf, image/*" target="/file-upload"></pebble-file-upload>
                <bedrock-pubsub on-bedrock-event-pebble-file-upload-success="_onFileUploadSuccess"></bedrock-pubsub>
            </div>
        </div>
        <div id="content-label" hidden>
            <pebble-image-viewer alt="Product image." id="image-container" sizing="contain"
                                         src="/src/images/Microsoft Excel 50, 100, 500 px/Microsoft Excel_100.svg"></pebble-image-viewer>
            <span class="import-log"><strong>[[_fileName]]</strong> uploaded <strong>[[_entities.length]]</strong> items with <strong>[[attributeNames.length]]</strong> attributes.</span>
        </div>
        <div id="content-mapping-grid" hidden>
            <!-- screen for multi entity create function- probably grid -->
            <div id="upperGridHeader"><b>[[attributeNames.length]] Attributes</b> ([[_managedAttrs]] Managed, [[_mappedAttrs]] Mapped, [[_newAttrs]]
                New). Last Updated on <b>[[_currentDateTime.date]]</b> at <b>[[_currentDateTime.time]]</b></div>
            <rock-grid id="multiEntityUpperGrid" page-size="2" no-header></rock-grid>
            <bedrock-pubsub on-bedrock-event-save-item="_onSaveItem"></bedrock-pubsub>
        </div>
        <div id="content-entities-grid" hidden>
            <rock-grid id="entitiesGrid" data="{{_gridData}}" page-size="10" no-header></rock-grid>
        </div>
        <div id="content-actions" class="p-b-10" align="center" hidden>
            <pebble-button class="action-button btn btn-secondary m-r-5" id="skip" button-text="Cancel" raised on-tap="_onSkipTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>
    </template>
     <script>
            (function () {
                'use strict';

                Polymer({
                    is: "rock-entity-create-import",

                    properties: {
                        /**
                         * Indicates the names of the attributes that are rendered while creating a single entity.
                         */
                        attributeNames: {
                            type: Array,
                            value: function() {
                                return [];
                            }
                        },
                        /**
                         * Indicates the mode in which the attributes are rendered.
                         */
                        mode: {
                            type: String,
                            value: "edit",
                            notify: true
                        },
                        /**
                         * Specifies the request object for attribute model request.
                         */
                        attributeModelRequest: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        /**
                         * Specifies the response object for attribute models.
                         */
                        attributeModelResponse: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        /**
                         * Specifies the source in which entity has to be created.
                         */
                        source: {
                            type: String
                        },
                        /**
                         * Specifies the locale in which entity has to be created.
                         */
                        locale: {
                            type: String
                        },
                        /**
                         * Specifies the list in which entity has to be created.
                         */
                        list: {
                            type: String
                        },
                        /**
                         * Specifies the classification in which entity has to be created.
                         */
                        classification: {
                            type: String
                        },
                        /**
                         * Specifies the type of the entity to be created.
                         */
                        entityType: {
                            type: String
                        },
                        context: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        _attributeValues: {
                            type: Array,
                            value: function() {
                                return [];
                            }
                        },
                        _gridConfig: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        _gridData: {
                            type: Array,
                            value: function() {
                                return [];
                            }
                        },
                        _managedAttrs: {
                            type: Number,
                            value: 0
                        },
                        _mappedAttrs: {
                            type: Number,
                            value: 0
                        },
                        _newAttrs: {
                            type: Number,
                            value: 0
                        },
                        _currentDateTime: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        context: {
                            type: Object,
                            value: function() {
                                return {};
                            }
                        },
                        _copTransformRequest: {
                            type: Object,
                            value: function() { return {}; }
                        },
                        _entitiesData: {
                            type: Object,
                            value: function() { return {}; }
                        },
                        _entities: {
                            type: Array,
                            value: function() { return []; }
                        },
                        _saveRequest: {
                            type: Object,
                            value: function() { return {}; }
                        },
                        _attributeModels: {
                            type: Object
                        },
                        _fileName: {
                            type: String
                        },
                        _currentBatchNumber: {
                            type: Number,
                            value: 0
                        },
                        _batchSize: {
                            type: Number,
                            value: 10
                        },
                        _loading: {
                            type: Boolean,
                            value: false
                        }
                    },
                    observers: [
                        '_attributesChanged(attributeNames)'
                    ],
                    behaviors: [
                        RUFBehaviors.UIBehavior
                    ],
                    ready: function() {
                        this._prepareContext();
                        this._showView("entity-import");
                    },
                    _prepareContext: function() {
                        this.source = DataHelper.getParamValue("source");
                        this.locale = DataHelper.getParamValue("locale");
                        this.list = DataHelper.getParamValue("list");
                        this.classification = DataHelper.getParamValue("classification");
                        this.entityType = DataHelper.getParamValue("entityType");
                        var context = {
                            "list": this.list,
                            "source": this.source,
                            "locale": this.locale,
                            "classification": this.classification,
                            "entityType": this.entityType
                        };
                        this.set("context", context);
                    },
                    _getCurrentCtx: function() {
                        var ctxItem = {};
                        ctxItem.list = this.list;
                        ctxItem.classification = this.classification;
                        return ctxItem;
                    },
                    _attributesChanged: function(attributeNames) {
                        if (attributeNames && attributeNames.length > 0) {
                            var ctxGroup = this._getCurrentCtx();
                            var t = {
                                "params": {
                                    "query": {
                                        "ctx": [
                                            ctxGroup
                                        ],
                                        "locale": this.locale,
                                        "name": this.entityType
                                    },
                                    "fields": {
                                        "ctxTypes": [
                                            "properties"
                                        ],
                                        "attributes": attributeNames
                                    }
                                }
                            };
                            this.set("attributeModelRequest", t);
                            var liquidModelGet = this.$$("[name=compositeAttributeModelGet]");
                            if (liquidModelGet) {
                                liquidModelGet.generateRequest();
                            }
                        }
                    },
                    _onCompositeModelResponse: function(e) {
                        if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                            
                            var valCtx = {
                                "locale": this.locale,
                                "source": this.source
                            };

                            var ctxGroup = this._getCurrentCtx();
                            if(!this._attributeModels) {
                                this._attributeModels = DataHelper.transformAttributeModelsToUIFormat(e.detail.response.content.entityModels[0], ctxGroup);
                                this._populateEntityGrid();
                            }
                        } else {
                            this._showErrorToast("Unable to fetch attribute models. Please check the service or contact your administrator.");
                            this._loading = false;
                        }
                    },
                     _showView: function(viewName) {
                        if (viewName) {
                            var contentView = this.$$("#content-" + viewName);
                            if (contentView) {
                                contentView.removeAttribute("hidden");
                            }
                        }
                    },

                    _hideView: function(viewName) {
                        if (viewName) {
                            var contentView = this.$$("#content-" + viewName);
                            if (contentView) {
                                contentView.setAttribute("hidden", "");
                            }
                        }
                    },
                    _populateMultiEntityUpperGrid: function() {
                        //Fetch the attributes from COP and pass to this.attributeNames
                        //Based on attributeNames change, attributeModelRequest will be set
                        //Using attributeModelGetServiceFetch, attribute models will be provided

                        //Prepare grid configuration and data based on COP and Liquid details                    
                        this._prepareMultiEntityUpperGridConfiguration();
                        this._prepareMultiEntityUpperGridData();
                        this._prepareUpperGridHeader();

                        //Set config and data to grid
                        this.$$('#multiEntityUpperGrid').config = this._gridConfig;
                        this.$$('#multiEntityUpperGrid').data = this._gridData;

                        this.async(function() {
                            var gridTable = this.$$('#multiEntityUpperGrid').$$('#pebbleGridContainer').querySelector('iron-data-table');
                            var firstRow = gridTable.querySelectorAll('data-table-row')[1];
                            var secondRow = gridTable.querySelectorAll('data-table-row')[2];

                            // Section start, will be removed this logic once rock-grid updated
                            var firstRowButtons = firstRow.querySelectorAll('pebble-button');
                            if (firstRowButtons.length > 0) {
                                firstRowButtons[0].remove();
                                firstRowButtons[1].remove();
                            }
                            // Section end

                            firstRow.querySelectorAll('data-table-cell')[1].style['font-weight'] = 'bold';
                            secondRow.querySelectorAll('data-table-cell')[1].style['font-weight'] = 'bold';

                            // Attributes matched from managed list is black
                            // Attributes matched from inferred list is green
                            // Attributes are not matched (new), then red                        

                        }, 100);
                    },

                    _prepareMultiEntityUpperGridConfiguration: function() {
                        this._gridConfig.tabular.columns.push({
                            "header": "Mapping",
                            "name": "mapping"
                        });
                        for (var idx = 0; idx < this.attributeNames.length; idx++) {
                            this._gridConfig.tabular.columns.push({
                                "header": "Column " + (idx + 1),
                                "name": this.attributeNames[idx],
                                "displayType": "textbox"
                            });
                        }
                    },

                    _prepareMultiEntityUpperGridData: function() {
                        this._gridData = []; //Clear the data
                        var gridRow = {};
                        gridRow["id"] = 1;
                        gridRow["mapping"] = "Excel column name";
                        //First row
                        for (var idx = 0; idx < this.attributeNames.length; idx++) {
                            gridRow[this.attributeNames[idx]] = this.attributeNames[idx];
                        }
                        this._gridData.push(gridRow);

                        gridRow = {};
                        gridRow["id"] = 2;
                        gridRow["mapping"] = "Mapped attribute name";

                        //Second row - Capture the details from data model 
                        for (var idx = 0; idx < this.attributeNames.length; idx++) {
                            if (this._findAttribute(this.attributeNames[idx])) {
                                this._mappedAttrs++;
                                gridRow[this.attributeNames[idx]] = this._findAttribute(this.attributeNames[idx]).name;
                            } else {
                                this._newAttrs++;
                            }
                        }
                        this._gridData.push(gridRow);

                        //Current Datetime
                        var datetime = new Date();
                        this._currentDateTime = {
                            "date": moment(datetime).format('MM/DD/YYYY'),
                            "time": moment(datetime).format('hh:mm A')
                        }
                    },

                    _findAttribute: function(attribute) {
                        for (var i = 0; i < this._attributeValues.length; i++) {
                            for (var j = 0; j < this._attributeValues[i].attributes.length; j++) {
                                if (this._attributeValues[i].attributes[j].name == attribute) {
                                    return this._attributeValues[i].attributes[j];
                                }
                            }
                        }
                    },

                    _prepareUpperGridHeader: function() {
                        //Total managed attributes                    
                        for (var i = 0; i < this._attributeValues.length; i++) {
                            this._managedAttrs = this._managedAttrs + this._attributeValues[i].attributes.length;
                        }
                    },

                    _onSaveItem: function(e, details, sender) {
                        //Save logic comes here
                    },

                    _onFileUploadSuccess: function(e, detail, sender) {
                        this._loading = true;
                        //this._populateMultiEntityUpperGrid();
                        var fileName = detail.fileName;
                        this.set("_fileName", detail.originalFileName);
                        var copRequest = {
                            "fileName": fileName
                        };
                        this.set("_copTransformRequest", copRequest);
                        var liqTransform = this.$$("#copTransform");
                        if(liqTransform) {
                            liqTransform.generateRequest();
                        }
                        this.async(function() {
                            //Clear file upload
                            this.$$('pebble-file-upload').reset();
                        });
                    },
                    _onTransformSuccess: function(e) {
                        var response = e.detail.response;
                        if(response && response.entityOperationResponse && response.entityOperationResponse.entities
                            && response.entityOperationResponse.entities.length > 0) {
                             this._hideView("entity-import");
                             this._hideButtons();
                             this._showView("label");
                             this._showView("entities-grid");
                             this._showView("actions");
                             this._entities = response.entityOperationResponse.entities;
                             this.attributeNames = DataHelper.getAttributeNamesFromEntities(this._entities);
                        } else {
                            console.warn("Unexpected COP response:" + e.detail.response);
                            this._showErrorToast("Unable to transform excel to json. Please check the service or contact your administrator.");
                            this._loading = false;
                        }
                    },
                    _onTransformFailure: function(e) {
                        console.warn('COP transformation failed with error ', e.detail);
                        this._showErrorToast("Unable to transform excel to json. Please check the service or contact your administrator.");
                        this._loading = false;
                    },
                    _populateEntityGrid: function() {
                        var entitiesGrid = this.$$('#entitiesGrid');
                        if(entitiesGrid) {
                            entitiesGrid.config = {};
                            entitiesGrid.data = [];
                            this._prepareEntityGridConfig();
                            entitiesGrid.config = this._gridConfig;
                            this._prepareEntityGridData();
                            entitiesGrid.data = this._gridData;
                            this._loading = false;
                        }
                    },
                    _prepareEntityGridConfig: function() {
                        if(this._attributeModels) {
                            var keys = Object.keys(this._attributeModels);
                            if(keys && keys.length > 0) {
                                for (var i = 0; i< keys.length; i++) {
                                    var model = this._attributeModels[keys[i]];
                                    this._gridConfig.tabular.columns.push({
                                        "header": model.externalName,
                                        "name": model.name,
                                        "sortable": true
                                    });
                                }
                            }
                        }
                    },
                    _prepareEntityGridData: function() {
                        var dataContext = {
                                "list": this.list,
                                "classification": this.classification,
                                "source": this.source,
                                "time": "now",
                                "locale": this.locale
                            };
                        //DataHelper.transformEntitySchemaForGrid(this._entities, this._attributeModels, dataContext);
                        for(var i=0; i< this._entities.length; i++) {
                            var attributes = this._entities[i].data.ctxInfo[0].attributes;
                            var keys = Object.keys(attributes);
                            if(keys && keys.length>0) {
                                var rowData = {
                                    "id": this._entities[i].id
                                };
                                for(var j=0; j<keys.length; j++) {
                                    var key = keys[j];
                                    rowData[key] = attributes[key].values[0].value;
                                }
                                this._gridData.push(rowData);
                            }
                        }
                    },
                    _onSaveTap: function(e) {
                        this._disableActions();
                        this._loading = true;
                        //get all entities from grid and process save
                        var gridData = this.$$("#entitiesGrid").data;
                        var dataContext = {
                                "list": this.list,
                                "classification": this.classification,
                                "source": this.source,
                                "time": "now",
                                "locale": this.locale,
                                "entityType": this.entityType
                            };
                        this._entities = DataHelper.TransformGridDataToEntitiesSchema(gridData, dataContext, this._attributeModels);
                        var batchEntities = this._getNextBatch(this._entities, this._currentBatchNumber,  this._batchSize);
                        this._saveRequest = {
                            "entities": batchEntities
                        };
                        var liquidSave = this.$$("[name=entitiesSaveDataService]");
                        if (liquidSave) {
                            liquidSave.generateRequest();
                        }
                    },
                    _onSaveResponse: function(e) {
                        this._currentBatchNumber++;
                        var batchEntities = this._getNextBatch(this._entities, this._currentBatchNumber,  this._batchSize);
                        if(batchEntities && batchEntities.length > 0) {
                            this._saveRequest = {
                                "entities": batchEntities
                            };
                            var liquidSave = this.$$("[name=entitiesSaveDataService]");
                            if (liquidSave) {
                                liquidSave.generateRequest();
                            }
                        } else {
                            this._loading = false;
                            var msg = this._entities.length + " entities saved successfully!!";
                            this._showSuccessToast(msg);
                            var eventName = "onSave";
                            var eventDetail = {
                                name: eventName
                            };
                            this.async(function() {
                                this.fireBedrockEvent(eventName, eventDetail, {
                                    ignoreId: true
                                });
                            }, 1000);
                        }
                        
                    },
                    _onSkipTap: function(e) {
                        //raise event with name given for onbackAction in configuration
                        var data;
                        var eventName = "onCancel";
                        var eventDetail = {
                            name: eventName,
                            data: data
                        }
                        this.fireBedrockEvent(eventName, eventDetail, {
                            ignoreId: true
                        });
                    },
                     _hideButtons: function() {
                        var parentEl = ComponentHelper.getParentElement(this);
                        if(parentEl && parentEl.hideCreateButtons) {
                            parentEl.hideCreateButtons();
                        }
                    },
                    _getNextBatch: function(entities, currentBatchNumber, batchSize) {
                        var start = currentBatchNumber*batchSize;
                        var end = ((currentBatchNumber+1)*batchSize) - 1;
                        if(start > entities.length) { 
                            return; 
                        }
                        if(end > entities.length) { 
                            end = entities.length - 1; 
                        } 
                        return entities.slice(start, end+1);
                    },
                    _showSuccessToast: function(message) {
                        var mainApp = document.querySelector('#app');
                        mainApp.toastText = message;
                        var toastElement = mainApp.$$("#pebbleAppToast");
                        toastElement.toastType = "success";
                        toastElement.heading = "Success";
                        toastElement.autoClose = true;

                        toastElement.show();
                    },
                    _showErrorToast: function(message) {
                        var mainApp = document.querySelector('#app');
                        mainApp.toastText = message;
                        var toastElement = mainApp.$$("#pebbleAppToast");
                        toastElement.toastType = "error";
                        toastElement.heading = "Error";
                        toastElement.autoClose = true;

                        toastElement.show();
                    },
                    _disableActions: function() {
                        var saveButton = this.$$("#next");
                        var cancelButton = this.$$("#skip")
                        saveButton.setAttribute("disabled", true);
                        cancelButton.setAttribute("disabled", true);
                    }
                });
            })();
        </script>
</dom-module>