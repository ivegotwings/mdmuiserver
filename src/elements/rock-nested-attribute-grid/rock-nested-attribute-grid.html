<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-info-icon/pebble-info-icon.html">

<link rel="import" href="../rock-grid/rock-grid.html">

<dom-module id="rock-nested-attribute-grid">
    <template>
        <style  include="bedrock-style-common">
            rock-grid {
                --rock-grid-height: auto !important;
                --data-table-container-position: relative;
            }

            .grid {
                margin-top: 10px;
            }
        </style>
        <label class="attribute-view-label" hidden$="[[!label]]" aria-hidden="true">[[label]]
            <pebble-info-icon description-object="[[__getDescriptionValue()]]"></pebble-info-icon>
        </label>
        <template is="dom-if" if="[[_isEditMode(mode)]]">
            <template is="dom-if" if="[[_isAttributeEditable(attributeModelObject)]]">
                <div class="button">
                    <pebble-button icon="pebble-sm-icons:Add" id="button_add" class="btn btn-primary m-r-10" button-text="Add"
                        on-click="_onAddRowClick"></pebble-button>
                </div>     
            </template>
        </template>
        <div class="grid" hidden$="[[!_showGrid]]">
            <rock-grid id="attributesGrid"
                    config="{{_gridConfig}}"
                    data="{{_gridData}}"
                    attribute-models = "[[_attributeModels]]"
                    no-header page-size="20"
                    is-dirty="{{_isGridDirty}}"
                    context-data="[[contextData]]">
            </rock-grid>
            <bedrock-pubsub event-name="delete-item" handler="_onRowDelete" target-id="attributesGrid"></bedrock-pubsub>
            <bedrock-pubsub event-name="refresh-grid" handler="_onRefreshGrid" target-id="attributesGrid"></bedrock-pubsub>
        </div>
    </template>
    <script>
        (function() {
            'use strict';

            Polymer({
                is: "rock-nested-attribute-grid",

                properties: {
                    contextData: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    /**
                    * Indicates the label for the nested attribute grid.
                    * It allows to add descriptive text for the nested attribute to inform the user about the type of data 
                    * expected in the nested attribute. 
                    */
                    label: {
                        type: String
                    },
                    _gridConfig: {
                        type: Object,
                        value: function () {
                            return {
                                "viewMode": "Tabular",
                                "schemaType": "colModel",
                                "statusEnabled": true,
                                "tabular": {
                                    "settings": {
                                        "isMultiSelect": false,
                                        "disableSelectAll": true,
                                        "rowIdentifier": "groupidentifier",
                                        "actions": [
                                            {
                                                "name": "delete",
                                                "icon": "pebble-icons:Delete",
                                                "eventName": "delete-item"
                                            }
                                        ]
                                    },
                                    "columns": []
                                }
                            };
                        }
                    },
                    /**
                     * Indicates whether the attribute is rendered in edit mode or view mode.
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                    * Indicates the JSON for the attribute value object. This object records all the user changes to the value.
                    * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                    */
                    attributeObject: {
                        type: Object,
                        value: function() {
                            return {};
                        },
                        notify: true
                    },
                    /**
                    * Indicates the JSON for the original attribute value object. This object does not record all the user changes to the value.
                    * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                    */
                    originalAttributeObject: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    /**
                    * Indicates the JSON for the attribute model object.
                    * It renders appropriate UI element to edit the attribute, to configure the validation, and other behaviors.
                    * Sample: {
                                "name": "name",
                                "externalName": "Name",
                                "displayType": "textbox",
                                "minLength": 5,
                                "maxLength": 10
                              }
                    */
                    attributeModelObject: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    /**
                     * Indicates whether or not an attribute object value is changed.
                     */
                    changed: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    _gridData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _attributeModels: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _isGridDirty: {
                        type: Boolean,
                        value: false
                    },
                    _isGridReady: {
                        type: Boolean,
                        value: false
                    },
                    _showGrid: {
                        type: Boolean,
                        value: false
                    }
                },
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                observers: [
                    '_attributeModelObjectChanged(attributeModelObject)',
                    '_attributeObjectChanged(attributeObject)',
                    '_modeChanged(mode)',
                    '_gridDataChanged(_isGridDirty)'
                ],
                _attributeModelObjectChanged: function(attributeModelObject) {
                    if(!_.isEmpty(attributeModelObject)) {
                        this._prepareGridConfig(attributeModelObject);
                    }
                },
                _attributeObjectChanged: function(attributeObject) {
                    if(!_.isEmpty(attributeObject) && attributeObject.value && (!this._isGridReady || (this.originalAttributeObject && this.originalAttributeObject.value && DataHelper.areEqualArrays(attributeObject.value, this.originalAttributeObject.value)))) {
                        this._prepareGridData(attributeObject);
                    }
                },
                _prepareGridConfig: function(attributeModelObject) {
                    if(attributeModelObject && attributeModelObject.group && attributeModelObject.group.length > 0) {
                        var attributeModels = attributeModelObject.group[0];
                        for(var model in attributeModels) {
                            attributeModels[model].hasWritePermission = true;
                        }
                        this._gridConfig.mode = this.mode === "edit" ? "edit" : "read";
                        this.set("_attributeModels", attributeModels);
                        var keys = Object.keys(attributeModels);
                        if(keys && keys.length>0) {
                            for(var i=0; i<keys.length; i++) {
                                var attributeModel = attributeModels[keys[i]];
                                var column = {
                                    "header": attributeModel.externalName,
                                    "name": attributeModel.name,
                                    "filterable": true,
                                    "sortable": true
                                };
                                this._gridConfig.tabular.columns.push(column);
                            }
                        }
                    }
                },
                _prepareGridData: function(attributeObject) {
                    this._gridData = [];
                    
                    this.async(function() {
                        if(attributeObject && attributeObject.value && attributeObject.value.length > 0) {
                            for(var  i=0; i<attributeObject.value.length; i++) {
                                var value = attributeObject.value[i];
                                if(!this._gridData.find(obj => value["valueIdentifier"] && (obj.valueIdentifier === value["valueIdentifier"].value))) {
                                    var rowData = {};
                                    for(var attrName in value) {
                                        rowData[attrName] = value[attrName].value;
                                        if(value[attrName].referenceDataId) {
                                            rowData[attrName + "_referenceDataId"] = value[attrName].referenceDataId;
                                        }
                                        if(value[attrName].properties) {
                                            rowData[attrName + "_properties"] = value[attrName].properties;
                                        }
                                        if(value[attrName].contextCoalescePaths) {
                                            rowData[attrName + "_contextCoalescePaths"] = value[attrName].contextCoalescePaths;
                                        }
                                    }
                                    if(!this._isRowEmpty(rowData))  this._gridData.push(rowData);
                                }
                            }
                        }
                        this._originalGridData = DataHelper.cloneObject(this._gridData);
                        if(this.mode === "edit") {
                            setTimeout(function () {
                                this._modeChanged(this.mode);
                            }.bind(this), 500);
                        } else {
                            this._modeChanged(this.mode);
                        }
                        this._setGridHeight(this._gridData.length);
                    });
                    this._isGridReady = true;
                },
                _modeChanged: function(mode) {
                    this._gridData = this._originalGridData ? DataHelper.cloneObject(this._originalGridData) : [];
                    
                    const _showGrid = mode === 'edit' || (mode === 'view' && !_.isEmpty(this.attributeObject.value));

                    this.set("_showGrid", _showGrid);

                    const _gridMode = mode === 'view' ? 'read' : mode;
                    this.set('_gridConfig.mode', _gridMode);
                },
                _gridDataChanged: function(_isGridDirty) {
                    if(_isGridDirty === true) {
                        this.changed = true;
                    } else if(_isGridDirty === false) {
                        this.changed = false;
                    } else {
                        this.changed = undefined;
                    }
                    this._setAttributeObject();
                },
                __getDescriptionValue: function () {
                    var props;
                    if (this.attributeModelObject) {
                        var props = {description: []};
                        if (this.attributeModelObject.externalName &&  this.attributeModelObject.description) {
                            props.description.push(this.attributeModelObject.externalName + ": " + this.attributeModelObject.description);
                        }
                        if (this.attributeModelObject.group) {
                            Object.getOwnPropertyNames(this.attributeModelObject.group[0]).forEach(function (name) {
                                var item = this.attributeModelObject.group[0][name];
                                if(item.externalName && item.description) {
                                    props.description.push(item.externalName + ": " + item.description);
                                }
                            }.bind(this));
                        }
                    }
                    return props;
                },
                _setAttributeObject: function() {
                    if(this.changed) {
                        var grid = this.shadowRoot.querySelector("#attributesGrid");
                        var modifiedData = grid.getModifiedData();

                        if(modifiedData && modifiedData.length > 0) {
                            for(var i=0; i<modifiedData.length; i++) {
                                var rowData = modifiedData[i];

                                var _status = rowData["_rowStatus"]["status"];
                                var value = this.attributeObject.value.find(obj => obj.valueIdentifier.value === rowData.valueIdentifier && obj.action !== "delete");
                                var deletedValue = this.attributeObject.value.find(obj => obj.valueIdentifier.value === rowData.valueIdentifier && obj.action === "delete");
                                var originalVal = this.originalAttributeObject.value.find(obj => obj.valueIdentifier.value === rowData.valueIdentifier);

                                if(this._isRowEmpty(rowData)) {
                                    if(value) {
                                        /***means user cleared all child attributes in this row. Hence update status to "delete".***/
                                        _status = "delete";
                                    }
                                } else {
                                    if(!value && !deletedValue) {
                                        /***when new row added, we are just modifying grid data, not nested attribute object.
                                         * Nested attribute object will be modified only when user enters some value in 
                                         * one of the child attributes. This is to make sure we don't send any row with empty data to RDF for save.
                                         * Here when "value" and "deletedValue" are undefined, means its a new row added, creating one empty row, pushing it to attribute object
                                         * to update the data of this row later***/
                                        value = this._getNewValueObject(rowData);
                                        this.attributeObject.value.push(value);
                                    }
                                }

                                if(value) {
                                    if(_status === "delete") {
                                        /***find the row with this value, replace it with original data and mark it as delete.
                                         * If not replaced with original data, RDF cannot be able to delete the row***/
                                        var index = this.attributeObject.value.indexOf(value);
                                        if(index !== -1) {
                                            if(deletedValue && value.valueIdentifier.value === deletedValue.valueIdentifier.value) {
                                                /***if value and deleted value both are present, user has edited child attribute with
                                                 * with isAttributeIdentifier flag first and then cleared all child attributes or marked 
                                                 * it delete. In this case to avoid duplicating the rows to be deleted.***/
                                                this.attributeObject.value.splice(index,1);
                                            } else {
                                                /***replace the row data with original row data before marking the row with delete.***/
                                                this.attributeObject.value[index] = DataHelper.cloneObject(originalVal);
                                                this.attributeObject.value[index]["action"] = "delete";
                                            }
                                        }
                                    } else if(this._isIdentifierUpdated(rowData, originalVal) && !deletedValue) {
                                        /***if a child attribute with isAttributeIdentifier flag updated, we need to mark the 
                                         * existing row as delete, create new row with new/modified data.***/
                                        var index = this.attributeObject.value.indexOf(value);
                                        if(index !== -1) {
                                            if(originalVal) {
                                                /***replace the row data with original row data before marking the row with delete.***/
                                                this.attributeObject.value[index] = DataHelper.cloneObject(originalVal);
                                            }
                                            this.attributeObject.value[index]["action"] = "delete";
                                        }
                                        
                                        /***creating one new empty row***/
                                        var valObj = this._getNewValueObject(rowData);
                                        /***updating new row with updated data***/
                                        this._updateRowDataWithValue(rowData, valObj);
                                        /***pushing it to attribute object***/
                                        this.attributeObject.value.push(valObj);
                                    } else {
                                        /***Child attribute without isAttributeIdentifier flag updated, directly
                                        * update the original row.***/
                                        this._updateRowDataWithValue(rowData, value);
                                    }
                                }
                            }
                        }
                    } else if(this.changed === false) {
                        this.attributeObject = DataHelper.cloneObject(this.originalAttributeObject);
                    }
                },
                _isRowEmpty: function(rowData) {
                    var attributes = Object.keys(rowData);
                    var self = this;
                    if(attributes && attributes.length) {
                        var keysWithValue = attributes.filter(function(key) {
                            if(self._attributeModels[key] && (!_.isEmpty(rowData[key]) || _.isNumber(rowData[key]))) {
                                return key;
                            }
                        });
                        if(keysWithValue && keysWithValue.length > 0) {
                            return false;
                        }
                    }
                    return true;
                },
                _getNewValueObject: function(rowData) {
                    var values = DataTransformHelper.transformNestedAttributes({}, this._attributeModels, true);
                    var value = values[0];
                    value["valueIdentifier"].value = rowData.valueIdentifier;
                    return value
                },
                _isIdentifierUpdated: function(data, value) {
                    var identifierAttrName = undefined;
                    for(var attrName in this._attributeModels) {
                        if(this._attributeModels[attrName] && this._attributeModels[attrName].isAttributeIdentifier === true) {
                            identifierAttrName = this._attributeModels[attrName].name;
                        }
                    }
                    if(identifierAttrName) {
                        if(value && value[identifierAttrName] && data[identifierAttrName] !== value[identifierAttrName].value) {
                            return true;
                        }
                    }
                    return false;
                },
                _updateRowDataWithValue: function(rowData, value) {
                    for(var attrName in rowData) {
                        if(this._attributeModels[attrName]) {
                            value[attrName] = value[attrName] ? value[attrName]: {};
                            value[attrName]["value"] = rowData[attrName];
                        }
                        if(attrName.indexOf("referenceDataId") !== -1) {
                            var name = attrName.substring(0, attrName.indexOf("_"));
                            value[name]["referenceDataId"] = rowData[attrName];
                        }
                        if(attrName.indexOf("selectedLocales") !== -1) {
                            var name = attrName.substring(0, attrName.indexOf("_"));
                            value[name]["selectedLocales"] = rowData[attrName];
                        }
                    }
                },
                _onRowDelete: function(e, detail) {
                   this._notifyDirty();
                },
                _isEditMode: function(mode) {
                    return mode === "edit";
                },
                _isAttributeEditable: function (attributeModelObject) {
                    return attributeModelObject.hasWritePermission && !attributeModelObject.readOnly;
                },
                _onAddRowClick: function(e) {
                    var length = this._gridData.length;
                    var values = DataTransformHelper.transformNestedAttributes({}, this._attributeModels, true);
                    var value = values[0];
                    value["valueIdentifier"].value = length;
                    var newRowItem = {};
                    for(var attrName in value) {
                        newRowItem[attrName] = value[attrName].value;
                    }
                    var grid = this.shadowRoot.querySelector("#attributesGrid");
                    grid.addNewRecords([newRowItem]);
                    this._setGridHeight(length + 1);
                },
                _notifyDirty: function() {
                    var grid = this.shadowRoot.querySelector("#attributesGrid");
                    var modifiedData = grid.getModifiedData();
                    if(!_.isEmpty(modifiedData)) {
                        this._isGridDirty = undefined;
                        this._isGridDirty = true;
                    } else {
                        this._isGridDirty = undefined;
                        this._isGridDirty = false;
                    }
                },
                _setGridHeight: function(length) {
                    var grid = this.shadowRoot.querySelector("#attributesGrid");
                    var gridHeight = 60;
                    if(length < 4) {
                        gridHeight = 60 + 40 * length;
                    } else {
                        gridHeight = 200;
                    }
                    grid.updateStyles({"--rock-grid-height": gridHeight + 'px'});
                },
                _onRefreshGrid: function(e, detail) {
                    var gridData = DataHelper.cloneObject(this._gridData);
                    this._gridData = [];
                    this._gridData = gridData;
                }
            });
        })();
    </script>
</dom-module>