<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-dropdown/iron-dropdown-scroll-manager.html">
<link rel="import" href="../../../bower_components/iron-overlay-behavior/iron-overlay-behavior.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<!--
`<pebble-popover>` Represents a popover raised for a target.

### Example

    <pebble-button id="simpleButton" button-text="Test Button" onclick="buttonpopover.show()"></pebble-button>
    <pebble-popover id="buttonpopover" for="simpleButton" auto-fit-on-attach no-overlap>
        Popover simple text.                    
    </pebble-popover>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|---------
`--pebble-popover-background-color` | The background color of the popover | `#ffffff`
`--pebble-popover-text-color` | The color of the popover text | `#000000`
`--pebble-popover-max-height` | The max height of the popover | `300px`
`--pebble-popover-max-width` | The max width of the popover | `300px`
`--pebble-popover-height` | The height of the popover | ``
`--pebble-popover-width` | The width of the popover | ``

### Accessibility

See the docs for `Polymer.IronOverlayBehavior` for accessibility features implemented by this element.

@group Pebble Elements
@element pebble-popover
@demo demo/index.html
-->
<dom-module id="pebble-popover">
  <template>
    <custom-style>
      <style include="pebble-styles-shared">
        :host {
          display: inline-table;
          position: absolute;
          background-color: var(--pebble-popover-background-color, #ffffff);
          color: var(--pebble-popover-text-color, #000000);
          box-sizing: border-box;
          border: 0;
          border-radius: var(--default-border-radius,3px);        
          font-size: var(--default-font-size, 14px);
          box-shadow: 0 0 var(--popup-box-shadow-size,8px) 0 var(--popup-box-shadow,#8A98A3);
          background: var(--palette-white);
        }
              
        .popover {
          display: block;
          border-radius: 3px;
          height: var(--pebble-popover-height);
          width: var(--pebble-popover-width); 
          /*max-height: var(--pebble-popover-max-height, 268px);
          /*max-width: var(--pebble-popover-max-width, 333px);*/
          padding-top:var(--default-popup-t-p,20px);
          padding-bottom:var(--default-popup-b-p,20px);
          @apply(--popover);
        }
        
        .arrow_box {
          position: relative;  
        }
        
        .arrow_box:before,
        .arrow_box:after {
          bottom: var(--arrow-position-bottom);
          /*Arrow moved to top from bottom*/
          top: var(--arrow-position-top);
          /*Arrow moved to bottom from top*/
          left: calc(var(--arrow-position-left) - 6px);
          /*Arrow moved to right from left*/
          right: var(--arrow-position-right);
          /*Arrow moved to left from right*/
          border: solid transparent;
          content: " ";
          height: 0;
          width: 0;
          position: absolute;
          pointer-events: none;
        }
        
        .arrow_box:before {
          border-bottom-color: var(--up-arrow-border-color);
          border-left-color: var(--right-arrow-border-color);
          border-right-color: var(--left-arrow-border-color);
          border-top-color: var(--down-arrow-border-color);
          border-width: var(--arrow-size, 8px);
          /*Arrow size*/
          margin-left: var(--arrow-margin-left);
          margin-bottom: var(--arrow-margin-bottom);
        }
        
        .arrow_box:after {
          border-color: rgba(194, 225, 245, 0);
          border-bottom-color: var(--up-arrow);
          border-left-color: var(--right-arrow);
          border-right-color: var(--left-arrow);
          border-top-color: var(--down-arrow);
          border-width: var(--arrow-size, 8px);
          /*Arrow size*/
          margin-left: var(--arrow-margin-left);
          margin-bottom: var(--arrow-margin-bottom);
        }
      </style>
    </custom-style>
    <div class="arrow_box">
        <div class="popover">
          <slot>
          </slot>
        </div>
    </div>
  </template>
  <script>
    //To capture current opened popover
    var currentPopover = null;
    Polymer({
      is: 'pebble-popover',
      properties: {
        /**
         * Performance fix for iron-fit-behavior (used by iron-overlay-behavior)
         * */
        _isRTL: {
          type: Boolean,
          value: false
        },
        /*
         *  Indicates the target for popover to display.
         */
        for: {
          type: String,
          value: null
        },
        /*
         *  Specifies that popover is aligned vertically.
         *  If the value is specified as "bottom", then the popover is placed above the target.
         *  If the value is specified as "top", then the popover is placed below the target.
         *  If the value is specified as "auto", then the popover is placed as per the available space.            
         */
        verticalAlign: {
          type: String,
          value: "auto"
        },
        /*
         *  Specifies that popover is aligned horizontally.
         *  If the value is specified as "left", then the popover is placed to the left of the target.
         *  If the value is specified as "right", then the popover is placed to the right of the target.
         *  If the value is specified as "auto", then the popover is placed as per the available space.
         *  
         */
        horizontalAlign: {
          type: String,
          value: "auto"
        },
        /*
         *  Specifies the popover not to overlap with target. It indicates the `Overlay behavior`.
         */
        noOverlap: {
          type: Boolean,
          value: true
        },
        /*
         *  Indicates display arrow as per target without any position calculations.
         */
        displayArrowAsPerTarget: {
          type: Boolean,
          value: false
        },
        /**
         * Indicates whether to show multiple popovers or not
         */
        allowMultiple: {
          type: Boolean,
          value: false
        },
        /**
         * Indicates not to show arrow
         */
        showCaret: {
          type: Boolean,
          value: false
        }
      },
      listeners: {
        'iron-overlay-opened': '_popoverOpened',
        'iron-overlay-closed': '_popoverClosed'
      },      
      behaviors: [
        Polymer.IronOverlayBehavior,
        RUFBehaviors.UIBehavior
      ],
      attached: function () {
        window.addEventListener('scroll', this._fixPopoverOnScrollAndResize);
        window.addEventListener('resize', this._fixPopoverOnScrollAndResize);
      },
      _fixPopoverOnScrollAndResize: function () {
        if (currentPopover == null) {
          return;
        }
        currentPopover.refitPopover();
      },
      /*
       *  Can be used to display the popover.
       */
      show: function (doNotSetTarget) {
        this.open(); //IronOverlayBehavior to display popover
        if(!doNotSetTarget)
        {
          var scope = Polymer.dom(this).getOwnerRoot();
          var target = Polymer.dom(scope).querySelector('#' + this.for);
          this.positionTarget = target;
        }        
        this._updateAlign();
      },
      /*
       *  Can be used to hide the popover.
       */
      hide: function () {
        this.close();
      },
      /*
       *  Update alignment based on properties
       */
      _updateAlign: function (e) {
        this.refitPopover();
      },
      /*
       *  Can be used to reset the position of the popover and arrow.
       */
      refitPopover: function () {
        if(this.positionTarget) {
          this.refit();
          //After resetting the popover, now fix the arrow position
          this._fitArrowPosition();        
        }
      },
      /*
       * Raised when popover opens, initial arrow position will be set from here
       */
      _popoverOpened: function (e) {
        if(currentPopover != null && currentPopover != this && !this.allowMultiple)
        {          
          currentPopover.close();
        }
        Polymer.IronDropdownScrollManager.removeScrollLock(currentPopover);
        currentPopover = this;        
        this._fitArrowPosition();
        Polymer.IronDropdownScrollManager.pushScrollLock(this);
        this.fireBedrockEvent("on-popover-open", null, { ignoreId: true });
      },
      
      _popoverClosed: function () {        
        //If popover opened, then do NOT make it to null and just return back
        if (currentPopover.opened) {
          return;
        }
        
        Polymer.IronDropdownScrollManager.removeScrollLock(currentPopover);        
        currentPopover = null;
        this.fireBedrockEvent("on-popover-close", null, { ignoreId: true });
      },
      _fitArrowPosition: function () {
        if(!this.showCaret)
        {
          return;
        }
        var scope = Polymer.dom(this).getOwnerRoot();
        var targetBounding = Polymer.dom(scope).querySelector('#' + this.for).getBoundingClientRect();
        var popoverBounding = this.getBoundingClientRect();
        //Popover opened first time, so popover size not determined yet and now return back
        if (popoverBounding.width == 0) {
          return;
        }
        var arrowType = '';
        var arrowPositionLeft = '';
        var arrowPositionBottom = '';
        var arrowboxsize = 16;
        var padding = 5;
        var margin = 5;
        var arrowMarginBottom = '0px';
        if (this.displayArrowAsPerTarget) //When user adjusted the popover position, implemented for up and down arrows
        {
          arrowPositionLeft = (targetBounding.left - popoverBounding.left) + targetBounding.width / 2;
          if (targetBounding.bottom < popoverBounding.top) {
            arrowType = 'up';
            arrowPositionBottom = '100%';
            arrowMarginBottom =  padding + 'px';           
          } else {
            arrowType = 'down';
            arrowPositionBottom = -(arrowboxsize + margin);
          }
        } else if (targetBounding.bottom < popoverBounding.top) //Popover below the target
        {
          arrowType = 'up';
          if (targetBounding.left < popoverBounding.left) {
            arrowPositionLeft = (targetBounding.right - popoverBounding.left) / 2;
            if(arrowPositionLeft > (popoverBounding.right - popoverBounding.left)) //When target is bigger than popover
            {
              arrowPositionLeft = (popoverBounding.right - popoverBounding.left) / 2;
            }
          } else {
            arrowPositionLeft = (targetBounding.left - popoverBounding.left) + targetBounding.width / 2 -
              arrowboxsize;
          }
          arrowPositionBottom = '100%';
          arrowMarginBottom = padding + 'px';         
        } else if (popoverBounding.bottom < targetBounding.top) //Popover above the target
        {
          arrowType = 'down';
          if (targetBounding.left < popoverBounding.left) {
            arrowPositionLeft = (targetBounding.right - popoverBounding.left) / 2;
            if(arrowPositionLeft > (popoverBounding.right - popoverBounding.left)) //When target is bigger than popover
            {
              arrowPositionLeft = (popoverBounding.right - popoverBounding.left) / 2;
            }
          } else {
            arrowPositionLeft = (targetBounding.left - popoverBounding.left) + targetBounding.width / 2;
          }
          arrowPositionBottom = -(arrowboxsize + margin);
        } else if (targetBounding.right < popoverBounding.left) //Popover right side of the target
        {
          arrowType = 'left';
          if (targetBounding.bottom > popoverBounding.bottom) {
            arrowPositionBottom = popoverBounding.height - (targetBounding.bottom - popoverBounding.top);
          } else {
            arrowPositionBottom = popoverBounding.height - (targetBounding.bottom - popoverBounding.top) - (
              padding + margin);
          }
          arrowPositionLeft = -(arrowboxsize);
        } else //Popover left side of the target
        {
          arrowType = 'right';
          if (targetBounding.bottom > popoverBounding.bottom) {
            arrowPositionBottom = popoverBounding.height - (targetBounding.bottom - popoverBounding.top);
          } else {
            arrowPositionBottom = popoverBounding.height - (targetBounding.bottom - popoverBounding.top) - (
              padding + margin);
          }
          arrowPositionLeft = popoverBounding.width;
        }
        this._enableArrow(arrowType);
        var arrowPositionBottomValue = '100%';
        if(arrowPositionBottom != '100%'){
          arrowPositionBottomValue = arrowPositionBottom + 'px';
        }
        this.updateStyles({'--arrow-position-bottom' : arrowPositionBottomValue,'--arrow-position-left': arrowPositionLeft + 'px','--arrow-margin-bottom': arrowMarginBottom + 'px'});
      },
      _enableArrow: function (type) {
        var upArrow = '';
        var downArrow = '';
        var leftArrow = '';
        var rightArrow = '';
        var upArrowBorderColor = '';
        var downArrowBorderColor = '';
        var leftArrowBorderColor = '';
        var rightArrowBorderColor = '';

        var backgroundColor = window.getComputedStyle(this, null).getPropertyValue('background-color');
        if (type == 'right') {
          rightArrow = backgroundColor;
          rightArrowBorderColor = 'rgba(0, 0, 0, 0.26)';
        } else if (type == 'left') {
          leftArrow = backgroundColor;
          leftArrowBorderColor = 'rgba(0, 0, 0, 0.26)';
        } else if (type == 'down') {
          downArrow = backgroundColor;
          downArrowBorderColor = 'rgba(0, 0, 0, 0.26)';
        } else {
          upArrow = backgroundColor;
          upArrowBorderColor = 'rgba(0, 0, 0, 0.26)';
        }        
        this.updateStyles({'--up-arrow': upArrow,'--down-arrow': downArrow,'--left-arrow': leftArrow,'--right-arrow': rightArrow,'--up-arrow-border-color': upArrowBorderColor,'--down-arrow-border-color': downArrowBorderColor,'--left-arrow-border-color': leftArrowBorderColor,'--right-arrow-border-color': rightArrowBorderColor});
        
      }
    });
  </script>
</dom-module>
