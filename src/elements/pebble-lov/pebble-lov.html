<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-input/iron-input.html">
<link rel="import" href="../../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../../bower_components/iron-scroll-threshold/iron-scroll-threshold.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-lov-behavior/bedrock-lov-behavior.html">

<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-position-tracker/pebble-position-tracker.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-styles-scroll-bar.html">


<!--
`<pebble-lov>` Represents a control which contains a list of items with the material design styling. 
This control contains a search box where you can type and filter the items. It allows you to 
select single item or multiple items.
The following code renders a list of values control which contains item with the title, subtitle, and image. You 
can select single value.
### Example
    <pebble-lov items={{items}} show-image no-sub-title></pebble-lov>

The following code renders a list of values control which contains item with title, subtitle, and image. You 
can select multiple values.
    <pebble-lov items={{items}} show-image multi-select></pebble-lov>
@demo demo/index.html
-->
<dom-module id="pebble-lov">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            :host {
                background: var(--palette-white, #fff);
                overflow: hidden;
                display: block;
                max-height: var(--pebble-lov-height, 250px);
                position: relative;
                border-radius: 3px;
                @apply --pebble-lov;
            }

            pebble-spinner {
                --pebble-spinner-position: {
                    top: 35px;
                };
            }

            #scroller {
                max-height: calc(var(--pebble-lov-height, 250px) - 94px);
                min-height: 100px;
                overflow: auto;
                transform: translate3d(0, 0, 0);
                -webkit-transform: translate3d(0, 0, 0);
                -ms-transform: translate3d(0, 0, 0);
                -webkit-overflow-scrolling: touch;
            }

            #searchbox .item {
                padding: 0px 0px 10px 0px;
                position: relative;
            }

            #searchbox pebble-icon {
                position: absolute;
                color: var(--default-icon-color, #8994a0);
                top: 5px;
                left: 8px;
                @apply --lov-searchbox-icon;
            }

            #searchbox .item,
            #selector .item {
                cursor: pointer;
                color: var(--primary-text-color, #212121);
                overflow: hidden;
            }

            input[type=text],
            select {
                width: 100%;
                padding: 4px 10px 3px 30px;
                margin: 0;
                display: inline-block;
                border: 1px solid var(--textbox-border, #d2d8de);
                border-radius: 4px;
                box-sizing: border-box;
                height: 27px;
                font-size: var(--font-size-sm, 12px);
                vertical-align: middle;
            }

            #selector .item {
                text-align: left;
                color: var(--palette-steel-grey, #75808b);
                line-height: 0;
                @apply --popup-item;
            }

            #selector .item:focus {
                color: var(--primary-button-color, #036bc3);
                background-color: var(--bgColor-hover, #e8f4f9);
            }

            #selector:not([touch-device]) .item:hover {
                background: var(--dropdown-selected, #e8f4f9);
                color: var(--dropdown-selected-font, #036bc3);
            }

            #selector .item:hover {
                background-color: var(--bgColor-hover, #e8f4f9);
                color: var(--focused-line, #026bc3);
            }

            .color-wrapper {
                width: var(--pebble-thumb-color-size, 34px);
                height: var(--pebble-thumb-color-size, 24px);
                display: inline-block;
                vertical-align: middle;
                border-radius: 2px;
                margin-right: 5px;
            }

            .thumb-image {
                width: 100%;
                height: 100%;
            }

            .image-wrapper {
                width: var(--pebble-thumb-image-size, 24px);
                height: var(--pebble-thumb-image-size, 24px);
                display: inline-block;
                margin-right: 5px;
                vertical-align: middle;
                padding: 2px 0;
            }

            .item-wrapper {
                max-width: calc(100% - 30px);
                display: inline-block;
                padding: 5px 0;
            }

            #items {
                border: none;
                width: 20px;
            }

            .checkbox-wrapper {
                margin-right: 10px;
                float: left;
                margin-top: 6px;
            }

            .title {
                font-size: var(--font-size-sm, 12px);
                line-height: 14px;
            }

            .sub-title {
                font-size: var(--font-size-sm, 12px);
                color: var(--color-steal-grey, #75808b);
                width: 190px;
                text-overflow: ellipsis;
                overflow: hidden;
                white-space: nowrap;
                line-height: 13px
            }

            .title,
            .item-list {
                font-size: var(--default-font-size, 14px);
                line-height: 17px;
                color: var(--text-primary-color, #1a2028);
                transition: all 0.3s;
            }

            .item-list:hover,
            .item[selected] .item-list {
                color: var(--focused-line, #026bc3);
            }

            .item:hover .only-badge {
                opacity: 1;
            }

            .only-badge {
                font-size: 11px;
                color: var(--text-primary-color, #364653);
                margin-left: 10px;
                opacity: 0;
                transition: all 0.3s;
                -webkit-transition: all 0.3s;
            }

            .buttons {
                text-align: center;
            }

            #selectall {
                margin-left: 20px;
            }

            .item-length-overflow {
                @apply --item-length-overflow;
            }

            #selector .item[selected],
            #selector .item[focused] {
                background: var(--pebble-lov-selected-item-background, #DBE4EB)!important;
            }

            #selector.multiselect .item {
                background: var(--palette-white, #ffffff)!important;
            }
        </style>
        <template is="dom-if" if="[[_isSelectAllEnabled(selectAll,multiSelect)]]">
            <div id="selectall" class="checkbox-wrapper">
                <pebble-checkbox checked$="[[_isAllItemsSelected(selectedItems)]]" indeterminate="[[_isSelectAllIndeterminate(selectedItems.length, items.length)]]"
                    on-tap="_selectAllItems"></pebble-checkbox>
            </div>
        </template>
        <div id="searchbox" class="popup-item-padding">
            <div class="item">
                <pebble-icon icon="pebble-icon:Search" class="iconstyle pebble-icon-size-16"></pebble-icon>
                <input is="iron-input" id="input" type="text" autocomplete="off" autocapitalize="none" value="{{_inputElementSearchValue::input}}"
                    placeholder$="[[_placeholder]]" on-keyup="_inputValueChanged" on-change="_stopPropagation" key-event-target
                    on-paste='_onPaste'>
            </div>
        </div>

        <div>
            <pebble-spinner active="[[_loading]]"></pebble-spinner>
            <div id="scroller" scroller="[[_getScroller()]]" on-tap="_stopPropagation">
                <iron-list id="selector" class$="[[_getMultiselectClass()]]" role="listbox" touch-device$="[[_touchDevice]]" on-touchend="_preventDefault"
                    multi-selection="[[multiSelect]]" items="[[_itemsObject]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                    scroll-target="[[_getScroller()]]">
                    <template>
                        <div class="item" on-tap="_onTap" selected$="[[_isItemSelected(item, selectedItems, selectedItem)]]" role$="[[_getAriaRole(index)]]"
                            aria-selected$="[[_getAriaSelected(_focusedIndex,index)]]" focused$="[[_isItemFocused(_focusedIndex, index)]]">
                            <template is="dom-if" if="[[multiSelect]]">
                                <div class="checkbox-wrapper">
                                    <pebble-checkbox item="[[item]]" checked$="[[_isItemSelected(item, selectedItems, selectedItem)]]" noink></pebble-checkbox>
                                </div>
                            </template>
                            <template is="dom-if" if="[[showImage]]">
                                <div class="image-wrapper">
                                    <pebble-image-viewer id$="[[item.imageId]]" callback="{{_positionCallback}}" lazy-load src="[[_getItemImage(item)]]"
                                        alt="text" sizing="contain" class="thumb-image"></pebble-image-viewer>
                                </div>
                            </template>
                            <template is="dom-if" if="[[showColor]]">
                                <div id="cw_[[item.title]]" class="color-wrapper">
                                </div>
                                [[_applyColor(item)]]
                            </template>
                            <div class="item-wrapper">
                                <template is="dom-if" if="[[noSubTitle]]">
                                    <div class="item-list item-length-overflow" style$="[[_getItemColorAndFontStyle(item)]]" title="[[_getItemTitle(item)]]">[[_getItemTitle(item)]]
                                        <template is="dom-if" if="[[multiSelect]]">
                                            <span class="only-badge" on-tap="_selectCurrentItemOnly"> only </span>
                                        </template>
                                    </div>
                                </template>
                                <template is="dom-if" if="[[!noSubTitle]]">
                                    <div class="title item-length-overflow" style$="[[_getItemColorAndFontStyle(item)]]" title="[[_getItemTitle(item)]]">
                                        [[_getItemTitle(item)]]
                                        <template is="dom-if" if="[[multiSelect]]">
                                            <span class="only-badge" on-tap="_selectCurrentItemOnly"> only </span>
                                        </template>
                                    </div>
                                    <div class="sub-title">
                                        [[_getItemSubTitle(item)]]
                                    </div>
                                </template>
                            </div>
                        </div>
                    </template>
                </iron-list>
            </div>
        </div>
        <!-- this element will load more data when the user scrolls down and reached the lower threshold -->
        <iron-scroll-threshold id="scrollTheshold" on-lower-threshold="_onLowerThreshold" scroll-target="[[_getScroller()]]">
        </iron-scroll-threshold>
        <template is="dom-if" if="[[showActionButtons]]">
            <div id="actionButtons" class="buttons m-t-10">
                <pebble-button id="cancelButton" class="close btn btn-secondary m-r-5" button-text="Close" noink elevation="2" on-tap="_onClose"></pebble-button>
                <pebble-button id="confirmButton" disabled$="[[readonly]]" class="apply btn btn-success" button-text="Apply" noink elevation="2"
                    on-tap="_onConfirm"></pebble-button>
            </div>
        </template>
    </template>
    <script>
        Polymer({
            is: 'pebble-lov',
            properties: {
                /**
                 * Fired when user selects or deselects an item.
                 *
                 * @event selection-changed (pub-sub event)
                 * @param {Object} selectedItem
                 */
                /**
                 * Fired when user clicks on the "confirm" button.
                 *
                 * @event lov-confirm-button-tap (pub-sub event)
                 * @param {Object} event
                 */
                /**
                 * Fired when user clicks on the "close" button.
                 *
                 * @event lov-close-button-tap (pub-sub event)
                 * @param {Object} event
                 */
                /*
                 * Specifies whether or not the element is disabled.
                 */
                disabled: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /*
                 * Specifies whether or not the element is set to "read-only".
                 */
                readonly: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /**
                 * Indicates a function that provides items lazily. Receives parameters such as `opts`, `callback`, and `err`.
                 *
                 * `opts.page` indicates the requested page index.
                 *
                 * `opts.pageSize` indicates the current page size.
                 *
                 * `opts.filter` indicates the current filter parameters.
                 *
                 * `opts.sortOrder` indicates the current sorting parameters.
                 */
                rDataSource: {
                    type: Function
                },
                /**
                 * Specifies whether or not to generate the console logs.
                 */
                verbose: {
                    type: Boolean,
                    value: false
                },
                selectAll: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Indicates that pushing of items in control is in progress
                 */
                _loading: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                _selectedItemId: {
                    type: String,
                    value: "-1",
                    notify: true
                },
                _selectedItemIds: {
                    type: Array,
                    value: function () {
                        return [];
                    },
                    notify: true
                },
                _previousSelectedItemId: {
                    type: String,
                    value: "-1",
                    notify: true
                },
                _previousSelectedItemIds: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _touchDevice: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: function () {
                        try {
                            document.createEvent('TouchEvent');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    }
                },
                _itemsObject: {
                    type: Object
                },
                _inputElementSearchValue: {
                    type: String
                },
                _placeholder: {
                    type: String,
                    value: "Search"
                },
                _filter: {
                    type: String,
                    value: '',
                    notify: true
                },
                _filteredItems: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _focusedIndex: {
                    type: Number,
                    notify: true,
                    value: -1
                },
                _focusedItem: {
                    type: String,
                    computed: '_getFocusedItem(_focusedIndex)'
                },
                _imageUrl: {
                    type: String,
                    value: ""
                },
                _closeOnBlurIsPrevented: {
                    type: Boolean
                },
                _handler: {
                    type: Object
                },
                _page: {
                    type: Number,
                    value: 0
                },
                minFilterLength: {
                    type: Number,
                    value: 1
                },
                selectedItem: {
                    type: Object,
                    notify: true,
                    value: function () {
                        return {};
                    }
                },
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                _positionCallback: {
                    type: Object,
                    value: function () {
                        return this._getImageSrc.bind(this);
                    }
                },
                imageSource: {
                    type: Object
                },
                allowSearchQueryFormat: {
                    type: Boolean,
                    value: false
                }
            },
            behaviors: [
                RUFBehaviors.LovBehavior
            ],
            listeners: {
                'on-mousedown': '_preventDefault',
                'keydown': '_onKeyDown'
            },
            observers: [
                '_itemsChanged(items.*)',
                '_focusedIndexChanged(_focusedIndex)',
                '_filterChanged(_filter)',
                '_filteredItemsChanged(_filteredItems.*)',
                '_selectedItemChanged(selectedItem)',
                '_selectedItemsChanged(selectedItems.*)',
                '_pageChanged(rDataSource, _page)',
                '_multiSelectChanged(multiSelect)'
            ],
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            ready: function () {
                this._patchWheelOverScrolling();
                // Fix for #182. Only relevant for iron-list 1.0.X and 1.1.X.
                // 1.2.X works fine without this.
                if (this.$.selector._scroller !== undefined) {
                    this.$.selector._scroller = this._getScroller();
                }

                this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(5000), () => {
                    if (this.multiSelect) {
                        this._previousSelectedItemIds = this._selectedItemIds
                    } else {
                        this._previousSelectedItemId = this._selectedItemId
                    }
                })
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            attached: function () {
                this._handler = this._outsideClickListener.bind(this);
                this.$.input.focus();
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            detached: function () {
                this.cancelDebouncer('lov-filter-changed');
            },
            /* LifeCycle Callbacks */
            /* Template Methods */
            /* Note: this whole scroller thing is done to support iron lists scrollToIndex()
                     and features that use it like keyboard navigation in IE11 for iron-list 1.0.x.
                     Tested that iron-list 1.2.x works nicely even without the external scroller, but
                     left these here for now for backwards compatibility.
            */
            _getScroller: function () {
                return this.$.scroller;
            },
            _isItemSelected: function (item, selectedItems, selectedItem) {
                if (this.multiSelect == false) {
                    return item === selectedItem;
                } else {
                    if (selectedItems) {
                        var index = this._functiontofindIndexByKeyValue(selectedItems, "id", item.id); // Move to helper file
                        if (index != null || index != undefined) {
                            return index >= 0;
                        } else {
                            return false;
                        }
                    }
                }
            },
            /*
            *  Check if selectAll checkbox is enabled or not
            *  selectAll option provided for multi select only 
            */
            _isSelectAllEnabled: function (selectAll, multiSelect) {
                if (selectAll && multiSelect) {
                    return true;
                } else {
                    return false;
                }
            },
            /*
            *  Check if all the items in the lov are selected or not
            */
            _isAllItemsSelected: function (selectedItems) {
                if (this.selectedItems.length > 0 && this.selectedItems.length == this.items.length) {
                    return true;
                } else {
                    return false;
                }
            },
            /*
            *  Check if selectall is inderterminate
            */
            _isSelectAllIndeterminate: function (length, size) {
                return size > 0 && length > 0 && length < size;
            },
            /*
            *  Select/Unselect all items when selectAll checkbox is clicked
            */
            _selectAllItems: function (e) {
                var clonedItems = DataHelper.cloneObject(this.items);
                if (e.target.checked) {
                    this._selectCheckbox(clonedItems);
                    this.selectedItems = clonedItems;
                } else {
                    this._deSelectCheckBox(clonedItems);
                    this.selectedItems = [];
                }
            },
            /*
            *  Select only the current item and unselect remaining 
            */
            _selectCurrentItemOnly: function (e) {
                var clonedItems = DataHelper.cloneObject(this.selectedItems);
                for (var i = 0; i < clonedItems.length; i++) {
                    this._selectionChanged(clonedItems[i]);
                }
            },
            _getAriaSelected: function (focusedIndex, itemIndex) {
                return this._isItemFocused(focusedIndex, itemIndex).toString();
            },
            _isItemFocused: function (focusedIndex, itemIndex) {
                return focusedIndex == itemIndex;
            },
            _getAriaRole: function (itemIndex) {
                return itemIndex !== undefined ? 'option' : false;
            },
            /* Template Methods */
            /* Computed Methods */
            _getFocusedItem: function (focusedIndex) {
                if (focusedIndex >= 0) {
                    return this._itemsObject[focusedIndex];
                }
            },
            // Apply color to div as per data
            _applyColor: function (item) {
                setTimeout(() => {
                    this.shadowRoot.querySelector('#cw_' + item.title).style['background-color'] = item.color;
                }, 150); // Delayed to apply color to div 
            },

            /* Computed Methods */
            _multiSelectChanged: function () {
                if (this.multiSelect != undefined) {
                    this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(1000), () => {
                        if (this.multiSelect) {
                            this._previousSelectedItemIds = this._selectedItemIds
                        } else {
                            this._previousSelectedItemId = this._selectedItemId
                        }
                    });
                }
                
                this.$.selector.className = this._getMultiselectClass();
            },
            /* Functional Methods */
            _onLowerThreshold: function () {
                //load more data only when - items are more than current page can hold
                if (this.items && (this.items.length < this._page * this.pageSize)) {
                    return;
                }
                this._page++;
            },
            _pageChanged: function (rDataSource, currentPage) {
                if (!(rDataSource === undefined || currentPage === undefined)) {
                    if (typeof (rDataSource) == 'function' && currentPage > 0) {
                        this._loading = true;

                        // Note: Reference from Iron Datatable - LoadPage Method
                        var success = this._success.bind(this);
                        var error = this._error.bind(this);

                        rDataSource({
                            page: this._page,
                            pageSize: this.pageSize,
                            filter: this._inputElementSearchValue,
                            sortOrder: this.sortOrder
                        }, success, error);
                    }
                }
            },
            _success: function (data) {
                if (data && data.length > 0) {
                    var lastVisibleIndex = this._lastVisibleIndex();
                    for (var i = 0; i < data.length; i++) {
                        this.push('items', data[i]);
                    }

                    this.$.selector.scrollToIndex(lastVisibleIndex);
                    this.$.scrollTheshold.clearTriggers();
                } else {
                    this.page = -1; // Future Enhancement
                }
                this._loading = false;
            },
            _error: function () {
                this._loading = false;
            },
            _itemsChanged: function (e) {
                if (this.items != undefined) {
                    var path = ElementHelper.getElementPath(e);

                    if (path === 'items' || path === 'items.splices') {
                        this._filteredItems = this.items ? this.items.slice(0) : this.items;
                    }
                }
            },
            _onTap: function (e) {
                if (this.multiSelect) {
                    var checkBox = e.currentTarget.querySelector("pebble-checkbox");
                    var path = ElementHelper.getElementPath(e);
                    if (checkBox && path.indexOf(checkBox) == -1) {
                        if (!checkBox.checked) {
                            checkBox.checked = true;
                        } else {
                            checkBox.checked = false;
                        }
                    }
                }

                this._selectionChanged(e.model.item);

                if (!this.multiSelect) {
                    this._clearFilter();
                    if(!this.showActionButtons) {
                        this.reset();
                    }
                }
            },
            _inputValueChanged: function (e) {
                var length = this._inputElementSearchValue ? this._inputElementSearchValue.replace(/\s/g, '').length : 0;
                if (length > 0 && length < this.minFilterLength) {
                    return;
                }

                if (this.rDataSource && this.rDataSource instanceof Function) {
                    this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(500), () => {
                        if (this.items) {
                            this.set("items", []);
                        }
                        this._page = 0;
                        this._page++;
                    });
                } else {
                    // Handle only input events from our inputElement.
                    if (Polymer.dom(e).path.indexOf(this.$.input) !== -1) {
                        if (this._filter === this._inputElementSearchValue) {
                            // Filter and input value might get out of sync, while keyboard navigating for example.
                            // Afterwards, input value might be changed to the same value as used in filtering.
                            // In situation like these, we need to make sure all the filter changes handlers are run.
                            this._filterChanged(this._filter);
                        } else {
                            this._userDefinedFilter = true;
                            this._filter = this._inputElementSearchValue;
                            this._userDefinedFilter = false;
                        }
                    }
                }
            },
            _filterChanged: function (filter) {
                if (filter != undefined) {
                    if (this.items) {
                        this._filteredItems = this._filterItems(this.items, filter);
                    }
                }
            },
            _filteredItemsChanged: function (e) {
                if (this._filteredItems != undefined) {
                    var path = ElementHelper.getElementPath(e);
                    if (path === '_filteredItems' || path === '_filteredItems.splices') {
                        this._setOverlayItems();
                        if (this._userDefinedFilter) {
                            this._focusedIndex = this._indexOfTitle(this._filter);
                        }
                    }
                }
            },
            _filterItems: function (arr, filter) {
                if (!arr) {
                    return arr;
                }
                return arr.filter((function (item) {
                    filter = filter ? filter.toString().toLowerCase() : '';
                    // Check if item contains input value.
                    return this._getItemTitle(item).toString().toLowerCase().indexOf(filter) >
                        -1 || this._getItemSubTitle(item).toString().toLowerCase().indexOf(
                            filter) > -1;
                }).bind(this));
            },
            _setOverlayItems: function () {
                var selectedItem = this.selectedItem;
                var selectedItems = this.selectedItems;
                //TODO: There is something wrong with observers and using set function
                // see here: https://github.com/Polymer/polymer/issues/3254
                //As a workaround setting/notifying the observer with the value undefined helps
                this.notifyPath('_itemsObject', undefined);
                this.set('_itemsObject', this._filteredItems);
                // After filter selected items were set to NULL by Iron List
                if (!this.multiSelect) {
                    this.selectedItem = undefined;
                    this.selectedItem = selectedItem;
                } else {
                    //this.notifyPath('selectedItems', undefined);
                    this.set('selectedItems', []);
                    this.set('selectedItems', selectedItems);
                }
            },
            _focusedIndexChanged: function (index) {
                if (index != undefined) {
                    if (index >= 0) {
                        this._scrollIntoView(index);
                    }
                }
            },
            _indexOfTitle: function (title) {
                if (this._itemsObject && title) {
                    for (var i = 0; i < this._itemsObject.length; i++) {
                        if (this._getItemTitle(this._itemsObject[i]).toString().toLowerCase() === title.toString()
                            .toLowerCase()) {
                            return i;
                        }
                    }
                }
                return -1;
            },
            _getMultiselectClass: function () {
                if (this.multiSelect) {
                    return "multiselect";
                } else {
                    return "";
                }
            },
            _getItemId: function (item) {
                var itemId = this.get("id", item);
                if (itemId === undefined || itemId === null) {
                    itemId = item ? item.toString() : '';
                }
                return itemId;
            },
            _getItemsIds: function (items) {
                var itemsIds = [];
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        itemsIds.push(this._getItemId(items[i]));
                    }
                }
                return itemsIds;
            },
            _getItemTitle: function (item) {
                var title = this.get('title', item);
                if (title === undefined || title === null) {
                    title = item ? item.toString() : '';
                }
                return title;
            },
            _getItemImage: function (item) {
                var image = this.get("image", item);
                if (image === undefined || image === null) {
                    image = this._imageUrl;
                }
                return image;
            },
            _getItemSubTitle: function (item) {
                var subtitle = this.get("subtitle", item);
                if (subtitle === undefined || subtitle === null) {
                    subtitle = '';
                }
                return subtitle;
            },
            _clear: function () {
                if (this.items) {
                    this._clearSelection();
                }
            },
            _clearSelection: function () {
                if (!this.multiSelect) {
                    this._clearFilter();
                }
                this._deSelectCheckBox();
                this.$.selector.clearSelection();
            },
            _clearFilter: function () {
                this._inputElementSearchValue = '';
                this._filter = "";
            },
            _selectCheckbox: function (items) {
                this._toggleSelectionForCheckBoxes(true, items);
            },
            _deSelectCheckBox: function (items) {
                this._toggleSelectionForCheckBoxes(false, items);
            },
            _toggleSelectionForCheckBoxes: function (checkedStatus, items) {
                var checkBoxes = this.$.selector.querySelectorAll("pebble-checkbox");
                if (checkBoxes && checkBoxes.length > 0) {
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            for (var j = 0; j < checkBoxes.length; j++) {
                                var checkBox = checkBoxes[j];
                                if (items[i].id === checkBox.item.id) {
                                    checkBox.checked = checkedStatus;
                                    break;
                                }
                            }
                        }
                    } else {
                        for (var i = 0; i < checkBoxes.length; i++) {
                            var listItem = checkBoxes[i];
                            listItem.checked = checkedStatus;
                        }
                    }
                }
            },
            /* Functional Methods */
            /* Stlyling and Positioning Methods */
            _scrollIntoView: function (index) {
                if (this._visibleItemsCount() === undefined) {
                    // Scroller is not visible. Moving is unnecessary.
                    return;
                }
                var targetIndex = index;
                if (index > this._lastVisibleIndex()) {
                    // Index is below the bottom, scrolling down. Make the item appear at the bottom.
                    targetIndex = index - this._visibleItemsCount() + 1;
                    // From iron-list 1.2.4, scrolling to an index guarantees that the item
                    // is visible into the viewport, but does not gurarantee that it is at the
                    // first position. Jumping first to the item we want to be at the bottom,
                    // fixes the problem.
                    this.$.selector.scrollToIndex(index);
                } else if (index > this.$.selector.firstVisibleIndex) {
                    // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set
                    // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.
                    targetIndex = this.$.selector.firstVisibleIndex;
                }
                this.$.selector.scrollToIndex(Math.max(0, targetIndex));
            },
            _ensureItemsRendered: function () {
                this.$.selector.flushDebouncer('_debounceTemplate');
                this.$.selector._render && this.$.selector._render();
            },
            _updateViewportBoundaries: function () {
                this._cachedViewportTotalPadding = undefined;
                this.$.selector._updateViewportBoundaries();
            },
            _adjustScrollHeight: function () {
                // Note: Code is never executed
                // var lovHeight = this.getBoundingClientRect().height;
                // var searchBoxHeight = this.$.input.getBoundingClientRect().height;
                // var actionButtonsHeight = this.shadowRoot.querySelector("#actionButtons") ? this.shadowRoot.querySelector("#actionButtons").getBoundingClientRect()
                //     .height : 0;
                // var otherControlsHeight = searchBoxHeight + actionButtonsHeight * 2
                // if (actionButtonsHeight == 0) {
                //     otherControlsHeight = otherControlsHeight * 2;
                // }
                // this.$.scroller.style.height = (lovHeight - otherControlsHeight) + "px";
                // if (this._itemsObject) {
                //     this._scrollIntoView(this._focusedIndex);
                // }
            },
            _patchWheelOverScrolling: function () {
                var selector = this.$.selector;
                selector.addEventListener('wheel', function (e) {
                    var scroller = selector._scroller || selector.scrollTarget;
                    var scrolledToTop = scroller.scrollTop === 0;
                    var scrolledToBottom = (scroller.scrollHeight - scroller.scrollTop - scroller.clientHeight) <=
                        1;
                    if (scrolledToTop && e.deltaY < 0) {
                        e.preventDefault();
                    } else if (scrolledToBottom && e.deltaY > 0) {
                        e.preventDefault();
                    }
                }, {passive: true});
            },
            get _viewportTotalPadding() {
                if (this._cachedViewportTotalPadding === undefined) {
                    var itemsStyle = window.getComputedStyle(this._unwrapIfNeeded(this.$.selector.$.items));
                    this._cachedViewportTotalPadding = [
                        itemsStyle.paddingTop,
                        itemsStyle.paddingBottom,
                        itemsStyle.borderTopWidth,
                        itemsStyle.borderBottomWidth
                    ].map(function (v) {
                        return parseInt(v, 10);
                    }).reduce(function (sum, v) {
                        return sum + v;
                    });
                }
                return this._cachedViewportTotalPadding;
            },
            /* Stlyling and Positioning Methods */
            /* Utility Methods */
            _visibleItemsCount: function () {
                var firstItemIndex = this.$.selector._physicalStart;
                var firstItemHeight = this.$.selector._physicalSizes[firstItemIndex];
                var viewportHeight = this.$.selector._viewportHeight || this.$.selector._viewportSize; //Changed in v1.3.0.
                if (firstItemHeight && viewportHeight) {
                    var visibleItems = (viewportHeight - this._viewportTotalPadding) / firstItemHeight;
                    return Math.floor(visibleItems);
                }
            },
            _lastVisibleIndex: function () {
                if (this._visibleItemsCount()) {
                    return this.$.selector.firstVisibleIndex + this._visibleItemsCount() - 1;
                }
            },
            _stringToBoolean: function (_str) {
                return _str === "true";
            },
            _functiontofindIndexByKeyValue: function (arraytosearch, key, valuetosearch) {
                for (var i = 0; i < arraytosearch.length; i++) {
                    if (arraytosearch[i] && arraytosearch[i][key] == valuetosearch) {
                        return i;
                    }
                }
                return null;
            },
            _hasItems: function (array) {
                return array && array.length;
            },
            _preventDefault: function (e) {
                e.preventDefault();
            },
            _stopPropagation: function (e) {
                e.stopPropagation();
            },
            /* Utility Methods */
            /* KeyBoard Methods */
            _onKeyDown: function (e) {
                if (this._isEventKey(e, 'down')) {
                    this._closeOnBlurIsPrevented = true;
                    this._onArrowDown();
                    this._closeOnBlurIsPrevented = false;
                    // prevent caret from moving
                    e.preventDefault();
                } else if (this._isEventKey(e, 'up')) {
                    this._closeOnBlurIsPrevented = true;
                    this._onArrowUp();
                    this._closeOnBlurIsPrevented = false;
                    // prevent caret from moving
                    e.preventDefault();
                } else if (this._isEventKey(e, 'enter')) {
                    this._onEnter(e);
                } else if (this._isEventKey(e, 'esc')) {
                    this._onEscape();
                } else if (this._isEventKey(e, 'space')) {
                    // this._onSpace();
                    // Do not submit the surrounding form.
                    // e.preventDefault();
                }
            },
            _isEventKey: function (e, k) {
                return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k.toString());
            },
            _onArrowDown: function () {
                if (this._itemsObject) {
                    this._focusedIndex = Math.min(this._itemsObject.length - 1, this._focusedIndex + 1);
                }
            },
            _onArrowUp: function () {
                if (this._focusedIndex > -1) {
                    this._focusedIndex = Math.max(0, this._focusedIndex - 1);
                } else {
                    if (this._itemsObject) {
                        this._focusedIndex = this._itemsObject.length - 1;
                    }
                }
            },
            _onEnter: function (e) {
                if (!this.multiSelect && (this._focusedIndex > -1)) {
                    this._close();
                    // Do not submit the surrounding form.
                    e.preventDefault();
                }

                if (this._focusedIndex > -1 && this.multiSelect) {
                    var focusedItem = this._itemsObject[this._focusedIndex];
                    this._selectionChanged(focusedItem);
                }
            },
            _onEscape: function () {
                if (this._focusedIndex > -1) {
                    this._focusedIndex = -1;
                    // this._revertInputValue();
                } else {
                    this._cancel();
                }
            },
            _onSpace: function () {
                if (this._focusedIndex > -1 && this.multiSelect) {
                    var focusedItem = this._itemsObject[this._focusedIndex];
                    this._selectionChanged(focusedItem);
                }
            },
            _cancel: function () {
                this._close();
            },
            /* KeyBoard Methods */
            /* Dropdown Methods */
            /*
             * Can be used to activate and ensure that all the items are rendered in the control
             */
            activate: function () {
                // Prevent _open() being called when input is disabled or read-only
                if (!this.disabled && !this.readonly) {
                    this._open();
                }
            },
            refereshTemplate: function () {
                Polymer.Async.microTask.run(() => {
                    this._filter = '';
                    this.$.input.focus();
                    this._deSelectCheckBox(); // Will DeSelect All CheckBox
                    this._selectCheckbox(this.selectedItems);
                });

            },
            _open: function () {
                this._addOutsideClickListener();
                // Note: Code is never executed
                // this.hidden = !this._hasItems(this._itemsObject) && !this._loading;
                // this._filter = '';
                // this.async(function () {
                //     this.$.input.focus();
                //     // With iron-list v1.3.9, calling `notifyResize()` no longer renders
                //     // the items synchonously. It is required to have the items rendered
                //     // before we update the overlay and the list positions and sizes.
                //     this._ensureItemsRendered();
                //     this._adjustScrollHeight();
                //     this._cachedViewportTotalPadding = undefined;
                //     this.$.selector.updateViewportBoundaries();
                //     this._deSelectCheckBox(); // Will DeSelect All CheckBox
                //     this._selectCheckbox(this.selectedItems);
                // }, 45);
            },
            _close: function () {
                this._removeOutsideClickListener();
                if (this._focusedIndex > -1) {
                    if (!this.multiSelect) {
                        var focusedItem = this._itemsObject[this._focusedIndex];
                        this._selectionChanged(focusedItem);
                    } else {
                        this._focusedIndex = -1;
                        // this._revertInputValue();
                    }
                } else if (this._inputElementSearchValue === '') {
                    this._clear();
                }
                this._clearFilter();
            },
            // We need to listen on 'click' / 'tap' event and capture it and close the overlay before
            // propagating the event to the listener in the button. Otherwise, if the clicked button would call
            // open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
            _outsideClickListener: function (event) {
                var eventPath = event.composedPath();
                if (!this.multiSelect) {
                    if (eventPath.indexOf(this) === -1 || (eventPath.indexOf(this) >= 0 && eventPath.indexOf(
                        this.$.searchbox) < 1)) {
                        this._close();
                    }
                } else {
                    if (eventPath.indexOf(this) === -1) {
                        this._close();
                    }
                }
            },
            _addOutsideClickListener: function () {
                // With desktop mouse, 'click' will make Polymer to fire 'tap' event.
                // With touch devices, 'touchend' will make Polymer to fire 'tap' event, but browser will also fire 'click'.
                // So, 'click' and 'tap' can come in any order and we need to make sure that the first one fired will close the overlay.
                if (this._touchDevice) {
                    Polymer.Gestures.add(this, 'tap', null);
                    document.addEventListener('tap', this._handler, true);
                } else {
                    document.addEventListener('click', this._handler, true);
                }
            },
            _removeOutsideClickListener: function () {
                if (this._touchDevice) {
                    // Not sure if this is a good idea to remove this Gesture globally, but that's how the iron-overlay-behavior does it.
                    Polymer.Gestures.remove(this, 'tap', null);
                    document.removeEventListener('tap', this._handler, true);
                } else {
                    document.removeEventListener('click', this._handler, true);
                }
            },
            /* Dropdown Methods */
            _selectionChanged: function (selectedItem) {
                if (!this.multiSelect) {
                    if (this.selectedItem && this.selectedItem.id == selectedItem.id) {
                        this.selectedItem = undefined;
                        this.selectedItems = undefined;
                    } else {
                        this.selectedItem = selectedItem;
                    }
                } else {
                    if (selectedItem) {
                        // If undefined set as empty array
                        if (!this.selectedItems) {
                            this.selectedItems = [];
                        }

                        var selectedItemIndex = -1;
                        for (var i = 0; i < this.selectedItems.length; i++) {
                            if (selectedItem.id == this.selectedItems[i].id) {
                                selectedItemIndex = i;
                                break;
                            }
                        }

                        if (selectedItemIndex >= 0) {
                            this.splice('selectedItems', selectedItemIndex, 1);
                        } else {
                            this.push('selectedItems', selectedItem);
                        }

                        //Notify selected items
                        var selectedItemList = this.selectedItems;
                        this.selectedItems = [];
                        this.selectedItems = selectedItemList;
                    }
                }
                this.dispatchEvent(new CustomEvent('selection-changed', {
                    detail: {
                        item: selectedItem
                    }, bubbles: true, composed: true
                }));
            },
            _selectedItemChanged: function (selectedItem) {
                if (!this._filteredItems || this._filteredItems.length < 1) {
                    return;
                }
                if (selectedItem === null || selectedItem === undefined) {
                    this._selectedItemId = -1;
                } else {
                    this._selectedItemId = this._getItemId(selectedItem);
                }
                if (selectedItem) {
                    this._focusedIndex = this._functiontofindIndexByKeyValue(this._filteredItems, 'id',
                        selectedItem.id);
                } else {
                    this._focusedIndex = -1;
                }
            },
            _selectedItemsChanged: function (selectedItems) {
                if (selectedItems != undefined) {
                    if (selectedItems.path == 'selectedItems') {
                        this.selectedItems = selectedItems.value;
                    }
                    if (this.selectedItems === null || this.selectedItems === undefined || this.selectedItems.length <= 0) {
                        this._selectedItemIds = [];
                    } else {
                        this.set('_selectedItemIds', this._getItemsIds(this.selectedItems));
                    }
                }
            },
            _onConfirm: function (event) {
                if (event.currentTarget.disabled == true) {
                    return;
                }
                if (this.multiSelect) {
                    this._previousSelectedItemIds = this._selectedItemIds
                } else {
                    this._previousSelectedItemId = this._selectedItemId
                }

                var eventDetail = {
                    data: {
                        id: this.id
                    }
                };
                this.dispatchEvent(new CustomEvent("lov-confirm-button-tap", { detail: eventDetail, bubbles: true, composed: true }));
                this._inputValueChanged();
                this._clearFilter();
            },
            _onClose: function (event) {
                if (this.multiSelect) {
                    if (!DataHelper._isEqual(this._previousSelectedItemIds, this._selectedItemIds)) {
                        var selectedItems = [];

                        for (var i = 0; i < this._previousSelectedItemIds.length; i++) {
                            selectedItems.push(this._getItemById(this._previousSelectedItemIds[i]));
                        }

                        // Todo.. Verify this minor change
                        this.set("selectedItems", selectedItems);
                    }
                } else {
                    if (!DataHelper._isEqual(this._previousSelectedItemId, this._selectedItemId)) {
                        this.selectedItem = this._getItemById(this._previousSelectedItemId);
                    }
                }

                var eventDetail = {
                    data: {
                        id: this.id
                    }
                }

                this.dispatchEvent(new CustomEvent("lov-close-button-tap", { detail: eventDetail, bubbles: true, composed: true }));
            },
            _unwrapIfNeeded: function (element) {
                var isWrapped = Polymer.Settings.hasShadow && !Polymer.Settings.nativeShadow;
                return isWrapped ? window.unwrap(element) : element;
            },
            _getItemById: function (itemId) {
                return DataHelper._findItemByKeyValue(this.items, "id", itemId);
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            refreshData: function () {
                if (this.rDataSource && this.rDataSource instanceof Function) {
                    if (this.items) {
                        this.set("items", []);
                    }
                    this._page = 0;
                    this._page++;
                }
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            reset: function () {
                this._inputElementSearchValue = '';
                this.refreshData();
            },
            _getImageSrc: function (detail) {
                if (detail && detail.target) {
                    var target = detail.target;
                    detail.imageId = target.imageId;
                    if (typeof (this.imageSource) == 'function') {
                        this.imageSource(detail);
                    }
                }
            },
            _onPaste: function (e) {
                //If LOV consumer do not want to format then return without any format
                if (!this.allowSearchQueryFormat) {
                    this._inputValueChanged();
                    return;
                }

                var pastedQuery = "";
                var formattedQuery = "";

                e.preventDefault();

                if (e.clipboardData) {
                    pastedQuery = e.clipboardData.getData('text/plain');
                } else if (window.clipboardData) { //IE
                    pastedQuery = window.clipboardData.getData("text");
                }

                formattedQuery = DataHelper.getFormatedSearchQuery(pastedQuery);
                if (DataHelper.isTextSelected(this.$.input)) {
                    // What if user select spaces and there are multiple spaces?
                    this._inputElementSearchValue = this._inputElementSearchValue.replace(DataHelper.getSelectedText(this.$.input), formattedQuery);
                } else {
                    this._inputElementSearchValue = DataHelper.replaceAt(this._inputElementSearchValue, this.$.input.selectionStart, formattedQuery);
                }

                this._inputValueChanged();
            },
            _getItemColorAndFontStyle: function(item) {
                var style = "";

                if(!_.isEmpty(item.textColor)) {
                    style = style + "color:" + item.textColor + ";";
                }
                if(!_.isEmpty(item.fontStyle)) {
                    style = style + "font-style:" + item.fontStyle + ";";
                }

                return style;
            }
        });
    </script>
</dom-module>