<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-input/iron-input.html">
<link rel="import" href="../../../bower_components/iron-list/iron-list.html">
<link rel="import" href="../../../bower_components/iron-scroll-threshold/iron-scroll-threshold.html">

<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">

<!--
`<pebble-lov>` Represents a control which contains a list of items with material design styling. 
This control contains a search box where user can type and filter the items. It allows you to 
select single item or multiple items.
The following code renders a list of values control which contains item with title, subtitle, and image and allows user 
to select single value.
### Example
    <pebble-lov items={{items}} show-image no-sub-title></pebble-lov>

The following code renders a list of values control which contains item with title, subtitle, and image and allows user 
to select multiple values.
    <pebble-lov items={{items}} show-image multi-select></pebble-lov>
@demo demo/index.html
-->
<dom-module id="pebble-lov">
    <style is="custom-style" include="pebble-styles-shared">
         :host {
            box-shadow: 0 0px 6px 0px rgba(0, 0, 0, 0.24);
            background: var(--palette-white, #fff);
            border-radius: 0 0 2px 2px;
            overflow: hidden;
            padding-bottom: 8px;
            display: block;
            height: var(--pebble-lov-height, 250px);
            padding: 5px;
            position: relative;
        }
        
        #scroller {
            height: calc(var(--pebble-lov-height, 250px) - 50px);
            overflow: auto;
            /* Fixes item background from getting on top of scrollbars on Safari */
            transform: translate3d(0, 0, 0);
            -webkit-transform: translate3d(0, 0, 0);
            -ms-transform: translate3d(0, 0, 0);
            /* Enable momentum scrolling on iOS (iron-list v1.2+ no longer does it for us) */
            -webkit-overflow-scrolling: touch;
        }
        
        #searchbox .item,
        #selector .item {
            cursor: pointer;
            border-radius: 3px;
            color: var(--primary-text-color, #212121);
            white-space: nowrap;
            overflow: hidden;
        }
        
        #selector .item {
            padding: 2px;
            text-align: left;
        }
        
        #searchbox .item {
            padding: 2px 0 11px 0;
        }
        
        #selector .item[selected] {
            /*background-color: var(--accent-color);*/
            color: var(--primary-color, #212121);
        }
        
        #searchbox pebble-icon {
            position: absolute;
            color: var(--default-icon-color, #8994a0);
            padding-top: 6px;
            padding-left: 8px;
            @apply(--lov-searchbox-icon);
        }
        
        .color-wrapper {
            width: var(--pebble-thumb-color-size, 34px);
            height: var(--pebble-thumb-color-size, 24px);
            display: inline-block;
            vertical-align: middle;
            border-radius: 2px;
            margin-right: 5px;
        }
        
        #selector:not([touch-device]) .item:hover,
        #selector .item[focused] {
            background: #eee;
            font-weight: var(--font-bold, bold);
        }
        
        input[type=text],
        select {
            width: 100%;
            padding: 4px 10px 3px 30px;
            margin: 0;
            display: inline-block;
            border: 1px solid var(--textbox-border, #d2d8de);
            border-radius: 4px;
            box-sizing: border-box;
            height: 27px;
            font-size: var(--font-size-sm, 12px);
            vertical-align: middle;
        }
        
        .image-wrapper {
            width: var(--pebble-thumb-image-size, 24px);
            height: var(--pebble-thumb-image-size, 24px);
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }
        
        .thumb-image {
            width: 100%;
            height: 100%;
        }
        
        .item-wrapper {
            display: inline-block;
            vertical-align: middle;
        }
        
        .checkbox-wrapper {
            display: inline-block;
            vertical-align: middle;
        }
        
        #items {
            border: none;
            width: 20px;
        }
        
        .sub-title {
            font-size: var(--default-font-size, 14px);
            color: var(--color-steal-grey, #75808b);
            width: 190px;
            text-overflow: ellipsis;
            overflow: hidden;
            white-space: nowrap;
        }
        
        #selector .item:hover {
            background-color: var(--grid-hover, #e9f1f9);
            font-weight: bold;
        }
        
        .title {
            font-size: var(--font-size-sm, 12px);
            line-height: 15px;
            color: #1a2028;
            margin: -3px 0 0 0;
        }
        
        .buttons {
            text-align: center;
        }
        
        .apply {
            --pebble-button: {
                height: 30px;
                background: #0ABF21;
                color: var(--palette-white, #FFFFFF);
                border: 1px solid var(--connected-childBadge-background, #0ABF21);
                font-size: var(--default-font-size, 14px);
            }
        }
        
        .close {
            --pebble-button: {
                height: 30px;
                color: var(--palette-medium-steel-grey, #7D8690);
                border: 1px solid var(--palette-cloudy-blue, #C1CAD4);
                font-size: var(--default-font-size, 14px);
            }
        }
        
        pebble-button::shadow paper-button iron-icon {
            height: 16px !important;
            width: 16px !important;
            color: var(--palette-cerulean, #036BC3) !important;
        }
        
        pebble-button::shadow paper-button {
            min-width: 66px!important;
        }
        
        .paper-icon-button-margin {
            padding-right: 15%;
        }
        
        #actionButtons {
            width: 166px;
        }
    </style>
    <template>
        <pebble-spinner active="[[loading]]"></pebble-spinner>
        <div id="searchbox">
            <div class="item">
                <pebble-icon icon="pebble-md-icons:ToolbarSearch" class="iconstyle pebble-md-icons"></pebble-icon>
                <input is="iron-input" id="input" type="text" autocomplete="off" autocapitalize="none" bind-value="{{_inputElementSearchValue}}"
                    placeholder$="[[_placeholder]]" on-input="_inputValueChanged" on-change="_stopPropagation" key-event-target>
            </div>
        </div>
        <div id="scroller" scroller="[[_getScroller()]]" on-tap="_stopPropagation">
            <iron-list id="selector" role="listbox" touch-device$="[[_touchDevice]]" on-touchend="_preventDefault" multi-selection="[[multiSelect]]"
                items="[[_itemsObject]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" scroll-target="[[_getScroller()]]">
                <template>
                    <div class="item" on-tap="_onTap" selected$="[[_isItemSelected(item, selectedItems, selectedItem)]]" role$="[[_getAriaRole(index)]]"
                        aria-selected$="[[_getAriaSelected(_focusedIndex,index)]]" focused$="[[_isItemFocused(_focusedIndex, index)]]">
                        <template is="dom-if" if="[[multiSelect]]">
                            <div class="checkbox-wrapper">
                                <pebble-checkbox item="[[item]]" checked$="[[_isItemSelected(item, selectedItems, selectedItem)]]" noink></pebble-checkbox>
                            </div>
                        </template>
                        <template is="dom-if" if="[[showImage]]">
                            <div class="image-wrapper">
                                <pebble-image-viewer src="[[_getItemImage(item)]]" alt="text" sizing="contain" class="thumb-image"></pebble-image-viewer>
                            </div>
                        </template>
                        <template is="dom-if" if="[[showColor]]">
                            <div id="cw_[[item.title]]" class="color-wrapper">
                            </div>
                            [[_applyColor(item)]]
                        </template>
                        <div class="item-wrapper">
                            <div class="title">
                                [[_getItemTitle(item)]]
                            </div>
                            <template is="dom-if" if="[[!noSubTitle]]">
                                <div class="sub-title">
                                    [[_getItemSubTitle(item)]]
                                </div>
                            </template>
                        </div>
                    </div>
                </template>
            </iron-list>
        </div>
        <!-- this element will load more data when the user scrolls down and reached the lower threshold -->
        <iron-scroll-threshold id="scrollTheshold" on-lower-threshold="_onLowerThreshold" scroll-target="[[_getScroller()]]">
        </iron-scroll-threshold>
        <template is="dom-if" if="[[showActionButtons]]">
            <div id="actionButtons" class="buttons p-r-15">
                <pebble-button class="close btn btn-secondary m-r-5" button-text="Close" noink elevation="2" on-tap="_onClose"></pebble-button>
                <pebble-button class="apply btn btn-success" button-text="Apply" noink elevation="2" on-tap="_onConfirm"></pebble-button>
            </div>
        </template>
    </template>
    <script>
        Polymer({
            is: 'pebble-lov',
            properties: {
                /**
                 * Fired when user selects or deselects an item
                 *
                 * @event selection-changed (pub-sub event)
                 * @param {Object} selectedItem
                 */
                /**
                 * Fired when user clicks on confirm button
                 *
                 * @event lov-confirm-button-tap (pub-sub event)
                 * @param {Object} event
                 */
                /**
                 * Fired when user clicks on close button
                 *
                 * @event lov-close-button-tap (pub-sub event)
                 * @param {Object} event
                 */
                /*
                 * Specifies whether or not the element is disabled.
                 */
                disabled: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },                
                /*
                 * Specifies whether or not the element is set to readonly.
                 */
                readonly: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /*
                 * Specifies whether or not multiple items is selected at once. When it is set to <b>true</b>, 
                 * multiple items are selected at a time. In this case, selected is an array of currently selected items.
                 * When it is set to <b>false</b>, only one item is selected at a time.
                 */
                multiSelect: {
                    type: Boolean,
                    value: false,
                    observer: '_clear'
                },
                /* 
                 * Specifies whether or not to show image with item text.
                 */
                showImage: {
                    type: Boolean,
                    value: false
                },
                /* 
                 * Specifies whether to show color with item text or not
                 */
                showColor: {
                    type: Boolean,
                    value: false
                },
                /* 
                 * Specifies whether or not to show subtitle.
                 */
                noSubTitle: {
                    type: Boolean,
                    value: false
                },
                /* 
                 * Specifies whether or not to show action buttons
                 */
                showActionButtons: {
                    type: Boolean,
                    value: false,
                },
                /**
                 * Function that provides items lazily. Receives parameters `opts`, `callback`, `err`
                 *
                 * `opts.page` Requested page index
                 *
                 * `opts.pageSize` Current page size
                 *
                 * `opts.filter` Current filter parameters
                 *
                 * `opts.sortOrder` Current sorting parameters
                 */
                dataSource: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /*
                 * Indicates an array of items that determines how many instances of the template 
                 * to stamp and to what instances the template binds to.
                 */
                items: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                /*
                 * Indicates the currently selected item when multiSelection is false. 
                 * It indicates null if no item is selected.
                 */
                selectedItem: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /*
                 * Indicates an array that contains the selected items when the  multiselection is true.
                 */
                selectedItems: {
                    type: Array,
                    value: function () {
                        return [];
                    },
                    notify: true
                },
                /**
                 * Indicates the number of items to be fetch from datasource per request
                 */
                pageSize: {
                    type: Number,
                    value: 10
                },
                /**
                 * Indicates that pushing of items in control is in progress
                 */
                loading: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /**
                 * Specifies whether or not to generate console logs.
                 */
                verbose: {
                    type: Boolean,
                    value: false
                },
                _selectedItemId: {
                    type: Number
                },
                _selectedItemIds: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _oldSelectedItemIds: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _touchDevice: {
                    type: Boolean,
                    reflectToAttribute: true,
                    value: function () {
                        try {
                            document.createEvent('TouchEvent');
                            return true;
                        } catch (e) {
                            return false;
                        }
                    }
                },
                _itemsObject: {
                    type: Object
                },
                _inputElementSearchValue: {
                    type: String
                },
                _placeholder: {
                    type: String,
                    value: "Search"
                },
                _filter: {
                    type: String,
                    value: '',
                    notify: true
                },
                _filteredItems: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                _focusedIndex: {
                    type: Number,
                    notify: true,
                    value: -1
                },
                _focusedItem: {
                    type: String,
                    computed: '_getFocusedItem(_focusedIndex)'
                },
                _imageUrl: {
                    type: String,
                    value: "/src/images/polymer.svg" // Some Default Image
                },
                _closeOnBlurIsPrevented: {
                    type: Boolean
                },
                _handler: {
                    type: Object
                },
                _page: {
                    type: Number,
                    value: 0
                },
            },
            listeners: {
                'on-mousedown': '_preventDefault',
                'keydown': '_onKeyDown'
            },
            observers: [
                '_itemsChanged(items.*)',
                '_focusedIndexChanged(_focusedIndex)',
                '_filterChanged(_filter)',
                '_filteredItemsChanged(_filteredItems.*)',
                '_selectedItemChanged(selectedItem)',
                '_selectedItemsChanged(selectedItems.*)',
                '_pageChanged(dataSource, _page)',
            ],
            ready: function () {
                this._patchWheelOverScrolling();
                // Fix for #182. Only relevant for iron-list 1.0.X and 1.1.X.
                // 1.2.X works fine without this.
                if (this.$.selector._scroller !== undefined) {
                    this.$.selector._scroller = this._getScroller();
                }
            },
            attached: function () {
                this._handler = this._outsideClickListener.bind(this);
            },
            detached: function () {
                this.cancelDebouncer('lov-filter-changed');
            },
            /* LifeCycle Callbacks */
            /* Template Methods */
            /* Note: this whole scroller thing is done to support iron lists scrollToIndex()
                     and features that use it like keyboard navigation in IE11 for iron-list 1.0.x.
                     Tested that iron-list 1.2.x works nicely even without the external scroller, but
                     left these here for now for backwards compatibility.
            */
            _getScroller: function () {
                return this.$.scroller;
            },
            _isItemSelected: function (item, selectedItems, selectedItem) {
                if (this.multiSelect == false) {
                    return item === selectedItem;
                } else {
                    if (selectedItems) {
                        var index = this._functiontofindIndexByKeyValue(selectedItems, "id", item.id); // Move to helper file
                        if (index != null || index != undefined) {
                            return index >= 0;
                        } else {
                            return false;
                        }
                    }
                }
            },
            _getAriaSelected: function (focusedIndex, itemIndex) {
                return this._isItemFocused(focusedIndex, itemIndex).toString();
                var path = ElementHelper.getElementPath(e);
            },
            _isItemFocused: function (focusedIndex, itemIndex) {
                return focusedIndex == itemIndex;
            },
            _getAriaRole: function (itemIndex) {
                return itemIndex !== undefined ? 'option' : false;
            },
            /* Template Methods */
            /* Computed Methods */
            _getFocusedItem: function (focusedIndex) {
                if (focusedIndex >= 0) {
                    return this._itemsObject[focusedIndex];
                }
            },
            // Apply color to div as per data
            _applyColor: function (item) {
                this.async(function () {
                    this.$$('#cw_' + item.title).style['background-color'] = item.color;
                }, 150); // Delayed to apply color to div 
            },

            /* Computed Methods */
            /* Functional Methods */
            _onLowerThreshold: function () {
                this._page++;
            },
            _pageChanged: function (dataSource, currentPage) {
                if (typeof (dataSource) == 'function' && currentPage > 0) {
                    this.loading = true;

                    // Note: Reference from Iron Datatable - LoadPage Method
                    var success = this._success.bind(this);
                    var error = this._error.bind(this);

                    dataSource({
                        page: this._page,
                        pageSize: this.pageSize,
                        filter: this._inputElementSearchValue,
                        sortOrder: this.sortOrder
                    }, success, error);
                }
            },
            _success: function (data) {
                if (data.length > 0) {
                    var lastVisibleIndex = this._lastVisibleIndex();
                    for (var i = 0; i < data.length; i++) {
                        this.push('items', data[i]);
                    }

                    this.$.selector.scrollToIndex(lastVisibleIndex);
                    this.$.scrollTheshold.clearTriggers();
                } else {
                    this.page = -1; // Future Enhancement
                }
                this.loading = false;
            },
            _error: function () {
                this.loading = false;
            },
            _itemsChanged: function (e) {
                var path = ElementHelper.getElementPath(e);
                if (path === 'items' || path === 'items.splices') {
                    this._filteredItems = this.items ? this.items.slice(0) : this.items;
                }
            },
            _onTap: function (e) {
                if (this.multiSelect) {
                    var checkBox = e.currentTarget.querySelector("pebble-checkbox");
                    var path = ElementHelper.getElementPath(e);
                    if (checkBox && path.indexOf(checkBox) == -1) {
                        if (!checkBox.checked) {
                            checkBox.checked = true;
                        } else {
                            checkBox.checked = false;
                        }
                    }
                }
                this._selectionChanged(e.model.item);
                if (!this.multiSelect) {
                    this._clearFilter();
                }
            },
            _inputValueChanged: function (e) {
                if (this.dataSource && this.dataSource instanceof Function) {
                    this.debounce("lov-filter-changed", function () {
                        if (this.items) {
                            this.set("items", []);
                        }
                        this._page = 0;
                        var success = this._success.bind(this);
                        var error = this._error.bind(this);

                        this.dataSource({
                            page: this._page,
                            pageSize: this.pageSize,
                            filter: this._inputElementSearchValue,
                            sortOrder: this.sortOrder // Future Enhancement
                        }, success, error);
                    }, 500);
                } else {
                    // Handle only input events from our inputElement.
                    if (Polymer.dom(e).path.indexOf(this.$.input) !== -1) {
                        if (this._filter === this._inputElementSearchValue) {
                            // Filter and input value might get out of sync, while keyboard navigating for example.
                            // Afterwards, input value might be changed to the same value as used in filtering.
                            // In situation like these, we need to make sure all the filter changes handlers are run.
                            this._filterChanged(this._filter);
                        } else {
                            this._userDefinedFilter = true;
                            this._filter = this._inputElementSearchValue;
                            this._userDefinedFilter = false;
                        }
                    }
                }
            },
            _filterChanged: function (filter) {
                if (this.items) {
                    this._filteredItems = this._filterItems(this.items, filter);
                }
            },
            _filteredItemsChanged: function (e) {
                var path = ElementHelper.getElementPath(e);
                if (path === '_filteredItems' || path === '_filteredItems.splices') {
                    this._setOverlayItems();
                    if (this._userDefinedFilter) {
                        this._focusedIndex = this._indexOfTitle(this._filter);
                    }
                }
            },
            _filterItems: function (arr, filter) {
                if (!arr) {
                    return arr;
                }
                return arr.filter((function (item) {
                    filter = filter ? filter.toString().toLowerCase() : '';
                    // Check if item contains input value.
                    return this._getItemTitle(item).toString().toLowerCase().indexOf(filter) >
                        -1 || this._getItemSubTitle(item).toString().toLowerCase().indexOf(
                            filter) > -1;
                }).bind(this));
            },
            _setOverlayItems: function () {
                var selectedItem = this.selectedItem;
                var selectedItems = this.selectedItems;
                //TODO: There is something wrong with observers and using set function
                // see here: https://github.com/Polymer/polymer/issues/3254
                //As a workaround setting/notifying the observer with the value undefined helps
                this.notifyPath('_itemsObject', undefined);
                this.set('_itemsObject', this._filteredItems);
                // After filter selected items were set to NULL by Iron List
                if (!this.multiSelect) {
                    this.selectedItem = undefined;
                    this.selectedItem = selectedItem;
                } else {
                    this.notifyPath('selectedItems', undefined);
                    this.set('selectedItems', selectedItems);
                }
            },
            _focusedIndexChanged: function (index) {
                if (index >= 0) {
                    this._scrollIntoView(index);
                }
            },
            _indexOfTitle: function (title) {
                if (this._itemsObject && title) {
                    for (var i = 0; i < this._itemsObject.length; i++) {
                        if (this._getItemTitle(this._itemsObject[i]).toString().toLowerCase() === title.toString()
                            .toLowerCase()) {
                            return i;
                        }
                    }
                }
                return -1;
            },
            _getItemId: function (item) {
                var itemId = this.get("id", item);
                if (itemId === undefined || itemId === null) {
                    itemId = item ? item.toString() : '';
                }
                return itemId;
            },
            _getItemsIds: function (items) {
                var itemsIds = [];
                if (items) {
                    for (var i = 0; i < items.length; i++) {
                        itemsIds.push(this._getItemId(items[i]));
                    }
                }
                return itemsIds;
            },
            _getItemTitle: function (item) {
                var title = this.get('title', item);
                if (title === undefined || title === null) {
                    title = item ? item.toString() : '';
                }
                return title;
            },
            _getItemImage: function (item) {
                var image = this.get("image", item);
                if (image === undefined || image === null) {
                    image = this._imageUrl;
                }
                return image;
            },
            _getItemSubTitle: function (item) {
                var subtitle = this.get("subtitle", item);
                if (subtitle === undefined || subtitle === null) {
                    subtitle = '';
                }
                return subtitle;
            },
            _clear: function () {
                if (this.items) {
                    this._clearSelection();
                    if (!this.multiSelect) {
                        this.selectedItem = null;
                    } else {
                        this.set("selectedItems", []);
                    }
                    this._close();
                }
            },
            _resetItems: function () {
                if (this.items) {
                    this.set("items", []);
                }
            },
            _clearSelection: function () {
                if (!this.multiSelect) {
                    this._clearFilter();
                    this.showActionButtons = false;
                } else {
                    this.showActionButtons = true;
                }
                this._deSelectCheckBox();
                this.$.selector.clearSelection();
            },
            _clearFilter: function () {
                this._inputElementSearchValue = '';
                this._filter = "";
            },
            _selectCheckbox: function (items) {
                this._toggleSelectionForCheckBoxes(true, items);
            },
            _deSelectCheckBox: function (items) {
                this._toggleSelectionForCheckBoxes(false, items);
            },
            _toggleSelectionForCheckBoxes: function (checkedStatus, items) {
                var checkBoxes = this.$.selector.querySelectorAll("pebble-checkbox");
                if (checkBoxes && checkBoxes.length > 0) {
                    if (items) {
                        for (var i = 0; i < items.length; i++) {
                            for (var j = 0; j < checkBoxes.length; j++) {
                                var checkBox = checkBoxes[j];
                                if (items[i].id === checkBox.item.id) {
                                    checkBox.checked = checkedStatus;
                                    break;
                                }
                            }
                        }
                    } else {
                        for (var i = 0; i < checkBoxes.length; i++) {
                            var listItem = checkBoxes[i];
                            listItem.checked = checkedStatus;
                        }
                    }
                }
            },
            /* Functional Methods */
            /* Stlyling and Positioning Methods */
            _scrollIntoView: function (index) {
                if (this._visibleItemsCount() === undefined) {
                    // Scroller is not visible. Moving is unnecessary.
                    return;
                }
                var targetIndex = index;
                if (index > this._lastVisibleIndex()) {
                    // Index is below the bottom, scrolling down. Make the item appear at the bottom.
                    targetIndex = index - this._visibleItemsCount() + 1;
                    // From iron-list 1.2.4, scrolling to an index guarantees that the item
                    // is visible into the viewport, but does not gurarantee that it is at the
                    // first position. Jumping first to the item we want to be at the bottom,
                    // fixes the problem.
                    this.$.selector.scrollToIndex(index);
                } else if (index > this.$.selector.firstVisibleIndex) {
                    // The item is already visible, scrolling is unnecessary per se. But we need to trigger iron-list to set
                    // the correct scrollTop on the scrollTarget. Scrolling to firstVisibleIndex.
                    targetIndex = this.$.selector.firstVisibleIndex;
                }
                this.$.selector.scrollToIndex(Math.max(0, targetIndex));
            },
            _updateViewportBoundaries: function () {
                this._cachedViewportTotalPadding = undefined;
                this.$.selector._updateViewportBoundaries();
            },
            _ensureItemsRendered: function () {
                this.$.selector.flushDebouncer('_debounceTemplate');
                this.$.selector._render && this.$.selector._render();
            },
            _adjustScrollHeight: function () {
                var lovHeight = this.getBoundingClientRect().height;
                var searchBoxHeight = this.$.input.getBoundingClientRect().height;
                var actionButtonsHeight = this.$$("#actionButtons") ? this.$$("#actionButtons").getBoundingClientRect()
                    .height : 0;
                var otherControlsHeight = searchBoxHeight + actionButtonsHeight * 2
                if (actionButtonsHeight == 0) {
                    otherControlsHeight = otherControlsHeight * 2;
                }
                this.$.scroller.style.height = (lovHeight - otherControlsHeight) + "px";
                if (this._itemsObject) {
                    this._scrollIntoView(this._focusedIndex);
                }
            },
            _patchWheelOverScrolling: function () {
                var selector = this.$.selector;
                selector.addEventListener('wheel', function (e) {
                    var scroller = selector._scroller || selector.scrollTarget;
                    var scrolledToTop = scroller.scrollTop === 0;
                    var scrolledToBottom = (scroller.scrollHeight - scroller.scrollTop - scroller.clientHeight) <=
                        1;
                    if (scrolledToTop && e.deltaY < 0) {
                        e.preventDefault();
                    } else if (scrolledToBottom && e.deltaY > 0) {
                        e.preventDefault();
                    }
                });
            },
            get _viewportTotalPadding() {
                if (this._cachedViewportTotalPadding === undefined) {
                    var itemsStyle = window.getComputedStyle(this._unwrapIfNeeded(this.$.selector.$.items));
                    this._cachedViewportTotalPadding = [
                        itemsStyle.paddingTop,
                        itemsStyle.paddingBottom,
                        itemsStyle.borderTopWidth,
                        itemsStyle.borderBottomWidth
                    ].map(function (v) {
                        return parseInt(v, 10);
                    }).reduce(function (sum, v) {
                        return sum + v;
                    });
                }
                return this._cachedViewportTotalPadding;
            },
            /* Stlyling and Positioning Methods */
            /* Utility Methods */
            _visibleItemsCount: function () {
                var firstItemIndex = this.$.selector._physicalStart;
                var firstItemHeight = this.$.selector._physicalSizes[firstItemIndex];
                var viewportHeight = this.$.selector._viewportHeight || this.$.selector._viewportSize; //Changed in v1.3.0.
                if (firstItemHeight && viewportHeight) {
                    var visibleItems = (viewportHeight - this._viewportTotalPadding) / firstItemHeight;
                    return Math.floor(visibleItems);
                }
            },
            _lastVisibleIndex: function () {
                if (this._visibleItemsCount()) {
                    return this.$.selector.firstVisibleIndex + this._visibleItemsCount() - 1;
                }
            },
            _stringToBoolean: function (_str) {
                return _str === "true";
            },
            _functiontofindIndexByKeyValue: function (arraytosearch, key, valuetosearch) {
                for (var i = 0; i < arraytosearch.length; i++) {
                    if (arraytosearch[i][key] == valuetosearch) {
                        return i;
                    }
                }
                return null;
            },
            _hasItems: function (array) {
                return array && array.length;
            },
            _preventDefault: function (e) {
                e.preventDefault();
            },
            _stopPropagation: function (e) {
                e.stopPropagation();
            },
            /* Utility Methods */
            /* KeyBoard Methods */
            _onKeyDown: function (e) {
                if (this._isEventKey(e, 'down')) {
                    this._closeOnBlurIsPrevented = true;
                    this._onArrowDown();
                    this._closeOnBlurIsPrevented = false;
                    // prevent caret from moving
                    e.preventDefault();
                } else if (this._isEventKey(e, 'up')) {
                    this._closeOnBlurIsPrevented = true;
                    this._onArrowUp();
                    this._closeOnBlurIsPrevented = false;
                    // prevent caret from moving
                    e.preventDefault();
                } else if (this._isEventKey(e, 'enter')) {
                    this._onEnter(e);
                } else if (this._isEventKey(e, 'esc')) {
                    this._onEscape();
                } else if (this._isEventKey(e, 'space')) {
                    this._onSpace();
                    // Do not submit the surrounding form.
                    e.preventDefault();
                }
            },
            _isEventKey: function (e, k) {
                return Polymer.IronA11yKeysBehavior.keyboardEventMatchesKeys(e, k.toString());
            },
            _onArrowDown: function () {
                if (this._itemsObject) {
                    this._focusedIndex = Math.min(this._itemsObject.length - 1, this._focusedIndex + 1);
                }
            },
            _onArrowUp: function () {
                if (this._focusedIndex > -1) {
                    this._focusedIndex = Math.max(0, this._focusedIndex - 1);
                } else {
                    if (this._itemsObject) {
                        this._focusedIndex = this._itemsObject.length - 1;
                    }
                }
            },
            _onEnter: function (e) {
                if (!this.multiSelect && (this._focusedIndex > -1)) {
                    this._close();
                    // Do not submit the surrounding form.
                    e.preventDefault();
                }
            },
            _onEscape: function () {
                if (this._focusedIndex > -1) {
                    this._focusedIndex = -1;
                    // this._revertInputValue();
                } else {
                    this._cancel();
                }
            },
            _onSpace: function () {
                if (this._focusedIndex > -1 && this.multiSelect) {
                    var focusedItem = this._itemsObject[this._focusedIndex];
                    this._selectionChanged(focusedItem);
                }
            },
            _cancel: function () {
                this._close();
            },
            /* KeyBoard Methods */
            /* Dropdown Methods */
            /*
             * Can be used to activate and ensure that all the items are rendered in the control
             */
            activate: function () {
                // Prevent _open() being called when input is disabled or read-only
                if (!this.disabled && !this.readonly) {
                    this._open();
                }
            },
            _open: function () {
                this._oldSelectedItemIds = this._selectedItemIds;

                this._addOutsideClickListener();
                // this.hidden = !this._hasItems(this._itemsObject) && !this.loading;
                this._filter = '';
                this.async(function () {
                    this.$.input.focus();
                    // With iron-list v1.3.9, calling `notifyResize()` no longer renders
                    // the items synchonously. It is required to have the items rendered
                    // before we update the overlay and the list positions and sizes.
                    this._ensureItemsRendered();
                    this._adjustScrollHeight();
                    this._cachedViewportTotalPadding = undefined;
                    this.$.selector.updateViewportBoundaries();

                    this._deSelectCheckBox(); // Will DeSelect All CheckBox
                    this._selectCheckbox(this.selectedItems);
                }, 45);
            },
            _close: function () {
                this._removeOutsideClickListener();
                if (this._focusedIndex > -1) {
                    if (!this.multiSelect) {
                        var focusedItem = this._itemsObject[this._focusedIndex];
                        this._selectionChanged(focusedItem);
                    } else {
                        this._focusedIndex = -1;
                        // this._revertInputValue();
                    }
                } else if (this._inputElementValue === '') {
                    this._clear();
                }
                this._clearFilter();
            },
            // We need to listen on 'click' / 'tap' event and capture it and close the overlay before
            // propagating the event to the listener in the button. Otherwise, if the clicked button would call
            // open(), this would happen: https://www.youtube.com/watch?v=Z86V_ICUCD4
            _outsideClickListener: function (event) {
                var eventPath = Polymer.dom(event).path;
                if (!this.multiSelect) {
                    if (eventPath.indexOf(this) === -1 || (eventPath.indexOf(this) >= 0 && eventPath.indexOf(
                        this.$.searchbox) < 1)) {
                        this._close();
                    }
                } else {
                    if (eventPath.indexOf(this) === -1) {
                        this._close();
                    }
                }
            },
            _addOutsideClickListener: function () {
                // With desktop mouse, 'click' will make Polymer to fire 'tap' event.
                // With touch devices, 'touchend' will make Polymer to fire 'tap' event, but browser will also fire 'click'.
                // So, 'click' and 'tap' can come in any order and we need to make sure that the first one fired will close the overlay.
                if (this._touchDevice) {
                    Polymer.Gestures.add(document, 'tap', null);
                    document.addEventListener('tap', this._handler, true);
                } else {
                    document.addEventListener('click', this._handler, true);
                }
            },
            _removeOutsideClickListener: function () {
                if (this._touchDevice) {
                    // Not sure if this is a good idea to remove this Gesture globally, but that's how the iron-overlay-behavior does it.
                    Polymer.Gestures.remove(document, 'tap', null);
                    document.removeEventListener('tap', this._handler, true);
                } else {
                    document.removeEventListener('click', this._handler, true);
                }
            },
            /* Dropdown Methods */
            _selectionChanged: function (selectedItem) {
                if (!this.multiSelect) {
                    this.selectedItem = selectedItem;
                } else {
                    if (selectedItem) {
                        // If undefined set as empty array
                        if (!this.selectedItems) {
                            this.selectedItems = [];
                        }

                        var selectedItemIndex = -1;
                        for (var i = 0; i < this.selectedItems.length; i++) {
                            if (selectedItem.id == this.selectedItems[i].id) {
                                selectedItemIndex = i;
                                break;
                            }
                        }

                        if (selectedItemIndex >= 0) {
                            this.splice('selectedItems', selectedItemIndex, 1);
                        } else {
                            this.push('selectedItems', selectedItem);
                        }

                        //Notify selected items
                        var selectedItemList = this.selectedItems;
                        this.selectedItems = [];
                        this.selectedItems = selectedItemList;
                    }
                }
                this.fire('selection-changed', {
                    item: selectedItem
                });
            },
            _selectedItemChanged: function (selectedItem) {
                if (!this._filteredItems || this._filteredItems.length < 1) {
                    return;
                }
                if (selectedItem === null || selectedItem === undefined) {
                    this._selectedItemId = -1;
                } else {
                    this._selectedItemId = this._getItemId(selectedItem);
                }
                if (selectedItem) {
                    this._focusedIndex = this._functiontofindIndexByKeyValue(this._filteredItems, 'id',
                        selectedItem.id);
                } else {
                    this._focusedIndex = -1;
                }
            },
            _selectedItemsChanged: function (selectedItems) {
                if (selectedItems.hasOwnProperty('base')) {
                    selectedItems = selectedItems.base
                }
                if (!this._filteredItems || this._filteredItems.length < 1) {
                    return;
                }
                if (selectedItems === null || selectedItems === undefined || selectedItems.length <= 0) {
                    this._selectedItemIds = [];
                } else {
                    this.set('_selectedItemIds', this._getItemsIds(selectedItems));
                }
            },
            _onConfirm: function (event) {
                if (!DataHelper._isEqual(this._oldSelectedItemIds, this._selectedItemIds)) {
                    if (this._selectedItemIds.length > 0) {
                        var eventDetail = {
                            'id': this.id,
                            'oldSelectedItemIds': this._oldSelectedItemIds,
                            'selectedItemIds': this._selectedItemIds
                        }
                        this._oldSelectedItemIds = this._selectedItemIds;
                        this.fire("lov-confirm-button-tap", eventDetail);
                    }
                }
            },
            _onClose: function (event) {
                if (!DataHelper._isEqual(this._oldSelectedItemIds, this._selectedItemIds)) {
                    var selectedItems = [];

                    for (var i = 0; i < this._oldSelectedItemIds.length; i++) {
                        selectedItems.push(this._getItemById(this._oldSelectedItemIds[i]));
                    }

                    // Need to find some better solution
                    this.selectedItems = selectedItems;
                }

                var eventDetail = {
                    'id': this.id
                }
                this.fire("lov-close-button-tap", eventDetail);
            },
            _unwrapIfNeeded: function (element) {
                var isWrapped = Polymer.Settings.hasShadow && !Polymer.Settings.nativeShadow;
                return isWrapped ? window.unwrap(element) : element;
            },
            _getItemById: function (itemId) {
                return DataHelper._findItemByKeyValue(this.items, "id", itemId);
            }
        });
    </script>
</dom-module>