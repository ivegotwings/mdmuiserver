<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-data-table/iron-data-table.html">
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/paper-input/paper-textarea.html">
<link rel="import" href="../../../bower_components/paper-dropdown-menu/paper-dropdown-menu.html">
<link rel="import" href="../../../bower_components/paper-radio-button/paper-radio-button.html">
<link rel="import" href="../../../bower_components/paper-checkbox/paper-checkbox.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">

<link rel="import" href="../pebble-popover/pebble-popover.html">

<link rel="import" href="../rock-attribute/rock-attribute.html">
<link rel="import" href="../rock-entity-tofix/rock-entity-tofix.html">

<link rel="import" href="grid-list-view.html">
<link rel="import" href="grid-tile-view.html">

<!--
`pebble-grid` Represents the grid control of the framework. This grid creates visual consistency between layouts 
while allowing flexibility across a wide variety of designs.
The following JSON object is a config sample which is used to configure the grid.
### Example
```json
{
    "viewMode": "Tabular",
    "title": "Simple Data Table",
    "readOnly":true,
    "tabular": {
        "settings": {
        
            "isMultiSelect": true
        
        },
        "columns": [
            {
                "header": "Short Name",
                "name": "shortName",
                "sortable": true,
                "filterable": false,
                "editType":"text"
            },
            {
                "header": "Long Name",
                "name": "longName",
                "sortable": false,
                "filterable": true,
                "editType":""
            },
            {
                "header": "Product Type",
                "name": "productType",
                "sortable": false,
                "filterable": false,
                "editType":"text"
            }
}
```
The following JSON object is a sample of data which can be used to bind the grid.
```json
[
    {
        "shortName": "web Price",
        "longName": "Web Price",
        "productType": "Electronics",
        "description": "product web price",
        "isNew": false,
        "isApproved": true
    },
    {
        "shortName": "catalog",
        "longName": "Catalog",
        "productType": "Toys",
        "description": "catalog information",
        "isNew": true,
        "isApproved": false
    },
    {
        "shortName": "cost1",
        "longName": "Cost2",
        "productType": "Value",
        "description": "cost of the product1",
        "isNew": false,
        "isApproved": true
    }
]
```
@demo demo/index.html
-->

<dom-module id="pebble-grid">
	<template>
		<style include="pebble-styles-shared">
			.attribute {
				width: 100%;
			}
			
			h1 {
				text-align: center;
				font-family: var(--default-font-family);
			}
			
			div.clearboth {
				clear: both;
			}
			iron-data-table {
				--iron-data-table-header: {
					height: 45px;
				}
			}
			
			iron-data-table data-table-row[header],
			iron-data-table data-table-row[header] /deep/ label {
				font-weight: var(--font-bold);
				color: var(--palette-cerulean);
				border-bottom: none;
				text-transform:uppercase;
				font-size: var(--table-head-font-size,11px);
			}
			iron-data-table data-table-row:not([header]){
				color: var(--palette-dark);
				font-size: var(--default-font-size);
				border-bottom: solid 1px var(--palette-pale-grey-three);
			}
			
			iron-data-table data-table-row[header] /deep/ paper-icon-button:not([direction]) {
				opacity: 0.7 !important;
			}
			
			#pebbleGridContainer {
				border: 1px solid var(--palette-cloudy-blue);
				font-family: var(--default-font-family);
				font-size: var(--default-font-size);
				border-radius: var(--default-border-radius);
			}
			#pebbleGridContainer grid-list-view::shadow .container{
				will-change: unset;
				transform: none!important;
				position: relative;
			}
			
			#gridHeader {				
				font-family: var(--default-font-family);
				font-size: var(--default-font-size);
				padding: 10px;
				color: var(--palette-steel-grey);
			}
			
			#gridHeader > span {
				font-weight: var(--font-bold);
				color: var(--palette-dark);
			}
			
			pebble-button {
				vertical-align: -webkit-baseline-middle;
				vertical-align: -moz-baseline-middle;
				vertical-align: baseline-middle;				;
				--pebble-button: {
					padding: 0.5em 0em 0.5em 0em;
					min-width: 2.14em;
					margin: 0px;
				}
				--pebble-button-iron-icon: {
					height: 20px;
					width: 20px;
					color: var(--icon-color);
				}
			}
			
			pebble-button.pageRange::shadow paper-button {
				line-height: var(--border-btn-height,24px);
				height: var(--border-btn-height,30px);
				box-shadow: none;
				font-family: var(--default-font-family);
				padding:0 5px 0px 4px;
				font-size: var(--default-font-size)!important;
			}
			
			pebble-vertical-divider {
				min-width: 1px;
				min-height: 24px;
				border-right: 0;
				--pebble-vertical-divider-color: var(--drawer-border-color);
			}
			
			.input-content.paper-input-container .paper-input-label {
				color: var(--white) !important;
				font-family: var(--default-font-family);
			}
			paper-dropdown-menu {
				width: 90px;
				--paper-input-container: {
					padding: 0;
				}
				--paper-input-container-underline: {
					display: none;
				};
				--paper-input-container-underline-focus: {
					display: none;
				};
				--paper-dropdown-menu-icon: {
					color:var(--palette-steel-grey);
				};
				--paper-input-container-input: {
					color: var(--palette-steel-grey);
					font-size:var(--dropdown-inside-grid-size,12px);
					vertical-align:top !important;
					line-height:22px !important;
					padding-left: var(--gutter-width);
				};			
			}
			.actionButton{
				margin-right:var(--default-margin);
			}
			
			data-table-checkbox{
				border-right:none;
				flex-basis: 36px;
				padding: 0 10px;
			}
			data-table-checkbox[header]{				
				height: 32px!important;				
			}
			data-table-cell{
				padding: 0;
			}
			data-table-cell[header]{
				height: 32px!important;
				font-size: var(--font-size-small);
				color: var(--palette-cerulean);
				padding: 3px 0 0 0;
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container {
				padding: 0;
				margin: 0;
				height: 32px;
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container::shadow .floated-label-placeholder{
				line-height: 3px;
			}
			iron-data-table::shadow #header{
				height: 32px;
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell rock-attribute::shadow .attribute-main{
				padding: 0;
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container label{
				top: 1px;
				font-size: var(--font-size-small);
				color: var(--palette-cerulean);
				font-weight: bold;
			}
			#pebbleGridContainer iron-data-table data-table-row data-table-cell data-table-column-filter::shadow paper-input::shadow paper-input-container input{
				font-size: var(--default-font-size);
			}
			data-table-row[header]{
				border-bottom: 1px solid var(--palette-cloudy-blue)!important;
			}
			data-table-row[header] data-table-checkbox::shadow #container{
				border-color: var(--paper-checkbox-unchecked-color, var(--palette-cerulean));
			}
			data-table-row[header] data-table-checkbox[indeterminate]::shadow .checkmark{
				border-color: var(--paper-checkbox-indeterminate-color, var(--palette-cerulean));
			}
			data-table-row data-table-checkbox::shadow #container,paper-checkbox::shadow #checkbox{
				border: solid 1px;
				border-color: var(--paper-checkbox-unchecked-color, var(--palette-cloudy-blue));
				border-radius: var(--default-border-radius);
				height:var(--paper-checkbox-size, var(--default-checkbox-size));
				width:var(--paper-checkbox-size, var(--default-checkbox-size));
			}
			data-table-row data-table-checkbox[checked]::shadow #container,paper-checkbox[checked]::shadow #checkbox {
				background-color: var(--paper-checkbox-checked-color, var(--palette-cerulean-two));
				border-color: var(--paper-checkbox-checked-color, var(--palette-white));
			}
			data-table-row data-table-checkbox[checked]::shadow .checkmark, paper-checkbox[checked]::shadow #checkmark{
				width: 20%;
				height: 50%;
				-webkit-transform-origin: 60% 110%;
				transform-origin: 60% 110%;
			}
			data-table-column-sort::shadow paper-icon-button{
				width: 15px;
				height: 13px;
				padding: 0;
				position: relative;
				top: -2px;
				opacity: 1;
			}
			paper-dropdown-menu::shadow paper-menu-button::shadow .dropdown-content{
				@apply --common-popup;
				margin-top:0;
				top:var(--grid-header-height,47px);
				overflow:visible !important;
			}
			paper-dropdown-menu::shadow paper-menu-button::shadow .dropdown-content:after{
				content: "";
				position: absolute;
				width: 0;
				height: 0;
				margin-left: 4px;
				top:0;
				left: 50%;
				box-sizing: border-box;
				border: 4px solid var(--border-black);
				border-color: transparent transparent var(--palette-white) var(--palette-white);
				transform-origin: 0 0;
				transform: rotate(135deg);
				box-shadow: -1px 1px 1px 0 var(--palette-cloudy-blue);
			}
			paper-listbox paper-item{
				font-size: var(--font-size-small);
				color: var(--palette-dark-two);
				min-height: 30px;
				width: 100px;
			}
			.trim {
				display: inline-flex;
				width: 30%;
				text-overflow: ellipsis;
				overflow: hidden;
				white-space:nowrap;
			}
			pebble-actions{
				padding-left:10px;
				padding-right:10px;
				height:32px;
			}
			--pebble-button-iron-icon: {
				height: 20px;
				width: 20px ;
				padding:0 3px 0 3px;
				color: var(--white);
				@apply(--pebble-actions-button-icon);
			}
			pebble-actions::shadow pebble-button::shadow paper-button{
				background-color:var(--white);
				color:var(--color-steal-grey) !important;
			}
			pebble-actions::shadow pebble-button::shadow iron-icon{
				color:var(--default-icon-color) !important;
			}
				
			.error-circle {
				height: 18px;
				width: 18px;
				line-height:18px;
				text-align: center;
				border-radius: 50%;
				background: var(--error-color);
				font-size: 9px;
				float: right;
				color: var(--white);
			}
		</style>
<template is="dom-if" if="{{_dataIsNotNull(data, config, attributeModels)}}">
	<div id="gridHeader" align="right" class="row layout-middle layout-between">
		<span class="trim">[[title]] </span>
		<div class="grid-actions row layout-middle">
			<pebble-button class="pageRange m-r-5 m-l-5" button-text="{{_pageRange}}" noink></pebble-button>
			<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
			<pebble-button icon="pebble-md-icons:ToolbarRefresh" class="pebble-md-icons m-l-5 m-r-5" on-tap="_onRefresh" noink></pebble-button>
			<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
			<template is="dom-if" if="[[!config.readOnly]]">
				<pebble-button icon="pebble-md-icons:Edit" class="pebble-md-icons m-l-5 m-r-5" on-tap="_changeToEditMode" noink></pebble-button>
				<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
			</template>
			<pebble-button class="pageRange btn-with-border m-l-5 m-r-5" button-text="Add" on-tap="_addNewRow" noink></pebble-button>
			<pebble-button icon="pebble-md-icons:Import" on-tap="_onDownload" class="pebble-md-icons m-l-5 m-r-5" noink></pebble-button>
			<pebble-button icon="pebble-md-icons:Upload" on-tap="_onUpload" class="pebble-md-icons m-l-5 m-r-5" noink></pebble-button>
			<pebble-vertical-divider class="m-l-5 m-r-5"></pebble-vertical-divider>
			<paper-dropdown-menu label="{{config.viewMode}}" no-label-float>
				<paper-listbox class="dropdown-content" attr-for-selected="value" selected="{{config.viewMode}}">
					<paper-item value="Tabular">
						<pebble-button icon="pebble-md-icons:Tableview" class="pebble-md-icons m-r-5"></pebble-button>Tabular</paper-item>
					<paper-item value="List">
						<pebble-button icon="pebble-md-icons:Listview" class="pebble-md-icons m-r-5"></pebble-button>List</paper-item>
					<paper-item value="Tile">
						<pebble-button icon="pebble-md-icons:Tileview" class="pebble-md-icons m-r-5"></pebble-button>Tile</paper-item>
				</paper-listbox>
			</paper-dropdown-menu>
		</div>
	</div>
	<div id="pebbleGridContainer" class="m-l-10 m-r-10">
		<template is="dom-if" if="{{_isTabularMode(config.viewMode)}}">
			<iron-data-table page-size="{{pageSize}}" size="{{_currentPageDataSize}}" selection-enabled multi-selection="{{config.tabular.settings.isMultiSelect}}"
				data-source="{{dataSource}}" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" sort-order="{{sortOrder}}">
				<data-table-column name="Actions" hidden$="[[!_hasActions()]]">
					<template>
						<template is="dom-repeat" items="[[_actions()]]" as="col" index-as="colIndex">
							<pebble-button class="actionButton" icon="[[_actionValue(colIndex)]]" on-tap="_fireActionEvent" item="[[item]]" index="[[colIndex]]"></pebble-button>
						</template>
						<span id="error-circle[[item.id]]" class="error-circle" hidden item="[[item]]" on-tap="_openPopover" on-mouseenter="_openPopover"> </span>
					</template>
				</data-table-column>
				<template is="dom-repeat" items="[[config.tabular.columns]]" as="col" index-as="colIndex">
					<data-table-column name="[[col.header]]" column-index="{{colIndex}}" filter-by$="[[_isFilterEnabled(col)]]" sort-by$="[[_isSortable(col)]]"
						icon="pebble-icons:Edit" model-object="{{_getAttributeModelObject(col)}}">
						<template>
							<rock-attribute functional-mode="grid" id="row[[item.id]]col[[column.columnIndex]]" class="attribute" mode="{{_getViewMode(_mode,item)}}"
								attribute-model-object="{{column.modelObject}}" attribute-object="{{_getAttributeObject(item, column.columnIndex)}}"
								on-attribute-value-changed="_updateValue"></rock-attribute>
						</template>
					</data-table-column>
				</template>
			</iron-data-table>
			<pebble-popover id="errorPopover" no-overlap>
				<pebble-error-list></pebble-error-list>
			</pebble-popover>
		</template>
		<template is="dom-if" if="{{_isTileMode(config.viewMode)}}">
			<grid-tile-view items="{{data}}" multi-selection="{{config.tile.settings.isMultiSelect}}" selected-item="{{selectedItem}}"
				selected-items="{{selectedItems}}" tile-items="{{config.tile.tileItems}}" actions="{{config.tile.settings.actions}}"></grid-tile-view>
		</template>
		<template is="dom-if" if="{{_isListMode(config.viewMode)}}">
			<grid-list-view id="gridListView" items="{{data}}" multi-selection="{{config.list.settings.isMultiSelect}}" selected-item="{{selectedItem}}"
				selected-items="{{selectedItems}}" list-items="{{config.list.listItems}}" actions="{{config.list.settings.actions}}"></grid-list-view>
		</template>
	</div>
</template>
</template>
<script> 
	(function () {
		'use strict';
		Polymer({
			is: 'pebble-grid',
			/**
			* Fired when user clicks on a item to select it.
			*
			* @event grid-selecting-item (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item item to be selected
			*/
			/**
			* Fired when user clicks on a item to deselect it.
			*
			* @event grid-deselecting-item (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item item to be deselected
			*/
			/**
			* Fired when user clicks on the select all checkbox to select the items.
			*
			* @event grid-selecting-all-items (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item containing current filters for items
			*/
			/**
			* Fired when user clicks on the select all checkbox to deselect the items.
			*
			* @event grid-deselecting-all-items (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item containing current filters for items
			*/
			/**
			* Fired when user clicks on a item to expand it.
			*
			* @event grid-expanding-item (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item item to be expanded
			*/
			/**
			* Fired when user clicks on a item to collapse it.
			*
			* @event grid-collapsing-item (pub-sub event)
			* @param {Object} detail
			* @param {Object} detail.item item to be collapsed
			*/
			properties: {
				/**
				 * Indicates the data which is wrapped in a data-source that is used as a grid data.
				 * The format for the JSON object is given in the above description.
				 */
				data: {
					type: Object,
					notify: true,
					value: function () {
						return {};
					}
				},
				/**
				 * Indicates a data-source that has to grid.
				 * The format for the JSON object is given in the above description.
				 */
				dataSource: {
					notify: true,
					value: function () {
						return this._dataSource.bind(this);
					}
				},
				/**
				 * Indicates the total size of the data-source.
				 */
				recordSize: {
					notify: true,
					type: Number,
					value: 0
				},
				/**
				 * Indicates the number of items fetched at a time from the data-source.
				 */
				pageSize: {
					type: Number,
					notify: true,
					value: 0
				},
				/**
				 * Indicates a config object which decides the rendering behavior.
				 * The format for the JSON object is given in above description.
				 */
				config: {
					type: Object,
					notify: true
				},
				/**
				 * Indicates an attribute model to be used if the schema type is a <b>attribute</b>.
				 */
				attributeModels: {
					type: Object,
					notify: true,
					value: function () {
						return {};
					}
				},
				currentPage: {
					notify: true,
					value: 0
				},
				/**
				 * Indicates an array that contains the selected items when `multiSelection` is true.
				 * Otherwise, indicates null if no item is selected.
				 */
				selectedItems: {
					type: Array,
					//value : [],
					notify: true,
					reflectToAttribute: true
				},
				/**
				 * Indicates the currently selected item when `multiSelection` is false. 
				 * Otherwise, indicates null if no item is selected.
				 */
				selectedItem: {
					type: Object,
					//value : {},
					notify: true,
					reflectToAttribute: true
				},
				/**
				 * Specifies whether or not multiple items may be selected at once. When it is set to <b>true</b>
				 * you can select multiple items at once. In this case, it indicates an array of currently selected items. 
				 * When it is set to <b>false</b>, you can select only one item at a time.
				 */
				multiSelection: {
					type: Boolean,
					value: false,
					notify: true,
					reflectToAttribute: true
				},
				/**
				  * Indicates the title for the grid.
				  */
				title: {
					type: String,
					notify: true
				},
                /**
                 * Indicates an array with a path and a sort order. <b>`asc`</b> or <b>`desc</b>` pairs 
				 * are used to sort the items.
                 */
				sortOrder: {
					type: Array,
					notify: true
				},
				_mode: {
					type: String,
					computed: '_getMode(config.mode)',
					notify: true
				},
				_pageRange: {
					value: ""
				},
				_attributeModelMap: {
					type: Object
				},
				_currentPageDataSize: {
					notify: true,
					value: 10
				}
			},
			behaviors: [
				RUFBehaviors.UIBehavior
			],
			observers: [
				'_calculatePageRange(currentPage, pageSize, recordSize)',
				'_computeTitle(config, data, recordSize, sortOrder, sortOrder.*)'
			],
			listeners: {
				'selecting-item': '_onSelectingItem',
				'deselecting-item': '_onDeselectingItem',
				'selecting-all-items': '_onSelectingAllItems',
				'deselecting-all-items': '_onDeselectingAllItems',
				'expanding-item': '_onExpandingItem',
				'collapsing-item': '_onCollapsingItem'
			},
			_addNewRow: function () {
				var newItem = {};
				newItem.isEditable = true;
				newItem.status = 'new';
				newItem.errors = [];
				var oldsize = this.data.length;
				this.data.unshift(newItem);
				this._getIronDataTable()._sizeChanged(oldsize + 1, oldsize);
				this._getIronDataTable()._resetData(this.dataSource);
			},
			/**
			  * Can be used to add the new rows to the grid.
			  */
			addNewRows: function (noOfRows) {
				for (var i = 0; i < noOfRows; i++) {
					var newItem = {};
					newItem.isEditable = true;
					newItem.status = 'new';
					this.data.unshift(newItem);
				}
				var oldsize = this.data.length;
				this._getIronDataTable()._sizeChanged(oldsize + noOfRows, oldsize);
				this._getIronDataTable()._resetData(this.dataSource);
			},
			/* 
			 * Can be used to re-render the grid.
			 */
			reRenderGrid: function () {
				if (this._getIronDataTable()) {
					this._getIronDataTable()._resetData(this.dataSource);
				}
			},
			_computeTitle: function (config, data, size, sortOrder) {
				if (config && config.header && config.header.displayTitle) {
					if (config.title) {
						this.set('title', config.title);
					}
					this.set('title', config.header.defaultValue);
				} else if (data && size) {
					var status = size + ' items.';
					if (sortOrder && sortOrder.length > 0) {
						status += ' Sorted by ';
						for (var i = 0; i < sortOrder.length; i++) {
							var sort = sortOrder[i];
							status += sort.path + ' ' + sort.direction;
							if (i < sortOrder.length - 1) {
								status += ', ';
							}
						}
					}
					this.set('title', status);
				}
			},
			/**
			* Can be used to clear the cached pages and reload the data from the data-source when needed.
			*/
			clearCache: function () {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.clearCache();
			},
			/**
			* Can be used to clear the cache for a page and reload the data from the data-source.
			*/
			refreshPage: function (page) {
				var ironDataTable = this._getIronDataTable();
				if (ironDataTable) {
					ironDataTable.refreshPage(page);
				}
			},
			/*
			* Can be used to select all the items in the list.
			*/
			selectAll: function () {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.selectAll();
			},
			/**
			* Can be used to clear the current selection state.
			*/
			clearSelection: function () {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.clearSelection();
			},
			/**
			* Can be used to select the list item at the given index.
			*
			* @method selectItem
			* @param {(Object|number)} item The item object or its index
			*/
			selectItem: function (item) {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.selectItem(item);
			},
			/**
			* Can be used to deselect the given item list if it is already selected.
			*
			* @method deselect
			* @param {(Object|number)} item The item object or its index
			*/
			deselectItem: function (item) {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.deselectItem(item);
			},
			/**
			* Can be used to expand the row details for this item if it is available.
			*/
			expandItem: function (item) {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.expandItem(item);
			},
			/**
			* Can be used to collapse the row details for this item if it is expanded.
			*/
			collapseItem: function (item) {
				var ironDataTable = this._getIronDataTable();
				ironDataTable.collapseItem(item);
			},
			/**
			 * Can be used to reuturn the array of selectedItems.
			 * When `multiSelection` is true, the array contains the selected items.
			 * @return {Array<object>} The selectedItems is an array of object and other properties as below.
			 * If `selectedItems.inverted` is `true`, the array contains deselected items.
			 * `selectedItems.filters` contains an array of filters that are active when the selection changes.
			 */
			getSelectedItems: function () {
				var ironDataTable = this._getIronDataTable();
				return ironDataTable.selectedItems;
			},
			/**
			 * @return {object}
			 * Used to return currently selected item. If no item is selected, then it returns `null`.
			 */
			getSelectedItem: function () {
				var ironDataTable = this._getIronDataTable();
				return ironDataTable.selectedItem;
			},
			//_computeCachedItems : function() {
			//	return this.data.slice(0, (this.currentPage * this.pageSize) + this.pageSize);
			//},
			_dataSource: function (opts, cb) {
				this.currentPage = opts.page;
				if (this.config.schemaType == undefined || this.config.schemaType == "Simple") {
					var pagedData = this.data.slice(opts.page * opts.pageSize, (opts.page * opts.pageSize) + opts.pageSize)
					// if last page is reached, increment the size.
					if (this._currentPageDataSize / opts.pageSize >= opts.page) {
						this._currentPageDataSize += opts.pageSize;
					}
					cb(pagedData);
				}
				else {
					this.dataChangedHandler = function (e) {
						if (this.data) {
							
							var pagedData = this._getAttributeFormattedData(this.data, opts);
							if(!pagedData){
								pagedData = [];
							}
							// if last page is reached, increment the size.
							if (pagedData.length > 0 && this._currentPageDataSize / opts.pageSize >= opts.page) {
								this._currentPageDataSize += opts.pageSize;
							}
							cb(pagedData);
							//this.removeEventListener("data-changed", this.dataChangedHandler);
						}
					};
					if (opts.page == 0) {
						
						var pagedData = [];
						if (this.data) {
							pagedData = this._getAttributeFormattedData(this.data, opts);
						}
						cb(pagedData);
					}
					else {
						this.addEventListener("data-changed", this.dataChangedHandler);
					}
				}
			},
			_calculatePageRange: function (currentPage, pageSize, recordSize) {
				var currentSize = currentPage == 0 ? pageSize * 2 : (currentPage + 1) * pageSize;
				if(currentSize > recordSize){
					currentSize = recordSize;
				}
				this._pageRange = "1 - " + currentSize + " / " + recordSize;
				//It is temporary heck, need to remove it
				// if (this) {
				// 	this.refreshPage(currentPage);
				// }
			},
			_columnValue: function (gridData, index) {
				var cellData;
				var columnName = this.config.tabular.columns[index].name;
				if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
					cellData = gridData[columnName];
				}
				else if (this.config.schemaType == "attribute") {
					for (var key in gridData.attributes) {
						if (gridData.attributes[key].hasOwnProperty(columnName)) {
							cellData = gridData.attributes[key][columnName].value;
							break;
						}
					}
				}
				if (cellData != undefined) {
					index++;
				}
				if (typeof (cellData) === "boolean") {
					return cellData.toString();
					//Had to manually convert to string because pebble-boolean is not working when you pass boolean.
				}
				return cellData;
			},
			_isTabularMode: function (viewMode) {
				return viewMode == 'Tabular';
			},
			_isTileMode: function (viewMode) {
				return viewMode == 'Tile';
			},
			_isListMode: function (viewMode) {
				return viewMode == 'List';
			},
			_getAttributeModelObject: function (col) {
				var displayType = "";
				if (this.config.schemaType == undefined || this.config.schemaType == "simple") {
					if (!col.displayType) {
						col.displayType = col.editType;
					}
					return col;
				}
				else if (this.config.schemaType == "attribute") {
					return this._getAttributeModelMap(col.name);
				}
			},
			_getAttributeObject: function (item, columnIndex) {
				var value = { "value": this._columnValue(item, columnIndex) };
				if (this.config.tabular.columns.length == columnIndex + 1) {
					this.async(function () {
						this._updateError(item);
					})
				}
				return value;
			},
			_isFilterEnabled: function (col) {
				return col.filterable ? col.name : undefined;
			},
			_isSortable: function (col) {
				return col.sortable ? col.name : undefined;
			},
			_dataIsNotNull: function (data, config, attributeModels) {
				var result = typeof (data) == "object" && typeof (config) == "object";
				if (result && config.schemaType == "attribute" && Object.keys(attributeModels).length == 0) {
					result = false;
				}
				return result;
			},
			_onRefresh: function (e) {
				this.clearCache();
			},
			_onDownload: function (e) {
				this.selectAll();
			},
			_onUpload: function (e) {
				this.clearSelection();
			},
			_getIronDataTable: function () {
				return Polymer.dom(this.root).node.querySelector("iron-data-table")
					|| Polymer.dom(this).node.querySelector("iron-data-table");
			},
			_onSelectingItem: function (e) {
				this.fireBedrockEvent("grid-selecting-item", e.detail);
			},
			_onDeselectingItem: function (e) {
				this.fireBedrockEvent("grid-deselecting-item", e.detail);
			},
			_onSelectingAllItems: function (e) {
				this.fireBedrockEvent("grid-selecting-all-items", e.detail);
			},
			_onDeselectingAllItems: function (e) {
				this.fireBedrockEvent("grid-deselecting-all-items", e.detail);
			},
			_onExpandingItem: function (e) {
				this.fireBedrockEvent("grid-expanding-item", e.detail);
			},
			_onCollapsingItem: function (e) {
				this.fireBedrockEvent("grid-collapsing-item", e.detail);
			},
			_getAttributeModelMap: function (name) {
				if (this.attributeModels) {
					if (this._attributeModelMap == undefined) {
						this._attributeModelMap = {};
						for (var key in this.attributeModels) {
							for (var attrKey in this.attributeModels[key]) {
								if (attrKey != "name") {
									this._attributeModelMap[attrKey] = this.attributeModels[key][attrKey];
								}
							}
						}
					}
					return this._attributeModelMap[name];
				}
				return {};
			},
			_getRecordSize: function () {
				if (this.recordSize > 0) {
					return this.recordSize;
				}
				if (this.data) {
					if (this.config && this.config.schemaType == "attribute") {
						return Object.keys(this.data).length;
					}
					else {
						return this.data.length;
					}
				}
				return 0;
			},
			_changeToEditMode: function () {
				this.set('config.mode', "edit");
				this.fire('editMode');
			},
			_actionValue: function (index) {
				var action = this.config.tabular.settings.actions[index];
				var icon = action.icon;
				if (!icon) {
					if (action.name == 'delete') {
						return 'pebble-icons:Delete';
					} else if (action.name == 'edit') {
						return 'pebble-icons:Edit'
					} else {
						return '';
					}
				}
				return icon;
			},
			_updateValue: function (e) {
				var columnIndex = typeof e.target.column === 'undefined' ? e.srcElement.dataHost.column.columnIndex : e.target.column.columnIndex;
				var item = typeof e.target.item === 'undefined' ? e.srcElement.dataHost.item : e.target.item;
				var value = e.detail;
				var columnName = this.config.tabular.columns[columnIndex].name;
				item[columnName] = value;
			},
			_fireActionEvent: function (e) {
				var action = this.config.tabular.settings.actions[e.currentTarget.index];
				var eventName = action.eventName;
				if (!eventName) {
					if (action.name == 'delete') {
						eventName = "grid-delete-item";
					} else if (action.name == 'edit') {
						eventName = "grid-edit-item";
					} else {
						return;
					}
				}
				if (action.name == "edit") {
					this.editInline(e.currentTarget.item);
					return;
				}
				//				alert("fired " + eventName);
				this.fire('bedrock-event', { name: eventName, data: e.currentTarget.item });
			},
			_hasActions: function () {
				if (this.config.tabular.settings.actions && this.config.tabular.settings.actions.length > 0) {
					return true;
				}
				return false;
			},
			_actions: function () {
				return this.config.tabular.settings.actions;
			},
			_getMode: function (mode) {
				return mode;
			},
			_getViewMode: function (mode, item) {
				if (item.isEditable) {
					return "edit";
				}
				return mode;
			},
			_updateError: function (item) {
				var errors = [];
				for (var i = 0; i < this.config.tabular.columns.length; i++) {
					var attr = this.$$("#row" + item.id + "col" + i);
					if (attr && attr.errors.length > 0) {
						var error = {};
						error.name = this.config.tabular.columns[i].name;
						error.error = attr.errors;
						errors.push(error);
					}
				}
				item.errors = errors;
				var errorLength = errors.length;
				var sp;
				if (item.id) {
					sp = this.$$("#error-circle" + item.id);
				} else {
					sp = this.$$("#error-circle");
				}
				if (sp) {
					if (errorLength) {
						sp.hidden = false;
						sp.textContent = errorLength;
					} else {
						sp.hidden = true;
					}
				}
			},
			_openPopover: function (e) {
				var sp = e.currentTarget;
				var item = e.currentTarget.item;
				var popover = this.$$("#errorPopover");
				popover.positionTarget = sp;
				popover.setAttribute("for", "error-circle" + item.id);
				popover.querySelector("pebble-error-list").errors = item.errors;
				popover.show();
			},
			// Can be used to change a row's mode to the edit mode.
			editInline: function (item) {
				item.isEditable = true;
				for (var i = 0; i < this.config.tabular.columns.length; i++) {
					var attr = this.$$("#row" + item.id + "col" + i);
					if (attr) {
						attr.mode = 'edit';
					}
				}
			},
			// Can be used to change a row's mode to the read mode.
			changeRowToViewMode: function (item) {
				item.isEditable = false;
				for (var i = 0; i < this.config.tabular.columns.length; i++) {
					var attr = this.$$("#row" + item.id + "col" + i);
					if (attr) {
						attr.mode = 'read';
					}
				}
			},
			_getAttributeFormattedData: function (data, opts) {
				var dataArray = Object.keys(data).map(function (key) {
					if (data.hasOwnProperty(key)) {
						return data[key];
					}
				});
				//var pagedData = dataArray.slice(opts.page * opts.pageSize, (opts.page * opts.pageSize) + opts.pageSize)
				DataHelper.transformEntitySchemaForGrid(dataArray, this.attributeModels);
				return dataArray;
			}
		});
	})();
</script>
</dom-module>