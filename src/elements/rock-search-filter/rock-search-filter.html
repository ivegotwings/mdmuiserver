<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/paper-radio-group/paper-radio-group.html">
<link rel="import" href="../../../bower_components/paper-menu-button/paper-menu-button.html">
<link rel="import" href="../../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-app-context-behavior/bedrock-app-context-behavior.html">
<link rel="import" href="../bedrock-helpers/constant-helper.html">

<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-gridsystem.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-tags/pebble-tags.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textbox-collection/pebble-textbox-collection.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-datetime-picker/pebble-datetime-picker-overlay.html">

<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-search-bar/rock-search-bar.html">
<link rel="import" href="../rock-self-attribute-model-lov/rock-self-attribute-model-lov.html">
<!--
`rock-search-filter` Represents an element that contains the "search bar" and filter tags. 
The users can switch between a search mode and a filter mode to get the query they want to search.

@demo demo/index.html
-->

<dom-module id="rock-search-filter">

  <template>
    <style include="bedrock-style-common bedrock-style-gridsystem"></style>
    <style>
      :host {
        --item-length-overflow: {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
      }

      .container {
        @apply --layout-horizontal;
        @apply --layout-center;
        display: inline-flex;
        display: -webkit-inline-flex;
        width: 100%;
      }

      pebble-tags {
        --tag-color: var(--top-header-background);
        --actions-icon-button: {
          height: var(--tag-icon-size);
          width: var(--tag-icon-size);
          padding-top: 0px;
          padding-right: 0px;
          padding-bottom: 0px;
          padding-left: 0px;
        };
      }

      pebble-tags {
        --pebble-button-iron-icon: {
          height: 20px;
          width: 20px;
        };
      }

      .tagContainer{
        width: calc(100% - 290px);
      }

      paper-menu-button {
        padding: 0;
      }

      paper-menu.dropdown-content {
        padding: 0;
      }

      paper-menu-button paper-menu paper-item {
        --pebble-button-paper-menu-item:{
        color: var(--palette-dark, #1a2028);
        };
      }
      paper-menu-button paper-menu paper-item:hover {
        background-color: var(--bgColor-hover, #e8f4f9);
        color: var(--focused-line, #026bc3) !important;
      }

      paper-menu-button paper-menu paper-item:focus:before,
      paper-menu-button paper-menu paper-item:focus:after {
        background-color: var(--bgColor-hover, #e8f4f9);
      }

      paper-menu-button paper-menu paper-item:focus {
        background-color: var(--bgColor-hover, #e8f4f9);
        color: var(--focused-line, #026bc3) !important;
      }
      paper-menu-button paper-menu paper-item iron-icon:hover {
          color: var(--focused-line, #026bc3) !important;
      }

      #filterPopover {
        min-width: 240px;
      }

      pebble-textbox {
        --paper-input-container: {
          padding-top: 0px;
          padding-right: 20px;
          padding-bottom: 0px;
          padding-left: 20px;
        }
      }

      #filterPopover paper-item {
        --paper-item: {
          font-size: 12px;
        }
        --paper-item-min-height: 30px;
      }

      #filterPopover paper-menu {
        --paper-menu-selected-item: {
          font-size: 12px;
        }
      }

      pebble-boolean {
        --pebble-boolean: {
          height: 30px;
          width: 100px;
          font-size: var(--default-font-size, 14px) !important;
        }
      }

      pebble-button[disabled] {
        pointer-events: none;
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        border-color: #c1cad4;
      }

      pebble-textarea {
        --textarea-container: {
          padding-top: 0px !important;
          padding-right: 20px !important;
          padding-bottom: 0px !important;
          padding-left: 20px !important;
        };
      }

      pebble-textarea(.floated-label-placeholder) {
        line-height: 0;
      }

      pebble-popover {
        --pebble-popover-max-width: 100%;
        --pebble-popover-width: 260px;
      }

      pebble-popover .dialogOptions paper-radio-button {
        @apply --popup-item;
      }

      pebble-popover .dialogOptions paper-radio-button input {
        width: 100px;
        font-size: 15px;
        padding: 0 4px;
        line-height: 30px;
      }

      pebble-popover rock-entity-lov {
        --pebble-lov: {
          padding-top: 0px;
          padding-right: 0px;
          padding-bottom: 0px;
          padding-left: 0px;
        }
      }

      paper-input {
        width: 90%;
      }

      .dialogOptions paper-radio-button {
        display: block;
      }
     paper-radio-group paper-radio-button{
        --paper-radio-button-unchecked-color: var(--radio-button-border, #026bc3);
        --paper-radio-button-checked-color: var(--radio-button-selected, #026bc3);
      }
      .input-content::slotted(input), .input-content::slotted(textarea), .input-content::slotted(iron-autogrow-textarea),
      .input-content::slotted(.paper-input-input) {
        font-size: var(--default-font-size, 14px);
      }

      pebble-textbox-collection {
        --tags-container: {
          min-height: 0px;
          margin-right: 0px;
        }
        --text-collection-container: {
          min-height: 0px;
          margin-top: 0px;
        }
      }

      #filter-entity-type-tag{
        --tag-name: {
          max-width : 250px;
        }
      }
    </style>

    <template is="dom-if" if="{{searchMode}}">
      <div class="container">
        <rock-search-bar id="searchSection" style="width:90%" search-input="{{tags}}"></rock-search-bar>
        <pebble-button icon="filter-list" class="button" on-tap="toggleMode" raised></pebble-button>
      </div>
    </template>
    <template is="dom-if" if="{{!searchMode}}">
      <div class="row layout-top">
        <template is="dom-if" if="{{!hideSearchTrigger}}">
          <pebble-button icon="search" class="button" on-tap="toggleMode" raised></pebble-button>
        </template>
        <pebble-button id="filterButton" icon="{{icon}}" button-text="{{text}}" dropdown-icon noink class="dropdownText dropdownIcon btn dropdown-primary dropdown-trigger"
          on-tap="_openFilterLov"></pebble-button>
        <pebble-popover id="refineFilterPopover" for="filterButton" no-overlap auto-fit-on-attach vertical-align="auto" horizontal-align="auto">
          <rock-self-attribute-model-lov id="attributeModelLov" context-data="[[contextData]]" no-sub-title id-field="name" title-pattern="externalName"
            type-field="[]" sort-details="[[filtersConfig]]"></rock-self-attribute-model-lov>
        </pebble-popover>

        <bedrock-pubsub event-name="self-attribute-model-lov-selection-changed" handler="_onSelectedFilterChange" target-id="attributeModelLov"></bedrock-pubsub>
        <div class="tagContainer">
          <pebble-tags id="filter-entity-type-tag" tags="{{entityTypeTag}}" class="p-l-10 p-r-10">
          </pebble-tags>
          <pebble-tags id="filter-tags" tags="{{tags}}" show-expand-icon show-remove-icon class="p-l-10 p-r-10">
          </pebble-tags>
        </div>       
        <bedrock-pubsub event-name="on-tap-tag-item" handler="_onTagItemTap"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-attached-tag-item" handler="_onTagItemTap"></bedrock-pubsub>
        <bedrock-pubsub event-name="entity-lov-confirm-button-tap" handler="_onLOVConfirmTap" target-id="rockEntityLov"></bedrock-pubsub>
        <bedrock-pubsub event-name="entity-lov-close-button-tap" handler="_onLOVCloseTap" target-id="rockEntityLov"></bedrock-pubsub>
        <!-- Refine popover starts here -->
         <pebble-popover id="filterPopover" for="pebble-tag" no-overlap auto-fit-on-attach vertical-align="auto" horizontal-align="auto">
          <template is="dom-if" if="{{_showTagModifier('textbox', _tigger)}}">
            <pebble-textbox-collection id="textCollection" values="{{_tagsCollection}}" no-popover textbox-label="Enter more values here to search" show-seperator seperator="or"></pebble-textbox-collection>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_onTextCollectionUpdate"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('textArea', _tigger)}}">
            <pebble-textarea class="input" label="Enter text here" value="{{tav}}"></pebble-textarea>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
           <template is="dom-if" if="{{_showTagModifier('richtexteditor', _tigger)}}">
            <pebble-textarea class="input" label="Enter text here" value="{{tav}}"></pebble-textarea>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('referenceList', _tigger)}}">
            <rock-entity-lov id="rockEntityLov" multi-select show-action-buttons selected-items="{{_selectedItems}}">
            </rock-entity-lov>
          </template>
          <template is="dom-if" if="{{_showTagModifier('boolean', _tigger)}}">
            <pebble-boolean class="text-center" id="booleanDisplay" value="{{booleanvalue}}" required></pebble-boolean>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue"></pebble-button>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('numeric', _tigger)}}">
            <paper-radio-group aria-labelledby="{{longName}}" class="dialogOptions" on-paper-radio-group-changed="_onRadioGroupChange">
              <paper-radio-button name="range">
                <div class="colspan-2 pull-left">
                  <pebble-textbox label="Min" prevent-invalid-input allowed-pattern="[0-9.]" invalid="{{numericMinInvalid}}" show-error input-data-type="[[currentTag.options.dataType]]"
                    value="{{gte}}">
                  </pebble-textbox>
                </div>
                <div class="colspan-2 pull-left">
                  <pebble-textbox label="Max" prevent-invalid-input allowed-pattern="[0-9.]" invalid="{{numericMaxInvalid}}" show-error input-data-type="[[currentTag.options.dataType]]"
                    value="{{lte}}">
                  </pebble-textbox>
                </div>
                <div class="clearfix"></div>
              </paper-radio-button>
              <paper-radio-button name="equalToDate">
                <div class="col-90 pull-left">
                  <pebble-textbox label="Equal to" prevent-invalid-input allowed-pattern="[0-9.]" invalid="{{numericEqualInvalid}}" show-error
                    input-data-type="[[currentTag.options.dataType]]" value="{{equalNum}}">
                  </pebble-textbox>
                </div>
                <div class="clearfix"></div>
              </paper-radio-button>
            </paper-radio-group>
            <div class="PebbleButtonPadding text-center">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue" disabled="{{_updateDisable}}"></pebble-button>
            </div>
          </template>
        </pebble-popover>
        <!-- Already overlay, so out of popover -->
        <pebble-datetime-picker-overlay id="rangepicker" for="pebble-tag" picker-type="daterange" show-ranges heading-format="ddd, MMM DD YYYY"
          start-date-text="{{displaygte}}" end-date-text="{{displaylte}}" start-date-value="{{gte}}" end-date-value="{{lte}}"
          on-date-range-selected="_updateValue">
        </pebble-datetime-picker-overlay>
        <!-- Refine popover ends here -->
      </div>
    </template>
  </template>
  <script>
    Polymer({

      is: 'rock-search-filter',

      properties: {
        /**
         * Indicates the list of string type that holds the tags. 
         * Note that values in this array must be identical and duplicates must be avoided due to the definition of the tags.
         */
        tags: {
          type: Array,
          notify: true,
          reflectToAttribute: true,
          value: function () {
            return []
          }
        },

        entityTypeTag: {
          type: Array,          
          value: function () {
            return []
          }
        },
        /**
         * Indicates the configuration that is used in filters.
         */
        filtersConfig: {
          type: Object,
          value: function () {
            return {};
          }
        },

        /**
         * Specifies whether or not an element is in the search or filter mode.
         */
        searchMode: {
          type: Boolean,
          value: false,
          notify: true
        },
        /**
         * Specifies whether or not the "search bar" triggered button is visible when the search mode is disabled.
         */
        hideSearchTrigger: {
          type: Boolean,
          value: false
        },
        /**
         * Specifies the text for the search filter button.
         */
        text: {
          type: String,
          value: "Refine",
          reflectToAttribute: true
        },
        /**
         * Specifies the icon for the search filter button.
         */
        icon: {
          type: String,
          value: "pebble-sm-icons:Filter-wt",
          reflectToAttribute: true
        },
        /**
         *  Indicates the reference to the currently opened tag.
         */
        currentTag: {
          type: Object,
          notify: true
        },

        _tigger: {
          type: String
        },

        _selectedItems: {
          type: Array,
          value: function () {
            return [];
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        colors: {
          type: Array,
          value: ['red', 'green', 'blue']
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        contextData: {
          type: Object,
          value: function () {
            return {};
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        gte: {
          type: String,
          value: function () {
            return "";
          },
          observer: '_isMaxGreaterThanMin'
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        lte: {
          type: String,
          value: function () {
            return "";
          },
          observer: '_isMaxGreaterThanMin'
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        equalNum: {
          type: String,
          value: function () {
            return "";
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericMinInvalid: {
          type: Boolean,
          value: false
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericMaxInvalid: {
          type: Boolean,
          value: false
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericEqualInvalid: {
          type: Boolean,
          value: false
        },
        _updateDisable: {
          type: Boolean,
          computed: '_disableUpdate(numericMinInvalid,numericMaxInvalid,numericEqualInvalid,gte,lte,equalNum)'
        }

      },
      behaviors: [
        RUFBehaviors.UIBehavior,
        RUFBehaviors.AppContextBehavior
      ],      
      /**
       * <b><i>Content development is under progress... </b></i> 
       */
      removeAllSearchFilters: function () {
        if (this.shadowRoot.querySelector("#filter-tags")) {
          this.shadowRoot.querySelector("#filter-tags").removeAllTags();
        }
      },

      /**
       * validate the input for numeric display type and disables the update button
       */
      _disableUpdate: function (numericMinInvalid, numericMaxInvalid, numericEqualInvalid, gte, lte, equalNum) {
        if (!_.isEmpty(this.gte + "") || !_.isEmpty(this.lte + "") || !_.isEmpty(this.equalNum + "")) {
          if (this.shadowRoot.querySelector('paper-radio-group') && this.shadowRoot.querySelector('paper-radio-group').selected == "range") {
            return (numericMaxInvalid || numericMinInvalid)
          } else {
            return numericEqualInvalid
          }
        } else {
          return true;
        }
      },
      /**
       * checks if the min value is less than maximum value in numeric display type popover
       */
      _isMaxGreaterThanMin: function () {
        if (!_.isEmpty(this.gte + "") && !_.isEmpty(this.lte + "")) {
          if (parseFloat(this.gte) > parseFloat(this.lte)) {
            this.set('numericMaxInvalid', true);
          } else {
            this.set('numericMaxInvalid', false);
          }
        } else {
          this.set('numericMaxInvalid', false);
        }
      },
           
      /**
       * Updating the entity tags when the user updates the entity selection
       */
      onEntityTypeChange: function (selectedEntities) {            
          var entityTypeTagStr = this._getEntityTypeDisplayValue(selectedEntities);           
          var entityTypeTagObj =  this.shadowRoot.querySelector("#filter-entity-type-tag");
          entityTypeTagObj.set('tags.0.longName', entityTypeTagStr);          
      },

      /**
       * Displaying the selected entity types as tags
       */
      addEntityTypeTag: function (selectedEntities) {  
          if(selectedEntities.length > 0) {             
            this.entityTypeTag = [];
            var entityTypeTagStr = this._getEntityTypeDisplayValue(selectedEntities); 
            this.entityTypeTag["longName"] = entityTypeTagStr;
            this.shadowRoot.querySelector("#filter-entity-type-tag").addTag(this.entityTypeTag); 
          }                                
      },
       
      /**
       *  Formating the selected entity tag
       */  
      _getEntityTypeDisplayValue: function (entityTypeList) {
        //Capitalizing the first character of the list
        for(var i = 0 ; i < entityTypeList.length ; i++){
          entityTypeList[i] = entityTypeList[i].charAt(0).toUpperCase()+ entityTypeList[i].substr(1);
        }  

        return "Entity Types: " + entityTypeList.join(",");
      },
        
      /**
       * Can be used add a filter tag on selecting it from the dropdown.
       */
      _onSelectedFilterChange: function (e, detail) {
        //Reseting the selected values of the attribute
        this._selectedItems = [];
        var data = detail.data;
        var tag = {};
        if (data && data.displayType && data.displayType.toLowerCase() == "referencelist") {
          data.selectedItems = this._selectedItems; //reset 
        }
        tag["value"] = (data.value && !_.isEmpty(data.value)) ? data.value : {
          "eq": "All"
        };
        tag["displayParams"] = (data.displayParams && !_.isEmpty(data.displayParams)) ? data.displayParams : [
          "eq"
        ];
        var dataType = data.dataType;
        var displayType = data.displayType;

        if (displayType == "textCollection") {
          displayType = "textbox";
        }

        // For now, we are not showing LOV for textbox attributes,
        // as system does not know how to return distinct / unique values for given attribute in given search scope.
        // We fix would show textbox only to type freeflow data till we fix the api / get new api
        // if(displayType.toLowerCase() == "textbox") {
        //   displayType = "referenceList";
        // }

        if (displayType == "date") {
          displayType = "datetime";
        }

        if (dataType.toLowerCase() == "integer" || dataType.toLowerCase() == "decimal") {
          displayType = "numeric";
        }

        tag.value["type"] = ConstantHelper.getDataTypeConstant(dataType);

        tag.options = data;
        tag.options.displayType = displayType
        tag["longName"] = data.externalName;
        tag["name"] = data.name;
        this.shadowRoot.querySelector("#filter-tags").addTag(tag);
        this._fireAddEvent(data.name);
        this.shadowRoot.querySelector("#refineFilterPopover").close();
      },
      /**
       *  Can be used to toggle between the search and filter mode.
       */
      toggleMode: function (e) {
        this.searchMode = !this.searchMode;
      },

      _prepareRequestData: function (contextData) {
        return DataRequestHelper.createEntityGetRequest(contextData);
      },

      // On tag tap should select the specific element 
      _onTagItemTap: function (e, detail) {
        //To avoid textcollection tag item tap
        if(!detail || !detail.options) {
          return;
        }
        this.currentTag = detail;
        var showTagPopover = true;        

        if (detail && detail.value && detail.value.noPopoverOnAttach) {
          if (e.type.indexOf("on-tap-tag-item") == -1) {
            showTagPopover = false; //set only on attach
          }
          delete detail.value.noPopoverOnAttach; //delete, as it is only on attach
        }

        if (!this.currentTag || !this.currentTag.options) return;

        if (this.currentTag && this.currentTag.options.displayType.toLowerCase() == "datetime") {
          var rangePicker = this.shadowRoot.querySelector('#rangepicker');

          //Display range picker based on the currerntTag
          if (this.currentTag.value.eq != 'All') {
            if (this.currentTag.value.eq) {
              rangePicker.startDateValue = this.currentTag.value.eq;
              rangePicker.endDateValue = this.currentTag.value.eq;
            } else {
              rangePicker.startDateValue = this.currentTag.value.gte;
              rangePicker.endDateValue = this.currentTag.value.lte;
            }

            var _date = new Date(rangePicker.startDateValue);
            rangePicker.setDate(_date);
          } else {
            rangePicker.startDateValue = "";
            rangePicker.endDateValue = "";
            rangePicker.setDate(new Date());
          }

          rangePicker.setRangeType(null);

          Polymer.Async.microTask.run(() => {
            rangePicker.positionTarget = this.shadowRoot.querySelector('#filter-tags').shadowRoot.querySelector("#tag" + detail.index);
            rangePicker.noOverlap = true;
            if (showTagPopover) {
              rangePicker.show(true);
            }
          });
        } else {
          this._tigger = Date.parse(new Date().toString()); //Just used to trigger popover element

          //Delayed to open the popover, because want to close the existing popover
          Polymer.Async.microTask.run(() => {
            var filterPopover = this.shadowRoot.querySelector('#filterPopover');

            filterPopover.positionTarget = this.shadowRoot.querySelector('#filter-tags').shadowRoot.querySelector("#tag" + detail.index);
            if (showTagPopover) {
              filterPopover.show(true);
            }

            //Set values to the components
            var tagDisplayType = this.currentTag.options.displayType.toLowerCase();
             // textbox is a collection in filters
             if (tagDisplayType == "textbox") {
              var filterInput = filterPopover.querySelector('#textCollection');
              if (!filterInput) {
                return;
              }

              filterInput.values = [];
              if (this.currentTag.value.exacts && this.currentTag.value.exacts != 'All') {
                filterInput.values =  DataHelper.cloneObject(this.currentTag.value.exacts);
              }

              setTimeout(() => {
                var collectionInput = filterInput.shadowRoot.querySelector("#txtInputTag");
                if(collectionInput) {
                  collectionInput.focus();
                }
              }, 10); //Delayed to set the value and focus the input
            } else if (tagDisplayType == "richtexteditor") {
              var filterInput = filterPopover.querySelector('.input');
              if (filterInput) {

                filterInput.value = '';

                if (this.currentTag.value.exact && this.currentTag.value.exact != 'All') {
                  filterInput.value = this.currentTag.value.exact;
                }

                setTimeout(() => {
                  filterInput.focus();
                }, 10); //Delayed to set the value and focus the input
              }
            } else if (tagDisplayType == "textarea") {
              var filterInput = filterPopover.querySelector('.input');
              if (filterInput) {

                filterInput.value = '';

                if (this.currentTag.value.exact && this.currentTag.value.exact != 'All') {
                  filterInput.value = this.currentTag.value.exact;
                }

                setTimeout(() => {
                  filterInput.focus();
                }, 10); //Delayed to set the value and focus the input
              }
            } else if (tagDisplayType == "numeric") {
              this.gte = this.lte = this.equalNum = "";
              if (this.currentTag.value.eq && this.currentTag.value.eq != 'All') {
                filterPopover.querySelector('paper-radio-group').selected = 'equalToDate';
                this.equalNum = this.currentTag.value.eq;
              } else {
                filterPopover.querySelector('paper-radio-group').selected = 'range';
                this.gte = this.currentTag.value.gte || "";
                this.lte = this.currentTag.value.lte || "";

              }
            } else if (tagDisplayType == "referencelist") {
              //Set Id, Title and Value to the LOV
              var lovComponent = filterPopover.querySelector('#rockEntityLov');

              if (this.currentTag.options.isReferenceType) {
                var titlePattern = "name";
                var subTitlePattern = "";
                var options = this.currentTag.options;

                if (options.properties && options.properties.referenceEntityInfo && options.properties.referenceEntityInfo.length) {
                  titlePattern = options.properties.referenceEntityInfo[0].listTitle;
                  subTitlePattern = options.properties.referenceEntityInfo[0].listSubTitle;
                }

                lovComponent.idField = "id";
                lovComponent.titlePattern = titlePattern;
                lovComponent.subTitlePattern = subTitlePattern;
                lovComponent.valueField = "name";
                lovComponent.selectedItems = this.currentTag.options.selectedItems;
                var refEntityTypes = this.currentTag.options.referenceEntityTypes;
                var itemContexts = [];
                for (var i in refEntityTypes) {
                  itemContexts.push({
                    "type": refEntityTypes[i]
                  });
                }
                var contextData = DataHelper.cloneObject(this.contextData);
                contextData[this.CONTEXT_TYPE_ITEM] = itemContexts;
                lovComponent.requestData = this._prepareRequestData(contextData);
                lovComponent.requestData.params.additionalIds = this.currentTag.options.selectedIds;
              } else {
                lovComponent.idField = this.currentTag.name;
                lovComponent.titlePattern = this.currentTag.name;
                lovComponent.valueField = this.currentTag.name;
                lovComponent.requestData = this._prepareRequestData(this.contextData);
                lovComponent.requestData.params.fields.attributes = [this.currentTag.name];
              }
              lovComponent.reset();
            } else if (tagDisplayType == "boolean") {
              var filterInput = filterPopover.querySelector('#booleanDisplay');
              if (filterInput) {
                filterInput.value = this.currentTag.value.eq;
              }
            }
          });
        }
      },

      // Refine filter radio buttons
      _onRadioGroupChange: function () {
        this.gte = this.lte = this.equalNum = "";
      },

      _onLOVConfirmTap: function (e, detail) {
        var selectedItemString = "";
        var selectedItemSearchString = "";
        var selectedIds = [];
        var selectedItemsObj = this._selectedItems;
        if (selectedItemsObj.length) {
          for (let i = 0; i < selectedItemsObj.length; i++) {
            if (selectedItemsObj[i].value) {
              selectedItemString = selectedItemString + selectedItemsObj[i].value + " ";
              selectedItemSearchString = selectedItemSearchString + selectedItemsObj[i].value + ", ";
            }
            if (selectedItemsObj[i].id) {
              selectedIds.push(selectedItemsObj[i].id);
            }
          }
          selectedItemString = selectedItemString.trim();
          selectedItemSearchString = selectedItemSearchString.substr(0, selectedItemSearchString.length - 2);
        }
        if (detail && detail.data) {
          this.currentTag.value = {
            "exacts": selectedItemSearchString.split(", ")
          }

          this.currentTag.options["selectedItem"] = detail.data;
          this.currentTag.options["selectedItems"] = selectedItemsObj;
          this.currentTag.options["selectedIds"] = selectedIds;
          this.currentTag.displayValue = detail.data.value;

          this.set('tags.' + this.currentTag.index + '.displayValue', this.formatFilterCollectionDisplay(selectedItemSearchString.split(", ")));
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        }

        this.shadowRoot.querySelector('#filterPopover').hide();
        //Fire event
        this._fireChangeEvent(this.currentTag.name, this.currentTag.value, this.currentTag.options.type);

      },

      _onTextCollectionUpdate: function(e, detail) {
        this.currentTag.value = {
            "exacts": this._tagsCollection
        }

        this.set('tags.' + this.currentTag.index + '.displayValue', this.formatFilterCollectionDisplay(this._tagsCollection));
        this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        this.shadowRoot.querySelector('#filterPopover').hide();
        //Fire event
        this._fireChangeEvent(this.currentTag.name, this.currentTag.value, this.currentTag.options.type)
      },

      formatFilterCollectionDisplay: function(collection, seperator) {
        seperator = seperator || 'or';
        collection = collection.map(function(el) { 
          return "'" + el + "'"; 
        });
        return collection.join(' '+ seperator +' ');
      },

      // Closing the filter popover 
      _onLOVCloseTap: function (e, detail) {
        this.shadowRoot.querySelector("#filterPopover").hide();
      },

      // Refine filter tags will be updated as per selection
      _updateValue: function (e) {
        var dataType = ConstantHelper.getDataTypeConstant(this.currentTag.options.dataType);
        if (this.currentTag.options.displayType.toLowerCase() == "datetime") { //DateTime
          // Note:- For datetime attribute it is necessary to pass dataType as 'datetime' because from UI the 
          //        system is currently passing datetime value instead of date value in range search
          if (this.gte == this.lte) {

            this.currentTag.value = {
              "gte": this.gte,
              "lte": this.lte,
              "type": ConstantHelper.getDataTypeConstant("datetime")
            };

            this.currentTag.displayValue = this.displaygte;
          } else {

            this.currentTag.value = {
              "gte": this.gte,
              "lte": this.lte,
              "type": ConstantHelper.getDataTypeConstant("datetime")
            };
            //console.log('range ', JSON.stringify(this.currentTag.value));

            if (this.displaygte == this.displaylte) {
              this.currentTag.displayValue = this.displaygte;
            } else {
              this.currentTag.displayValue = this.displaygte + " - " + this.displaylte;
            }
          }

          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        } else if (this.currentTag.options.displayType.toLowerCase() == "numeric") { //Radio group
          if (this.shadowRoot.querySelector('paper-radio-group').selected == "range") {
            if (this.gte == "") {
              this.gte = undefined;
            }
            if (this.lte == "") {
              this.lte = undefined;
            }
            if (!(this.gte || this.lte)) {
              this.logWarning("FilterValuesEmpty");
              return;
            } else {
              var gteAsString = (parseFloat(this.gte)).toString();
              var lteAsString = (parseFloat(this.lte)).toString();
              if (!this.gte) {
                this.currentTag.value = {
                  "gte": this.gte,
                  "lte": lteAsString,
                  "type": dataType
                };
                this.currentTag.displayValue = "<= " + lteAsString;
              } else if (!this.lte) {
                this.currentTag.value = {
                  "gte": gteAsString,
                  "lte": this.lte,
                  "type": dataType
                };
                this.currentTag.displayValue = ">= " + gteAsString;
              } else {
                this.currentTag.value = {
                  "gte": gteAsString,
                  "lte": lteAsString,
                  "type": dataType
                };
                this.currentTag.displayValue = gteAsString + " - " + lteAsString;
              }
            }
          } else {
            if (!this.equalNum) {
              this.logWarning("FilterValuesEmpty");
              return;
            } else {
              var parsedValue = parseFloat(this.equalNum);
              this.currentTag.value = {
                "eq": parsedValue.toString(),
                "type": dataType
              };
              this.currentTag.displayValue = parsedValue.toString();
            }
          }

          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        } else if (this.currentTag.options.displayType.toLowerCase() == "boolean") { //boolean
          this.currentTag.value = {
            "eq": this.booleanvalue,
            "type": dataType
          };
          this.currentTag.displayValue = this.booleanvalue;
          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        } else { //TextArea
          if (!this.tav) {
            this.logWarning("FilterValuesEmpty");
            return;
          }

          var operator;
          this.currentTag.displayValue = this.tav;
          var displayType = this.currentTag.options.displayType.toLowerCase();
          var splitQueryByAnd = this.tav.toLowerCase().split(' and ');
          var splitQueryByOr = this.tav.toLowerCase().split(' or ');
          var containsStr = this.tav;

          if (splitQueryByAnd.length > 1) {
            operator = "_AND";
            containsStr = splitQueryByAnd;
          } else if (splitQueryByOr.length > 1) {
            operator = "_OR";
            containsStr = splitQueryByOr;
          }

          if (containsStr instanceof Array) {
            containsStr = containsStr.join(' ');
          }

          if (operator || displayType == 'richtexteditor') {
            this.currentTag.value = {
              "contains": containsStr,
              "type": dataType,
              "operator": operator
            };          
          } else {
            // exact search
            this.currentTag.value = {
              "exact": this.tav,
              "type": dataType
            };
          }

          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        }

        //Close the popover once value updated
        if (this.currentTag.options.displayType.toLowerCase() == "datetime") {
          this.shadowRoot.querySelector('#rangepicker').hide();
        } else {
          this.shadowRoot.querySelector('#filterPopover').hide();
        }

        //Fire event
        this._fireChangeEvent(this.currentTag.name, this.currentTag.value);
      },

      _fireChangeEvent: function (_name, _value, _type) {
        var attribute = {
          name: _name,
          value: _value,
          type: _type
        };
        if (_name) {
          this.fireBedrockEvent('tag-value-change', attribute, {
            ignoreId: true
          });
        }
      },

      _fireAddEvent: function (_name, _value, _type) {
        var attribute = {
          name: _name
        };
        if (_name) {
          this.fireBedrockEvent('tag-item-added', attribute, {
            ignoreId: true
          });
        }
      },

      // When tag tapped, which popover component need to show
      _showTagModifier: function (displayType) {
        if (this.currentTag && this.currentTag.options.displayType.toLowerCase() == displayType.toLowerCase()) {
          return true;
        }

        return false;
      },

      //Hide the popover
      _dismissDialog: function () {
        this.shadowRoot.querySelector('#filterPopover').hide();
      },
      _openFilterLov: function () {
        this.shadowRoot.querySelector("#refineFilterPopover").open();
      },
      _openEntityTypeFilterLov: function () {
        this.shadowRoot.querySelector("#entityTypeFilterPopover").open();
      }
    });
  </script>
</dom-module>