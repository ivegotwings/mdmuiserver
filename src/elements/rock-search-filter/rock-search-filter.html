<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/paper-radio-group/paper-radio-group.html">
<link rel="import" href="../../../bower_components/paper-menu-button/paper-menu-button.html">
<link rel="import" href="../../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-app-context-behavior/bedrock-app-context-behavior.html">
<link rel="import" href="../bedrock-helpers/constant-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-gridsystem.html">

<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-tags/pebble-tags.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textbox-collection/pebble-textbox-collection.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-datetime-picker/pebble-datetime-picker-overlay.html">

<link rel="import" href="../rock-entity-lov/rock-entity-lov.html">
<link rel="import" href="../rock-search-bar/rock-search-bar.html">
<link rel="import" href="../rock-attribute-model-lov/rock-attribute-model-lov.html">
<!--
`rock-search-filter` Represents an element that contains the "search bar" and filter tags. 
The users can switch between a search mode and a filter mode to get the query they want to search.

@demo demo/index.html
-->

<dom-module id="rock-search-filter">

  <template>
    <style include="bedrock-style-common bedrock-style-gridsystem"></style>
    <style>
      :host {
        --item-length-overflow: {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
      }

      .container {
        @apply --layout-horizontal;
        @apply --layout-center;
        display: inline-flex;
        display: -webkit-inline-flex;
        width: 100%;
      }

      pebble-tags {
        --tag-color: var(--top-header-background);
        --actions-icon-button: {
          height: var(--tag-icon-size);
          width: var(--tag-icon-size);
          padding-top: 0px;
          padding-right: 0px;
          padding-bottom: 0px;
          padding-left: 0px;
        };
      }

      .tagContainer{
        width: calc(100% - 290px);
      }

      paper-menu-button {
        padding: 0;
      }

      paper-menu.dropdown-content {
        padding: 0;
      }

      paper-menu-button paper-menu paper-item {
        --pebble-button-paper-menu-item:{
        color: var(--palette-dark, #1a2028);
        };
      }
      paper-menu-button paper-menu paper-item:hover {
        background-color: var(--bgColor-hover, #e8f4f9);
        color: var(--focused-line, #026bc3) !important;
      }

      paper-menu-button paper-menu paper-item:focus:before,
      paper-menu-button paper-menu paper-item:focus:after {
        background-color: var(--bgColor-hover, #e8f4f9);
      }

      paper-menu-button paper-menu paper-item:focus {
        background-color: var(--bgColor-hover, #e8f4f9);
        color: var(--focused-line, #026bc3) !important;
      }

      #filterPopover {
        min-width: 240px;
      }

      pebble-textbox {
        --paper-input-container: {
          padding-top: 0px;
          padding-right: 20px;
          padding-bottom: 0px;
          padding-left: 20px;
        }
      }

      #filterPopover paper-item {
        --paper-item: {
          font-size: 12px;
        }
        --paper-item-min-height: 30px;
      }

      #filterPopover paper-menu {
        --paper-menu-selected-item: {
          font-size: 12px;
        }
      }

      pebble-boolean {
        --pebble-boolean: {
          height: 30px;
          line-height: 30px;
          padding-right: 5px;
          padding-left: 5px;
          width: 100px;
          font-size: var(--default-font-size, 14px) !important;
        };
      }

      pebble-textarea {
        --textarea-container: {
          padding-top: 0px !important;
          padding-right: 20px !important;
          padding-bottom: 0px !important;
          padding-left: 20px !important;
        };

        --autogrowtextarea:{
          max-height: 200px;
        };
      }

      pebble-textarea .floated-label-placeholder {
        line-height: 0;
      }

      pebble-popover {
        --pebble-popover-max-width: 100%;
        --pebble-popover-width: 260px;
      }

      pebble-popover .dialogOptions paper-radio-button {
        @apply --popup-item;
      }

      pebble-popover .dialogOptions paper-radio-button input {
        width: 100px;
        font-size: 15px;
        padding: 0 4px;
        line-height: 30px;
      }

      pebble-popover rock-entity-lov {
        --pebble-lov: {
          padding-top: 0px;
          padding-right: 0px;
          padding-bottom: 0px;
          padding-left: 0px;
        }
      }

      paper-input {
        width: 90%;
      }

      .dialogOptions paper-radio-button {
        display: block;
      }
      paper-radio-group {
        width: 100%;
      }
      paper-radio-group paper-radio-button{
        padding-top: 0;
        padding-bottom: 0; 
        --paper-radio-button-unchecked-color: var(--radio-button-border, #026bc3);
        --paper-radio-button-checked-color: var(--radio-button-selected, #026bc3);
      }
      .input-content::slotted(input), .input-content::slotted(textarea), .input-content::slotted(iron-autogrow-textarea),
      .input-content::slotted(.paper-input-input) {
        font-size: var(--default-font-size, 14px);
      }

      pebble-textbox-collection {
        --tags-container: {
          min-height: 0px;
          margin-right: 0;
          padding-left: 10px;
          padding-right: 10px;
        };
        --text-collection-container: {
          min-height: 0px;
          margin-top: 0px;
        };
      }

      #filter-entity-type-tag{
        --tag-name: {
          max-width : 250px;
        }
      }

      #textNumericCollection {
        --text-collection-manage-tag-container: {
          width: 180px;
        }
      }
      pebble-toggle-button {
          --pebble-toggle-button-checked-bar-color: var(--success-color, #4caf50);
          --pebble-toggle-button-checked-button-color: var(--success-color, #4caf50);
          --pebble-toggle-button-checked-ink-color: var(--success-color, #4caf50);
      }
    </style>

    <template is="dom-if" if="{{searchMode}}">
      <div class="container">
        <rock-search-bar id="searchSection" style="width:90%" search-input="{{tags}}"></rock-search-bar>
        <pebble-button icon="filter-list" class="button" on-tap="toggleMode" raised></pebble-button>
      </div>
    </template>
    <template is="dom-if" if="{{!searchMode}}">
      <div class="row layout-top">
        <template is="dom-if" if="{{!hideSearchTrigger}}">
          <pebble-button icon="search" class="button" on-tap="toggleMode" raised></pebble-button>
        </template>
        <pebble-button id="filterButton" icon="{{icon}}" button-text="{{text}}" dropdown-icon noink class="dropdownText dropdownIcon btn dropdown-primary dropdown-trigger"
          on-tap="_openFilterLov"></pebble-button>
        <pebble-popover id="refineFilterPopover" for="filterButton" no-overlap vertical-align="auto" horizontal-align="auto">
          <rock-attribute-model-lov id="attributeModelLov" mode="[[attributesType]]" context-data="[[contextData]]" no-sub-title id-field="name" title-pattern="externalName"
            type-field="[]" sort-details="[[filtersConfig]]" items="{{_filterAttributes}}" show-nested-child-attributes=[[_showNestedChildAttributes]] show-nested-attributes=[[_showNestedAttributes]]></rock-attribute-model-lov>
        </pebble-popover>

        <bedrock-pubsub event-name="attribute-model-lov-selection-changed" handler="_onSelectedFilterChange" target-id="attributeModelLov"></bedrock-pubsub>
        <div class="tagContainer">
          <!--pebble-tags id="filter-entity-type-tag" tags="{{entityTypeTag}}" class="p-l-10 p-r-10">
          </pebble-tags-->
          <pebble-tags id="filter-tags" tags="{{tags}}" show-expand-icon show-remove-icon class="p-l-10 p-r-10">
          </pebble-tags>
        </div>
        <bedrock-pubsub event-name="on-tap-tag-item" handler="_onTagItemTap"></bedrock-pubsub>
        <bedrock-pubsub event-name="on-attached-tag-item" handler="_onTagItemTap"></bedrock-pubsub>
        <bedrock-pubsub event-name="tag-item-remove" handler="_onTagItemRemove"></bedrock-pubsub>
        <bedrock-pubsub event-name="entity-lov-confirm-button-tap" handler="_onLOVConfirmTap" target-id="rockEntityLov"></bedrock-pubsub>
        <bedrock-pubsub event-name="entity-lov-close-button-tap" handler="_onLOVCloseTap" target-id="rockEntityLov"></bedrock-pubsub>
        <!-- Refine popover starts here -->
         <pebble-popover id="filterPopover" for="pebble-tag" no-overlap vertical-align="auto" horizontal-align="auto">
            <template is="dom-if" if="{{_isAttributeValuesExistsSearchEnabled}}">
                <pebble-toggle-button class="m-l-20 m-b-10" checked={{currentTag.options.hasValueChecked}}>[[_toggleButtonText]]</pebble-toggle-button>
              </template>
          <template is="dom-if" if="{{_showTagModifier('textbox', _trigger)}}">
            <pebble-textbox-collection id="textCollection" values="{{_tagsCollection}}" no-popover textbox-label="Enter values to search" show-seperator seperator="or" text-collection-input="{{_tagInput}}" disabled=[[!currentTag.options.hasValueChecked]]></pebble-textbox-collection>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_onTextCollectionUpdate" disabled="{{_disableCollectionUpdate(_tagsCollection, _tagInput)}}"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('textArea', _trigger)}}">
            <pebble-textarea class="input" label="Enter text here" value="{{tav}}" disabled=[[!currentTag.options.hasValueChecked]]></pebble-textarea>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue" disabled="{{_disableTextAreaUpdate(tav)}}"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
           <template is="dom-if" if="{{_showTagModifier('richtexteditor', _trigger)}}">
            <pebble-textarea class="input" label="Enter text here" value="{{tav}}" disabled=[[!currentTag.options.hasValueChecked]]></pebble-textarea>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue"></pebble-button>
              <div class="clearfix"></div>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('referenceList', _trigger)}}">
            <rock-entity-lov id="rockEntityLov" 
                  multi-select 
                  show-action-buttons 
                  apply-locale-coalesced-style
                  apply-context-coalesced-style
                  selected-items="{{_selectedItems}}" disable-selection="[[!currentTag.options.hasValueChecked]]">
            </rock-entity-lov>
          </template>
          <template is="dom-if" if="{{_showTagModifier('boolean', _trigger)}}">
            <pebble-boolean class="text-center" id="booleanDisplay" true-text="[[currentTag.options.trueText]]" false-text="[[currentTag.options.falseText]]" value="{{booleanvalue}}" disabled="[[!currentTag.options.hasValueChecked]]"></pebble-boolean>
            <div class="PebbleButtonPadding text-center m-t-15">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue"></pebble-button>
            </div>
          </template>
          <template is="dom-if" if="{{_showTagModifier('numeric', _trigger)}}">
            <paper-radio-group aria-labelledby="{{longName}}" class="dialogOptions" on-paper-radio-group-changed="_onRadioGroupChange">
              <paper-radio-button name="range" disabled={{!currentTag.options.hasValueChecked}}>
                <div class="colspan-2 pull-left">
                  <pebble-textbox label="Min" prevent-invalid-input allowed-pattern="[0-9.]" invalid="{{numericMinInvalid}}" show-error input-data-type="[[currentTag.options.dataType]]"
                    value="{{gte}}">
                  </pebble-textbox>
                </div>
                <div class="colspan-2 pull-left">
                  <pebble-textbox label="Max" prevent-invalid-input allowed-pattern="[0-9.]" invalid="{{numericMaxInvalid}}" show-error input-data-type="[[currentTag.options.dataType]]"
                    value="{{lte}}">
                  </pebble-textbox>
                </div>
                <div class="clearfix"></div>
              </paper-radio-button>
              <paper-radio-button name="equalToData" disabled={{!currentTag.options.hasValueChecked}}>
                <div class="col-90 pull-left">
                  <pebble-textbox-collection id="textNumericCollection" values="{{_tagsNumericCollection}}" no-popover textbox-label="Enter values to search" show-seperator seperator="or" allowed-pattern="[0-9.]" text-collection-input="{{_tagNumericInput}}" disabled=[[!currentTag.options.hasValueChecked]]></pebble-textbox-collection>
                </div>
                <div class="clearfix"></div>
              </paper-radio-button>
            </paper-radio-group>
            <!-- </template> -->
            <div class="PebbleButtonPadding text-center">
              <pebble-button class="btn btn-secondary m-r-5" on-tap="_dismissDialog" raised elevation="1" button-text="Close"></pebble-button>
              <pebble-button class="btn btn-success" button-text="Apply" raised elevation="1" on-tap="_updateValue" disabled="{{_updateDisable}}"></pebble-button>
            </div>
          </template>
        </pebble-popover>
        <!-- Already overlay, so out of popover -->
          <pebble-datetime-picker-overlay id="rangepicker" for="pebble-tag" picker-type="daterange" heading-format="ddd, MMM DD YYYY"
          start-date-text="{{displaygte}}" end-date-text="{{displaylte}}" start-date-value="{{gte}}" end-date-value="{{lte}}"
          on-date-range-selected="_updateValue" has-value-checked="{{currentTag.options.hasValueChecked}}" attribute-values-exists-search-enabled=[[_isAttributeValuesExistsSearchEnabled]] show-ranges>
        </pebble-datetime-picker-overlay>
        <!-- Refine popover ends here -->
      </div>
    </template>
  </template>
  <script>
    Polymer({

      is: 'rock-search-filter',

      properties: {
        /**
         * Indicates the list of string type that holds the tags. 
         * Note that values in this array must be identical and duplicates must be avoided due to the definition of the tags.
         */
        tags: {
          type: Array,
          notify: true,
          value: function () {
            return []
          }
        },

        entityTypeTag: {
          type: Array,          
          value: function () {
            return []
          }
        },
        /**
         * Indicates the configuration that is used in filters.
         */
        filtersConfig: {
          type: Object,
          value: function () {
            return {};
          }
        },

        /**
         * Specifies whether or not an element is in the search or filter mode.
         */
        searchMode: {
          type: Boolean,
          value: false,
          notify: true
        },
        /**
         * Specifies whether or not the "search bar" triggered button is visible when the search mode is disabled.
         */
        hideSearchTrigger: {
          type: Boolean,
          value: false
        },
        /**
         * Specifies the text for the search filter button.
         */
        text: {
          type: String,
          value: "Refine"
        },
        /**
         * Specifies the icon for the search filter button.
         */
        icon: {
          type: String,
          value: "pebble-icon:filter"
        },
        /**
         *  Indicates the reference to the currently opened tag.
         */
        currentTag: {
          type: Object,
          notify: true
        },

        _trigger: {
          type: String
        },

        _selectedItems: {
          type: Array,
          value: function () {
            return [];
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        colors: {
          type: Array,
          value: ['red', 'green', 'blue']
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        contextData: {
          type: Object,
          value: function () {
            return {};
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        gte: {
          type: String,
          value: function () {
            return "";
          },
          observer: '_isMaxGreaterThanMin'
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        lte: {
          type: String,
          value: function () {
            return "";
          },
          observer: '_isMaxGreaterThanMin'
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        equalNum: {
          type: String,
          value: function () {
            return "";
          }
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericMinInvalid: {
          type: Boolean,
          value: false
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericMaxInvalid: {
          type: Boolean,
          value: false
        },
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        numericEqualInvalid: {
          type: Boolean,
          value: false
        },

        _updateDisable: {
          type: Boolean,
          computed: '_disableUpdate(numericMinInvalid, numericMaxInvalid, _tagsNumericCollection, _tagNumericInput, gte, lte, _isAttributeValuesExistsSearchEnabled)'
        },

        _tagsCollection: {
          type: Array,
          value: function() {
            return [];
          }
        },

        _tagsNumericCollection: {
          type: Array,
          value: function() {
            return [];
          }
        },

        _filterAttributes: {
          type: Array,
          value: function() {
            return [];
          },
          observer: '_onFilterAttributesChange'
        },
        attributesType: {
            type: String,
            value: "self"
        },
        settings: {
          type: Object,
          value: function () {
            return {};
          }
        },
        _showNestedChildAttributes:{
          type: Boolean,
          value: false,
          computed: '_getItemVisibility(settings,"showNestedChildAttributes")'
        },
        _showNestedAttributes:{
          type: Boolean,
          value: true,
          computed: '_getItemVisibility(settings,"showNestedAttributes")'
        },
        _isAttributeValuesExistsSearchEnabled:{
          type: Boolean,
          value: false,
          computed: '_getItemVisibility(settings,"attributeValuesExistsSearchEnabled")'
        },
        _tagNumericInput:{
          type: String,
          value: function () {
            return "";
        }
        },
        _toggleButtonText:{
          type: String,
          value: "Has Value"
        },
        _defaultRadioButtonColor:{
          type: String,
          value:"#026bc3"
        }
      },
      behaviors: [
        RUFBehaviors.UIBehavior,
        RUFBehaviors.AppContextBehavior
      ],      
      observers: [
          "_onToggleButtonChange(currentTag.options.hasValueChecked)"
      ],  
      /**
       * <b><i>Content development is under progress... </b></i> 
       */
      attached: function(){
        var _computedStyle = getComputedStyle(this);
        if(_computedStyle){
          var _propertyValue = _computedStyle.getPropertyValue('--focused-line')
          if(_propertyValue){
            this._defaultRadioButtonColor = _propertyValue;
          }
        }
      },
      removeAllSearchFilters: function () {
        const filterTags = this.shadowRoot.querySelector("#filter-tags");
        if (filterTags) {
          filterTags.removeAllTags();
        }
      },

      /**
       * validate the input for numeric display type and disables the update button
       */
      _disableUpdate: function (numericMinInvalid, numericMaxInvalid, _tagsNumericCollection, _tagNumericInput, gte, lte,_isAttributeValuesExistsSearchEnabled) {
        if(_isAttributeValuesExistsSearchEnabled){
            return false;
        }
        if (!_.isEmpty(this.gte + "") || !_.isEmpty(this.lte + "") || !_.isEmpty(_tagsNumericCollection) || _tagNumericInput) {
          const radioGroup = this.shadowRoot.querySelector('paper-radio-group');
          if ( radioGroup && radioGroup.selected == "range") {
            return (numericMaxInvalid || numericMinInvalid);
          }

          return _.isEmpty(_tagsNumericCollection) && !_tagNumericInput;
        }

        return true;
      },

      _disableCollectionUpdate: function(_tagsCollection, input) {
        if(this._isAttributeValuesExistsSearchEnabled){
          return false;
        }
        return !input && (!_tagsCollection || _tagsCollection.length == 0);
      },

      _disableTextAreaUpdate: function(tav) {
        if(this._isAttributeValuesExistsSearchEnabled){
          return false;
        }
        return !tav || !tav.trim();
      },
      
      /**
       * checks if the min value is less than maximum value in numeric display type popover
       */
      _isMaxGreaterThanMin: function () {
        if (!_.isEmpty(this.gte + "") && !_.isEmpty(this.lte + "")) {
          if (parseFloat(this.gte) > parseFloat(this.lte)) {
            this.set('numericMaxInvalid', true);
            return;
          }
        }

        this.set('numericMaxInvalid', false);
      },

      /**
       * Updating the entity tags when the user updates the entity selection
       *
      onEntityTypeChange: function (selectedEntities) {            
          var entityTypeTagStr = this._getEntityTypeDisplayValue(selectedEntities);           
          var entityTypeTagObj =  this.shadowRoot.querySelector("#filter-entity-type-tag");
          if(entityTypeTagStr) {
            if(this.entityTypeTag.length > 0){
              entityTypeTagObj.set('tags.0.longName', entityTypeTagStr); 
            } else {
              this.addEntityTypeTag(selectedEntities);
            }
          } else {
            this.entityTypeTag = [];
          }
                   
      },

      /**
       * Displaying the selected entity types as tags
       *
      addEntityTypeTag: function (selectedEntities) {  
          if(selectedEntities.length > 0) {             
            this.entityTypeTag = [];
            var entityTypeTagStr = this._getEntityTypeDisplayValue(selectedEntities); 
            this.entityTypeTag["longName"] = entityTypeTagStr;
            this.shadowRoot.querySelector("#filter-entity-type-tag").addTag(this.entityTypeTag); 
          }                                
      },
       
      /**
       *  Formating the selected entity tag
       *  
      _getEntityTypeDisplayValue: function (entityTypeList) {
        var tempArray = [];
        //Capitalizing the first character of the list
        if(entityTypeList.length > 0) {
          for(var i = 0 ; i < entityTypeList.length ; i++){
            tempArray[i] = entityTypeList[i].charAt(0).toUpperCase()+ entityTypeList[i].substr(1);
          } 
          return "Entity Types: " + tempArray.join(",");
        }

      }*/

      /**
       * Can be used add a filter tag on selecting it from the dropdown.
       */
      _onSelectedFilterChange: function (e, detail) {
        //Reseting the selected values of the attribute
        this._selectedItems = [];
        var data = detail.data;
        var tag = {};
        if (data && data.displayType && data.displayType.toLowerCase() == "referencelist") {
          data.selectedItems = this._selectedItems; //reset 
        }
        if(data.displayType == "boolean" && !this._isAttributeValuesExistsSearchEnabled) {
          tag["value"] = (data.value && !_.isEmpty(data.value)) ? data.value : {
          "eq": data.trueText
        };
        } else {
          tag["value"] = (data.value && !_.isEmpty(data.value)) ? data.value : {
          "eq": "All"
        };
        }
        tag["displayParams"] = (data.displayParams && !_.isEmpty(data.displayParams)) ? data.displayParams : [
          "eq"
        ];
        var dataType = data.dataType;
        var displayType = data.displayType;

        if (displayType == "textCollection" || displayType == "image") {
          displayType = "textbox";
        }

        // For now, we are not showing LOV for textbox attributes,
        // as system does not know how to return distinct / unique values for given attribute in given search scope.
        // We fix would show textbox only to type freeflow data till we fix the api / get new api
        // if(displayType.toLowerCase() == "textbox") {
        //   displayType = "referenceList";
        // }

        if (displayType == "date") {
          displayType = "datetime";
        }

        if (dataType.toLowerCase() == "integer" || dataType.toLowerCase() == "decimal") {
          displayType = "numeric";
        }

        tag.value["type"] = ConstantHelper.getDataTypeConstant(dataType);

        tag.options = data;
        tag.options.displayType = displayType;
        tag["longName"] = data.externalName;
        tag["name"] = data.name;
        tag.options.hasValueChecked = true;
        this.shadowRoot.querySelector("#filter-tags").addTag(tag);
        this._fireAddEvent(data.name);
        this.shadowRoot.querySelector("#refineFilterPopover").close();
      },
      /**
       *  Can be used to toggle between the search and filter mode.
       */
      toggleMode: function (e) {
        this.searchMode = !this.searchMode;
      },

      _prepareRequestData: function (contextData) {
        return DataRequestHelper.createEntityGetRequest(contextData, true, true);
      },

      // On tag tap should select the specific element 
      _onTagItemTap: function (e, detail) {
        //To avoid textcollection tag item tap
        if(!detail || !detail.options) {
          return;
        }
        this.currentTag = detail;
        var showTagPopover = true;

        if (detail && detail.options && detail.options.noPopoverOnAttach) {
          if (e.type.indexOf("on-tap-tag-item") == -1) {
            showTagPopover = false; //set only on attach
          }
          delete detail.options.noPopoverOnAttach; //delete, as it is only on attach
        }

        if (!this.currentTag || !this.currentTag.options) return;

        if(DataHelper.isValidObjectPath(this.currentTag, "value.hasvalue")) {
          this.currentTag.options.hasValueChecked = this.currentTag.value.hasvalue ? true : false;
        } 
        const positionTarget = this.shadowRoot.querySelector('#filter-tags').shadowRoot.querySelector("#tag" + detail.index);
        if (this.currentTag && this.currentTag.options.displayType.toLowerCase() == "datetime") {
          var rangePicker = this.shadowRoot.querySelector('#rangepicker');

          //Display range picker based on the currerntTag
          if (this.currentTag.value.eq != 'All') {
            if (this.currentTag.value.eq) {
              rangePicker.startDateValue = this.currentTag.value.eq;
              rangePicker.endDateValue = this.currentTag.value.eq;
            } else {
              rangePicker.startDateValue = this.currentTag.value.gte;
              rangePicker.endDateValue = this.currentTag.value.lte;
            }

            var _date = new Date(rangePicker.startDateValue);
            rangePicker.setDate(_date);
          } else {
            rangePicker.startDateValue = "";
            rangePicker.endDateValue = "";
            rangePicker.setDate(new Date());
          }

          rangePicker.setRangeType(null);

          Polymer.Async.microTask.run(() => {
            rangePicker.positionTarget = positionTarget;
            rangePicker.noOverlap = true;
            if (showTagPopover) {
              rangePicker.show(true);
            }
          });
        } else {
          this._trigger = Date.parse(new Date().toString()); //Just used to trigger popover element

          //Delayed to open the popover, because want to close the existing popover
          Polymer.Async.microTask.run(() => {
            var filterPopover = this.shadowRoot.querySelector('#filterPopover');

            filterPopover.positionTarget = positionTarget;
            if (showTagPopover) {
              filterPopover.show(true);
            }

            //Set values to the components
            var tagDisplayType = this.currentTag.options.displayType.toLowerCase();
             // textbox is a collection in filters
             if (tagDisplayType == "textbox") {
              var filterInput = filterPopover.querySelector('#textCollection');
              this._clearCollectionInput(filterPopover, '#textCollection', '#txtInputTag');
              
              if (!filterInput) {
                return;
              }
              
              filterInput.values = [];
              filterInput.textCollectionInput = "";
              if (this.currentTag.value.exacts && this.currentTag.value.exacts != 'All') {
                filterInput.values =  DataHelper.cloneObject(this.currentTag.value.exacts);
              }

              setTimeout(() => {
                var collectionInput = filterInput.shadowRoot.querySelector("#txtInputTag");
                if(collectionInput) {
                  collectionInput.focus();
                }
              }, 10); //Delayed to set the value and focus the input
            } else if (tagDisplayType == "richtexteditor" || tagDisplayType == "textarea") {
              var filterInput = filterPopover.querySelector('.input');
              if (filterInput) {

                filterInput.value = '';

                if (this.currentTag.value.exact && this.currentTag.value.exact != 'All') {
                  filterInput.value = this.currentTag.value.exact;
                }

                setTimeout(() => {
                  filterInput.focus();
                }, 10); //Delayed to set the value and focus the input
              }
            } else if (tagDisplayType == "numeric") {
              this.gte = this.lte = "";
              this._tagsNumericCollection = [];
              this._tagNumericInput = "";
              this._clearCollectionInput(filterPopover, '#textNumericCollection', '#txtInputTag');              

              if (this.currentTag.value.contains && this.currentTag.value.contains.length > 0 && this.currentTag.value.contains != 'All') {
                filterPopover.querySelector('paper-radio-group').selected = 'equalToData';
                this._tagsNumericCollection = this.currentTag.value.contains.split(" ");
              } else {
                if(filterPopover.querySelector('paper-radio-group')){
                  filterPopover.querySelector('paper-radio-group').selected = 'range';
                }
                this.gte = this.currentTag.value.gte || "";
                this.lte = this.currentTag.value.lte || "";
                
              }
            } else if (tagDisplayType == "referencelist") {
              //Set Id, Title and Value to the LOV
              var lovComponent = filterPopover.querySelector('#rockEntityLov');

              if (this.currentTag.options.isReferenceType) {
                  var titlePattern;
                  var subTitlePattern;
                  var valueField;
                  var options = this.currentTag.options;

                  if (options.properties && options.properties.referenceEntityInfo && options.properties.referenceEntityInfo.length) {
                    titlePattern = options.properties.referenceEntityInfo[0].listTitle;
                    valueField = options.properties.referenceEntityInfo[0].listValueAttribute;
                    subTitlePattern = options.properties.referenceEntityInfo[0].listSubTitle;
                  }

                  lovComponent.idField = "id";
                  lovComponent.titlePattern = titlePattern ? titlePattern : "name";
                  lovComponent.subTitlePattern = subTitlePattern ? subTitlePattern : "";
                  lovComponent.valueField = valueField ? valueField : "name";
                  lovComponent.selectedItems = this.currentTag.options.selectedItems;
                  var refEntityTypes = this.currentTag.options.referenceEntityTypes;
                  var itemContexts = [];
                  for (var i in refEntityTypes) {
                    itemContexts.push({
                      "type": refEntityTypes[i]
                    });
                  }
                  var contextData = DataHelper.cloneObject(this.contextData);
                  contextData[this.CONTEXT_TYPE_ITEM] = itemContexts;
                  lovComponent.requestData = this._prepareRequestData(contextData);
                  lovComponent.requestData.params.additionalIds = this.currentTag.options.selectedIds;
                } else {
                  lovComponent.idField = this.currentTag.name;
                  lovComponent.titlePattern = this.currentTag.name;
                  lovComponent.valueField = this.currentTag.name;
                  lovComponent.requestData = this._prepareRequestData(this.contextData);
                  lovComponent.requestData.params.fields.attributes = [this.currentTag.name];
                }
                lovComponent.reset();
             } else if (tagDisplayType == "boolean") {
              var filterInput = filterPopover.querySelector('#booleanDisplay');
              if (filterInput) {
                filterInput.value = this.currentTag.value.eq;
              }
            }
          });
        }
      },

      // Refine filter radio buttons
      _onRadioGroupChange: function () {
        this.gte = this.lte = "";
        this._tagsNumericCollection = [];
        this._tagNumericInput = "";

        var filterPopover = this.shadowRoot.querySelector('#filterPopover');
        if(filterPopover) {
          this._clearCollectionInput(filterPopover, '#textNumericCollection', '#txtInputTag');
        }
      },

      _clearCollectionInput: function(filterPopover, collection, input) {
        var filterNumericCollection = filterPopover.querySelector(collection);
        if(filterNumericCollection) {
          var collectionInput = filterNumericCollection.shadowRoot.querySelector(input);
          if(collectionInput) {
            collectionInput.value = "";
          }
        }
      },

      _onLOVConfirmTap: function (e, detail) {
        var selectedItemString = "";
        var selectedItemSearchString = "";
        var selectedIds = [];
        var selectedItemsObj = this._selectedItems;
        if(this._isAttributeValuesExistsSearchEnabled && !this.currentTag.options.hasValueChecked){
            this.getUpdatedValue();
        }else{
          if (selectedItemsObj.length) {
            for (let i = 0; i < selectedItemsObj.length; i++) {
              if (selectedItemsObj[i].value) {
                selectedItemString = selectedItemString + selectedItemsObj[i].value + " ";
                selectedItemSearchString = selectedItemSearchString + selectedItemsObj[i].value + ", ";
              }
              if (selectedItemsObj[i].id) {
                selectedIds.push(selectedItemsObj[i].id);
              }
            }
            selectedItemString = selectedItemString.trim();
            selectedItemSearchString = selectedItemSearchString.substr(0, selectedItemSearchString.length - 2);
          }
          if (detail && detail.data) {
            this.currentTag.value = {
              "exacts": selectedItemSearchString.split(", ")
            }

            this.currentTag.options["selectedItem"] = detail.data;
            this.currentTag.options["selectedItems"] = selectedItemsObj;
            this.currentTag.options["selectedIds"] = selectedIds;
            this.currentTag.displayValue = detail.data.value;
            var isValueUpdated = false;
            if(this._isAttributeValuesExistsSearchEnabled){
              isValueUpdated = this.getUpdatedValue(this.currentTag.value);
            }
            if(!isValueUpdated){
              this.set('tags.' + this.currentTag.index + '.displayValue', this.formatFilterCollectionDisplay(selectedItemSearchString.split(", ")));
              this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
            }
          }
        }

        this.shadowRoot.querySelector('#filterPopover').hide();
        //Fire event
        this._fireChangeEvent();

      },

      _onTextCollectionUpdate: function(e, detail) {
        if(!this._tagsCollection || this._tagsCollection.length == 0 && this._tagInput) {
          this._tagsCollection.push(this._tagInput);
          this._tagInput = "";
        }
        if(this._isAttributeValuesExistsSearchEnabled && !this.currentTag.options.hasValueChecked){
            this.getUpdatedValue();
        }else {
          this.currentTag.value = {
              "exacts": this._tagsCollection
          }
          var isValueUpdated = false;
          if(this._isAttributeValuesExistsSearchEnabled){
            isValueUpdated = this.getUpdatedValue(this.currentTag.value);
          }
        
          if(!isValueUpdated){
            this.set('tags.' + this.currentTag.index + '.displayValue', this.formatFilterCollectionDisplay(this._tagsCollection));
            this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
          }
        }
        
        this.shadowRoot.querySelector('#filterPopover').hide();
        //Fire event
        this._fireChangeEvent();
      },

      getUpdatedValue: function(currentValue){
        var isValueAvailable = false;
        if(this.currentTag.options.hasValueChecked && typeof currentValue === 'object'){
          for(var key in currentValue){
            if(key != "type" && key != "operator"){
              if(currentValue[key] != "" && currentValue[key] != undefined && currentValue[key] != "NaN" && currentValue[key] !=  "Invalid date"){
                isValueAvailable = true;
              }
            }
          }
        }
        if(!isValueAvailable){
          var updatedValue = "!%&has value!%&";
          if(!this.currentTag.options.hasValueChecked){
            updatedValue = "!%&has no value!%&";
          }
          this.currentTag.value = {
            "exacts": [updatedValue]
          }
          this.set('tags.' + this.currentTag.index + '.displayValue', updatedValue);
          this.set('tags.' + this.currentTag.index + '.value', updatedValue);
          if(this.currentTag.options.displayType.toLowerCase() == "boolean"){
            this.set('tags.' + this.currentTag.index + '.booleanSearchValue', updatedValue);
          }
          this.displaygte = "";
          this.displaylte = "";
          return true;
        }
        return false;
      },

      formatFilterCollectionDisplay: function(collection, seperator) {
        seperator = seperator || 'or';
        collection = collection.map(function(el) { 
          return "'" + el + "'"; 
        });
        return collection.join(' '+ seperator +' ');
      },

      // Closing the filter popover 
      _onLOVCloseTap: function (e, detail) {
        this.shadowRoot.querySelector("#filterPopover").hide();
      },

      // Refine filter tags will be updated as per selection
      _updateValue: function (e) {
        var dataType = ConstantHelper.getDataTypeConstant(this.currentTag.options.dataType);
        var isValueUpdated = false;
        if(this._isAttributeValuesExistsSearchEnabled && !this.currentTag.options.hasValueChecked){
            this.getUpdatedValue()
        }else if (this.currentTag.options.displayType.toLowerCase() == "datetime") { //DateTime
          // Note:- For datetime attribute it is necessary to pass dataType as 'datetime' because from UI the 
          //        system is currently passing datetime value instead of date value in range search
          this.currentTag.value = {
            "gte": this.gte,
            "lte": this.lte,
            "type": ConstantHelper.getDataTypeConstant("datetime")
          };

          if (this.gte == this.lte) {
            this.currentTag.displayValue = this.displaygte;
          } else {
            //console.log('range ', JSON.stringify(this.currentTag.value));

            if (this.displaygte == this.displaylte) {
              this.currentTag.displayValue = this.displaygte;
            } else {
              this.currentTag.displayValue = this.displaygte + " - " + this.displaylte;
            }
          }
          
          if(this._isAttributeValuesExistsSearchEnabled){
            isValueUpdated = this.getUpdatedValue(this.currentTag.value);
          }

          if(!isValueUpdated){
          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
          }
        } else if (this.currentTag.options.displayType.toLowerCase() == "numeric") { //Radio group
          if (this.shadowRoot.querySelector('paper-radio-group').selected == "range") {


            if (this.gte == "") {
              this.gte = undefined;
            }
            if (this.lte == "") {
              this.lte = undefined;
            }
            if (!(this.gte || this.lte) && !this._isAttributeValuesExistsSearchEnabled) {
              this.logWarning("FilterValuesEmpty");
              return;
            } else {
              var gteAsString = (parseFloat(this.gte)).toString();
              var lteAsString = (parseFloat(this.lte)).toString();
              if (!this.gte) {
                this.currentTag.value = {
                  "gte": this.gte,
                  "lte": lteAsString,
                  "type": dataType
                };
                this.currentTag.displayValue = "<= " + lteAsString;
              } else if (!this.lte) {
                this.currentTag.value = {
                  "gte": gteAsString,
                  "lte": this.lte,
                  "type": dataType
                };
                this.currentTag.displayValue = ">= " + gteAsString;
              } else {
                this.currentTag.value = {
                  "gte": gteAsString,
                  "lte": lteAsString,
                  "type": dataType
                };
                this.currentTag.displayValue = gteAsString + " - " + lteAsString;
              }
            }
            if(this._isAttributeValuesExistsSearchEnabled){
              isValueUpdated = this.getUpdatedValue(this.currentTag.value);
            }

            if(!isValueUpdated){
            this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
            this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
            }
          } else {
            if(_.isEmpty(this._tagsNumericCollection) && this._tagNumericInput) {
              this._tagsNumericCollection.push(this._tagNumericInput);
              this._tagNumericInput = ""; //Reset
            }

            if(_.isEmpty(this._tagsNumericCollection) && !this._isAttributeValuesExistsSearchEnabled) {
              this.logWarning("FilterValuesEmpty");
              return;
            } else {
              this.currentTag.value = {
                "contains": this._tagsNumericCollection.join(" "),
                "type": dataType,
                "operator": "_OR"
              };
            }
            if(this._isAttributeValuesExistsSearchEnabled){
              isValueUpdated = this.getUpdatedValue(this.currentTag.value);
            }

            if(!isValueUpdated){
            this.set('tags.' + this.currentTag.index + '.displayValue', this.formatFilterCollectionDisplay(this._tagsNumericCollection));
            this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
          }
          }
        } else if (this.currentTag.options.displayType.toLowerCase() == "boolean") { //boolean
          if(this.booleanvalue == "All" && this._isAttributeValuesExistsSearchEnabled){
            this.booleanvalue = "";
          }
          this.currentTag.value = {
            "eq": this.booleanvalue,
            "type": dataType
          };
          this.currentTag.booleanSearchValue = FormatHelper.checkTrueBooleanVal(this.booleanvalue, this.currentTag.options.trueText, this.currentTag.options.falseText);
          // (this.booleanvalue == this.currentTag.options.trueText ? "true" : "false");
          this.currentTag.displayValue = this.booleanvalue;
          if(this._isAttributeValuesExistsSearchEnabled){
            isValueUpdated = this.getUpdatedValue(this.currentTag.value);
          }

          if(!isValueUpdated){
            this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
            this.set('tags.' + this.currentTag.index + '.booleanSearchValue', this.currentTag.booleanSearchValue);
            this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
          }
        } else { //TextArea
          if (!this.tav && !this._isAttributeValuesExistsSearchEnabled) {
            this.logWarning("FilterValuesEmpty");
            return;
          }

          var operator;
          this.tav = this.tav.trim();
          this.currentTag.displayValue = this.tav;
          var displayType = this.currentTag.options.displayType.toLowerCase();
          var splitQueryByAnd = this.tav.toLowerCase().split(' and ');
          var splitQueryByOr = this.tav.toLowerCase().split(' or ');
          var containsStr = this.tav;

          if (splitQueryByAnd.length > 1) {
            operator = "_AND";
            containsStr = splitQueryByAnd;
          } else if (splitQueryByOr.length > 1) {
            operator = "_OR";
            containsStr = splitQueryByOr;
          }

          if (containsStr instanceof Array) {
            containsStr = containsStr.join(' ');
          }

          if (operator || displayType == 'richtexteditor') {
            this.currentTag.value = {
              "contains": containsStr,
              "type": dataType,
              "operator": operator
            };          
          } else {
            // exact search
            this.currentTag.value = {
              "exact": this.tav,
              "type": dataType
            };
          }
          if(this._isAttributeValuesExistsSearchEnabled){
            isValueUpdated = this.getUpdatedValue(this.currentTag.value);
          }

          if(!isValueUpdated){
          this.set('tags.' + this.currentTag.index + '.displayValue', this.currentTag.displayValue);
          this.set('tags.' + this.currentTag.index + '.value', this.currentTag.value);
        }
        }

        //Close the popover once value updated
        if (this.currentTag.options.displayType.toLowerCase() == "datetime") {
          this.shadowRoot.querySelector('#rangepicker').hide();
        } else {
          this.shadowRoot.querySelector('#filterPopover').hide();
        }

        //Fire event
        this._fireChangeEvent();
      },

      _fireChangeEvent: function () {        
        //Fire the event to build the query string
        this.fireBedrockEvent("build-query", this.tags, {
            ignoreId: true
        });       
        
      },

      _onTagItemRemove: function(e,detail){

          //Fire the event to build the query string
          if(!detail.isChildTag){
            this._fireChangeEvent();
          } 
      },
        
      _fireAddEvent: function (_name, _value, _type) {
        var attribute = {
          name: _name
        };
        if (_name) {
          this.fireBedrockEvent('tag-item-added', attribute, {
            ignoreId: true
          });
        }
      },

      // When tag tapped, which popover component need to show
      _showTagModifier: function (displayType) {
        return this.currentTag && this.currentTag.options.displayType.toLowerCase() == displayType.toLowerCase();
      },

      //Hide the popover
      _dismissDialog: function () {
        this.shadowRoot.querySelector('#filterPopover').hide();
      },
      _openFilterLov: function () {
        this.shadowRoot.querySelector("#refineFilterPopover").open();
      },
      _openEntityTypeFilterLov: function () {
        this.shadowRoot.querySelector("#entityTypeFilterPopover").open();
      },

      _onFilterAttributesChange: function() {
        if(!this.tags || this.tags.length == 0) {
          return;
        }

        var tags = [];
        var removeTags = [];
        for(var i = 0; i < this.tags.length; i++) {
          if(this._filterAttributes.find(fa => fa.name == this.tags[i].name)) {
            tags.push(this.tags[i]);
            continue;
          } else {
            removeTags.push(this.tags[i]);
          }
        }

        this.tags = tags;
        if(removeTags.length > 0) {
          this.fireBedrockEvent('filter-tags-remove', removeTags, { ignoreId: true });
        }
      },

      refresh: function() {
        var attributesLov = this.shadowRoot.querySelector('[id=attributeModelLov]');
        if(attributesLov && attributesLov.refresh) {
          attributesLov.refresh();
        }
      },
      _getItemVisibility: function (settings,val) {
          if(settings){
              if(!_.isEmpty(settings)){
                  return settings[val];
              }
          }
          if(val == "showNestedAttributes"){
            return true;
          }
        return false;
      },

      
      _onToggleButtonChange: function(toggleState){
          var currentItem = this.currentTag.options.displayType;
          if(toggleState){
            this._toggleButtonText =  "Has Value"
            this.updateStyles({
              '--radio-button-border': this._defaultRadioButtonColor,
            });
          }else{
            this._toggleButtonText = "Has No Value";
            this.updateStyles({
              '--radio-button-border': '#bdbdbd',
            });
            if(currentItem == "referencelist"){
              this._selectedItems = "";
            }else if(currentItem == "numeric"){
                this.gte = "";
                this.lte = "";
                this._tagsNumericCollection = [];
                this._tagNumericInput = "";
            }else if(currentItem == "textbox"){
              this._tagsCollection = [];
              this._tagInput = "";
            }else if(currentItem == "textarea"){
              this.tav = "";
            }else if(currentItem == "boolean"){
              this.booleanvalue = "";
            }
        }
      }   
    });
  </script>
</dom-module>
