<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">

<link rel="import" href="../liquid-config-get/liquid-config-get.html">
<link rel="import" href="../liquid-config-save/liquid-config-save.html">
<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-data-table/pebble-data-table.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<link rel="import" href="../rock-attribute-model-lov/rock-attribute-model-lov.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">

<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->

<dom-module id="rock-attribute-mapping-grid">
    <template>
            <style include="bedrock-style-common">
                :host {
                    --paper-input-container: {
                        bottom: 8px;
                        position: relative;
                    };
                    --item-length-overflow: {
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;
                    }
                }
                pebble-popover {
                    --pebble-popover-width: 260px;
                }
                pebble-textbox {
                    --pebble-textbox-paper-input-style : {
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;  
                    }      
                }          
                #inputDiv  pebble-textbox {
                    --pebble-textbox-paper-input-style : {  
                        overflow: hidden;
                        text-overflow: ellipsis;
                        white-space: nowrap;                  
                        width: 90%;
                    }
                }
                #inputDiv {
                    width:250px;
                }
                .attributes-text .context-text {
                    line-height: 56px;
                }  
                #iconDiv {
                    align-self: flex-end;
                    -webkit-align-self: flex-end;
                    padding: 0 15px;
                    margin-left: -32px;
                    cursor: pointer;
                    margin-bottom: 10px;
                }
                .actionButton {
                    height: 20px;
                    width: 20px;
                }

                pebble-data-table {
                    height: 340px;
                }

                pebble-data-table data-table-row[header] {
                    font-weight: var(--font-bold, bold);
                    color: var(--palette-cerulean, #036bc3);
                    border-bottom: none;
                    text-transform: uppercase;
                    font-size: var(--table-head-font-size, 11px);
                }
                
                pebble-data-table data-table-row:not([header]) {
                    color: var(--palette-dark, #1a2028);
                    font-size: var(--default-font-size, 12px);
                    height: 100%;
                    background-color: var(--palette-white, #ffffff);
                }
                
                pebble-data-table data-table-row:not([header]):hover,
                pebble-data-table data-table-row[selected] {
                    background-color: var(--table-row-selected-color, #c1cad4) !important;
                }
                
                pebble-data-table data-table-row:not([header]):hover data-table-checkbox,
                pebble-data-table data-table-row[selected] data-table-checkbox {
                    background-color: var(--palette-white, #ffffff) !important;
                }

                pebble-data-table data-table-checkbox {
                    flex-basis: 16px !important;
                    padding: 0 !important;
                }
                pebble-data-table data-table-row data-table-cell.check-filter {
                    flex: 0 0 16px !important;
                    padding: 0!important;
                }
			
                pebble-data-table data-table-row[header] {
                    --pebble-direction-icon-button: {
                        opacity: 0.7 !important;
                    }				
                }

                pebble-data-table data-table-row data-table-cell {
                    padding: 0 0 0 10px!important;
                }
            </style>
        <liquid-rest id="getUserOverrides" url="/data/cop/getOverrides" method="POST" request-data="[[_getOverridesRequest]]" on-liquid-response="_onGetOverridesResponse"></liquid-rest>
        <liquid-rest id="saveUserOverrides" url="/data/cop/saveOverrides" method="POST" request-data="[[_saveOverridesRequest]]" on-liquid-response="_onOverridesSaveResponse"></liquid-rest>
        <div id="grid-heading">
            <strong>Attribute Mapping</strong>
        </div>
        <!-- TODO -->
        <!-- Currently pebble dialog is coming out of app and sitting on body so css has been added inline needs to resolve it with some proper way. -->
        <pebble-dialog id="classificationDialog" modal show-close-icon>
            <div id="classificationContent" style="height:500px">
                <div>
                    Select one classification.
                </div>
                <div id="categoryTreeContainer" style="height:450px; overflow:auto;">
                    <rock-classification-tree id="contextTree" taxonomy="[[taxonomy]]" context-data="[[contextData]]"></rock-classification-tree>
                </div>
                <div id="exportActions" class="p-b-10" align="center">
                    <pebble-button class="btn btn-secondary m-r-5" id="cancel" button-text="Cancel" raised on-tap="_onCancelClassificationSelection"></pebble-button>
                    <pebble-button  class="btn btn-success" id="download" button-text="Select" raised on-tap="_selectClassification"></pebble-button>
                </div>
            </div>
        </pebble-dialog>
        <div id="grid-container">
            <template is="dom-if" if="[[_isDataAvailable(_gridData)]]">
                <pebble-data-table id="mapping-grid" items="{{_gridData}}" multi-selection selected-item="{{selectedItem}}">
                <data-table-column slot="column-slot" name="Actions" width="60px" flex="0">
                    <template>
                        <pebble-icon slot="cell-slot-content" icon="pebble-icon:Delete" class="actionButton" on-tap="_fireDeleteEvent"></pebble-icon>
                        <pebble-icon slot="cell-slot-content" icon="pebble-icon:Copy" class="actionButton"  on-tap="_fireCloneEvent"></pebble-icon>
                    </template>
                </data-table-column>
                <data-table-column slot="column-slot" name="Is Context" width="100px" flex="0" style="justify-content: center;">
                    <template>
                        <pebble-checkbox slot="cell-slot-content" id="isContextChk" checked$="[[item.isContext]]" on-change="_onIsContextChange"></pebble-checkbox>
                    </template>
                </data-table-column>
                <data-table-column slot="column-slot" name="Excel Column Name">
                    <template>
                        <pebble-textbox slot="cell-slot-content" readonly="[[_isReadonly(item)]]" class="column-text" id="excelColumnName_[[index]]" value="{{item.excelColumnName}}" title="{{item.excelColumnName}}"></pebble-textbox>
                    </template>
                </data-table-column>
                <data-table-column slot="column-slot" name="For Context">
                    <template>
                    <div id="inputDiv" slot="cell-slot-content">
                            <pebble-textbox slot="cell-slot-content" readonly class="context-text" id="context-text_[[index]]" row-id="[[index]]" value="[[item.context]]" title="[[item.context]]">[[item.context]]</pebble-textbox>
                        </div>
                        <div id="iconDiv" slot="cell-slot-content">
                            <pebble-icon class="dropdown-icon pebble-icon-size-10" id="txtDropdownIcon_[[index]]" row-id="[[index]]" icon="pebble-icon:Down" on-tap="_classificationDialogOpen"></pebble-icon>
                        </div>
                    </template>
                </data-table-column>
                <data-table-column slot="column-slot" name="Mapped System Attribute Name">
                    <template>
                        <div id="inputDiv" slot="cell-slot-content" on-tap="_onAttributeTap" index="[[index]]">
                            <pebble-textbox readonly class="attributes-text" id="attributes-text_[[index]]" row-id="[[index]]" value="[[item.attributeModel.title]]" title="[[item.attributeModel.title]]"></pebble-textbox>
                        </div>
                        <div id="iconDiv" slot="cell-slot-content">
                            <pebble-icon class="dropdown-icon pebble-icon-size-10" id="txtDropdownIcon_[[index]]" row-id="[[index]]" icon="pebble-icon:Down" on-tap="_showAttributesLOV"></pebble-icon>
                        </div>
                    </template>
                </data-table-column>
            </pebble-data-table>
            <bedrock-pubsub event-name="attribute-model-lov-selection-changed" handler="_onAttributeSelection" target-id="attributeModelLov"></bedrock-pubsub>
            <pebble-popover class="attributes-popover" id="attributesPopover" for="" no-overlap vertical-align="auto" horizontal-align="auto">
                <rock-attribute-model-lov mode="all" id="attributeModelLov" context-data="[[contextData]]" no-sub-title ></rock-attribute-model-lov>
            </pebble-popover>
            </template>
        </div>
        <div id="actions-container" class="m-t-20" align="center">
            <pebble-button class="action-button btn btn-secondary m-r-5" id="skip" button-text="Cancel" raised on-tap="_onCancelTap"></pebble-button>
            <pebble-button class="action-button btn btn-primary m-r-5" id="skip" button-text="Skip" raised on-tap="_onSkipTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>
        <liquid-entity-model-get name="liquidAttributeModelGet" operation="getbyids" request-data={{attributeModelRequest}} 
            on-response="_onAttributeModelGetResponse" on-error="_onError"
         ></liquid-entity-model-get>
    </template>
    <script>
        (function() {
            'use strict';

            Polymer({
                is: "rock-attribute-mapping-grid",

                properties: {
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                    mappingsData: {
                        type: Object,
                        value: function() { return {}; }
                    },
                     /**
                     * Indicates the currently selected item when the `multiSelection` is set to <b>false</b>.
                     * If the item is not selected, it indicates a "null" value.
                     */
					selectedItem: {
						type: Object,
						notify: true,
						reflectToAttribute: true
					},
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                    contextData: {
                        type: Object,
                        value: function() { return {}; }
                    },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                    taxonomy: {
                        type: String
                    },
                    _gridData: {
                        type: Array,
                        value: function() { return []; }
                    },
                    /**
                     * Specifies the request object for an attribute model request.
                     */
                    attributeModelRequest: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    _getOverridesRequest: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    _saveOverridesRequest: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },
                    _deletedOverrides: {
                        type: Array,
                        value: function() { return []; }
                    },
                    copContext: {
                        type: Object,
                        value: function() { return {}; }
                    }
                },
                observers: [
                    '_dataChanged(contextData, mappingsData, copContext)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                listeners: {
                    'selecting-item': '_onSelectingItem',
					'deselecting-item': '_onDeselectingItem',
					'selecting-all-items': '_onSelectingAllItems',
					'deselecting-all-items': '_onDeselectingAllItems',
                },
                _dataChanged: function(contextData, mappingsData, copContext) {
                    if(!_.isEmpty(contextData) && !_.isEmpty(mappingsData) && !_.isEmpty(copContext)) {
                        var req = DataRequestHelper.createOverridesGetRequest(copContext);
                        this.set("_getOverridesRequest", req);
                        this.shadowRoot.querySelector("#getUserOverrides").generateRequest();
                    }
                },
                 _onGetOverridesResponse: function(e) {
                    var response = e.detail.response.response;
                    var profile = undefined;
                    var userId = this.userId.indexOf("_user") < 0 ? this.userId + "_user" : this.userId;
                    var configId = userId + "_overrides";
                    if(response && response.status && response.status.toLowerCase() == "success" && response.configObjects) {
                        if(response.configObjects.length > 0) {
                            profile = response.configObjects.find(obj => obj.id === configId);
                        }
                    }

                    this._profile = DataHelper.validateAndFillProfile(profile, configId, this.copContext);
                    this._fieldOverrides = this._profile.data.contexts[0].jsonData.fieldOverrides;

                    var destinationAttributes = this._getAllDestinationAttributes(this.mappingsData);

                    var modelGetRequest = {
                        "params": {
                            "query": {
                                "filters": {
                                    "typesCriterion": [
                                        "attributeModel"
                                    ]
                                }
                            },
                            "fields": {
                                "attributes": ["externalName"]
                            }
                        }
                    };
                    var ids = [];
                    for(var i=0;i<destinationAttributes.length;i++) {
                        ids.push(destinationAttributes[i] + '_attributeModel');
                    }
                    modelGetRequest.params.query.ids = ids;
                    this.set("attributeModelRequest", modelGetRequest);

                    var liquidModelGet = this.shadowRoot.querySelector("[name=liquidAttributeModelGet]");
                    if (liquidModelGet) {
                        liquidModelGet.generateRequest();
                    } 
                },
                _onAttributeModelGetResponse: function(e) {
                    var response = e.detail.response;
                    if(response.content && !_.isEmpty(response.content.entityModels)) {
                        var attributeModels = {};
                        for(var i=0; i< response.content.entityModels.length; i++) {
                            var attributeModel = response.content.entityModels[i];
                            attributeModels[attributeModel.name] = {
                                "id": attributeModel.name,
                                "value": attributeModel.name,
                                "title": attributeModel.properties.externalName
                            };
                        }
                        this._attributeModels = attributeModels;
                        this._prepareGridData();
                    }
                },
                _getAllDestinationAttributes: function(mappingsData) {
                    var destinationAttributes = [];
                    for(var i=0; i<mappingsData.fieldMap.length; i++) {
                        var fieldMap = mappingsData.fieldMap[i];
                        if(fieldMap && fieldMap.destination && fieldMap.destination != "") {
                            var attribute = this._getNameFromDestination(fieldMap.destination);
                            destinationAttributes.push(attribute);
                        }
                    }
                    return destinationAttributes;
                },
                _getNameFromDestination: function(destination) {
                    var index1 = destination.lastIndexOf("(");
                    var index2 = destination.lastIndexOf(")");
                    return destination.substring(index1+1, index2);
                },
                _prepareGridData: function() {
                   var gridData = [];
                   var mappingContexts = this.mappingsData.contexts;
                   var contextFields = [];
                   if(mappingContexts && mappingContexts.length > 0) {
                       var classificationField = mappingContexts[0].context.classification;
                       var ctxFieldName = this._getNameFromDestination(classificationField);
                       contextFields.push(ctxFieldName);
                   }
                   var fieldMaps = this.mappingsData.fieldMap;
                   var itemContext = this.getFirstItemContext();
                   var entityType = itemContext.type;
                   for(var i=0; i<fieldMaps.length; i++) {
                       var fieldMap = fieldMaps[i];
                       if(fieldMap.entityType != entityType) {
                           continue;
                       }
                       if(!fieldMap.source.startsWith("@value")) {
                           var source = fieldMap.source;
                           var isContext = false;
                            if(contextFields.indexOf(fieldMap.source) != -1) {
                                isContext = true;
                            }
                            var attrModel = {};
                            if(fieldMap.destination && fieldMap.destination != "") {
                                var attribute = this._getNameFromDestination(fieldMap.destination);
                                attrModel =  this._attributeModels[attribute] ? this._attributeModels[attribute] : {};
                            }
                            var classification = fieldMap.context && fieldMap.context.classification ? fieldMap.context.classification : "";
                            var rowData = {
                                "isContext": isContext,
                                "excelColumnName": source,
                                "attributeModel": attrModel,
                                "context": classification,
                                "fieldMap": fieldMap
                            };
                            gridData.push(rowData);
                       }
                   }
                   gridData.sort(function(a,b){
                        var nameA = a.excelColumnName.toUpperCase(); 
                        var nameB = b.excelColumnName.toUpperCase(); 
                        if (nameA < nameB) {
                            return -1;
                        }
                        if (nameA > nameB) {
                            return 1;
                        }
                        return 0;
                   })
                   var sortedData = [];
                   var emptyDestinationData = gridData.filter(obj => _.isEmpty(obj.attributeModel) == true);
                   var dataWithDestination = gridData.filter(obj => _.isEmpty(obj.attributeModel) == false);
                   if(emptyDestinationData) {
                       sortedData = sortedData.concat(emptyDestinationData);
                   }
                   if(dataWithDestination) {
                       sortedData = sortedData.concat(dataWithDestination);
                   }
                   this.set("_gridData", sortedData);
                },
                _showAttributesLOV: function(e) {
                    var rowId = e.currentTarget.rowId;
                   if(rowId >= 0) {
                        var lov = this.shadowRoot.querySelector("#attributeModelLov");
                        var popover = this.shadowRoot.querySelector("#attributesPopover");
                        if(lov && popover) {
                            lov.currentRowId = rowId;
                            popover.for = "attributes-text_" + rowId;
                            popover.show();
                        }
                    }
                },

                _onAttributeSelection: function(e, detail) {
                    var lov = this.shadowRoot.querySelector("#attributeModelLov");
                    if(lov) {
                        var rowId = lov.currentRowId;
                        if(rowId >= 0) {
                            var attributeTxtbox = this.root.querySelector("#attributes-text_" + rowId);
                            if(!attributeTxtbox) {
                                attributeTxtbox = this.shadowRoot.querySelector("#attributes-text_" + rowId);
                            }
                            if(attributeTxtbox) {
                                var row = this._getParentRow(attributeTxtbox)
                                if(row) {
                                    row.item.attributeModel = detail.data;
                                    row.item["rowModified"] = true;
                                    attributeTxtbox.value = detail.data.title;
                                    attributeTxtbox.title = detail.data.title;
                                }
                            }
                        }
                    }
                    var popover = this.shadowRoot.querySelector("#attributesPopover");
                    popover.for = "";
                    popover.hide();
                },

                _getParentRow: function (element) {
					if (element) {
						if (element.is == "data-table-row") {
							return element;
						} else {
							return this._getParentRow(element.parentNode);
						}
					}
					return undefined;
				},

                _onSelectingItem: function(e) {
                    this.selectedItem = e.detail.item;
                    var attrsPopover = this.shadowRoot.querySelector("#attributesPopover_" + this.selectedItem.name);
                    var attrData;
                    var classificationData;
                    if(attrsPopover) {
                        attrData = attrsPopover.querySelector("rock-attribute-model-lov").selectedItem;
                        this.selectedItem["attrData"] = attrData;
                    }
                    this.fireBedrockEvent("mapping-grid-selecting-item", this.selectedItem);
                },
                _onIsContextChange: function(e) {
                    var chkBoxElement = e.currentTarget;
                    var row = this._getParentRow(chkBoxElement);
                    if(row) {
                        if(chkBoxElement.checked) {
                            row.item.isContext = true;
                        } else {
                            row.item.isContext = false;
                        }
                    }
                },
                _onDeselectingItem: function (e) {
					this.fireBedrockEvent("mapping-grid-deselecting-item", e.detail);
				},
				_onSelectingAllItems: function (e) {
					this.fireBedrockEvent("mapping-grid-selecting-all-items", e.detail);
				},
				_onDeselectingAllItems: function (e) {
					this.fireBedrockEvent("mapping-grid-deselecting-all-items", e.detail);
				},

                _fireDeleteEvent: function(e) {
                    this._deletedOverrides.push(e.model.item);
                    var grid = this.shadowRoot.querySelector("#mapping-grid");
                    var index = grid.items.indexOf(e.model.item);
                    grid.items.splice(index, 1);

                    grid.clearCache();
                },
                _fireCloneEvent: function(e) {
                    var icon = e.currentTarget;
                    var row = this._getParentRow(icon);
                    var grid = this.shadowRoot.querySelector("#mapping-grid");
                    if(row && grid) {
                        var rowIndex = row.index;
                        var rowItem = row.item;
                        var newRowItem = DataHelper.cloneObject(rowItem);
                        newRowItem.fieldMap.id = -1;
                        newRowItem.rowModified = true;
                        grid.items.splice(rowIndex+1, 0, newRowItem);

                        grid.clearCache();
                    }
                },

                _isDataAvailable: function(data) {
                    if(data && data.length>0) {
                        return true;
                    }
                    return false;
                },

                _onAttributeTap: function (e) {
                    var index = e.currentTarget.index;
                    index++;
                    if (index == this._currentEditIndex) {
                        return;
                    }
                    this._currentEditIndex = index;
                    var table = this.shadowRoot.querySelector("pebble-data-table");
                    var ironListComponent = table.shadowRoot.querySelector('#list');
                    if (ironListComponent) {
                        var prevItem = Polymer.dom(ironListComponent).querySelector('div.item.gridCurrentEditRow');
                        if (prevItem) {
                            prevItem.classList.remove('gridCurrentEditRow');
                            prevItem.style.zIndex = null;
                        }
                        var item = Polymer.dom(table.shadowRoot.querySelector('#list')).querySelector('div.item:nth-of-type(' + index + ')');
                        if (item) {
                            item.classList.add('gridCurrentEditRow');
                            item.style.zIndex = 2;
                        }
                    }
				},
                _classificationDialogOpen: function (e) {
                    var classificationDialog = this.shadowRoot.querySelector("#classificationDialog");
                    var icon = e.currentTarget;
                    var row = this._getParentRow(icon);
                    var currentValuePath = "";
                    var selectedClassifications = [];
                    if(row) {
                        var contextTxtBox = row.querySelector('.context-text');
                        if(contextTxtBox) {
                            this.contextTxtBoxId = contextTxtBox.id;
                            currentValuePath = contextTxtBox.value;
                            if(currentValuePath != "") {
                                selectedClassifications = [ currentValuePath.split('/') ];
                            }
                        }
                    }

                    var contextTree =this.shadowRoot.querySelector("#contextTree");
                    if(contextTree) {                        
                        contextTree.selectedClassifications = selectedClassifications;
                        contextTree.generateRequest();
                    }

                    if (classificationDialog) {
                        classificationDialog.dialogTitle = "Select Classification";
                        classificationDialog.open();
                    }
                },
                _onCancelClassificationSelection: function () {
                    var classificationDialog = this.$$("#classificationDialog");

                    if (classificationDialog) {
                        classificationDialog.close();
                    }
                },
                _selectClassification: function(e) {
                    var contextTree = this.$$("#contextTree");
                    var categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                    if(contextTree) {
                        var selectedItem;

                        if(contextTree.selectedClassifications && contextTree.selectedClassifications.length > 0)
                        {
                            selectedItem = contextTree.selectedClassifications[0];
                        }
                        
                        if(selectedItem) {
                            var valuePath = selectedItem.valuePath;
                            valuePath = valuePath.replace(/#@#/g, categoryPathSeperator);
                            var contextTxtBox = this.shadowRoot.querySelector("#"+ this.contextTxtBoxId);
                            if(contextTxtBox) {
                                var row = this._getParentRow(contextTxtBox);
                                if(row) {
                                    row.item.context = valuePath;
                                    row.item["rowModified"] = true;
                                    contextTxtBox.value = valuePath;
                                    contextTxtBox.title = valuePath;
                                }
                            }
                        }
                    }
                    var classificationDialog = this.$$("#classificationDialog");

                    if (classificationDialog) {
                        classificationDialog.close();
                    }
                },
                _onSaveTap: function(e) {
                    var mappings = this._transformGridDataToFieldOverrides();
                    if(!_.isEmpty(mappings)) {
                        if(!_.isEmpty(mappings.fieldOverrides)) {
                            this._profile.data.contexts[0].jsonData.fieldOverrides = mappings.fieldOverrides;
                        }
                        if(!_.isEmpty(mappings.contexts)) {
                            this._profile.data.contexts[0].jsonData.contexts = mappings.contexts;
                        }

                        var req = { "configObject": this._profile };
                        this.set("_saveOverridesRequest", req);
                        var configSaveService = this.shadowRoot.querySelector("#saveUserOverrides");
                        if(configSaveService) {
                            configSaveService.generateRequest();
                        }
                    } else {
                        this.showSuccessToast("There are no changes in mappings to save.");
                    }
                },
                _transformGridDataToFieldOverrides: function() {
                    var items = this.shadowRoot.querySelector("#mapping-grid").items;
                    var originalFieldOverrides = DataHelper.cloneObject(this._fieldOverrides);
                    var mappings = {};
                    var fieldOverrides = [];
                    var contextFields = [];
                    if(items && items.length > 0) {
                        var modifiedItems = items.filter(obj => obj.rowModified == true);
                        if(modifiedItems && modifiedItems.length > 0) {
                            for(var i=0; i<modifiedItems.length; i++) {
                                var item = modifiedItems[i];                            
                                var fieldOverride = this._prepareFieldOverrideFromRowItem(item);
                                if(!_.isEmpty(fieldOverride)) {
                                    if(originalFieldOverrides) {
                                        var existingOverride = originalFieldOverrides.find(obj => obj.id == fieldOverride.id);
                                        if(existingOverride) {
                                            var index = originalFieldOverrides.indexOf(existingOverride);
                                            originalFieldOverrides[index] = fieldOverride;
                                        } else {
                                            fieldOverrides.push(fieldOverride);
                                        }
                                    } else {
                                        fieldOverrides.push(fieldOverride);
                                    }
                                }
                                var isContext = item.isContext;
                                var excelColumnName = item.excelColumnName;
                                if(isContext && excelColumnName) {
                                    contextFields.push(excelColumnName);
                                }
                            }
                        }
                    }
                    if(fieldOverrides.length > 0) {
                        this._populateIdsForNewOverrides(fieldOverrides);
                    }
                    if(!_.isEmpty(this._deletedOverrides) && !_.isEmpty(originalFieldOverrides)) {
                        this._deleteFieldOverrides(originalFieldOverrides, this._deletedOverrides);
                    }
                    if(originalFieldOverrides && originalFieldOverrides.length > 0) {
                        fieldOverrides.push.apply(fieldOverrides, originalFieldOverrides);
                    }
                    var contexts = [];
                    if(!_.isEmpty(contextFields)) {
                        contexts = [
                            {
                                "context": 
                                    {
                                        "classification": "@field(" + contextFields[0] + ")",
                                        "taxonomy": "@field(Taxonomy)"
                                    }
                            }
                        ];
                    }
                    if(!_.isEmpty(fieldOverrides)) {
                        mappings["fieldOverrides"] = fieldOverrides;
                    }
                    if(!_.isEmpty(contexts)) {
                        mappings["contexts"] = contexts;
                    }
                    return mappings;
                },
                _populateIdsForNewOverrides: function(fieldOverrides) {
                    for(var i=0;i<fieldOverrides.length;i++) {
                        var item = fieldOverrides[i];
                        if(item.id == -1) {
                            item.id = this._generateFieldOverrideId(item);
                            }
                        }
                },
                _generateFieldOverrideId: function(item) {
                    var source = item.source ? item.source : ''; 
                    var context = item.context ? JSON.stringify(item.context) : '';
                    var entityType = item.entityType ? item.entityType : '';
                    var unique = source + context + entityType;//this is how Connect generates id, we must do the same for add to work
                    return unique.hashCode();
                },
                _prepareFieldOverrideFromRowItem: function(item) {
                    var fieldOverride;
                    var excelColumnName = item.excelColumnName;
                    var selectedCtx = item.context;
                    var selectedAttrModel = item.attributeModel;
                    var mappedAttribute = "";
                    var classification = "";
                    if(!_.isEmpty(selectedAttrModel)) {
                        mappedAttribute = selectedAttrModel.id;
                    }
                    if(!_.isEmpty(selectedCtx)) {
                        classification = selectedCtx;
                    }
                    if(!_.isEmpty(mappedAttribute) && !_.isEmpty(excelColumnName)) {
                        fieldOverride = {
                            "source": excelColumnName,
                            "destination": "@attr(" + mappedAttribute + ")"
                        };
                        if(classification && classification !="") {
                            fieldOverride["context"] = {
                                "classification": classification,
                                "taxonomy": this.taxonomy
                            };
                        }
                        var originalFieldMap = item.fieldMap;
                        if(originalFieldMap) {
                            for (var fieldMapKey in originalFieldMap) {
                                if (originalFieldMap.hasOwnProperty(fieldMapKey)) {
                                    if(fieldMapKey == "required" || fieldMapKey == "enabled") {
                                        fieldOverride[fieldMapKey] = true;//COP needs this as true always for overrides to work
                                    } else if(fieldMapKey != "source"
                                        && fieldMapKey != "destination"
                                        && fieldMapKey != "context") {
                                            fieldOverride[fieldMapKey] = originalFieldMap[fieldMapKey];
                                    }
                                }
                            }
                        }
                    }
                    return fieldOverride;
                },
                _deleteFieldOverrides: function(originalFieldOverrides, deletedOverrides) {
                    for(var i=0; i<deletedOverrides.length; i++) {
                        var overrideToDelete = deletedOverrides[i];
                        var originalOverride = originalFieldOverrides.find(obj => obj.id == overrideToDelete.fieldMap.id);
                        if(!_.isEmpty(originalOverride)) {
                            originalOverride.action = "delete";
                        }
                    }
                },
                _onOverridesSaveResponse: function(e) {
                    var response = e.detail.response.response;
                    if(response && response.status && response.status.toLowerCase() == "success") {
                        var eventName = "field-map-save";
                        var eventDetail = {
                            "name": eventName,
                        };
                        this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                    }
                },
                _onCancelTap: function(e) {
                    var eventName = "field-map-cancel";
                    var eventDetail = {
                        "name": eventName,
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },
                _onSkipTap: function(e) {
                    var eventName = "field-map-skip";
                    var eventDetail = {
                        "name": eventName,
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },
                _isReadonly: function(item) {
                    if(item && item.fieldMap && item.fieldMap.id == -1) {
                        return false;
                    }
                    return true;
                }
            });
        })();
    </script>
</dom-module>