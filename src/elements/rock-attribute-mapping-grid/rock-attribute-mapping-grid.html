<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">

<link rel="import" href="../liquid-config-get/liquid-config-get.html">
<link rel="import" href="../liquid-config-save/liquid-config-save.html">
<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-data-table/pebble-data-table.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">

<link rel="import" href="../rock-attribute-model-lov/rock-attribute-model-lov.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<link rel="import" href="../rock-dimension-selector/rock-dimension-selector.html">
<link rel="import" href="../rock-value-mappings-manage/rock-value-mappings-grid.html">

<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->

<dom-module id="rock-attribute-mapping-grid">
    <template>
        <style include="bedrock-style-common">
            :host {
                --paper-input-container: {
                    bottom: 8px;
                    position: relative;
                }

                --item-length-overflow: {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
            }

            pebble-popover {
                --pebble-popover-width: 260px;
            }

            pebble-textbox {
                --pebble-textbox-paper-input-style: {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }
            }

            #inputDiv pebble-textbox {
                --pebble-textbox-paper-input-style: {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    width: 90%;
                }
            }

            #inputDiv {
                width: 250px;
            }

            .attributes-text .context-text {
                line-height: 56px;
            }

            #iconDiv {
                align-self: flex-end;
                -webkit-align-self: flex-end;
                padding: 0 15px;
                margin-left: -32px;
                cursor: pointer;
                margin-bottom: 10px;
            }

            .actionButton {
                height: 20px;
                width: 20px;
            }

            pebble-data-table {
                height: 340px;
            }

            pebble-data-table data-table-row[header] {
                font-weight: var(--font-bold, bold);
                color: var(--palette-cerulean, #036bc3);
                border-bottom: none;
                text-transform: uppercase;
                font-size: var(--table-head-font-size, 11px);
            }

            pebble-data-table data-table-row:not([header]) {
                color: var(--palette-dark, #1a2028);
                font-size: var(--default-font-size, 12px);
                height: 100%;
                background-color: var(--palette-white, #ffffff);
            }

            pebble-data-table data-table-row:not([header]):hover,
            pebble-data-table data-table-row[selected] {
                background-color: var(--table-row-selected-color, #c1cad4) !important;
            }

            pebble-data-table data-table-row:not([header]):hover data-table-checkbox,
            pebble-data-table data-table-row[selected] data-table-checkbox {
                background-color: var(--palette-white, #ffffff) !important;
            }

            pebble-data-table data-table-checkbox {
                flex-basis: 16px !important;
                padding: 0 !important;
            }

            pebble-data-table data-table-row data-table-cell.check-filter {
                flex: 0 0 16px !important;
                padding: 0!important;
            }

            pebble-data-table data-table-row[header] {
                --pebble-direction-icon-button: {
                    opacity: 0.7 !important;
                }
            }

            pebble-data-table data-table-row data-table-cell {
                padding: 0 0 0 10px!important;
            }

            #gridManage {
                font-size: 0;
                padding: 10px;
            }

            #gridManage pebble-icon {
                display: inline-block;
                vertical-align: middle;
            }

            .gridCountMsg {
                font-weight: bold;
                margin-right: 10px;
                font-size: var(--grid-msg-font-size, 12px);
                display: inline-block;
                vertical-align: middle;
            }

            #context-header {
                box-shadow: 0 1px 7px 0 var(--palette-cloudy-blue, #c1cad4);
                padding: 15px;
                margin: 10px;
                height: 55px;
            }

            rock-dimension-selector {
                --dimension-selector-simple-button: {
                    width: 120px;
                }
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <liquid-rest id="getMappings" url="/data/cop/getMappings" method="POST" on-liquid-response="_onGetMappingsResponse"
            on-liquid-error="_onMappingsError"></liquid-rest>
        <liquid-rest id="saveMappings" url="/data/cop/saveMappings" method="POST" on-liquid-response="_onMappingsSaveResponse"
            on-liquid-error="_onMappingsError"></liquid-rest>
        <div id="grid-heading">
            <strong>Attribute Mapping</strong>
        </div>
        <div id="context-header">
            <span class="pull-right">
                <rock-dimension-selector id="dimensionSelector" context-data="[[contextData]]" app-name="app-business-function-mapping" all-single-select></rock-dimension-selector>
                <bedrock-pubsub event-name="dimension-selector-data-changed" handler="_onDimensionsChanged" target-id="dimensionSelector"></bedrock-pubsub>
            </span>
        </div>
        <div id="gridManage">
            <span class="gridCountMsg">[[_getGridRecordsCountMessage(_gridData)]]</span>
            <span class="pull-right">
                <pebble-icon class="iconButton pebble-icon-size-16 tooltip-bottom m-r-10" icon="pebble-icon:Add" id="add" data-tooltip="Add" raised on-tap="_onAddTap"></pebble-icon>
                <pebble-icon class="iconButton pebble-icon-size-16 tooltip-bottom" icon="pebble-icon:Delete" id="delete" data-tooltip="Delete" raised on-tap="_onDeleteTap"></pebble-icon>
            </span>
        </div>
        <div id="grid-container">
            <template is="dom-if" if="[[_isDataAvailable(_gridData)]]">
                <pebble-data-table id="mapping-grid" items="{{_gridData}}" multi-selection selected-item="{{selectedItem}}">
                    <data-table-column slot="column-slot" name="Excel Column Name">
                        <template>
                            <pebble-textbox slot="cell-slot-content" class="column-text" id="excelColumnName_[[index]]" no-label-float row-id="[[index]]" value="{{item.excelColumnName}}"
                                title="{{item.excelColumnName}}" on-change="_onRowChange"></pebble-textbox>
                        </template>
                    </data-table-column>
                    <data-table-column slot="column-slot" name="Mapped System Attribute Name">
                        <template>
                            <div id="inputDiv" slot="cell-slot-content" on-tap="_onAttributeTap" index="[[index]]">
                                <pebble-textbox readonly class="attributes-text" id="attributes-text_[[index]]" row-id="[[index]]" no-label-float value="[[item.attributeModel.title]]"
                                    title="[[item.attributeModel.title]]"></pebble-textbox>
                            </div>
                            <div id="iconDiv" slot="cell-slot-content">
                                <pebble-icon class="dropdown-icon pebble-icon-size-10" id="txtDropdownIcon_[[index]]" row-id="[[index]]" icon="pebble-icon:Down"
                                    on-tap="_showAttributesLOV"></pebble-icon>
                            </div>
                            <div id="buttonDiv" slot="cell-slot-content">
                                <pebble-icon class="action-button-focus pebble-icon-size-16 tooltip-right m-l-20" data-tooltip="Value Mapping" icon="pebble-icon:value-mapping" id="btnValueMappings_[[index]]" raised on-tap="_onTapValueMapping" data-args$="[[item.attributeModel.id]]" disabled$="[[!_isValueMappingsAvailable(item.attributeModel)]]"></pebble-icon>
                            </div>
                        </template>
                    </data-table-column>
                </pebble-data-table>
                <bedrock-pubsub event-name="attribute-model-lov-selection-changed" handler="_onAttributeSelection" target-id="attributeModelLov"></bedrock-pubsub>
                <pebble-popover class="attributes-popover" id="attributesPopover" for="" no-overlap vertical-align="auto" horizontal-align="auto">
                    <rock-attribute-model-lov mode="all" id="attributeModelLov" context-data="[[contextData]]" no-sub-title></rock-attribute-model-lov>
                </pebble-popover>
            </template>
        </div>
        <!-- Value mapping dialog -->
        <pebble-dialog id="valueMappingsDialog" dialog-title="VALUE MAPPINGS" modal show-close-icon no-cancel-on-outside-click
            no-cancel-on-esc-key>
        </pebble-dialog>

        <!-- Value mapping events -->
        <bedrock-pubsub event-name="value-mapping-cancel" handler="_onCancelOrSaveValueMappings" target-id=""></bedrock-pubsub>

        <div id="actions-container" class="m-t-20" align="center">
            <pebble-button class="action-button btn btn-secondary m-r-5" id="back" button-text="Back" raised on-tap="_onBackTap"></pebble-button>
            <pebble-button class="action-button btn btn-primary m-r-5" id="skipandimport" button-text="Skip & Import" raised on-tap="_onImportTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="save" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="saveandimport" button-text="Save & Import" raised on-tap="_onSaveAndImportTap"></pebble-button>
        </div>
        <liquid-entity-model-get name="liquidAttributeModelGet" operation="getbyids" on-response="_onAttributeModelGetResponse"
            on-error="_onError"></liquid-entity-model-get>
        <liquid-entity-model-get name="liquidEntityManageModelGet" operation="getbyids" on-response="_onEntityManageModelGetResponse" on-error="_onEntityManageModelGetError"></liquid-entity-model-get>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: "rock-attribute-mapping-grid",

                properties: {
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    mappingConfig: {
                        type: Object,
                        value: function () { return {}; }
                    },

                    mappingData: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    /**
                    * Indicates the currently selected item when the `multiSelection` is set to <b>false</b>.
                    * If the item is not selected, it indicates a "null" value.
                    */
                    selectedItem: {
                        type: Object,
                        notify: true,
                        reflectToAttribute: true
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    contextData: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    taxonomy: {
                        type: String
                    },
                    _gridData: {
                        type: Array,
                        value: function () { return []; }
                    },
                    copContext: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _entityManageModelAttributes: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _deletedMappings: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _refChangeDeletedMappings: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _currentTaxonomy: {
                        type: String,
                        value: ""
                    },

                    _taxonomies: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _contexts: {
                        type: Array,
                        value: function() {
                            return [];
                        }
                    },

                    _loading: {
                        type: Boolean,
                        value: false
                    }
                },

                observers: [
                    '_dataChanged(contextData, mappingConfig, mappingData, copContext)'
                ],

                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],

                listeners: {
                    'selecting-item': '_onSelectingItem',
                    'deselecting-item': '_onDeselectingItem',
                    'selecting-all-items': '_onSelectingAllItems',
                    'deselecting-all-items': '_onDeselectingAllItems',
                },

                attached() {
                    //this._confirmationDialog = this.shadowRoot.querySelector("#confirmationDialog");
                },

                get getMappingsLiq() {
                    this._getMappingsLiq = this._getMappingsLiq || this.shadowRoot.querySelector("#getMappings");
                    return this._getMappingsLiq;
                },

                get saveMappingsLiq() {
                    this._saveMappingsLiq = this._saveMappingsLiq || this.shadowRoot.querySelector("#saveMappings");
                    return this._saveMappingsLiq;
                },

                get liquidAttributeModelGetLiq() {
                    this._liquidAttributeModelGet = this._liquidAttributeModelGet || this.shadowRoot.querySelector("[name=liquidAttributeModelGet]");
                    return this._liquidAttributeModelGet;
                },

                get liquidEntityManageModelGetLiq() {
                    this._liquidEntityManageModelGet = this._liquidEntityManageModelGet || this.shadowRoot.querySelector("[name=liquidEntityManageModelGet]");
                    return this._liquidEntityManageModelGet;
                },

                get attributeModelLov() {
                    this._attributeModelLov = this._attributeModelLov || this.shadowRoot.querySelector("#attributeModelLov");;
                    return this._attributeModelLov;
                },

                get popover() {
                    this._popover = this._popover || this.shadowRoot.querySelector("#attributesPopover");
                    return this._popover;
                },

                get mappingGrid() {
                    this._mappingGrid = this._mappingGrid || this.shadowRoot.querySelector("#mapping-grid");
                    return this._mappingGrid;
                },

                get dimensionSelector() {
                    this._dimensionSelector = this._dimensionSelector || this.shadowRoot.querySelector("#dimensionSelector");
                    return this._dimensionSelector;
                },

                get valueMappingsDialog() {
                    this._valueMappingsDialog = this._valueMappingsDialog || this.shadowRoot.querySelector("#valueMappingsDialog");
                    return this._valueMappingsDialog;
                },

                _dataChanged: function () {
                    this._getMappings();
                },

                _getMappings: function() {
                    if (!_.isEmpty(this.contextData) && !_.isEmpty(this.mappingData) && !_.isEmpty(this.mappingConfig) && !_.isEmpty(this.copContext)) {
                        this._loading = true;
                        this._taxonomies = this.mappingData.taxonomies;
                        this._contexts = this.mappingData.contexts;
                        var selectedContexts = this._prepareContexts();
                        var types = ["attributemapping"];
                        var req = DataRequestHelper.createMappingsGetRequest(this.contextData, this.copContext, selectedContexts, types);
                        req.params.rsconnect.headers.entities = this.mappingData.headerFields;
                        req.params.query.contexts[0].ownershipdata = this.ownershipdata && this.ownershipdata != "undefined" ? this.ownershipdata : "";

                        if(this.getMappingsLiq) {
                            this.getMappingsLiq.requestData = req;
                            this.getMappingsLiq.generateRequest();
                        }
                    }
                },

                _prepareContexts: function() {
                    var contexts = [];
                    for(var i = 0; i < this._contexts.length; i++) {
                        var context = {};
                        if(this.selectedDimensions && 
                           this.selectedDimensions[this._contexts[i]] && 
                           this.selectedDimensions[this._contexts[i]].length) {
                            context.type = this._contexts[i];
                            context.value = this.selectedDimensions[this._contexts[i]][0];
                        } else {
                            context.type = this._contexts[i];
                            context.value = "_ALL";
                        }
                        contexts.push(context);
                    }

                    return contexts;
                },

                _onGetMappingsResponse: function (e, detail) {
                    this._loading = false;
                    if ( !DataHelper.isValidObjectPath(detail, "response.response.status") || 
                          detail.response.response.status.toLowerCase() != "success") {
                        this.showErrorToast("Unable to fetch attribute mappings, please contact administrator.");
                        return;
                    }

                    var response = detail.response.response;
                    var destinationAttributes = [];
                    if (response.entities) {
                        if (response.entities.length > 0 && DataHelper.isValidObjectPath(response, "entities.0.data.contexts.0.attributes")) {
                            this._mappingAttributes = response.entities[0].data.contexts[0].attributes;
                            for (var key in this._mappingAttributes) {
                                destinationAttributes.push(key);
                            }
                        }
                    }

                    if (destinationAttributes && destinationAttributes.length > 0) {
                        var attributes = [];
                        attributes.push("externalName");
                        var modelGetRequest = DataRequestHelper.createGetAttributeModelRequest(destinationAttributes, attributes);

                        if(this.liquidAttributeModelGetLiq) {
                            this.liquidAttributeModelGetLiq.requestData = modelGetRequest;
                            this.liquidAttributeModelGetLiq.generateRequest();
                            this._loading = true;
                        }
                    }
                },

                _onAttributeModelGetResponse: function (e) {
                    var response = e.detail.response;
                    if (response.content && !_.isEmpty(response.content.entityModels)) {
                        var attributeModels = {};
                        for (var i = 0; i < response.content.entityModels.length; i++) {
                            var attributeModel = response.content.entityModels[i];
                            attributeModels[attributeModel.name] = {
                                "id": attributeModel.name,
                                "value": attributeModel.name,
                                "title": attributeModel.properties.externalName
                            };
                        }
                        this._attributeModels = attributeModels;
                        //Value Mappings - Fetch the entity manage model, before preparing the grid
                        this._getEntityManageModel();
                    }
                },

                _getEntityManageModel: function () {
                    var types = [];
                    types.push(this.getFirstItemContext().type);
                    var modelGetRequest = DataRequestHelper.createGetManageModelRequest(types);

                    if(this.liquidEntityManageModelGetLiq) {
                        this.liquidEntityManageModelGetLiq.requestData = modelGetRequest;
                        this.liquidEntityManageModelGetLiq.generateRequest();
                    }
                },

                _onEntityManageModelGetResponse: function (e, detail) {
                    if (detail && DataHelper.isValidObjectPath(detail, "response.content.entityModels.0.data.attributes")) {
                        this._entityManageModelAttributes = detail.response.content.entityModels[0].data.attributes;
                    }
                    //Got the entityManageModel to set the ValueMappings button, now prepare grid
                    this._prepareGridData();
                },

                _onEntityManageModelGetError: function (e, detail) {
                    this.logError("Entity manage model get error", detail);
                    this.showSuccessToast("Unable to get entity manage model, please contact administrator.");
                    this._loading = false;
                },

                _getAttributeModelForHeaderField: function (field) {
                    for (var key in this._mappingAttributes) {
                        if (!_.isEmpty(this._mappingAttributes[key])) {
                            for (var i = 0; i < this._mappingAttributes[key].values.length; i++) {
                                if (this._mappingAttributes[key].values[i].value.toLowerCase() == field.toLowerCase()) {
                                    return this._attributeModels[key];
                                }
                            }
                        }
                    }
                },

                _prepareGridData: function () {
                    var gridData = [];
                    var contextFields = [];
                    var headerFields = this.mappingData.headerFields;
                    var itemContext = this.getFirstItemContext();
                    var entityType = itemContext.type;
                    for (var i = 0; i < headerFields.length; i++) {
                        var headerField = headerFields[i];
                        var rowData = {
                            "excelColumnName": headerField,
                            "attributeModel": this._getAttributeModelForHeaderField(headerField),
                            "source": "system",
                            "action": ""
                        };
                        gridData.push(rowData);
                    }
                    gridData.sort(function (a, b) {
                        var nameA = a.excelColumnName.toUpperCase();
                        var nameB = b.excelColumnName.toUpperCase();
                        if (nameA < nameB) {
                            return -1;
                        }
                        if (nameA > nameB) {
                            return 1;
                        }
                        return 0;
                    })
                    var sortedData = [];
                    var emptyDestinationData = gridData.filter(obj => _.isEmpty(obj.attributeModel) == true);
                    var dataWithDestination = gridData.filter(obj => _.isEmpty(obj.attributeModel) == false);
                    if (emptyDestinationData) {
                        sortedData = sortedData.concat(emptyDestinationData);
                    }
                    if (dataWithDestination) {
                        sortedData = sortedData.concat(dataWithDestination);
                    }

                    //Set row index on the sorted data
                    for(var i = 0; i < sortedData.length; i++) {
                        sortedData[i].index = i;
                    }

                    this.set("_gridData", sortedData);
                    this._loading = false;
                },

                _showAttributesLOV: function (e) {
                    var rowId = e.currentTarget.rowId;
                    if (rowId >= 0) {
                        var lov = this.attributeModelLov;
                        if (lov && this.popover) {
                            lov.currentRowId = rowId;
                            this.popover.for = "attributes-text_" + rowId;
                            this.popover.show();
                            lov.reset();
                        }
                    }
                },

                _onAttributeSelection: function (e, detail) {
                    var lov = this.attributeModelLov;
                    if (lov) {
                        var rowId = lov.currentRowId;
                        if (rowId >= 0) {
                            var attributeTxtbox = this.root.querySelector("#attributes-text_" + rowId);
                            if (!attributeTxtbox) {
                                attributeTxtbox = this.shadowRoot.querySelector("#attributes-text_" + rowId);
                            }
                            if (attributeTxtbox) {
                                var row = this._getParentRow(attributeTxtbox);
                                this._setRowAsDeletedOnSelectionChange(DataHelper.cloneObject(row.item));
                                if (row) {
                                    row.item.attributeModel = detail.data;
                                    if (row.item["action"] != "new") {
                                        row.item["action"] = "updated";
                                    }
                                    attributeTxtbox.value = detail.data.title;
                                    attributeTxtbox.title = detail.data.title;
                                    this._setValueMappings(detail.data, rowId);
                                }
                            }
                        }
                    }
                    if(this.popover) {
                        this.popover.for = "";
                        this.popover.hide();
                    }
                },

                _setRowAsDeletedOnSelectionChange: function(row) {
                    row.action = "deleted";
                    this._refChangeDeletedMappings.push(row);
                },

                _getParentRow: function (element) {
                    if (element) {
                        if (element.is == "data-table-row") {
                            return element;
                        } else {
                            return this._getParentRow(element.parentNode);
                        }
                    }
                    return undefined;
                },

                _onSelectingItem: function (e) {
                    this.selectedItem = e.detail.item;
                    var attrsPopover = this.shadowRoot.querySelector("#attributesPopover_" + this.selectedItem.name);
                    var attrData;
                    var classificationData;
                    if (attrsPopover) {
                        attrData = attrsPopover.querySelector("rock-attribute-model-lov").selectedItem;
                        this.selectedItem["attrData"] = attrData;
                    }
                    this.fireBedrockEvent("mapping-grid-selecting-item", this.selectedItem);
                },

                _onDeselectingItem: function (e) {
                    this.fireBedrockEvent("mapping-grid-deselecting-item", e.detail);
                },

                _onSelectingAllItems: function (e) {
                    this.fireBedrockEvent("mapping-grid-selecting-all-items", e.detail);
                },

                _onDeselectingAllItems: function (e) {
                    this.fireBedrockEvent("mapping-grid-deselecting-all-items", e.detail);
                },

                _fireDeleteEvent: function (e) {
                    this._deletedMappings.push(e.model.item);
                    var grid = this.mappingGrid;
                    if(!grid) return;
                    var index = grid.items.indexOf(e.model.item);
                    grid.items.splice(index, 1);

                    grid.clearCache();
                },

                _fireCloneEvent: function (e) {
                    var icon = e.currentTarget;
                    var row = this._getParentRow(icon);
                    var grid = this.mappingGrid;
                    if (row && grid) {
                        var rowIndex = row.index;
                        var rowItem = row.item;
                        var newRowItem = DataHelper.cloneObject(rowItem);
                        newRowItem.fieldMap.id = -1;
                        newRowItem.action = "new";
                        grid.items.splice(rowIndex + 1, 0, newRowItem);

                        grid.clearCache();
                    }
                },

                _isDataAvailable: function (data) {
                    if (data && data.length > 0) {
                        return true;
                    }
                    return false;
                },

                _onAttributeTap: function (e) {
                    var index = e.currentTarget.index;
                    index++;
                    if (index == this._currentEditIndex) {
                        return;
                    }
                    this._currentEditIndex = index;
                    var grid = this.mappingGrid;

                    if(!grid) return;

                    var ironListComponent = Polymer.dom(grid.shadowRoot.querySelector('#list'));
                    if (ironListComponent) {
                        var prevItem = ironListComponent.querySelector('div.item.gridCurrentEditRow');
                        if (prevItem) {
                            prevItem.classList.remove('gridCurrentEditRow');
                            prevItem.style.zIndex = null;
                        }
                        var item = ironListComponent.querySelector('div.item:nth-of-type(' + index + ')');
                        if (item) {
                            item.classList.add('gridCurrentEditRow');
                            item.style.zIndex = 2;
                        }
                    }
                },

                _onSaveAndImportTap: function() {
                    this.isSaveAndImport = true;
                    this._onSaveTap();
                },

                _onSaveTap: function () {
                    this._loading = true;
                    if(!this.saveMappingsLiq) return;

                    this._loading = true;
                    var mappings = this._transformGridDataToSaveMappings();
                    if (_.isEmpty(mappings)) {
                        this._loading = false;
                        return this.showSuccessToast("There are no changes in mappings to save.");
                    }
                    var saveRequest = DataRequestHelper.createMappingsSaveRequest(this.contextData, this.copContext, this.selectedContexts, "attributemapping")
                    if (!_.isEmpty(saveRequest)) {
                        saveRequest.entity.data.contexts[0].attributes = mappings;
                        saveRequest.entity.data.contexts[0].context.ownershipdata = this.ownershipdata && this.ownershipdata != "undefined" ? this.ownershipdata : "";
                        this.saveMappingsLiq.requestData = saveRequest;
                        this.saveMappingsLiq.generateRequest();
                    }
                },

                _onMappingsSaveResponse: function (e, detail) {
                    var response = detail.response.response;
                    if (response && response.status == "success") {
                        this.async(function() {
                            this._resetMappings(); //Call this on save mappings success
                            if(this.isSaveAndImport) {
                                this.showSuccessToast("Attribute mappings submitted and imported the file successfully.");
                                this._onImportTap();
                                this.isSaveAndImport = false;
                            } else {
                                this.showSuccessToast("Attribute mappings submitted successfully.");
                            }
                            this._loading = false;
                        }, 10000);
                        return;
                    }

                    this._loading = false;
                    this.showErrorToast("Unable to submit attribute mappings, please contact administrator.");
                },

                _onMappingsError: function (e, detail) {
                    this.logError("Mapping get/save error", detail);
                    this.showErrorToast("Unable to perform mappings operation, please contact administrator.");
                    this._loading = false;
                },

                _resetMappings: function () {
                    this._deletedMappings = [];
                    this._refChangeDeletedMappings = [];
                    for (var i = 0; i < this._gridData.length; i++) {
                        this._gridData[i].action = "";
                    }
                },

                _transformGridDataToSaveMappings: function () {
                    var mappings = {};
                    var self = this;
                    //For updated and new
                    this._gridData.forEach(function (row) {
                        if (row.action == "updated" || row.action == "new") {
                            if (row.excelColumnName && row.attributeModel) {
                                if (mappings[row.attributeModel.id]) {
                                    var value = self._populateMappingValue(row.excelColumnName);
                                    mappings[row.attributeModel.id].values.push(value);
                                } else {
                                    mappings[row.attributeModel.id] = self._populateMappingValue(row.excelColumnName, true);
                                }
                            }
                        }
                    });

                    //Deleted mappings on reference change
                    for(var i = 0; i < this._refChangeDeletedMappings.length; i++) {
                        var isFound = false;
                        for(var key in mappings) {
                            if(this._refChangeDeletedMappings[i] && 
                               this._refChangeDeletedMappings[i].attributeModel &&
                               this._refChangeDeletedMappings[i].attributeModel.id == key) {
                                isFound = true;
                                break;
                            }
                        }

                        if(!isFound) {
                            this._deletedMappings.push(this._refChangeDeletedMappings[i]);
                        }
                    }

                    //For delete
                    this._deletedMappings.forEach(function (row) {
                        if (row.excelColumnName && row.attributeModel) {
                            if (mappings[row.attributeModel.id]) {
                                var value = self._populateMappingValue(row.excelColumnName);
                                value.action = "delete";
                                mappings[row.attributeModel.id].values.push(value);
                            } else {
                                var value = self._populateMappingValue(row.excelColumnName, true);
                                value.action = "delete";
                                mappings[row.attributeModel.id] = value;
                            }
                        }
                    });

                    //Modified above having untouched mappings
                    this._gridData.forEach(function (row) {
                        if (row.action == "" && row.excelColumnName && row.attributeModel) {
                            if (mappings[row.attributeModel.id]) {
                                var value = self._populateMappingValue(row.excelColumnName);
                                if (mappings[row.attributeModel.id].action == "delete") {
                                    for (var i = 0; i < mappings[row.attributeModel.id].values.length; i++) {
                                        mappings[row.attributeModel.id].values[i].action = "delete";
                                    }
                                    delete mappings[row.attributeModel.id].action;
                                    mappings[row.attributeModel.id].values.push(value);
                                } else {
                                    mappings[row.attributeModel.id].values.push(value);
                                }
                            }
                        }
                    });

                    this._setUniqueIds(mappings);
                    return mappings;
                },

                _setUniqueIds: function (mappings) {
                    if (!_.isEmpty(mappings)) {
                        for (var key in mappings) {
                            if (mappings[key] && mappings[key].properties && !mappings[key].properties.id) {
                                if (this._mappingAttributes && this._mappingAttributes[key]) {
                                    mappings[key].properties.id = this._mappingAttributes[key].properties.id;
                                } else {
                                    mappings[key].properties.id = this._generateMappingId();
                                }
                            }
                        }
                    }
                },

                _generateMappingId: function (item) {
                    var source = "ui";
                    var itemContext = this.getFirstItemContext(this.contextData);
                    var entityType = itemContext.type;
                    var unique = source + entityType;
                    return unique.hashCode();
                },

                _onBackTap: function (e) {
                    var eventName = "field-map-back";
                    var eventDetail = {
                        "name": eventName,
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },

                _onImportTap: function () {
                    var eventName = "field-map-import";
                    var eventDetail = {
                        "name": eventName,
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },

                _isReadonly: function (item) {
                    if (item && item.fieldMap && item.fieldMap.id == -1) {
                        return false;
                    }
                    return true;
                },

                _setValueMappings: function (attrModel, rowId) {
                    var isValueMappingAvailable = this._isValueMappingsAvailable(attrModel);
                    var btnValueMapping = this.root.querySelector("#btnValueMappings_" + rowId);
                    if (!btnValueMapping) {
                        btnValueMapping = this.shadowRoot.querySelector("#btnValueMappings_" + rowId);
                    }

                    if (btnValueMapping) {
                        if (isValueMappingAvailable) {
                            btnValueMapping.removeAttribute("disabled");
                            btnValueMapping.setAttribute("data-args", attrModel.id);
                        } else {
                            btnValueMapping.setAttribute("disabled", "");
                            btnValueMapping.setAttribute("data-args", "");
                        }
                    }
                },

                _isValueMappingsAvailable: function (attrModel) {
                    if (_.isEmpty(attrModel)) {
                        return;
                    }

                    var entityModelAttribute = this._entityManageModelAttributes[attrModel.id];
                    if (entityModelAttribute &&
                        entityModelAttribute.properties &&
                        entityModelAttribute.properties.supportsValueMapping) {
                        return entityModelAttribute.properties.supportsValueMapping;
                    }

                    return false;
                },

                _onTapValueMapping: function (e, detail) {
                    var valueMappingAttribute = e.currentTarget.getAttribute('data-args');

                    if (valueMappingAttribute && !_.isEmpty(this._entityManageModelAttributes)) {
                        var entityModelAttribute = this._entityManageModelAttributes[valueMappingAttribute];
                        if (entityModelAttribute &&
                            entityModelAttribute.properties &&
                            entityModelAttribute.properties.supportsValueMapping) {
                            //Value Mappings object will be input to ValueMappings component 
                            var valueMappings = {
                                "attribute": valueMappingAttribute,
                                "supportsValueMapping": entityModelAttribute.properties.supportsValueMapping,
                                "valueMappingContext": entityModelAttribute.properties.valueMappingContext,
                                "valueMappingTypeName": entityModelAttribute.properties.valueMappingTypeName,
                                "selectedDimensions": this.dimensionSelector.selectedDimensions
                            }

                            valueMappings.headerFields = this.mappingData.headerFields
                            valueMappings.taxonomies = this.mappingData.taxonomies
                            valueMappings.contexts = this.mappingData.contexts

                            if (this.valueMappingsDialog) {
                                var component = {
                                    "name": "rock-value-mappings-grid",
                                    "path": "/../../src/elements/rock-value-mappings-manage/rock-value-mappings-grid.html",
                                    "properties": {
                                        "mapping-data": valueMappings,
                                        "context-data": this.contextData,
                                        "cop-context": this.copContext,
                                        "mapping-config": this.mappingConfig
                                    }
                                };
                                ComponentHelper.loadContent(this.valueMappingsDialog, component, this);
                                this.valueMappingsDialog.open();
                            }
                        }
                    }
                },

                _onCancelOrSaveValueMappings: function () {
                    if(this.valueMappingsDialog) {
                        this.valueMappingsDialog.close();
                    }
                },

                _onAddTap: function () {
                    this.push("_gridData", {
                        "excelColumnName": "",
                        "source": "ui",
                        "action": "new",
                        "index": this._gridData.length
                    });

                    //Notify Grid data
                    var temp = this._gridData;
                    this._gridData = [];
                    this._gridData = temp;
                },

                _onDeleteTap: function () {
                    var grid = this.mappingGrid;
                    if (!grid) return;

                    var selectedItems = grid.getSelectedItems();
                    if (selectedItems.length == 0) {
                        //Show message if needed - Please select an item for delete
                        return;
                    }
                    var gridData = [];
                    for (var i = 0; i < this._gridData.length; i++) {
                        var isDelete = false;
                        for (var j = 0; j < selectedItems.length; j++) {
                            if (this._gridData[i].excelColumnName.toLowerCase() == selectedItems[j].excelColumnName.toLowerCase() &&
                                this._gridData[i].index == selectedItems[j].index) {
                                isDelete = true;
                                break;
                            }
                        }

                        if (!isDelete) {
                            gridData.push(this._gridData[i]);
                        } else {
                            if (this._gridData[i].action != "new") {
                                this._gridData[i].action = "deleted";
                                this._deletedMappings.push(this._gridData[i]);
                            }
                        }
                    }

                    //Reset row index
                    for(var i = 0; i < gridData.length; i++) {
                        gridData[i].index = i;
                    }

                    this.set("_gridData", gridData);
                },

                _onRowChange: function (e, detail) {
                    var rowId = e.currentTarget.rowId;
                    if (rowId >= 0) {
                        var excelColumnNameTxtbox = this.root.querySelector("#excelColumnName_" + rowId);
                        if (!excelColumnNameTxtbox) {
                            excelColumnNameTxtbox = this.shadowRoot.querySelector("#excelColumnName_" + rowId);
                        }
                        if (excelColumnNameTxtbox) {
                            var row = this._getParentRow(excelColumnNameTxtbox)
                            if (row) {
                                if (row.item["action"] != "new") {
                                    row.item["action"] = "updated";
                                }
                            }
                        }
                    }
                },

                _populateMappingValue: function (value, isSetProperties = false) {
                    var valContext = ContextHelper.getFirstValueContext(this.contextData);
                    var value = {
                        "value": value,
                        "locale": valContext.locale,
                        "id": ""
                    }

                    if(!isSetProperties) {
                        return value;
                    }

                    return {
                        "properties": {
                            "enabled": true,
                            "required": true
                        },
                        "values": [
                            value
                        ]
                    }
                },

                _getGridRecordsCountMessage: function () {
                    if (!this._gridData || this._gridData.length == 0) {
                        return "Showing 0 results";
                    }

                    return "Showing 1 - "+ this._gridData.length +" items of total "+ this._gridData.length +" results";
                },

                _onDimensionsChanged: function(e, detail) {
                    this._loading = true;
                    if(detail && detail.dimensions && 
                       detail.dimensions.taxonomy && 
                       detail.dimensions.taxonomy.length) {
                        if(this._currentTaxonomy != detail.dimensions.taxonomy[0]) {
                            this._currentTaxonomy = detail.dimensions.taxonomy[0];

                            if(this.dimensionSelector) {
                                for(var i = 0; i < this._taxonomies.length; i++) {
                                    if(this._taxonomies[i].name.toLowerCase() == this._currentTaxonomy.toLowerCase()) {
                                        this.dimensionSelector.classificationTaxonomy = this._taxonomies[i].id;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    //Load mappings
                    this._loadMappings();
                },

                _loadMappings: function() {
                    if(this.dimensionSelector) {
                        this.selectedDimensions = this.dimensionSelector.selectedDimensions;
                        this._resetMappings(); // Reset before get
                        this._getMappings(); // Get mappings based on dimensions
                    }
                }
            });
        })();
    </script>
</dom-module>