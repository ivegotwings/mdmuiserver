<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../liquid-behavior/liquid-behavior.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">
<!--
`liquid-dataobject-getdata`
Boolean control

@demo demo/index.html 
-->

<script>
    var RUFBehaviors = RUFBehaviors || {};
    var liquidDataObjectGetBehavior = {
        //behaviors: [RUFBehaviors.LiquidBehavior],
        attached: function () {
        },
        ready: function () {
        },
        properties: {
            _dataChannelName: {
                type: String,
                value: "dataObjectChannel",
                readonly: true
            },
            objectType: {
                type: String,
                value: 'entity'
            },
            _pathKeys: {
                type: Object,
                value: function(){
                    return this._getDataObjectPathKeys();
                }
            }
        },
        _executeRequest: function (model, request) {
            var op = request.operation,
                reqId = request.requestId === undefined ? '' : request.requestId,
                reqData = request.requestData;

            if(!this._validateRequestData(reqData)) {
                return;
            }

            if (op === 'initiatesearch') {
                return this._callInitiateSearch(model, reqData);
            } else if (op === 'getsearchresultdetail') {
                return this._callSearchResultDetail(model, request);
            } else if (op === 'getbyids') {
                return this._callGetByIds(model, request);
            }
            else {
                throw 'exception: operation ' + op + ' is not supported in ' + this.is + ' element.';
            }
        },
        _formatResponse: function(request, rawResponsePkg){
            var op = request.operation;
            var pathKeys = this._pathKeys;
            var objectType = this.objectType;
            var objTypeInfo = pathKeys.objectTypesInfo[objectType];
            
            if (op === 'initiatesearch') {
                var resSearchResultId = Object.keys(rawResponsePkg.json[pathKeys.root][objectType][pathKeys.searchResults])[0];
                return rawResponsePkg.json[pathKeys.root][objectType][pathKeys.searchResults][resSearchResultId];
            }
            else if (op === 'getsearchresultdetail') {
                var dataObjects = rawResponsePkg.json[pathKeys.root][objectType][pathKeys.searchResults][request.requestId][pathKeys.searchResultObjects];
                var formattedDataObjects = this._formatSearchResult(dataObjects);
                var searchResultDetailResponse = {};
                searchResultDetailResponse[objTypeInfo.collectionName] = formattedDataObjects;
                return searchResultDetailResponse;
            }
            else if (op === 'getbyids') {
                var dataObjects = {};
                if(rawResponsePkg !== undefined && rawResponsePkg.json && rawResponsePkg.json[pathKeys.root]) {
                    dataObjects = rawResponsePkg.json[pathKeys.root][objectType][pathKeys.masterListById];
                    this._formatData(dataObjects);
                }
                
                var getByIdsResponse = {};
                getByIdsResponse[objTypeInfo.collectionName] = dataObjects;
                return getByIdsResponse;
            }
        },
        _validateAutoTriggerChanges: function(requestData, operation, requestId){
            if(operation === "initiatesearch" && (requestData.path == "requestData.params.fields" || requestData.path == "requestData.params.options")) {
                return false;
            }

            return true;
        },
        _validateRequestData: function(requestData) {
            var isValid = false;
            if(!requestData) { return false; }
            if(!requestData.params) { return false; }
            if(requestData.params.query && !requestData.params.query.ctx) { return false; }
            if(requestData.params.query &&  requestData.params.query.ctx.length < 1) { return false; }
            if(requestData.params.query &&  requestData.params.query.ctx.length < 1) { return false; }

            return true; 
        },
        _callGetByIds: function (model, request, basePath) {
            var reqData = request.requestData,
                dataObjectIds = [];

            if (reqData === undefined || reqData.params === undefined) {
                return;
            }

            if ((!dataObjectIds || dataObjectIds.length == 0) && reqData.params && reqData.params.query && reqData.params.query.id) {
                dataObjectIds = [];
                dataObjectIds.push(reqData.params.query.id);
            }
            
            if (this.verbose) {
                this.log('Request for get data objects call...request: ', reqData, ' dataObjectIds: ', dataObjectIds);
            }

            if (!basePath && (!dataObjectIds || dataObjectIds.length == 0)) {
                throw "Cannot find dataObjectIds for get request";
                return;
            }

            var paths = [];
            var pathKeys = this._pathKeys;
            var objectType = this.objectType;
            var objTypeInfo = pathKeys.objectTypesInfo[objectType];

            basePath = basePath === undefined ? [pathKeys.root, objectType, pathKeys.masterListById, dataObjectIds] : basePath;
            
            var dataObjectFieldsPath = this._mergePathSets(basePath, [['id', objTypeInfo.typeInfo, 'systemInfo', 'properties']]);
            paths.push(dataObjectFieldsPath);
            
            var contextKeys = this._createContextKeys(reqData);

            if(reqData.params.fields.attributes !== undefined && reqData.params.fields.attributes.length > 0) {
                var attrs = reqData.params.fields.attributes;
                this._arrayRemove(attrs, "ALL"); //TODO: Fix this once we have logic to resolve ALL...
                var path2 = this._mergePathSets(basePath, ["data", "ctxInfo", contextKeys, "attributes", attrs, ["values", "groups"]]);
                paths.push(path2);
            }
        
            var relTypes = reqData.params.fields.relationships === undefined ? [] : reqData.params.fields.relationships;
            this._arrayRemove(relTypes, "ALL"); //TODO: Fix this once we have logic to resolve ALL...

            if(relTypes.length > 0) {
                var relAttrNames = reqData.params.fields.relationshipAttributes === undefined ? [] : reqData.params.fields.relationshipAttributes;
                this._arrayRemove(relAttrNames, "ALL"); //TODO: Fix this once we have logic to resolve ALL...

                var relatedDataObjectAttrs = reqData.params.fields.relatedEntityAttributes === undefined ? [] : reqData.params.fields.relatedEntityAttributes;
                this._arrayRemove(relatedDataObjectAttrs, "ALL"); //TODO: Fix this once we have logic to resolve ALL...

                var relIdCreatePath = this._mergePathSets(basePath, ["data", "ctxInfo", contextKeys, "relationships", relTypes, "relIds"]);

                var relAttrsPath = [];
                if(relAttrNames.length > 0){
                    var relAttrsPath = ['attributes', relAttrNames, 'values'];
                }
                
                var relToObjectPath_Fields = ['relToObject', ['id', objTypeInfo.typeInfo, 'systemInfo', 'properties']];
                
                var relToObjectPath_Attrs = [];
                if(relatedDataObjectAttrs.length > 0)
                    relToObjectPath_Attrs = ['relToObject', "data", "ctxInfo", contextKeys, "attributes", relatedDataObjectAttrs, "values"];
                
                var relFieldsPath = [['id', 'direction', 'operation', 'source', 'alias']];
                
                var self = this;
                model.get(relIdCreatePath).then(function(responsePkg){
                    //this.log('rel get call res ', JSON.stringify(responsePkg, null, 4));

                    var relDetailGetPaths = [];

                    if(responsePkg !== undefined) {
                        for(var dataObjectIdIdx in dataObjectIds) {
                            var dataObjectId = dataObjectIds[dataObjectIdIdx];
                            for(var ctxKeyIdx in contextKeys) {
                                var ctxKey = contextKeys[ctxKeyIdx];
                                for(var relTypeIdx in relTypes) {
                                    var relType = relTypes[relTypeIdx];
                                    var relIds = responsePkg.json[pathKeys.root][self.objectType][pathKeys.masterListById][dataObjectId]["data"]["ctxInfo"][ctxKey]["relationships"][relType]["relIds"];

                                    var from = reqData.params.options && reqData.params.options.from !== undefined ? reqData.params.options.from : 0;
                                    var to = reqData.params.options && reqData.params.options.to !== undefined ? reqData.params.options.to : relIds.length - 1;

                                    if(from >= relIds.length) {
                                        from = -1;
                                    }

                                    if(to >= relIds.length){
                                        to = relIds.length - 1;
                                    }

                                    if(from != -1) {
                                        var filteredRelIds = relIds.slice(from, to + 1);
                                        var relBasePath = self._mergePathSets(basePath, ["data", "ctxInfo", ctxKey, "relationships", relType, "rels", filteredRelIds]);
                                        
                                        //must have paths for eachrel..rel fields and relToObject with only fields..
                                        relDetailGetPaths.push(self._mergePathSets(relBasePath, relFieldsPath));                                            
                                        relDetailGetPaths.push(self._mergePathSets(relBasePath, relToObjectPath_Fields));

                                        //rel attrs..only if requested...
                                        if(relAttrsPath.length > 0) {
                                            relDetailGetPaths.push(self._mergePathSets(relBasePath, relAttrsPath));
                                        }
                                        
                                        //related entity attrs..only if requested...
                                        if(relToObjectPath_Attrs.length > 0) {
                                            relDetailGetPaths.push(self._mergePathSets(relBasePath, relToObjectPath_Attrs));
                                        }
                                    }
                                    else {
                                        throw "requested range is not available for relationships";
                                    }
                                }
                            }
                        }
                    }
                    
                    if(relDetailGetPaths.length > 0) {
                        paths.push.apply(paths, relDetailGetPaths); 
                    }

                    if(paths.length > 0) {
                        var getWithRelResponsePromise = self._makeFalcorGetCall(model, paths);
                        return self._handleModelResponse(request, getWithRelResponsePromise);
                    }
                });
            }
            else {
                return this._makeFalcorGetCall(model, paths);
            }
        },
        _callInitiateSearch: function (model, reqData) {
            var pathKeys = this._pathKeys;
            return model.call([pathKeys.root, this.objectType, pathKeys.searchResults, "create"], [reqData], [], []);
        },
        _callSearchResultDetail: function (model, request) {
            var self = this,
                reqId = request.requestId === undefined ? '' : request.requestId,
                reqData = request.requestData,
                totalRecords = 0;

            if(reqId === '') {
                return {}; // this means do nothing..
            }

            if (this.verbose) {
                this.log('Request Id for get search result detail: ', reqId);
            }

            var pathKeys = this._pathKeys;
            var objectType = this.objectType;
            var totalRecordsResponse = this._callSearchResultTotalRecordsGet(model, reqId);

            totalRecordsResponse.then(function (totalRecordsPkg) {
                totalRecords = totalRecordsPkg.json[pathKeys.root][objectType][pathKeys.searchResults][reqId].totalRecords;

                var from = reqData.params.options && reqData.params.options.from !== undefined ? reqData.params.options.from : 0;
                var to = reqData.params.options && reqData.params.options.to !== undefined ? reqData.params.options.to : totalRecords - 1;

                if(from >= totalRecords) {
                    from = -1;
                }

                var to1 = (to + 1) < totalRecords ? to : totalRecords - 1;

                if(from != -1) {
                    var searchResultPath = [pathKeys.root, objectType, pathKeys.searchResults, reqId, pathKeys.searchResultObjects, [{ 'from': from, 'to': to1 }]];
                    var getByIdsResponse = self._callGetByIds(model, request, searchResultPath);
                    return self._handleModelResponse(request, getByIdsResponse);
                }
                else {
                    var emptyResponse = {
                        'status': 'success',
                        'json': {
                        }
                    };

                    emptyResponse.json[pathKeys.root] = {};
                    emptyResponse.json[pathKeys.root][objectType] = {};
                    emptyResponse.json[pathKeys.root][objectType][pathKeys.searchResults] = {};
                    emptyResponse.json[pathKeys.root][objectType][pathKeys.searchResults][reqId] = {};
                    emptyResponse.json[pathKeys.root][objectType][pathKeys.searchResults][reqId][pathKeys.searchResultObjects] = {};
                    return self._handleModelResponse(request, emptyResponse);

                    if(self.verbose) {
                        self.log('no search results found for search request id ', reqId);
                    }
                }
            });
        },
        _callSearchResultTotalRecordsGet: function(model, reqId, reqData) {
            var pathKeys = this._pathKeys;
            return model.get([pathKeys.root, this.objectType, pathKeys.searchResults, reqId, "totalRecords"]);
        },
        _callSearchResultDataObjectIdsGet: function(model, reqId, from, to) {
            var pathKeys = this._pathKeys;
            return model.get([pathKeys.root, this.objectType, pathKeys.searchResults, reqId, pathKeys.searchResultObjects, [{ 'from': from, 'to': to }]]);
        },
        _createContextKeys: function (reqData) {
            var contextKeys = []
            var self = this;                 
            reqData.params.query.ctx.forEach(function (ctxGroup) {
                reqData.params.query.valCtx.forEach(function (valCtxGroup) {
                    var source = valCtxGroup.source !== undefined ? valCtxGroup.source.toLowerCase() : '';
                    var locale = valCtxGroup.locale !== undefined ? valCtxGroup.locale.toLowerCase() : '';
                    var classfication =  ctxGroup.classification ? ctxGroup.classification : '';
                    
                    var ctxGroupUI = {  'list': ctxGroup.list,
                                        'classification': classfication, 
                                        'source': source, 
                                        'locale': locale};
                    var ctxKey = self.createContextKey(ctxGroupUI);
                    contextKeys.push(ctxKey);
                });
            });

            return contextKeys;
        },
        getCtxDataByGroupObj: function(dataObject, ctxGroup) {
            var ctxInfoItem = {};
            if(ctxGroup && ctxGroup.list) {
                var ctxKey = this.createContextKey(ctxGroup);
                ctxInfoItem = this.getCtxDataByKey(dataObject, ctxKey);
            }

            return ctxInfoItem;
        },
        getCtxDataByKey: function(dataObject, ctxKey) {
            var ctxInfoItem = {};
            
            if(dataObject && dataObject.data && dataObject.data.ctxInfo && dataObject.data.ctxInfo[ctxKey]){
                ctxInfoItem = dataObject.data.ctxInfo[ctxKey];
            }

            return ctxInfoItem;
        },
        createContextKey: function (ctxGroup) {
            return "".concat(ctxGroup.list, '#@#', ctxGroup.classification, '#@#', ctxGroup.source, '#@#', ctxGroup.locale);                    
        },
        _populateContextGroups: function (dataObject) {
            if (dataObject.data && dataObject.data.ctxInfo) {
                var ctxKeys = Object.keys(dataObject.data.ctxInfo);
                for (var i in ctxKeys) {
                    var ctxKey = ctxKeys[i];
                    var ctxInfoItem = dataObject.data.ctxInfo[ctxKey];
                    
                    var ctxKeySegments = ctxKey.split('#@#');

                    var ctxGroupUI = {
                        list: ctxKeySegments[0],
                        classification: ctxKeySegments[1],
                        source: ctxKeySegments[2],
                        locale: ctxKeySegments[3]
                    };

                    ctxInfoItem["ctxGroup"] = ctxGroupUI;
                }
            }
        },
        _formatData: function(dataObjects) {
            for(var dataObjectId in dataObjects){
                var dataObject = dataObjects[dataObjectId];
                this._populateContextGroups(dataObject);
            }
        },
        _formatSearchResult: function(dataObjects) {
            var formattedDataObjects = {};
            for(var i in dataObjects) {
                var dataObject = dataObjects[i];
                this._populateContextGroups(dataObject);
                formattedDataObjects[dataObject.id] = dataObject;
            }
            
            return formattedDataObjects;
        },
        _mergePathSets: function (pathSet1, pathSet2) {
            return pathSet1.concat(pathSet2);
        },
        _makeFalcorGetCall: function(model, paths) {
            return model.get.apply(model, paths);
        },
        _arrayRemove: function(arr, val) {
            var index = -1;
            
            index = arr.indexOf(val);

            while(index >= 0) {
                arr.splice(index, 1);
                index = arr.indexOf(val);
            }
        },
        _getDataObjectPathKeys: function() {
            return SharedUtils.DataObjectFalcorUtil.getPathKeys();
        },
        log: function() {
            var a = arguments;

            if (typeof console != "undefined" && console.log) {
                if (console.log.apply) {
                    // It has Function#apply, use it
                    console.log.apply(console, arguments);
                } else {
                    // Ugh, no Function#apply
                    var output2 = '';
                    for (i=0;i<arguments.length;i++) {
                        output2 += arguments[i] + ' ';
                    }
                    console.log(output2);
                }
            }
        }
    };

    RUFBehaviors.LiquidDataObjectGetBehavior = [RUFBehaviors.LiquidBehavior, liquidDataObjectGetBehavior];
</script>
