<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../liquid-base-falcor-behavior/liquid-base-falcor-behavior.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">
<!--
`liquid-dataobject-get-behavior`
-->

<script>
    /*
     * @polymerBehavior RUFBehaviors.LiquidDataObjectGetBehavior
     * @demo demo/index.html 
     */
    var RUFBehaviors = RUFBehaviors || {};
    var liquidDataObjectGetBehavior = {
        //behaviors: [RUFBehaviors.LiquidBehavior],
        attached: function () {
        },
        ready: function () {
        },
        properties: {
            _dataChannelName: {
                type: String,
                value: 'dataObjectChannel',
                readonly: true
            },
            dataIndex: {
                type: String,
                value: 'entityData'
            },
            _pathKeys: {
                type: Object,
                value: function () {
                    return this._getDataObjectPathKeys();
                }
            }
        },
        _executeRequest: function (model, request) {
            var op = request.operation,
                reqId = request.requestId === undefined ? '' : request.requestId,
                reqData = request.requestData;

            if (!this._validateRequest(request)) {
                return;
            }

            if (op === 'initiatesearch') {
                return this._callInitiateSearch(model, reqData);
            } else if (op === 'getsearchresultdetail') {
                return this._callSearchResultDetail(model, request);
            } else if (op === 'getbyids') {
                return this._callGetByIds(model, request);
            }
            else {
                throw 'exception: operation ' + op + ' is not supported in ' + this.is + ' element.';
            }
        },
        _formatResponse: function (request, rawResponsePkg) {
            var op = request.operation;
            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];

            if (op === 'initiatesearch') {
                var resSearchResultId = Object.keys(rawResponsePkg.json[pathKeys.root][dataIndex][pathKeys.searchResults])[0];
                return rawResponsePkg.json[pathKeys.root][dataIndex][pathKeys.searchResults][resSearchResultId];
            }
            else if (op === 'getsearchresultdetail') {
                var dataObjects = rawResponsePkg.json[pathKeys.root][dataIndex][pathKeys.searchResults][request.requestId][pathKeys.searchResultItems];
                var formattedDataObjects = this._formatData(dataIndex, dataObjects);
                var searchResultDetailResponse = {};
                searchResultDetailResponse[dataIndexInfo.collectionName] = formattedDataObjects;
                return searchResultDetailResponse;
            }
            else if (op === 'getbyids') {
                var dataObjects = {};
                if (rawResponsePkg !== undefined && rawResponsePkg.json && rawResponsePkg.json[pathKeys.root]) {
                    dataObjects = this._getDataObjects(rawResponsePkg, dataIndex);
                    var formattedDataObjects = this._formatData(dataIndex, dataObjects);
                }

                var getByIdsResponse = {};
                getByIdsResponse[dataIndexInfo.collectionName] = formattedDataObjects;
                return getByIdsResponse;
            }
        },
        _validateAutoTriggerChanges: function (requestData, operation, requestId) {
            if (operation === "initiatesearch" && (requestData.path == "requestData.params.fields" || requestData.path == "requestData.params.options")) {
                return false;
            }

            return true;
        },
        _validateRequest: function (request) {
            var requestData = request.requestData;
            var operation = request.operation;
            var mainMessage = 'cannot make request for operation ' + operation + '{0} ... host: ' + this.domHost.localName + '... request: ' + JSON.stringify(requestData);

            if (!requestData) {
                console.warn(mainMessage.format(': requestData not found'));
                return false;
            }
            if (!requestData.params) {
                console.warn(mainMessage.format(': requestData.params not found'));
                return false;
            }
            if (!requestData.params.query) {
                console.warn(mainMessage.format(': requestData.params.query not found'));
                return false;
            }

            var isIdExists = requestData.params.query.id !== undefined || requestData.params.query.ids !== undefined;
            var isCtxExists = requestData.params.query.ctx !== undefined && requestData.params.query.ctx.length > 0;
            var isTypeCriterionExists = requestData.params.query.filters !== undefined && requestData.params.query.filters.typesCriterion !== undefined && requestData.params.query.filters.typesCriterion.length > 0;

            if (!(isIdExists || isCtxExists || isTypeCriterionExists)) {
                console.warn(mainMessage.format(': at least one must be present (ids, ctx, typesCriterion)'));
                return false;
            }

            if (!isTypeCriterionExists) {
                console.warn(mainMessage.format(': typesCriterion is mandatory in filters'));
                return false;
            }

            //operation based validation
            if (operation === 'getbyids') {
                if (!isIdExists) {
                    console.warn(mainMessage.format(': ids is mandatory for this operation'));
                    return false;
                }
            }
            else if (operation == "getsearchresultdetail") {
                if (!request.requestId) {
                    console.warn(mainMessage.format(': requestId is mandatory for this operation'));
                    return false;
                }
            }

            return true;
        },
        _callGetByIds: function (model, request, basePath) {
            var reqData = request.requestData,
                dataObjectIds = [];

            var utils = SharedUtils.DataObjectFalcorUtil;

            if (reqData === undefined || reqData.params === undefined) {
                return;
            }

            if ((!dataObjectIds || dataObjectIds.length == 0) && reqData.params && reqData.params.query && (reqData.params.query.id || reqData.params.query.ids)) {
                if (reqData.params.query.id) {
                    dataObjectIds.push(reqData.params.query.id);
                } else if (reqData.params.query.ids) {
                    dataObjectIds.push.apply(dataObjectIds, reqData.params.query.ids);
                }
            }

            if (this.verbose) {
                this.log('Request for get data objects call...request: ', reqData, ' ...dataObjectIds: ', dataObjectIds, ' ...base path: ', basePath);
            }

            if (!basePath && (!dataObjectIds || dataObjectIds.length == 0)) {
                throw "Cannot find dataObjectIds for get request";
                return;
            }

            var paths = [];
            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];
            var dataObjectTypes = this._getDataObjectTypes(reqData);

            basePath = basePath === undefined ? [pathKeys.root, dataIndex, dataObjectTypes, pathKeys.byIds, dataObjectIds] : basePath;

            var dataObjectFields = ['id', 'name', 'version', dataIndexInfo.typeInfo, 'properties'];

            var dataObjectFieldsPath = this._mergePathSets(basePath, [dataObjectFields]);
            paths.push(dataObjectFieldsPath);

            var ctxKeys = utils.createCtxKeys(reqData.params.query.ctx);
            var valCtxKeys = utils.createCtxKeys(reqData.params.query.valCtx);

            var attrDetailPath = ['valCtxInfo', valCtxKeys, ['values', 'group', 'properties']];

            if (reqData.params.fields.attributes !== undefined && reqData.params.fields.attributes.length > 0) {
                var attrs = reqData.params.fields.attributes;
                this._arrayRemove(attrs, '_ALL'); //TODO: Fix this once we have logic to resolve ALL...
                var path2 = this._mergePathSets(basePath, ['data', 'ctxInfo', ctxKeys, 'attributes', attrs], attrDetailPath);
                paths.push(path2);
            }

            var relTypes = reqData.params.fields.relationships === undefined ? [] : reqData.params.fields.relationships;
            this._arrayRemove(relTypes, '_ALL'); //TODO: Fix this once we have logic to resolve ALL...

            if (relTypes.length > 0) {
                var relAttrNames = reqData.params.fields.relationshipAttributes === undefined ? [] : reqData.params.fields.relationshipAttributes;
                this._arrayRemove(relAttrNames, '_ALL'); //TODO: Fix this once we have logic to resolve ALL...

                var relatedDataObjectAttrs = reqData.params.fields.relatedEntityAttributes === undefined ? [] : reqData.params.fields.relatedEntityAttributes;
                this._arrayRemove(relatedDataObjectAttrs, '_ALL'); //TODO: Fix this once we have logic to resolve ALL...

                var relIdCreatePath = this._mergePathSets(basePath, ['data', 'ctxInfo', ctxKeys, 'relationships', relTypes, 'relIds']);

                var relAttrsPath = [];
                if (relAttrNames.length > 0) {
                    var relAttrsPath = this._mergePathSets(['attributes', relAttrNames], attrDetailPath);
                }

                var relToObjectPath_Fields = this._mergePathSets(['relTo'], [dataObjectFields]);

                var relToObjectPath_Attrs = [];
                if (relatedDataObjectAttrs.length > 0)
                    relToObjectPath_Attrs = this._mergePathSets(['relTo', 'data', 'ctxInfo', ctxKeys, 'attributes', relatedDataObjectAttrs], attrDetailPath);

                var relFieldsPath = [['id', 'direction', 'operation', 'source', 'alias']];

                var self = this;
                model.get(relIdCreatePath).then(function (responsePkg) {
                    //this.log('rel get call res ', JSON.stringify(responsePkg, null, 4));

                    var relDetailGetPaths = [];

                    if (responsePkg !== undefined) {
                        for (var dataObjectIdIdx in dataObjectIds) {
                            var dataObjectId = dataObjectIds[dataObjectIdIdx];
                            var responseDataObjects = self._getDataObjects(responsePkg, self.dataIndex);

                            for (var ctxKeyIdx in ctxKeys) {
                                var ctxKey = ctxKeys[ctxKeyIdx];
                                for (var relTypeIdx in relTypes) {
                                    var relType = relTypes[relTypeIdx];
                                    var relIds = responseDataObjects[dataObjectId]['data']['ctxInfo'][ctxKey]['relationships'][relType]['relIds'];

                                    var from = reqData.params.options && reqData.params.options.from !== undefined ? reqData.params.options.from : 0;
                                    var to = reqData.params.options && reqData.params.options.to !== undefined ? reqData.params.options.to : relIds.length - 1;

                                    if (from == -1) {
                                        from = 0;
                                    }
                                    else if (from >= relIds.length) {
                                        from = -1;
                                    }

                                    if (to >= relIds.length) {
                                        to = relIds.length - 1;
                                    }

                                    if (from != -1) {
                                        var filteredRelIds = relIds.slice(from, to + 1);
                                        var relBasePath = self._mergePathSets(basePath, ['data', 'ctxInfo', ctxKey, 'relationships', relType, 'rels', filteredRelIds]);

                                        //must have paths for eachrel..rel fields and relTo with only fields..
                                        relDetailGetPaths.push(self._mergePathSets(relBasePath, relFieldsPath));
                                        relDetailGetPaths.push(self._mergePathSets(relBasePath, relToObjectPath_Fields));

                                        //rel attrs..only if requested...
                                        if (relAttrsPath.length > 0) {
                                            relDetailGetPaths.push(self._mergePathSets(relBasePath, relAttrsPath));
                                        }

                                        //related entity attrs..only if requested...
                                        if (relToObjectPath_Attrs.length > 0) {
                                            relDetailGetPaths.push(self._mergePathSets(relBasePath, relToObjectPath_Attrs));
                                        }
                                    }
                                    else {
                                        throw "requested range is not available for relationships";
                                    }
                                }
                            }
                        }
                    }

                    if (relDetailGetPaths.length > 0) {
                        paths.push.apply(paths, relDetailGetPaths);
                    }

                    if (paths.length > 0) {
                        var getWithRelResponsePromise = self._makeFalcorGetCall(model, paths);
                        return self._handleModelResponse(request, getWithRelResponsePromise);
                    }
                });
            }
            else {
                return this._makeFalcorGetCall(model, paths);
            }
        },
        _callInitiateSearch: function (model, reqData) {
            var pathKeys = this._pathKeys;
            return model.call([pathKeys.root, this.dataIndex, pathKeys.searchResults, 'create'], [reqData], [], []);
        },
        _callSearchResultDetail: function (model, request) {
            var self = this,
                reqId = request.requestId === undefined ? '' : request.requestId,
                reqData = request.requestData,
                totalRecords = 0;

            if (reqId === '') {
                return {}; // this means do nothing..
            }

            if (this.verbose) {
                this.log('Request Id for get search result detail: ', reqId);
            }

            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var totalRecordsResponse = this._callSearchResultTotalRecordsGet(model, reqId);

            totalRecordsResponse.then(function (totalRecordsPkg) {
                totalRecords = totalRecordsPkg.json[pathKeys.root][dataIndex][pathKeys.searchResults][reqId].totalRecords;

                var from = reqData.params.options && reqData.params.options.from !== undefined ? reqData.params.options.from : 0;
                var to = reqData.params.options && reqData.params.options.to !== undefined ? reqData.params.options.to : totalRecords - 1;

                if (from == -1) {
                    from = 0;
                }
                else if (from >= totalRecords) {
                    from = -1;
                }

                if (to == -1) {
                    to = totalRecords - 1; //todo: return all records..??? how to stop this??
                }

                var to1 = (to + 1) < totalRecords ? to : totalRecords - 1;

                if (from != -1) {
                    var searchResultPath = [pathKeys.root, dataIndex, pathKeys.searchResults, reqId, pathKeys.searchResultItems, [{ 'from': from, 'to': to1 }]];
                    var getByIdsResponse = self._callGetByIds(model, request, searchResultPath);
                    return self._handleModelResponse(request, getByIdsResponse);
                }
                else {
                    var emptyResponse = {
                        'status': 'success',
                        'json': {
                        }
                    };

                    emptyResponse.json[pathKeys.root] = {};
                    emptyResponse.json[pathKeys.root][dataIndex] = {};
                    emptyResponse.json[pathKeys.root][dataIndex][pathKeys.searchResults] = {};
                    emptyResponse.json[pathKeys.root][dataIndex][pathKeys.searchResults][reqId] = {};
                    emptyResponse.json[pathKeys.root][dataIndex][pathKeys.searchResults][reqId][pathKeys.searchResultItems] = {};
                    return self._handleModelResponse(request, emptyResponse);

                    if (self.verbose) {
                        self.log('no search results found for search request id ', reqId);
                    }
                }
            });
        },
        _callSearchResultTotalRecordsGet: function (model, reqId, reqData) {
            var pathKeys = this._pathKeys;
            return model.get([pathKeys.root, this.dataIndex, pathKeys.searchResults, reqId, 'totalRecords']);
        },
        _callSearchResultDataObjectIdsGet: function (model, reqId, from, to) {
            var pathKeys = this._pathKeys;
            return model.get([pathKeys.root, this.dataIndex, pathKeys.searchResults, reqId, pathKeys.searchResultItems, [{ 'from': from, 'to': to }]]);
        },
        _formatData: function (dataIndex, dataObjects) {
            var utils = SharedUtils.DataObjectFalcorUtil;
            var formattedDataObjects = [];

            for (var dataObjectId in dataObjects) {
                var dataObject = dataObjects[dataObjectId];
                var formattedDataObject = utils.transformToExternal(dataObject);
                formattedDataObjects.push(formattedDataObject);
            }

            return formattedDataObjects;
        },
        _getDataObjectTypes: function(reqData) {
            var dataObjectTypes = [];
            if(reqData && reqData.params && reqData.params.query 
                && reqData.params.query.filters && reqData.params.query.filters.typesCriterion
                && reqData.params.query.filters.typesCriterion.length > 0 ) {
                dataObjectTypes = reqData.params.query.filters.typesCriterion;
            }
            
            if(dataObjectTypes.length == 0) {
                dataObjectTypes = [SharedUtils.DataObjectFalcorUtil.CONST_ALL];
            }

            return dataObjectTypes;
        },
        _getDataObjects: function(rawResponsePkg, dataIndex) {
            var pathKeys = this._pathKeys;
            var dataObjects = {};
            var dataByIndex = rawResponsePkg.json[pathKeys.root][this.dataIndex];
            if (dataByIndex) {
                for (var dataObjectType in dataByIndex) {
                    var dataObjectTypeJson = dataByIndex[dataObjectType][pathKeys.byIds];
                    for (var dataObjectId in dataObjectTypeJson) {
                        dataObjects[dataObjectId] = dataObjectTypeJson[dataObjectId];
                    }
                }
            }

            return dataObjects;
        },
        _mergePathSets: function () {
            var mergedPathSets = [];
            var args = Array.prototype.splice.call(arguments, 0);
            var mergedPathSets = Array.prototype.concat.apply([], args);
            return mergedPathSets;
        },
        _makeFalcorGetCall: function (model, paths) {
            return model.get.apply(model, paths);
        },
        _arrayRemove: function (arr, val) {
            var index = -1;

            index = arr.indexOf(val);

            while (index >= 0) {
                arr.splice(index, 1);
                index = arr.indexOf(val);
            }
        },
        _getDataObjectPathKeys: function () {
            return SharedUtils.DataObjectFalcorUtil.getPathKeys();
        },
        log: function () {
            var a = arguments;

            if (typeof console != 'undefined' && console.log) {
                if (console.log.apply) {
                    // It has Function#apply, use it
                    console.log.apply(console, arguments);
                } else {
                    // Ugh, no Function#apply
                    var output2 = '';
                    for (i = 0; i < arguments.length; i++) {
                        output2 += arguments[i] + ' ';
                    }
                    console.log(output2);
                }
            }
        }
    };

    RUFBehaviors.LiquidDataObjectGetBehavior = [RUFBehaviors.LiquidBaseFalcorBehavior, liquidDataObjectGetBehavior];

</script>