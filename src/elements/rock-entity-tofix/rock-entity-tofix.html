<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-merge-helper.html">
<link rel="import" href="../bedrock-externalref-underscore/bedrock-externalref-underscore.html">

<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">

<!--
`<rock-entity-tofix>` Represents an element that displays the errors, warnings, and information 
of an entity as a list.

### Example

    <template is="dom-bind">
        <iron-ajax url="entities.json" last-response="{{response}}" auto></iron-ajax>
		<rock-entity-tofix entities="{{response}}"></rock-entity-tofix>                
	</template>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--entity-tofix-horizontal-divider` | Mixin applied to horizontal divider | {}
`--entity-tofix-container` | Mixin applied to entity item container | {}
`--entity-icon-outer-circle` | Mixin applied to item icon outer circle | {}
`--entity-icon-width` | The width of item icon | 20px
`--entity-icon-height` | The height of item icon | 20px
`--entity-icon-margin` | The margin of item icon | ``
`--error-icon-outer-bg-color` | The outer bg color of error item icon | rgba(251, 96, 103, 1)
`--entity-error-icon-fill-color` | The fill color of error icon | #ffffff
`--entity-error-icon-stroke-color` | The stroke color of error icon | rgba(251, 96, 103, 1)
`--warning-icon-outer-bg-color` | The outer bg color of warning item icon | orange
`--entity-warning-icon-fill-color` | The fill color of warning icon | #ffffff
`--entity-warning-icon-stroke-color` | The stroke color of warning icon | orange
`--info-icon-outer-bg-color` | The outer bg color of info item icon | rgba(22, 180, 252, 1)
`--entity-info-icon-fill-color` | The fill color of info icon | #ffffff
`--entity-info-icon-stroke-color` | The stroke color of info icon | rgba(22, 180, 252, 1)
`--entity-tofix-content` | Mixin applied to entity item content | {}

@group rock Elements
@element rock-entity-tofix
@demo demo/index.html
-->

<dom-module id="rock-entity-tofix">
    <template>
        <style is="custom-style" include="pebble-styles-shared">
            pebble-horizontal-divider {
                height: 1px;
                width: 100%;
                background: var(--divider-color, #c1cad4);
                opacity: 1;
                min-height: 1px;
                max-height: 1px;
                margin-bottom: 5px;
            }

            .tofix-data-container {
                max-height: 250px;
                overflow: auto;
                position: relative;
            }

            .title {
                font-size: var(--default-font-size, 14px);
                color: var(--link-text-color, #036Bc3);
                margin-top: 15px;
                font-weight: 500
            }

            .entity-icon-outer {
                display: inline-block;
                margin-right: 8px;
            }

            .entity-icon-outer pebble-icon {
                margin-top: -1px;
            }

            .entity-content {
                display: inline-block;
                color: var(--secondary-button-text-color, #75808b);
                font-size: var(--font-size-sm, 12px);
            }

            .entity-content.false {
                color: var(--text-primary-color, #1a2028);
            }
        </style>
        <liquid-entity-model-get id="workflowMappingsGet" operation="getbyids" request-id="workflowMappingsGet" on-response="_onWorkflowMappingsGetResponse"
            on-error="_onWorkflowMappingsGetError"></liquid-entity-model-get>

        <liquid-entity-govern-data-get id="entityGovernDataGet" no-cache operation="getbyids" request-id="entityGovernDataGet" on-response="_onEntityGovernDataGetResponse"
            on-error="_onEntityGovernDataGetResponseError"></liquid-entity-govern-data-get>

        <liquid-entity-model-get id="workflowDefintionGet" operation="getbyids" request-id="workflowDefinitionGet" on-response="_onWorkflowDefinitionGetResponse"
            on-error="_onWorkflowDefinitionGetError"></liquid-entity-model-get>

        <liquid-entity-model-get id="ruleContextMappingsGet" operation="getbyids" request-id="ruleContextMappingsGet" on-response="_onRuleContextMappingsGetResponse"
            on-error="_onRuleContextMappingsGetError"></liquid-entity-model-get>

        <liquid-entity-model-get id="businessConditionsGet" operation="getbyids" request-id="businessConditionsGet" on-response="_onBusinessConditionsGetResponse"
            on-error="_onBusinessConditionsGetError"></liquid-entity-model-get>

        <div class="tofix-data-container">
            <pebble-spinner active="[[!_isToFixDataExists]]"></pebble-spinner>
            <template is="dom-if" if="[[_isToFixDataExists]]">
                <template is="dom-repeat" items="[[_tofixData]]" as="tofixItem">
                    <div class="title">[[tofixItem.label]]</div>
                    <pebble-horizontal-divider></pebble-horizontal-divider>
                    <template is="dom-repeat" items="[[tofixItem.businessConditions]]" as="businessCondition">
                        <div class="data-list" data="[[businessCondition]]" on-tap="_onTap">
                            <div class="entity-icon-outer">
                                <pebble-icon icon="[[_getIconByType(businessCondition.status)]]" class="pebble-sm-icons"></pebble-icon>
                            </div>
                            <div class$="entity-content [[businessCondition.status]]">
                                [[businessCondition.name]]
                            </div>
                        </div>
                    </template>
                </template>
            </template>
            <div id="messagePanel" class="message-panel"></div>
        </div>
    </template>
    <script>
        Polymer({
            is: 'rock-entity-tofix',

            properties: {
                contextData: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    'observer': '_contextDataChanged'
                },

                verbose: {
                    type: Boolean,
                    value: false
                },

                _mappedWorkflowNames: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _entityGovernDataWorkflowStatus: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                _entityGovernDataBusinessConditions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _formattedBusinessConditions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _governBusinessConditionNames: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _formattedWorkflowStatus: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _governWorkflowNames: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _formattedWorkflowDefinitions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _contextSpecificBusinessConditions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _globalBusinessConditions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _originalBusinessConditions: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _isToFixDataExists: {
                    type: Boolean,
                    value: false
                },

                _tofixData: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                _errorMessage: {
                    type: String,
                    value: "Error in Loading Component: Please contact your Administrator."
                }
            },

            behaviors: [
                RUFBehaviors.UIBehavior,
                RUFBehaviors.ComponentContextBehavior
            ],

            attached: function () {
                // Use ES6 and Underscore methods whever applicable
                if (!_.isEmpty(this.contextData)) {
                    this.$$("#messagePanel").textContext = "";

                    var workflowMappingsGet = this.$$('#workflowMappingsGet');

                    if (typeof (workflowMappingsGet) === "undefined" ||
                        workflowMappingsGet == null) {
                        console.error("Liquid element having id workflowMappingsGet not found.");
                        this._showMessage(this._errorMessage);
                        return;
                    }

                    // Create Request and Get
                    workflowMappingsGet.requestData = DataRequestHelper.createWorkflowMappingGetRequest(
                        this.contextData);
                    workflowMappingsGet.generateRequest();
                }
            },

            _contextDataChanged: function () {
                if (typeof (this.contextData) !== "undefined" && !_.isEmpty(this.contextData)) {
                    var itemContext = ContextHelper.getFirstItemContext(this.contextData);
                    itemContext.attributeNames = ['_ALL'];
                    itemContext.relationships = [];
                    itemContext.relationshipAttributes = [];
                    this.contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    var valueContext = ContextHelper.getFirstValueContext(this.contextData);
                    valueContext = [];
                    this.contextData[ContextHelper.CONTEXT_TYPE_VALUE] = valueContext;
                }
            },


            _onWorkflowMappingsGetResponse: function (e) {
                var responseContent = this._validateAndGetResponseContent(e.detail.response);

                if (responseContent) {
                    var workflowMappingModels = responseContent.entityModels;

                    // Get Workflows Mapped to the Current EntityType
                    if (workflowMappingModels && workflowMappingModels.length > 0) {
                        var wfDefinitionMappingModel = workflowMappingModels.find(obj => obj.type ==
                            "workflowDefinitionMapping");
                        var wfRelationships = DataMergeHelper.mergeWorkflowMappings(
                            wfDefinitionMappingModel, this.contextData);

                        var mappedWorkflowNames = DataHelper.getRelToNames(wfRelationships.hasWorkflowsDefined);
                        this.set("_mappedWorkflowNames", mappedWorkflowNames);

                        if (this.verbose) {
                            console.info(JSON.stringify({
                                "MappedWorkflowNames": mappedWorkflowNames
                            }));
                        }
                    }

                    // Make Entity Govern Get
                    this._requestEntityGovernData();
                } else {
                    console.error("WorkflowMappingsGetResponseContent not found.");
                    this._showMessage(this._errorMessage);
                }
            },

            _onWorkflowMappingsGetError: function (e) {
                console.error("WorkflowMappingsGetError:- " + e.detail.response.reason.message);
            },


            _requestEntityGovernData: function () {
                var entityGovernDataGet = this.$$('#entityGovernDataGet');

                if (typeof (entityGovernDataGet) === "undefined" ||
                    entityGovernDataGet == null) {
                    console.error("Liquid element having id entityGovernDataGet not found.");
                    this._showMessage(this._errorMessage);
                    return;
                }

                var clonedContextData = DataHelper.cloneObject(this.contextData);

                var itemContext = ContextHelper.getFirstItemContext(clonedContextData);

                // Prepare DataContext
                // This should be optional because entity can be in workflow or cannot be in workflow
                var dataContext = ContextHelper.getFirstDataContext(clonedContextData);
                if (typeof (dataContext) === "undefined") {
                    dataContext = [];
                }

                if (typeof (this._mappedWorkflowNames) !== "undefined" && this._mappedWorkflowNames.length >
                    0) {
                    for (var i = 0; i < this._mappedWorkflowNames.length; i++) {
                        var workflowDataContext = {};
                        workflowDataContext.self = "self/" + itemContext.id;
                        workflowDataContext.workflow = this._mappedWorkflowNames[i];

                        dataContext.push(workflowDataContext);
                    }
                }

                clonedContextData[ContextHelper.CONTEXT_TYPE_DATA] = dataContext;

                // Create Request and Get
                entityGovernDataGet.requestData = DataRequestHelper.createEntityGetRequest(
                    clonedContextData);
                entityGovernDataGet.generateRequest();
            },

            _onEntityGovernDataGetResponse: function (e) {
                var responseContent = this._validateAndGetResponseContent(e.detail.response);

                if (responseContent) {
                    var entities = responseContent.entities;

                    if (typeof (entities) !== "undefined" && entities.length > 0) {
                        this._setGovernDataWorkflowStatus(entities[0]);
                        this._setGovernDataBusinessConditions(entities[0]);

                        this._requestWorkflowDefinition();
                        this._requestBusinessConditions();

                        // Note: Could be optimized.Why to bring all RuleMappings?
                        this._requestRuleContextMappings();
                    }
                } else {
                    console.error("EntityGovernDataGetResponseContent not found.");
                    this._showMessage(this._errorMessage);
                }
            },

            _onEntityGovernDataGetError: function (e) {
                console.error("EntityGovernDataGetError:- " + e.detail.response.reason.message);
                this._showMessage(this._errorMessage);
            },


            _requestWorkflowDefinition: function () {
                if (this._governWorkflowNames.length > 0) {
                    var workflowDefinitionGet = this.$$("#workflowDefintionGet");

                    if (typeof (workflowDefinitionGet) === "undefined" ||
                        workflowDefinitionGet == null) {
                        console.error("Element having id workflowDefinitionGet not found.");
                        this._showMessage(this._errorMessage);
                        return;
                    }

                    var clonedContextData = DataHelper.cloneObject(this.contextData);

                    // Prepare ItemContext 
                    var itemContext = ContextHelper.getFirstItemContext(clonedContextData);
                    itemContext.workflowNames = this._governWorkflowNames; //Get WorkflowNames From Context
                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    // Create Request and Get
                    workflowDefinitionGet.requestData = DataRequestHelper.createWorkflowDefinitionGetRequest(
                        clonedContextData);
                    workflowDefinitionGet.generateRequest();
                }
            },

            _onWorkflowDefinitionGetResponse: function (e) {
                var responseContent = this._validateAndGetResponseContent(e.detail.response);

                if (responseContent) {
                    var workflowDefintions = responseContent.entityModels;

                    if (typeof (workflowDefintions) !== "undefined" && workflowDefintions.length > 0) {
                        for (var i = 0; i < workflowDefintions.length; i++) {
                            var workflowDefinition = workflowDefintions[i];

                            var formattedWorflowDefintion = {};
                            formattedWorflowDefintion["name"] = workflowDefinition.name;
                            formattedWorflowDefintion["attributes"] = workflowDefinition.data.attributes;
                            this.push("_formattedWorkflowDefinitions", formattedWorflowDefintion);
                        }
                    }

                    if (this.verbose) {
                        console.info(JSON.stringify({
                            "FormattedWorkflowDefinitions:- ": this._formattedWorkflowDefinitions
                        }));
                    }

                    this._generateToFixData();

                } else {
                    console.error("EntityGovernDataGetResponse Content not found.");
                }
            },

            _onWorkflowDefinitionGetError: function (e) {
                console.error("Failed to get workflow definition with error: ", e.detail.response.reason.message);
                this._showMessage(this._errorMessage);
            },


            _requestBusinessConditions: function () {
                if (this._governBusinessConditionNames.length) {

                    var businessConditionsGet = this.$$('#businessConditionsGet');
                    if (typeof (businessConditionsGet) === "undefined" || businessConditionsGet == null) {
                        console.log("Element having id businessConditionsGet not found.");
                        this._showMessage(this._errorMessage);
                        return;
                    }

                    var clonedContextData = DataHelper.cloneObject(this.contextData);

                    // Prepare ItemContext
                    var itemContext = ContextHelper.getFirstItemContext(clonedContextData);
                    itemContext.id = this._governBusinessConditionNames;
                    itemContext.type = "businessCondition";
                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    // Create Request and Get
                    businessConditionsGet.requestData = DataRequestHelper.createEntityGetRequest(
                        clonedContextData);
                    businessConditionsGet.generateRequest();
                }
            },

            _onBusinessConditionsGetResponse: function (e) {
                var responseContent = this._validateAndGetResponseContent(e.detail.response);

                if (responseContent) {
                    var businessConditions = responseContent.entityModels;

                    if (typeof (businessConditions) !== "undefined" && businessConditions.length > 0) {
                        for (var i = 0; i < businessConditions.length; i++) {
                            var businessCondition = {};
                            businessCondition["id"] = businessConditions[i].id;
                            businessCondition["name"] = businessConditions[i].name;

                            // LongNames are required for Displaying BusinessConditions
                            var formattedBusinessCondition = this._formattedBusinessConditions.find(
                                businessCondition =>
                                businessCondition.id === businessConditions[i].id);

                            if (formattedBusinessCondition) {
                                formattedBusinessCondition["name"] = businessConditions[i].name;
                            }

                            this.push("_originalBusinessConditions", businessCondition);
                        }
                    }

                    if (this.verbose) {
                        console.info(JSON.stringify({
                            "OriginalBusinessConditions": this._originalBusinessConditions
                        }));
                    }

                    this._generateToFixData();
                } else {
                    console.error("EntityModelGetByIdsResponse Content not found.");
                    this._showMessage(this._errorMessage);
                }
            },

            _onBusinessConditionsGetError: function (e) {
                console.error("EntityModelGetByIdsError:- " + e.detail.response.reason.message);
                this._showMessage(this._errorMessage);
            },


            _requestRuleContextMappings: function () {
                if (this._governWorkflowNames.length > 0 || this._governBusinessConditionNames.length >
                    0) {
                    var ruleContextMappingsGet = this.$$('#ruleContextMappingsGet');

                    if (typeof (ruleContextMappingsGet) === "undefined" ||
                        ruleContextMappingsGet == null) {
                        console.log("Element having id ruleContextMappingsGet not found.");
                        this._showMessage(this._errorMessage);
                        return;
                    }


                    var clonedContextData = DataHelper.cloneObject(this.contextData);

                    // Prepare ItemContext
                    var itemContext = ContextHelper.getFirstItemContext(clonedContextData);
                    var requestedType = "ruleContextMappings";
                    var requestedId = itemContext.type + "_" + requestedType;
                    itemContext.id = requestedId;
                    itemContext.type = requestedType;
                    itemContext.relationships = ["hasBusinessConditions"];
                    itemContext.relationshipAttributes = ['isDeleted', 'enabled', 'stepName'];
                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    // Prepare DataContext
                    // This should be optional because entity can be in workflow or cannot be in workflow
                    var dataContext = ContextHelper.getFirstDataContext(clonedContextData);
                    if (typeof (dataContext) === "undefined") {
                        dataContext = [];
                    }

                    if (this._mappedWorkflowNames.length > 0) {
                        for (var i = 0; i < this._mappedWorkflowNames.length; i++) {
                            var workflowDataContext = {};
                            workflowDataContext.self = "self/" + requestedId;
                            workflowDataContext.workflow = this._mappedWorkflowNames[i];

                            dataContext.push(workflowDataContext);
                        }
                    }

                    clonedContextData[ContextHelper.CONTEXT_TYPE_DATA] = dataContext;


                    // Create Request and Get
                    ruleContextMappingsGet.requestData = DataRequestHelper.createEntityGetRequest(
                        clonedContextData);
                    ruleContextMappingsGet.generateRequest();
                } else {
                    this._showMessage("Nothing to fix!");
                }
            },

            _onRuleContextMappingsGetResponse: function (e) {
                var ruleContextMappingsResponse = e.detail.response;
                var responseContent = this._validateAndGetResponseContent(e.detail.response);

                if (responseContent) {
                    var ruleContextMappings = responseContent.entityModels.length > 0 ? responseContent.entityModels[
                        0].data : undefined;

                    if (this.verbose) {
                        console.log("RuleContextMappings:- " + JSON.stringify(responseContent.entityModels));
                    }

                    if (typeof (ruleContextMappings) !== "undefined" && typeof (ruleContextMappings.contexts) !==
                        "undefined" && ruleContextMappings.contexts.length > 0) {

                        var contextSpecificRuleMaps = ruleContextMappings.contexts;

                        for (var i = 0; i < contextSpecificRuleMaps.length; i++) {
                            var workflowName = contextSpecificRuleMaps[i].context.workflow; // Ask Jimmy: Will this be always workflow
                            var businessConditions = contextSpecificRuleMaps[i].relationships.hasBusinessConditions;

                            var contextSpecificBusinessCondition = {};
                            contextSpecificBusinessCondition["workflowName"] = workflowName;
                            contextSpecificBusinessCondition["businessConditions"] = businessConditions;
                            this.push("_contextSpecificBusinessConditions",
                                contextSpecificBusinessCondition);
                        }

                        if (this.verbose) {
                            console.log(JSON.stringify({
                                "ContextSpecificBusinessConditions:- ": this._contextSpecificBusinessConditions
                            }));
                        }
                    }

                    if (typeof (ruleContextMappings) !== "undefined" && typeof (ruleContextMappings.relationships) !==
                        "undefined") {

                        var globalBusinessConditions = ruleContextMappings.relationships.hasBusinessConditions;

                        if (typeof (globalBusinessConditions) !== "undefined") {
                            for (var j = 0; j < globalBusinessConditions.length; j++) {

                                var globalBusinessCondition = {};
                                globalBusinessCondition["name"] = globalBusinessConditions[j].relTo.id;
                                globalBusinessCondition["attributes"] = globalBusinessConditions[j].attributes;
                                this.push("_globalBusinessConditions", globalBusinessCondition);
                            }

                            if (this.verbose) {
                                console.log(JSON.stringify({
                                    "GlobalBusinessConditions:- ": this._globalBusinessConditions
                                }));
                            }
                        }
                    }

                    this._generateToFixData();
                } else {
                    console.error("RuleContextMappingsGetResponseContent not found.");
                    this._showMessage(this._errorMessage);
                }
            },

            _onRuleContextMappingsGetError: function (e) {
                console.error("RuleContextMappingsGetError:- " + e.detail.response.reason.message);
                this._showMessage(this._errorMessage);
            },


            _setGovernDataWorkflowStatus: function (entityGovernData) {
                if (typeof (entityGovernData) && typeof (entityGovernData.data) !== "undefined" &&
                    typeof (
                        entityGovernData.data.contexts) !== "undefined") {
                    var entityGovernWorkflowContexts = entityGovernData.data.contexts;

                    if (typeof (entityGovernWorkflowContexts) !== "undefined" &&
                        entityGovernWorkflowContexts
                        .length > 0) {
                        this._entityGovernDataWorkflowStatus = entityGovernWorkflowContexts;
                    }


                    var entityGovernDataWorkflowStatus = this._entityGovernDataWorkflowStatus;
                    if (typeof (entityGovernDataWorkflowStatus) !== "undefined" &&
                        entityGovernDataWorkflowStatus.length > 0) {
                        for (var i = 0; i < entityGovernDataWorkflowStatus.length; i++) {
                            var workflowContext = entityGovernDataWorkflowStatus[i].context;
                            var attributes = entityGovernDataWorkflowStatus[i].attributes;

                            if (typeof (workflowContext) !== "undefined" && typeof (attributes) !==
                                "undefined") {

                                var formattedWorkflowData = {
                                    "id": workflowContext.workflow,
                                    "name": workflowContext.workflow,
                                    "attributes": attributes // Workflow Attributes [Also includes activities]
                                }

                                this.push("_governWorkflowNames", workflowContext.workflow); // Should be renamed
                                this.push("_formattedWorkflowStatus", formattedWorkflowData); // Todo.. Name should be changed
                            }
                        }

                        if (this.verbose) {
                            console.info(JSON.stringify({
                                "EntityGovernDataWorkflowStatus": this._entityGovernDataWorkflowStatus
                            }));

                            console.info(JSON.stringify({
                                "FormattedWorkflowStatus": this._formattedWorkflowStatus
                            }));
                        }
                    }
                } else {
                    if (this.verbose) {
                        console.info(
                            "EntityGovernData is not available for EntityGovernDataWorkflowStatus.");
                    }
                }
            },

            _setGovernDataBusinessConditions: function (entityGovernData) {
                if (typeof (entityGovernData) && typeof (entityGovernData.data) !== "undefined" &&
                    typeof (
                        entityGovernData.data.attributes) !== "undefined") {
                    var entityGovernDataAttributes = entityGovernData.data.attributes;

                    if (typeof (entityGovernDataAttributes.businessConditions) !== "undefined" &&
                        typeof (
                            entityGovernDataAttributes.businessConditions.group) !== "undefined") {
                        this._entityGovernDataBusinessConditions = entityGovernDataAttributes.businessConditions
                            .group;
                    }

                    var businessConditions = this._entityGovernDataBusinessConditions;
                    if (typeof (businessConditions) !== "undefined" && businessConditions.length > 0) {
                        for (var i = 0; i < businessConditions.length; i++) {
                            var businessConditionId = AttributeHelper.getFirstAttributeValue(
                                businessConditions[i].businessConditionName);
                            var businessConditionStatus = AttributeHelper.getFirstAttributeValue(
                                businessConditions[i].businessConditionStatus);

                            var formattedBusinessCondition = {
                                "id": businessConditionId,
                                "name": businessConditionId,
                                "status": businessConditionStatus
                            }

                            this.push("_governBusinessConditionNames", businessConditionId); // Should be renamed
                            this.push("_formattedBusinessConditions", formattedBusinessCondition); // Todo.. Name should be changed
                        }

                        if (this.verbose) {
                            console.log(JSON.stringify({
                                "EntityGovernDataBusinessConditions": this._entityGovernDataBusinessConditions
                            }));

                            console.log(JSON.stringify({
                                "FormattedBusinessConditions": this._formattedBusinessConditions
                            }));
                        }
                    }
                } else {
                    if (this.verbose) {
                        console.info(
                            "EntityGovernDataBusinessConditions is not available for EntityGovernDataBusinessConditions."
                        )
                    }
                }
            },


            _generateToFixData: function () {
                if (this._isDataSetPrepared()) {

                    if (this._formattedWorkflowStatus.length > 0) {
                        for (var j = 0; j < this._formattedWorkflowStatus.length; j++) {
                            var workflowData = this._formattedWorkflowStatus[j];
                            workflowData.name = this._getWorkflowNameById(workflowData.id);

                            var workflowActivityNames = this._getWorkflowAcitivityNames(workflowData.attributes);

                            for (var k = 0; k < workflowActivityNames.length; k++) {
                                var tofixWorkflowData = {};
                                var workflowBusinessConditions = [];
                                var globalBusinessConditions = [];
                                var workflowActivityName = workflowActivityNames[k];

                                var workflowLabel = workflowActivityName + " - [" + workflowData.name + "]";
                                tofixWorkflowData["label"] = workflowLabel;
                                tofixWorkflowData["type"] = "Workflow";

                                for (var i = 0; i < this._formattedBusinessConditions.length; i++) {
                                    var businessCondition = this._formattedBusinessConditions[i];

                                    if (DataHelper.containsObject(businessCondition,
                                            workflowBusinessConditions) || DataHelper.containsObject(
                                            businessCondition, globalBusinessConditions)) {

                                        console.info(businessConditionName +
                                            " has already pushed to toFixDataSource");

                                        continue;
                                    }

                                    var isMapped = this._isBusinessConditionMappedToCurrentActivity(
                                        businessCondition.id,
                                        workflowActivityName);

                                    if (isMapped) {
                                        workflowBusinessConditions.push(businessCondition);
                                    } else {
                                        globalBusinessConditions.push(businessCondition);
                                    }
                                }

                                tofixWorkflowData["businessConditions"] = workflowBusinessConditions;
                                this.push("_tofixData", tofixWorkflowData);
                            }

                            this._prepareGlobalToFixData(globalBusinessConditions);
                        }
                    } else {
                        this._prepareGlobalToFixData(this._formattedBusinessConditions);
                    }

                    if (this.verbose) {
                        console.log(JSON.stringify({
                            "ToFixData:- ": this._tofixData
                        }));
                    }

                    this._isToFixDataExists = true;
                }
            },

            _validateAndGetResponseContent: function (responsePkg) {
                // If response package has an issue it should return false
                if (typeof (responsePkg) !== "undefined" &&
                    responsePkg.status == "success") {
                    return responsePkg.content;
                } else {
                    return false;
                }
            },

            _isDataSetPrepared: function () {
                var isWorkflowDefinitionAvailable = false;
                var isGovernDataBCAvailable = false;
                var originalBCAvailable = false;

                if (this._governBusinessConditionNames.length > 0) {

                    if (this._governWorkflowNames.length > 0) {
                        isWorkflowDefinitionAvailable = this._formattedWorkflowDefinitions.length > 0;
                    }

                    isGovernDataBCAvailable = this._contextSpecificBusinessConditions.length > 0 ==
                        0 || this._globalBusinessConditions.length > 0;

                    originalBCAvailable = this._originalBusinessConditions.length > 0;
                }

                if (this._formattedWorkflowDefinitions.length > 0) {
                    return isWorkflowDefinitionAvailable && isGovernDataBCAvailable && originalBCAvailable;
                } else {
                    return isGovernDataBCAvailable && originalBCAvailable;
                }
            },

            _getWorkflowAcitivityNames: function (workflowAttributes) {
                var workflowActivityNames = [];

                if (typeof (workflowAttributes) !== "undefined" && typeof (workflowAttributes.activities) !==
                    "undefined") {

                    var workflowActivities = workflowAttributes.activities;

                    if (typeof (workflowActivities) !== "undefined" && typeof (workflowActivities.group) !==
                        "undefined") {

                        var workflowActivityGroups = workflowActivities.group;

                        for (var i = 0; i < workflowActivityGroups.length; i++) {
                            workflowActivityNames.push(AttributeHelper.getFirstAttributeValue(
                                workflowActivityGroups[i].activityName));
                        }
                    }
                }

                return workflowActivityNames;
            },

            _isBusinessConditionMappedToCurrentActivity: function (businessConditionName, workflowActivityName) {
                var isMapped = false;

                var context = this._contextSpecificBusinessConditions[0]; // Could be Critical?

                for (var i = 0; i < context.businessConditions.length; i++) {
                    var contextSpecificBusinessCondition = context.businessConditions[i];
                    var mappedActivityName = AttributeHelper.getFirstAttributeValue(
                        contextSpecificBusinessCondition.attributes.stepName);

                    if (contextSpecificBusinessCondition.relTo.id == businessConditionName &&
                        mappedActivityName == workflowActivityName) {
                        return isMapped = true;
                    }
                }

                return isMapped;
            },

            _getWorkflowNameById: function (workflowId) {
                for (var i = 0; i < this._formattedWorkflowDefinitions.length; i++) {
                    var workflowDefinition = this._formattedWorkflowDefinitions[i];

                    if (workflowDefinition.name === workflowId) {
                        var workflowAttributes = workflowDefinition.attributes.workflows.group; // To be Changed
                        return AttributeHelper.getFirstAttributeValue(workflowAttributes[0].workflowName);
                    }
                }
            },

            _getBusinessConditionNameById: function (businessConditionId) {
                // Note: Code not used
                // for (var i = 0; i < this._originalBusinessConditions.length; i++) {
                //     var originalBusinessCondition = this._originalBusinessConditions[i];

                //     if (originalBusinessCondition.id === businessConditionId) {
                //         return originalBusinessCondition.name;
                //     }
                // }
            },

            _prepareGlobalToFixData: function (globalBusinessConditions) {
                var tofixGlobalData = {};
                tofixGlobalData["label"] = "General";
                tofixGlobalData["type"] = "Global";
                tofixGlobalData["businessConditions"] = globalBusinessConditions;
                this.push("_tofixData", tofixGlobalData);
            },

            _showMessage: function (message) {
                this.$$("#messagePanel").innerHTML = message;
                this._isToFixDataExists = true;
            },

            _onTap: function (e) {
                var eventDetail = {
                    name: e.currentTarget.data.eventName,
                    data: e.currentTarget.data
                }

                this.firebedrockevent('tofix-item-tap', eventDetail);
            },

            _getIconByType: function (type) {
                if (type == 'false') {
                    return 'pebble-sm-icons:errorcheck';
                } else {
                    return 'pebble-sm-icons:successCheck'
                }
            },

            _isDividerNeeded: function (item, index) {
                if (index != 0 && this.data && this.data.tofixes && item.data.type != this.data.tofixes[
                        index - 1].data.type) {
                    return true;
                }

                return false;
            }
        });
    </script>
</dom-module>