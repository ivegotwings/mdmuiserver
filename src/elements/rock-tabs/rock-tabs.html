<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/iron-pages/iron-pages.html">
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/component-helper.html">

<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<link rel="import" href="../pebble-tab/pebble-tab.html">
<link rel="import" href="../pebble-tab-group/pebble-tab-group.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-styles-app/pebble-styles-app.html">
<link rel="import" href="../pebble-badge/pebble-badge.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<!--
`<rock-tabs>` Represents a wrapper on top of the `<pebble-tab-group>` element. 
It generates the tabs with material design styling based on the given configuration.
It makes it easy to explore and switch between different views or functional aspects of an App. It helps to browse the categorized data sets dynamically.

@demo demo/index.html
-->
<dom-module id="rock-tabs">
    <template>
        <style include="pebble-styles-app">
            /*:host {
                 @apply --rock-tabs;
             }*/
            pebble-horizontal-divider {
                --pebble-horizontal-divider-color: var(--border-black, #000);
            }

            pebble-tab {
                margin-right: 25px;
                margin-left: 20px;
                overflow: inherit;
                @apply --tab-error-circle;
            }

            pebble-tab:last-of-type {
                margin-right: 0;
            }

            iron-icon {
                margin-right: var(--tab-icon-spacing, 0.5em);
            }

            paper-listbox iron-icon {
                --iron-icon-height: 20px;
                --iron-icon-width: 20px;
                margin-right: 10px;
            }

            pebble-tab .dropdown-content {
                box-sizing: border-box;
                position: fixed;
                max-height: 250px;
                overflow: auto;
                padding: 10px 0px;
                font-size: var(--default-font-size, 14px);
                color: var(--pebble-popover-text-color, #000000);
            }

            pebble-tab .dropdown-content paper-item {
                padding: 0px 20px;
            }

            paper-listbox {
                @apply --common-popup;
                margin-top: var(--default-tab-height, 38px);
            }

            .tab-subtitle {
                font-size: var(--font-size-sm, 12px);
                font-weight: var(--font-regular, 400);
                position: absolute;
                top: var(--subtitle-abs-position, -4px);
            }

            .iron-selected .tab-subtitle {
                color: var(--palette-cerulean, #036bc3);
            }

            .tab-subtitle-wrapper>pebble-badge {
                --pebble-badge-margin-left: 2%;
                --pebble-badge-margin-bottom: 1%;
            }

            .tab-title iron-icon {
                width: var(--tab-icon-dimension, 18px);
                height: var(--tab-icon-dimension, 18px);
            }

            .hide-element {
                display: none;
            }

            .truncate {
                width: 75px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                font-weight: var(--font-bold, bold);
            }

            pebble-tab[class="iron-selected"] .truncate,
            pebble-tab .truncate:hover {
                color: var(--palette-cerulean, #036bc3)
            }

            paper-item {
                /* this can be moved if paper item is moved inside the pebble tab*/
                --paper-item-min-height: 30px;
                --paper-item-selected-weight: bold;
                --paper-item: {
                    font-size: var(--default-font-size, 14px);
                    color: var(--color-steal-grey, #75808b);
                }
            }

            .tab-content {
                height: calc(100% - 37px);
                @apply --rock-tab-content;
            }
            /*IE 11 fix for paper-item alignment on hover of an element*/

            /*paper-item {
                height: 1px;
            }*/
            pebble-tab-group{
                margin-bottom:20px;
                @apply --pebble-tab-group;
            }
            pebble-tab{
                @apply --pebble-tab;
            }            
        </style>
        <div id="menuProviders" hidden></div>
        <pebble-tab-group id$="{{id}}" selected="{{selectedTabIndex}}" on-iron-select="_onIronSelect" on-iron-deselect="_onIronDeselect"
            noink>           
        <template is="dom-repeat" items="[[_calculatedTabItems]]" as="tabItem">
                <pebble-tab id="[[tabItem.name]]" display-menu="[[arrayItem(_calculatedTabItems.*, index, 'enableDropdownMenu')]]" tab-config="{{tabItem}}">
                    <div class="tab-title-content" slot="tab-title-content">
                        <div class="tab-subtitle" slot="tab-subtitle">
                            <span class="tab-subtitle-content truncate">[[tabItem.subtitle]]</span>
                        </div>
                        <div class="tab-badge" slot="tab-badge">
                            <pebble-badge hidden></pebble-badge>
                        </div>
                        <div class="tab-title" slot="tab-title">
                            <template is="dom-if" if="[[tabItem.icon]]">
                                <iron-icon icon="[[tabItem.icon]]"></iron-icon>
                            </template>
                            <span class="truncate">[[_temp(tabItem.title)]]</span>
                        </div>
                    </div>
                    
                    <paper-listbox slot="list" class="dropdown-content">
                        <template is="dom-repeat" items="[[arrayItem(_calculatedTabItems.*, index, 'menuItems')]]" as="menuItem">
                            <template is="dom-if" if="[[!_isDivider(menuItem)]]">
                                <paper-item id="[[tabItem.name]]-[[menuItem.name]]" tab-config="[[tabItem]]" menu-item-config="[[menuItem]]">
                                    <!--<iron-icon icon="[[menuItem.icon]]"></iron-icon>-->
                                    [[menuItem.title]]
                                </paper-item>
                            </template>
                            <template is="dom-if" if="[[_isDivider(menuItem)]]">
                                <pebble-horizontal-divider></pebble-horizontal-divider>
                            </template>
                        </template>
                    </paper-listbox>
                </pebble-tab>
            </template>            
        </pebble-tab-group>       
        <template is="dom-repeat" items="[[_calculatedTabItems]]" as="tabItemContent">
            <div id="content-[[tabItemContent.name]]" hidden class="tab-content"></div>
            <template is="dom-if" if="[[tabItemContent]]">
                <template is="dom-repeat" items="[[arrayItem(_calculatedTabItems.*, index, 'menuItems')]]" as="menuItemContent">
                    <template is="dom-if" if="[[!_isDivider(menuItemContent)]]">
                        <div id="content-[[tabItemContent.name]]-[[menuItemContent.name]]" class="tab-content" hidden></div>
                    </template>
                </template>
            </template>
        </template>       
        <bedrock-pubsub event-name="selection-changed" handler="_onSelectionChange" target-id=""></bedrock-pubsub>
    </template>
    <script>
        // (function () {
        //     'use strict';

            Polymer({
                is:"rock-tabs",
                properties: {
                    
                    /**
                     * Indicates the unique identification string of an `element`.
                     */
                    id: {
                        type: String,
                        notify: true
                    },

                    /**
                     * Indicates the configuration of an `element`.
                     */
                    config: {
                        type: Object,
                        observer: '_configChanged',
                        value: function () {
                            return {};
                        }
                    },
                    _calculatedTabItems: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    /**
                     * Indicates the selected index of a tab.
                     */
                    selectedTabIndex: {
                        type: Number,
                        reflectToAttribute: true,
                        notify: true
                    },

                    _currentTabName: {
                        type: String
                    },

                    /**
                     * Indicates the selected tab's configuration.
                     */
                    selectedTab: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },

                    _currentTabErrorLength: {
                        type: Number,
                        value: 0,
                        notify: true,
                        observer: '_errorLengthChanged'
                    },

                    _selectedTabConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    }
                },
                behaviors: [
                    RUFBehaviors.UIBehavior
                ],

                /*
                 * Can be used to get the value of a badge for the `tab-name` that the user specified.
                 */
                getTabByName: function (tabName) {
                    var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                    if (pebbleTabGroup) {
                        return pebbleTabGroup.querySelector("#" + tabName);
                    }
                },

                /*
                 * Can be used to set the value of a badge for the `tab-name` that the user specified.
                 */
                setBadgeValue: function (tabName, value) {
                    var self = this;
                    var tab = self.shadowRoot.querySelector("#" + this.id).querySelector("#" + tabName);
                    if (tab) {
                        var badge = tab.querySelector("pebble-badge");
                        if (badge && value) {
                            badge.label = value;
                            self.toggleBadge(tab, true);
                        } else {
                            self.toggleBadge(tab, false);
                        }
                    } else {
                        this.logWarning("TabNameError","tabName",tabName);
                    }
                },

                /*
                 * Can be used to return the value of a badge for the `tab-name` that the user specified.
                 */
                getBadgeValue: function (tabName) {
                    var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                    if (pebbleTabGroup) {
                        var tab = pebbleTabGroup.querySelector("#" + tabName);
                        if (tab) {
                            var badge = tab.querySelector("pebble-badge");
                            if (badge) {
                                return badge.label;
                            }
                        } else {
                            this.logWarning("TabNameError","tabName",tabName);
                        }
                    }
                },

                /*
                 * Can be used to toggle the display value of the badge element.
                 */
                toggleBadge: function (tab, showHide) {
                    if (tab) {
                        var badge = tab.querySelector("pebble-badge");
                        if (badge) {
                            if (showHide) {
                                badge.removeAttribute("hidden");
                            } else {
                                badge.setAttribute("hidden", "");
                            }
                        } else {
                            this.logWarning("PebbleBadgeError");
                        }
                    } else {
                        this.logWarning("TabNameError","tabName",tabName);
                    }
                },

                _configChanged: function (config) {
                    if (config != null && config != undefined) {
                        if (config.tabItems) {
                            var tabItems = config.tabItems;
                            if (tabItems != null && tabItems != undefined && tabItems.length > 0) {
                                for (var tabItemIndex in tabItems) {
                                    var tabItem = tabItems[tabItemIndex];
                                    tabItem.index = tabItemIndex;
                                    if (tabItem.selected) {
                                        this.selectedTabIndex = tabItemIndex;
                                    }
                                }
                            }

                            this._calculatedTabItems = DataHelper.cloneObject(tabItems);
                            for (var tabItemIndex in this._calculatedTabItems) {
                                var tabItem = this._calculatedTabItems[tabItemIndex];
                                //fill menuitems auto
                                this._fillMenuItems(tabItem);
                            }
                        }

                        var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                        if (pebbleTabGroup) {
                            if (config.scrollable) {
                                pebbleTabGroup.scrollable = true;
                            } else {
                                pebbleTabGroup.setAttribute("fitContainer", "");
                            }
                        }
                    }
                },

                _fillMenuItems: function (tabItem) {
                    var menuProviders = this.$.menuProviders;
                    if (tabItem.menuProviderComponent) {
                        Object.keys(tabItem.component.properties).map(function (tabComponentProperty) {
                            tabItem.menuProviderComponent.properties[tabComponentProperty] = tabItem.component.properties[tabComponentProperty];
                        });
                        ComponentHelper.loadContent(menuProviders, tabItem.menuProviderComponent, this, this._menuProviderCreated.bind(this, tabItem));
                    } else {
                        setTimeout(() =>{
                            if (tabItem.menuItems && tabItem.menuItems instanceof Array && tabItem.menuItems.length > 0) {
                                if (tabItem.selected) {
                                    Polymer.dom.flush();
                                    this._setSelectedMenuItem(tabItem);
                                }
                            }
                        }, 2000);
                    }
                },

                _menuProviderCreated: function (tabItem, menuProviderElement) {
                    if (menuProviderElement) {
                        if (tabItem && menuProviderElement.getMenu) {
                            Polymer.Async.microTask.run(() =>
                                menuProviderElement.getMenu(tabItem, this._menuProviderCallback.bind(this, tabItem))
                            );
                        }
                    }
                },

                _menuProviderCallback: function (tabItem, menuItems) {
                    //console.log("_menuProviderCallback tabItem.name: ", tabItem.name, " menuItems.length :", menuItems.length );
                    if (tabItem) {
                        this.set('_calculatedTabItems.' + tabItem.index, tabItem);
                        if (menuItems && menuItems.length > 0) {
                            var origCount = 0;
                            if (tabItem.menuItems) {
                                origCount = tabItem.menuItems.length;
                                tabItem.menuItems.forEach(function (item) {
                                    menuItems.push(item);
                                }, this);
                            }
                            if (menuItems.length > 0) {
                                this.set('_calculatedTabItems.' + tabItem.index + ".enableDropdownMenu", true);
                                this.set('_calculatedTabItems.' + tabItem.index + ".menuItems", menuItems);
                                if (tabItem.selected) {
                                    this._setSelectedMenuItem(tabItem);
                                }
                            }
                        } else {
                            this.set('_calculatedTabItems.' + tabItem.index + ".enableDropdownMenu", false);
                        }
                    }
                },

                _isDivider: function (item) {
                    return item.name == "divider";
                },

                //Clear tab errors on de-select
                _onIronDeselect: function (e) {
                    var tabName = e.detail.item.tabConfig.name;
                    var currentItem = this.shadowRoot.querySelector("#" + this.id).querySelector("#" + tabName);
                    var errorCircle = currentItem.shadowRoot.querySelector(".error-circle");
                    errorCircle.hidden = true;
                    errorCircle.textContent = "";
                },

                _onIronSelect: function (e) {
                    this._currentTabErrorLength = 0; //reset errors
                    if (e && e.detail && e.detail.item) {
                        // Capturing selected tab configuration
                        var tabConfig = this.selectedTab = e.detail.item.tabConfig;
                        var menuItemConfig = e.detail.item.menuItemConfig;
                        var subTitle = tabConfig.subtitle == undefined ? "" : tabConfig.subtitle;

                        //Capturing for Quick Manage, reload tab with this configuration
                        this._selectedTabConfig = {
                            "tabConfig": tabConfig,
                            "menuItemConfig": menuItemConfig,
                            "subTitle": subTitle
                        };

                        if (tabConfig && menuItemConfig) {
                            subTitle = menuItemConfig.title;
                            this._loadContent(menuItemConfig, tabConfig.name);
                            this._resetSubTitles(tabConfig,subTitle);
                        } else {
                            if (!this.shadowRoot.querySelector("#" + this.id)._isMenuIconClicked) {
                                this._loadContent(tabConfig);
                                this._resetSubTitles(tabConfig,subTitle);
                            }
                        }
                        if (subTitle) {
                            this._applyMargin(tabConfig.name, true);
                        } else {
                            this._applyMargin(tabConfig.name, false);
                        }
                    }
                },

                _resetSubTitles: function (currentTabConfig,subtitle) {
                    var tabsConfig = this.config.tabItems;
                    var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);

                    if (tabsConfig && pebbleTabGroup) {
                        for (var index in tabsConfig) {
                            var tabConfig = tabsConfig[index];
                            var tab = pebbleTabGroup.querySelector("#" + tabConfig.name);

                            if (tab) {
                                var tabSubTtile = tab.querySelector(".tab-subtitle-content");
                                if (tabConfig && tabSubTtile) {
                                    if(currentTabConfig.name==tab.id){
                                        tabSubTtile.textContent = subtitle?subtitle:"";
                                    }else{
                                        tabSubTtile.textContent = "";
                                    }
                                }
                                var menu = tab.querySelector("paper-listbox");
                                if (currentTabConfig.name !== tab.id && menu && menu.selected >= 0) {
                                    menu.selected = -1;
                                }
                            }
                        }
                    }
                },

                _loadContent: function (config, tabName) {
                    if (config) {
                        var viewName = config.name;
                        viewName = tabName ? tabName + '-' + viewName : viewName;
                        var contentElement = this.shadowRoot.querySelector("#content-" + viewName);

                        if (config.component) {
                            ComponentHelper.loadContent(contentElement, config.component, this);
                            this._showView(viewName);
                            if (this._currentTabName && this._currentTabName != viewName) {
                                this._hideView(this._currentTabName);
                            }
                            this._currentTabName = viewName;
                        }

                        if (config.errorLength) {
                            this._updateErrorVis(config.errorLength);
                        } else {
                            this._updateErrorVis(0);
                        }
                    } else {
                        this.logWarning("TabConfig");
                    }
                },

                _showView: function (viewName) {
                    if (viewName) {
                        var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.removeAttribute("hidden");
                        }
                    }
                },

                _hideView: function (viewName) {
                    if (viewName) {
                        var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.setAttribute("hidden", "");
                        }
                    }
                },

                _applyMargin: function (tabName, apply) {
                    var tab = this.getTabByName(tabName);

                    if (tab) {
                        var dropdownWrapper = tab.querySelector("#dropdown-wrapper");

                        if (dropdownWrapper && apply) {
                            if (apply) {
                                dropdownWrapper.style.marginTop = "2%";
                            } else {
                                dropdownWrapper.style.marginTop = "0%";
                            }
                        }
                    }
                },
                /**
                * Can be used to reload the current tab content.
                */
                reloadCurrentTab: function (isReloadByConfig) {
                    //to reload the current selected tab after any changes to tabItemConfig
                    //no inputs to this method. Find out the current selected tab and call _loadContent()
                    if(!this.shadowRoot) {
                        return;
                    }
                    var currentElement = this.shadowRoot.querySelector("#" + this.id);
                    
                    if(!currentElement) {
                        return;
                    }

                    var currentItem = currentElement.selectedItem;

                    if (isReloadByConfig && this._selectedTabConfig.tabConfig) {
                        var currentTabConfig = this._selectedTabConfig.tabConfig;
                        var currentTabMenuConfig = this._selectedTabConfig.menuItemConfig;
                    }
                    else if (currentItem) {
                        var currentTabConfig = currentItem.tabConfig;
                        var menu = currentItem.querySelector('paper-listbox');
                        var currentMenuItem;
                        var currentTabMenuConfig;
                        if (menu) {
                            currentMenuItem = menu.selectedItem;
                        }
                        if (currentMenuItem) {
                            currentTabMenuConfig = currentMenuItem.menuItemConfig;
                        }

                        // Work Around: When user is reloading tab but currentMenuItem is not mataching
                        //              with the one which is displayed to the user
                        if (currentTabConfig.name !== this._selectedTabConfig.tabConfig.name) {
                            currentTabConfig = this._selectedTabConfig.tabConfig;
                            currentTabMenuConfig = this._selectedTabConfig.menuItemConfig;
                        }
                    }

                    if (currentTabConfig && currentTabMenuConfig) {
                        this._loadContent(currentTabMenuConfig, currentTabConfig.name);
                    } else {
                        this._loadContent(currentTabConfig, null);
                    }
                },
                /**
                * Can be used to reload all tabs of a component.
                */
                reloadTabs: function () {
                    if (this.config && this.config.tabItems && this.config.tabItems.length > 0) {
                        var tabItems = DataHelper.cloneObject(this.config.tabItems);
                        for (var i = 0; i < tabItems.length; i++) {
                            var tabItem = tabItems[i];
                            var tabName = tabItem.name;
                            var contentElement = this.shadowRoot.querySelector('#content-' + tabName);
                            var contentTab = this.shadowRoot.querySelector('pebble-tab[id=' + tabName + ']');
                            if (contentTab) {
                                contentTab.tabConfig = tabItem;
                            }
                            if (contentElement && contentElement.firstChild) {
                                Polymer.dom(contentElement).removeChild(contentElement.firstChild);
                            }
                            if (tabItem.menuItems && tabItem.menuItems.length > 0) {
                                for (var j = 0; j < tabItem.menuItems.length; j++) {
                                    var meuItemName = tabItem.menuItems[j].name;
                                    var menuContentElement = this.shadowRoot.querySelector('#content-' + tabName + '-' +
                                        meuItemName);
                                    if (menuContentElement && menuContentElement.firstChild) {
                                        Polymer.dom(menuContentElement).removeChild(menuContentElement.firstChild);
                                    }
                                }
                            }
                            this._fillMenuItems(tabItem);
                        }
                    }

                    this.reloadCurrentTab();
                },
                _onSelectionChange: function (e, detail, sender) {
                    var isDirty = this.getIsDirty();
                    if (isDirty) {
                        this._showWarning(e);
                    }
                },
                /**
                * Can be used to get whether the current tab content is dirty or not.
                */
                getIsDirty: function () {
                    if (this._currentTabName) {
                        var content = this.shadowRoot.querySelector('#content-' + this._currentTabName);
                        if (content && content.firstChild && content.firstChild.getIsDirty) {
                            var isTabDirty = content.firstChild.getIsDirty();
                            return isTabDirty;
                        }
                    }
                },
                _showWarning: function (event) {
                    if (!window.confirm(
                        "There are unsaved changes. Do you want to discard the changes?")) {
                        event.preventDefault();
                    }
                },
                _errorLengthChanged: function (errorLength) {
                    var currentItem = this.shadowRoot.querySelector("#" + this.id).querySelector("#" + this._currentTabName);
                    if (currentItem) {
                        var currentTabConfig = currentItem.tabConfig;
                        var currentTabMenuConfig = currentItem.menuItemConfig;
                        if (currentTabConfig && currentTabMenuConfig) {
                            currentTabMenuConfig.errorLength = errorLength;
                        } else {
                            currentTabConfig.errorLength = errorLength;
                        }
                        this._updateErrorVis(errorLength);
                    }
                },
                _updateErrorVis: function (errorLength) {
                    var currentItem = this.shadowRoot.querySelector("#" + this.id).selectedItem;
                    var errorCircle = currentItem.shadowRoot.querySelector(".error-circle");
                    if (errorLength > 0) {
                        errorCircle.hidden = false;
                        errorCircle.textContent = errorLength;
                    } else {
                        errorCircle.hidden = true;
                        errorCircle.textContent = "";
                    }
                },
                _temp: function (x) {
                    return x;
                },
                arrayItem: function (change, index, path) {
                    return this.get(path, change.base[index]);
                },

                _setSelectedMenuItem: function (tabItem) {
                    var currentTab = this.shadowRoot.querySelector("#" + tabItem.name);
                    if (currentTab) {
                        var currentTabMenu = currentTab.querySelector("paper-listbox");
                        if (currentTabMenu) {
                            var selectedMenuIndex = this._getTabSelectedMenuIndex(tabItem);
                            if(selectedMenuIndex >= 0) {
                                currentTabMenu.selected = selectedMenuIndex;
                            }
                        }
                    }
                },

                _getTabSelectedMenuIndex: function (tabItem) {
                    var tabMenuIndex = -1;

                    if (tabItem) {
                        var menuItems = tabItem.menuItems;
                        if (menuItems && menuItems.length > 0) {
                            for (var i = 0; i < menuItems.length; i++) {
                                if (menuItems[i].selected) {
                                    tabMenuIndex = i;
                                }
                            }
                        }
                    }

                    return tabMenuIndex;
                }
            });
        // })();
    </script>
</dom-module>