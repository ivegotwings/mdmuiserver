<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/iron-pages/iron-pages.html">
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../bower_components/paper-menu/paper-menu.html">
<link rel="import" href="../../../bower_components/paper-item/paper-item.html">
<link rel="import" href="../../../bower_components/paper-listbox/paper-listbox.html">

<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/component-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-styles-scroll-bar.html" />
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<link rel="import" href="../pebble-tab/pebble-tab.html">
<link rel="import" href="../pebble-tab-group/pebble-tab-group.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-badge/pebble-badge.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<!--
`<rock-tabs>` Represents a wrapper on top of the `<pebble-tab-group>` element. 
It generates the tabs with material design styling based on the given configuration.
It makes it easy to explore and switch between different views or functional aspects of an App. It helps to browse the categorized data sets dynamically.

@demo demo/index.html
-->
<dom-module id="rock-tabs">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            /*:host {
                 @apply --rock-tabs;
             }*/

            pebble-horizontal-divider {
                --pebble-horizontal-divider-color: var(--border-black, #000);
            }

            pebble-tab {
                margin-right: 25px;
                overflow: inherit;
                @apply --tab-error-circle;
            }

            pebble-tab:last-of-type {
                margin-right: 0;
            }

            iron-icon {
                margin-right: var(--tab-icon-spacing, 0.5em);
            }

            paper-listbox iron-icon {
                --iron-icon-height: 20px;
                --iron-icon-width: 20px;
                margin-right: 10px;
            }

            pebble-tab .dropdown-content {
                box-sizing: border-box;
                position: fixed;
                max-height: 250px;
                overflow: auto;
                padding: 10px 0px;
                font-size: var(--default-font-size, 14px);
                color: var(--primary-text-color, #212121);
            }

            pebble-tab .dropdown-content paper-item {
                padding: 0px 20px;
                font-size: 14px;
            }

            pebble-tab .dropdown-content paper-item:hover {
                background-color: var(--bgColor-hover, #e8f4f9);
                color: var(--focused-line, #026bc3);
            }

            pebble-tab .dropdown-content paper-item:focus {
                color: var(--primary-button-color, #036bc3);
                background-color: var(--bgColor-hover, #e8f4f9);
            }

            paper-listbox {
                @apply --common-popup;
                margin-top: var(--default-tab-height, 38px);
            }

            .tab-subtitle {
                font-size: var(--font-size-sm, 12px);
                font-weight: var(--font-regular, 400);
                position: absolute;
                top: var(--subtitle-abs-position, -4px);
            }

            .iron-selected .tab-subtitle {
                color: var(--palette-cerulean, #036bc3);
            }

            .tab-subtitle-wrapper>pebble-badge {
                --pebble-badge-margin-left: 2%;
                --pebble-badge-margin-bottom: 1%;
            }

            .tab-title iron-icon {
                width: var(--tab-icon-dimension, 18px);
                height: var(--tab-icon-dimension, 18px);
            }

            .hide-element {
                display: none;
            }

            .truncate {
                width: 75px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                font-weight: var(--font-bold, bold);
            }

            pebble-tab[class="iron-selected"] .truncate,
            pebble-tab .truncate:hover {
                color: var(--palette-cerulean, #036bc3)
            }

            paper-item {
                /* this can be moved if paper item is moved inside the pebble tab*/
                --paper-item-min-height: 30px;
                --paper-item-selected-weight: bold;
                --paper-item: {
                    font-size: var(--default-font-size, 14px);
                    color: var(--color-steal-grey, #75808b);
                }
                ;
            }

            .tab-content {
                height: calc(100% - 37px);
                @apply --rock-tab-content;
            }

            /* IE edge specific fix for .tab-content */

            _:-ms-lang(x),
            _:-webkit-full-screen,
            .tab-content {
                height: auto;
            }

            /*IE 11 fix for paper-item alignment on hover of an element*/

            /*paper-item {
                height: 1px;
            }*/

            pebble-tab-group {
                margin-bottom: 20px;
                @apply --pebble-tab-group;
            }

            pebble-tab {
                height: 40px;
                @apply --pebble-tab;
            }

            pebble-tab-group#rockTabs pebble-tab {
                margin-left: 20px;
            }

            pebble-tab-group#rockTabs {
                margin-bottom: 0px;
            }

            #content-relationships {
                padding-top: 0;
                padding-right: 0;
                padding-bottom: 0;
                padding-left: 0;
            }

            #content-entity-family {
                padding-top: 20px;
                padding-right: 20px;
                padding-bottom: 20px;
                padding-left: 20px;
            }
        </style>
        <div id="menuProviders" hidden></div>
        <pebble-tab-group id$="{{id}}" selected="{{selectedTabIndex}}" on-iron-select="_onIronSelect" on-iron-deselect="_onIronDeselect"
            noink>
            <template is="dom-repeat" items="[[_calculatedTabItems]]" as="tabItem">
                <pebble-tab id="[[tabItem.name]]" display-menu="[[arrayItem(_calculatedTabItems.*, index, 'enableDropdownMenu')]]" tab-config="{{tabItem}}">
                    <div class="tab-title-content" slot="tab-title-content">
                        <div class="tab-subtitle" slot="tab-subtitle">
                            <span class="tab-subtitle-content truncate">[[tabItem.subtitle]]</span>
                        </div>
                        <div class="tab-badge" slot="tab-badge">
                            <pebble-badge hidden></pebble-badge>
                        </div>
                        <div class="tab-title" slot="tab-title">
                            <template is="dom-if" if="[[tabItem.icon]]">
                                <iron-icon icon="[[tabItem.icon]]"></iron-icon>
                            </template>
                            <span class="truncate">[[_temp(tabItem.title)]]</span>
                        </div>
                    </div>

                    <paper-listbox slot="list" class="dropdown-content">
                        <template is="dom-repeat" items="[[arrayItem(_calculatedTabItems.*, index, 'menuItems')]]" as="menuItem">
                            <template is="dom-if" if="[[!_isDivider(menuItem)]]">
                                <paper-item id="[[tabItem.name]]-[[menuItem.name]]" tab-config="[[tabItem]]" menu-item-config="[[menuItem]]">
                                    <!--<iron-icon icon="[[menuItem.icon]]"></iron-icon>-->
                                    [[menuItem.title]]
                                </paper-item>
                            </template>
                            <template is="dom-if" if="[[_isDivider(menuItem)]]">
                                <pebble-horizontal-divider></pebble-horizontal-divider>
                            </template>
                        </template>
                    </paper-listbox>
                </pebble-tab>
            </template>
        </pebble-tab-group>
        <template is="dom-repeat" items="[[_calculatedTabItems]]" as="tabItemContent">
            <div id="content-[[tabItemContent.name]]" hidden class="tab-content"></div>
            <template is="dom-if" if="[[tabItemContent]]">
                <template is="dom-repeat" items="[[arrayItem(_calculatedTabItems.*, index, 'menuItems')]]" as="menuItemContent">
                    <template is="dom-if" if="[[!_isDivider(menuItemContent)]]">
                        <div id="content-[[tabItemContent.name]]-[[menuItemContent.name]]" class="tab-content" hidden></div>
                    </template>
                </template>
            </template>
        </template>
        <bedrock-pubsub event-name="selection-changed" handler="_onSelectionChange" target-id=""></bedrock-pubsub>
    </template>
    <script>
        // (function () {
        //     'use strict';

        Polymer({
            is: "rock-tabs",
            properties: {

                /**
                 * Indicates the unique identification string of an `element`.
                 */
                id: {
                    type: String,
                    notify: true
                },

                loadOnConfigChange: {
                    type: Boolean,
                    value: false
                },

                /**
                 * If set as true , it indicates the component is in read only mode
                 */
                readonly: {
                    type: Boolean,
                    value: false,
                    observer: '_onReadonly'
                },
                /**
                 * Indicates the configuration of an `element`.
                 */
                config: {
                    type: Object,
                    observer: '_configChanged'
                },
                _calculatedTabItems: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },

                /**
                 * Indicates the selected index of a tab.
                 */
                selectedTabIndex: {
                    type: Number,
                    reflectToAttribute: true,
                    notify: true
                },

                _currentTabName: {
                    type: String
                },

                /**
                 * Indicates the selected tab's configuration.
                 */
                selectedTab: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },

                _currentTabErrorLength: {
                    type: Number,
                    value: 0,
                    notify: true,
                    observer: '_errorLengthChanged'
                },

                _selectedTabConfig: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },

                viewMode: {
                        type:String,
                        value:""
                }
            },
            behaviors: [
                RUFBehaviors.UIBehavior
            ],

            /*
             * Can be used to get the value of a badge for the `tab-name` that the user specified.
             */
            getTabByName: function (tabName) {
                var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                if (pebbleTabGroup) {
                    return pebbleTabGroup.querySelector("#" + tabName);
                }
            },

            _tabChange: function (activeTab) {
                if (activeTab) {
                    ComponentHelper.fireBedrockEvent("tabs-change", activeTab, { ignoreId: true });
                }
            },
            /*
             * Can be used to set the value of a badge for the `tab-name` that the user specified.
             */
            setBadgeValue: function (tabName, value) {
                var self = this;
                var tab = self.shadowRoot.querySelector("#" + this.id).querySelector("#" + tabName);
                if (tab) {
                    var badge = tab.querySelector("pebble-badge");
                    if (badge && value) {
                        badge.label = value;
                        self.toggleBadge(tab, true);
                    } else {
                        self.toggleBadge(tab, false);
                    }
                } else {
                    this.logWarning("TabNameError", "tabName", tabName);
                }
            },

            /*
             * Can be used to return the value of a badge for the `tab-name` that the user specified.
             */
            getBadgeValue: function (tabName) {
                var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                if (pebbleTabGroup) {
                    var tab = pebbleTabGroup.querySelector("#" + tabName);
                    if (tab) {
                        var badge = tab.querySelector("pebble-badge");
                        if (badge) {
                            return badge.label;
                        }
                    } else {
                        this.logWarning("TabNameError", "tabName", tabName);
                    }
                }
            },

            /*
             * Can be used to toggle the display value of the badge element.
             */
            toggleBadge: function (tab, showHide) {
                if (tab) {
                    var badge = tab.querySelector("pebble-badge");
                    if (badge) {
                        if (showHide) {
                            badge.removeAttribute("hidden");
                        } else {
                            badge.setAttribute("hidden", "");
                        }
                    } else {
                        this.logWarning("PebbleBadgeError");
                    }
                } else {
                    this.logWarning("TabNameError", "tabName", tabName);
                }
            },

            _configChanged: function (config) {
                if (config != null && config != undefined) {
                    if (config.tabItems) {
                        var tabItems = config.tabItems;
                        if (tabItems != null && tabItems != undefined && tabItems.length > 0) {
                            for (var tabItemIndex in tabItems) {
                                var tabItem = tabItems[tabItemIndex];
                                tabItem.index = tabItemIndex;
                                if (tabItem.selected) {
                                    this.selectedTabIndex = tabItemIndex;
                                }
                            }
                        }
                        
                        this._calculatedTabItems = DataHelper.cloneObject(tabItems);
                        for (var tabItemIndex in this._calculatedTabItems) {
                            var tabItem = this._calculatedTabItems[tabItemIndex];
                            //fill menuitems auto
                            if(this.loadOnConfigChange)
                                this._fillMenuItems(tabItem);
                        }
                    }

                    var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);
                    if (pebbleTabGroup) {
                        if (config.scrollable) {
                            pebbleTabGroup.scrollable = true;
                        } else {
                            pebbleTabGroup.setAttribute("fitContainer", "");
                        }
                    }
                }
            },

            _fillMenuItems: function (tabItem) {
                var menuProviders = this.$.menuProviders;
                if (tabItem.menuProviderComponent) {
                    Object.keys(tabItem.component.properties).map(function (tabComponentProperty) {
                        tabItem.menuProviderComponent.properties[tabComponentProperty] = tabItem.component.properties[tabComponentProperty];
                    });
                    ComponentHelper.loadContent(menuProviders, tabItem.menuProviderComponent, this, this._menuProviderCreated.bind(this, tabItem));
                } else {
                    setTimeout(() => {
                        if (tabItem.selected || tabItem.name == this.selectedTab.name) {
                            if (tabItem.menuItems && tabItem.menuItems instanceof Array && tabItem.menuItems.length > 0) {
                                Polymer.dom.flush();
                                this._setSelectedMenuItem(tabItem);
                            }
                            this.reloadCurrentTab();
                        }
                    }, 2000);
                }
            },

            _menuProviderCreated: function (tabItem, menuProviderElement) {
                if (menuProviderElement) {
                    if (tabItem && menuProviderElement.getMenu) {
                        Polymer.Async.microTask.run(() =>
                            menuProviderElement.getMenu(tabItem, this._menuProviderCallback.bind(this, tabItem))
                        );
                    }
                }
            },

            _menuProviderCallback: function (tabItem, menuItems) {
                if (tabItem) {
                    this.set('_calculatedTabItems.' + tabItem.index, tabItem);
                    if (menuItems && menuItems.length > 0) {
                        var origCount = 0;
                        if (tabItem.menuItems) {
                            origCount = tabItem.menuItems.length;
                            tabItem.menuItems.forEach(function (item) {
                                menuItems.push(item);
                            }, this);
                        }
                        if (menuItems.length > 0) {
                            this.set('_calculatedTabItems.' + tabItem.index + ".enableDropdownMenu", true);
                            this.set('_calculatedTabItems.' + tabItem.index + ".menuItems", menuItems);
                            if (tabItem.selected || tabItem.name == this.selectedTab.name) {
                                Polymer.dom.flush();
                                this._setSelectedMenuItem(tabItem);
                                this.reloadCurrentTab();
                            }
                        }
                    } else {
                        this.set('_calculatedTabItems.' + tabItem.index + ".enableDropdownMenu", false);
                    }
                }
            },

            _isDivider: function (item) {
                return item.name == "divider";
            },

            //Clear tab errors on de-select
            _onIronDeselect: function (e) {
                var tabName = e.detail.item.tabConfig.name;
                var currentItem = this.shadowRoot.querySelector("#" + this.id).querySelector("#" + tabName);
                var errorCircle = currentItem.shadowRoot.querySelector(".error-circle");
                errorCircle.hidden = true;
                errorCircle.textContent = "";
            },

           

            _onIronSelect: function (e) {
                this._currentTabErrorLength = 0; //reset errors

                if(this.viewMode){                    
                    var tab = this.getTabByName(this.viewMode);
                    e.detail.item = tab;
                    this.viewMode = "";                                    
                }

                if (!e || !e.detail || !e.detail.item) return;


                // Capturing selected tab configuration
                var tabConfig = this.selectedTab = e.detail.item.tabConfig;
                var menuItemConfig = e.detail.item.menuItemConfig;
                var subTitle = tabConfig.subtitle == undefined ? "" : tabConfig.subtitle;

                //Capturing for Quick Manage, reload tab with this configuration
                this._selectedTabConfig = {
                    "tabConfig": tabConfig,
                    "menuItemConfig": menuItemConfig,
                    "subTitle": subTitle
                };

                if (tabConfig && menuItemConfig) {
                    subTitle = menuItemConfig.title;
                    if(this.loadOnConfigChange)
                        this._loadContent(menuItemConfig, tabConfig.name);
                    this._resetSubTitles(tabConfig, subTitle);
                } else {
                    if (!this.shadowRoot.querySelector("#" + this.id)._isMenuIconClicked) {
                        if(this.loadOnConfigChange)
                            this._loadContent(tabConfig);
                        this._resetSubTitles(tabConfig, subTitle);
                        this.selectedTabIndex = tabConfig.index;
                    }
                }
                this.loadOnConfigChange = true;
                if (subTitle) {
                    this._applyMargin(tabConfig.name, true);
                } else {
                    this._applyMargin(tabConfig.name, false);
                }
            },

            _resetSubTitles: function (currentTabConfig, subtitle) {
                var tabsConfig = this.config.tabItems;
                var pebbleTabGroup = this.shadowRoot.querySelector("#" + this.id);

                if (tabsConfig && pebbleTabGroup) {
                    for (var index in tabsConfig) {
                        var tabConfig = tabsConfig[index];
                        var tab = pebbleTabGroup.querySelector("#" + tabConfig.name);

                        if (tab) {
                            var tabSubTtile = tab.querySelector(".tab-subtitle-content");
                            if (tabConfig && tabSubTtile) {
                                if (currentTabConfig.name == tab.id) {
                                    tabSubTtile.textContent = subtitle ? subtitle : "";
                                } else {
                                    tabSubTtile.textContent = "";
                                }
                            }
                            var menu = tab.querySelector("paper-listbox");
                            if (currentTabConfig.name !== tab.id && menu && menu.selected >= 0) {
                                menu.selected = -1;
                            }
                        }
                    }
                }
            },

            _loadContent: function (config, tabName) {
                if(!config) {
                    this.logWarning("TabConfig");
                    return;                    
                }
                console.log("loadcontent ", config, tabName, arguments.callee.caller.name);

                var viewName = config.name;
                viewName = tabName ? tabName + '-' + viewName : viewName;
                var contentElement = this.shadowRoot.querySelector("#content-" + viewName);

                if (config.component) {
                    ComponentHelper.loadContent(contentElement, config.component, this);
                    if (this._currentTabName && this._currentTabName != viewName) {
                        this._hideView(this._currentTabName);
                    }
                    this._currentTabName = viewName;
                    this._onReadonly();

                    [...this.shadowRoot.querySelectorAll('.tab-content')]
                        .forEach(tab => {
                            if(tab.id.indexOf(tabName)!== -1)
                                tab.setAttribute('hidden', '');
                        });

                    this._showView(viewName);
                }

                if (config.errorLength) {
                    this._updateErrorVis(config.errorLength);
                } else {
                    this._updateErrorVis(0);
                }
            },

            _showView: function (viewName) {
                if (viewName) {
                    this._tabChange(viewName);
                    var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                    if (contentView) {
                        contentView.removeAttribute("hidden");
                    }
                }
            },

            _hideView: function (viewName) {
                if (viewName) {
                    var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                    if (contentView) {
                        //no need to keep elements of the hidden tab, this creates huge dom tree and makes application slower over time.
                        while (contentView.firstChild) {
                            contentView.removeChild(contentView.firstChild);
                        }
                        contentView.setAttribute("hidden", "");
                    }
                }
            },

            _applyMargin: function (tabName, apply) {
                var tab = this.getTabByName(tabName);

                if (tab) {
                    var dropdownWrapper = tab.querySelector("#dropdown-wrapper");

                    if (dropdownWrapper && apply) {
                        if (apply) {
                            dropdownWrapper.style.marginTop = "2%";
                        } else {
                            dropdownWrapper.style.marginTop = "0%";
                        }
                    }
                }
            },

            refresh: function () {
                if (this._currentTabName) {
                    var content = this.$$('#content-' + this._currentTabName);
                    if (content && content.firstChild) {
                        content.firstChild.refresh();
                    }
                }
            },
            editCurrentTab: function () {
                if (!this.shadowRoot) {
                    return;
                }
                var currentElement = this.shadowRoot.querySelector("#" + this.id);

                if (!currentElement) {
                    return;
                }
                var currentItem = currentElement.selectedItem;
                if (currentItem) {
                    var currentTabConfig = currentItem.tabConfig;
                    var menu = currentItem.querySelector('paper-listbox');
                    var currentMenuItem;
                    var currentTabMenuConfig;
                    if (menu) {
                        currentMenuItem = menu.selectedItem;
                    }
                    if (currentMenuItem) {
                        currentTabMenuConfig = currentMenuItem.menuItemConfig;
                    }
                    if (currentTabConfig.name !== this._selectedTabConfig.tabConfig.name) {
                        currentTabConfig = this._selectedTabConfig.tabConfig;
                        currentTabMenuConfig = this._selectedTabConfig.menuItemConfig;
                    }
                }

                if (currentTabConfig && currentTabMenuConfig) {
                    this._editContent(currentTabMenuConfig, currentTabConfig.name);
                } else {
                    this._editContent(currentTabConfig, null);
                }

            },
            _editContent: function (config, tabName) {
                if (config) {
                    var viewName = config.name;
                    viewName = tabName ? tabName + '-' + viewName : viewName;
                    var contentElement = this.shadowRoot.querySelector("#content-" + viewName);
                    if (contentElement && contentElement.firstChild && typeof (contentElement.firstChild.globalEdit) == "function") {
                        contentElement.firstChild.globalEdit();
                    }
                }
            },
            /**
            * Can be used to reload the current tab content.
            */
            reloadCurrentTab: function (isReloadByConfig) {
                //to reload the current selected tab after any changes to tabItemConfig
                //no inputs to this method. Find out the current selected tab and call _loadContent()
                if (!this.shadowRoot) {
                    return;
                }
                var currentElement = this.shadowRoot.querySelector("#" + this.id);

                if (!currentElement) {
                    return;
                }

                var currentItem = currentElement.selectedItem;

                if (isReloadByConfig && this._selectedTabConfig.tabConfig) {
                    var currentTabConfig = this._selectedTabConfig.tabConfig;
                    var currentTabMenuConfig = this._selectedTabConfig.menuItemConfig;
                }
                else if (currentItem) {
                    var currentTabConfig = currentItem.tabConfig;
                    var menu = currentItem.querySelector('paper-listbox');
                    var currentMenuItem;
                    var currentTabMenuConfig;
                    if (menu) {
                        currentMenuItem = menu.selectedItem;
                    }
                    if (currentMenuItem) {
                        currentTabMenuConfig = currentMenuItem.menuItemConfig;
                    }

                    // Work Around: When user is reloading tab but currentMenuItem is not mataching
                    //              with the one which is displayed to the user
                    if (currentTabConfig.name !== this._selectedTabConfig.tabConfig.name) {
                        currentTabConfig = this._selectedTabConfig.tabConfig;
                        currentTabMenuConfig = this._selectedTabConfig.menuItemConfig;
                    }
                }

                if (currentTabConfig && currentTabMenuConfig) {
                    this._loadContent(currentTabMenuConfig, currentTabConfig.name);
                } else {
                    this._loadContent(currentTabConfig, null);
                }
            },
            /**
            * Can be used to reload all tabs of a component.
            */
            reloadTabs: function () {
                if (this.config && this.config.tabItems && this.config.tabItems.length > 0) {
                    var tabItems = DataHelper.cloneObject(this.config.tabItems);
                    for (var i = 0; i < tabItems.length; i++) {
                        var tabItem = tabItems[i];
                        var tabName = tabItem.name;
                        var contentElement = this.shadowRoot.querySelector('#content-' + tabName);
                        var contentTab = this.shadowRoot.querySelector('pebble-tab[id=' + tabName + ']');
                        if (contentTab) {
                            contentTab.tabConfig = tabItem;
                        }
                        if (contentElement && contentElement.firstChild) {
                            Polymer.dom(contentElement).removeChild(contentElement.firstChild);
                        }
                        if (tabItem.menuItems && tabItem.menuItems.length > 0) {
                            for (var j = 0; j < tabItem.menuItems.length; j++) {
                                var meuItemName = tabItem.menuItems[j].name;
                                var menuContentElement = this.shadowRoot.querySelector('#content-' + tabName + '-' +
                                    meuItemName);
                                if (menuContentElement && menuContentElement.firstChild) {
                                    Polymer.dom(menuContentElement).removeChild(menuContentElement.firstChild);
                                }
                            }
                        }
                        this._fillMenuItems(tabItem);
                    }
                }
            },
            reset: function () {
                this.set("_calculatedTabItems", []);
                this.selectedTabIndex = null;
            },
            _onSelectionChange: function (e, detail, sender) {
                var isDirty = this.getIsDirty();
                if (isDirty) {
                    this._showWarning(e);
                }
            },
            /**
            * Can be used to get whether the current tab content is dirty or not.
            */
            getIsDirty: function () {
                if (this._currentTabName) {
                    var content = this.shadowRoot.querySelector('#content-' + this._currentTabName);
                    if (content && content.firstChild && content.firstChild.getIsDirty) {
                        var isTabDirty = content.firstChild.getIsDirty();
                        return isTabDirty;
                    }
                }
            },
            /**
            * Can be used to get whether the current tab controls are dirty or not.
            */
            getControlIsDirty: function () {
                if (this._currentTabName) {
                    var content = this.$$('#content-' + this._currentTabName);
                    if (content && content.firstChild && content.firstChild.getControlIsDirty) {
                        var isTabDirty = content.firstChild.getControlIsDirty();
                        return isTabDirty;
                    }
                }
            },

            _onReadonly: function () {
                if (this._currentTabName) {
                    var content = this.$$('#content-' + this._currentTabName);
                    if (content && content.firstChild) {
                        content.firstChild.readonly = this.readonly;
                    }
                }
            },
            _showWarning: function (event) {
                if (!window.confirm(
                    "There are unsaved changes. Do you want to discard the changes?")) {
                    event.preventDefault();
                }
            },
            _errorLengthChanged: function (errorLength) {
                var currentItem = this.shadowRoot.querySelector("#" + this.id).querySelector("#" + this._currentTabName);
                if (currentItem) {
                    var currentTabConfig = currentItem.tabConfig;
                    var currentTabMenuConfig = currentItem.menuItemConfig;
                    if (currentTabConfig && currentTabMenuConfig) {
                        currentTabMenuConfig.errorLength = errorLength;
                    } else {
                        currentTabConfig.errorLength = errorLength;
                    }
                    this._updateErrorVis(errorLength);
                }
            },
            _updateErrorVis: function (errorLength) {
                var currentItem = this.shadowRoot.querySelector("#" + this.id).selectedItem;
                var errorCircle = currentItem.shadowRoot.querySelector(".error-circle");
                if (errorLength > 0) {
                    errorCircle.hidden = false;
                    errorCircle.textContent = errorLength;
                } else {
                    errorCircle.hidden = true;
                    errorCircle.textContent = "";
                }
            },
            _temp: function (x) {
                return x;
            },
            arrayItem: function (change, index, path) {
                return this.get(path, change.base[index]);
            },

            _setSelectedMenuItem: function (tabItem) {
                var currentTab = this.shadowRoot.querySelector("#" + tabItem.name);
                if (currentTab) {
                    var currentTabMenu = currentTab.querySelector("paper-listbox");
                    if (currentTabMenu) {
                        var selectedMenuIndex = this._getTabSelectedMenuIndex(tabItem);
                        if (selectedMenuIndex >= 0) {
                            currentTabMenu.selected = selectedMenuIndex;
                        }
                    }
                }
            },

            _getTabSelectedMenuIndex: function (tabItem) {
                var tabMenuIndex = -1;

                if (tabItem) {
                    var menuItems = tabItem.menuItems;
                    if (menuItems && menuItems.length > 0) {
                        for (var i = 0; i < menuItems.length; i++) {

                            if (this._selectedTabConfig && this._selectedTabConfig.menuItemConfig) {
                                if (this._selectedTabConfig.menuItemConfig.name == menuItems[i].name) {
                                    tabMenuIndex = i;
                                    break;
                                }
                            } else {
                                if (menuItems[i].selected) {
                                    tabMenuIndex = i;
                                    break;
                                }
                            }
                        }
                    }
                }

                return tabMenuIndex;
            }
        });
        // })();
    </script>
</dom-module>