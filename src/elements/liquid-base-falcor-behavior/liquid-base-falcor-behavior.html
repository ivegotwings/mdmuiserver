<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-datachannel/bedrock-datachannel.html">
<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-type-extensions/string-extensions.html">

<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">
<link rel="import" href="../liquid-base-behavior/liquid-base-behavior.html">

<script>
    /*
     * <i><b>Content development is under progress... </b></i>
     * @demo demo/index.html
     * @polymerBehavior RUFBehaviors.LiquidBaseFalcorBehavior
     */
    window.RUFBehaviors = window.RUFBehaviors || {};
    var Globals = Globals || {};
    /** @polymerBehavior RUFBehaviors.LiquidBaseFalcorBehavior */
    RUFBehaviors.LiquidBaseFalcorBehaviorImpl = {
        is: "liquid-base-falcor-behavior",
        attached: function () { },
        ready: function () {

            if (this.id == null || this.id == undefined || this.id == "") {
                this.id = ElementHelper.getRandomId();
            }
        },
        /**
         * Fired when a request is sent.
         *
         * @event request
         * @event liquid-request
         */
        /**
         * Fired when a response is received.
         *
         * @event response
         * @event liquid-response
         */
        /**
         * Fired when an error is received.
         *
         * @event error
         * @event liquid-error
         */
        properties: {
            /**
            * Content is not appearing - Content development is under progress. 
            */
            operation: {
                type: String,
                value: '',
                notify: true
            },
            /**
              * Content is not appearing - Content development is under progress. 
              */
            requestId: {
                type: String,
                value: '',
                notify: true
            },
            /**
              * Content is not appearing - Content development is under progress. 
              */
            dataIndex: {
                type: String,
                value: 'Unknown',
            },
            /**
              * Content is not appearing - Content development is under progress. 
              */
            excludeInProgress: {
                type: Boolean,
                value: false
            },
            /**
              * Content is not appearing - Content development is under progress. 
              */
            includeTypeExternalName: {
                type: Boolean,
                value: false
            },
            /**
              * Content is not appearing - Content development is under progress. 
              */
            noCache: {
                type: Boolean,
                value: false
            },
            activeRequests: {
                type: Array,
                value: function () {
                    return [];
                }
            }
        },
        observers: [
            '_requestOptionsChanged(requestData.*, operation, requestId, timeout, auto)'
        ],
        /**
         * Content is not appearing - Can be used to perform a request to the specified URL.
         *
         */
        generateRequest: async function () {
            var request = this._createRequest();
            var self = this;
            if (request.requestData === null || request.operation === '') {
                if (this.verbose) {
                    console.log('request operation is blank so NO request operation would be generated..terminating gracefully...');
                }

                return;
            }

            if (!this._executeRequest) {
                throw "_executeRequest method is not defined";
                return;
            }
            this._addRequestCount();
            this._handleProgress();
            this.push('activeRequests', request);
            this._setLastRequest(request);

            if (this._isDataIndexUpdateRequired(request.requestData)) {
                await this._updateDataIndexBasedOnType(request.requestData);
            }

            request.originalRequest = DataHelper.cloneObject(request);
            request.applyLocaleCoalesce = this.applyLocaleCoalesce;
            request.dataSubIndex = this.dataSubIndex;
            if (this.applyLocaleCoalesce) {
                await this._updateValueContextsWithFallbackLocales(request.requestData);
            }
            this._setLoading(true);
            var model = RUFBehaviors.DataChannel.getModel(this.dataIndex);

            var modelResponse = this._executeRequest(model, request);
            //console.log('response: ', JSON.stringify(modelResponse, null, 2));

            if (!this._handleModelResponse(request, modelResponse)) {
                //if moded response is not queued ...no need to create active request..
                return;
            }

            return request;
        },
        _updateValueContextsWithFallbackLocales: async function (reqData) {
            if (reqData.params && reqData.params.query && reqData.params.query.valueContexts) {
                var valContexts = DataHelper.cloneObject(reqData.params.query.valueContexts);
                for (let i = 0; i < valContexts.length; i++) {
                    var locale = valContexts[i].locale;
                    var fallbackLocales = await DataHelper.getFallbackLocalesForLocaleAsync(locale);
                    if (fallbackLocales) {
                        for (let j = 0; j < fallbackLocales.length; j++) {
                            let fallbackLocale = fallbackLocales[j].name;
                            let existingValCtx = reqData.params.query.valueContexts.find(obj => obj.locale === fallbackLocale);
                            if (!existingValCtx) {
                                var valCtx = DataHelper.cloneObject(valContexts[i]);
                                valCtx.locale = fallbackLocale;
                                reqData.params.query.valueContexts.push(valCtx);
                            }
                        }
                    }
                }
            }
        },
        _updateDataIndexBasedOnType: async function (requestData) {
            if (requestData) {
                let entityType, domain;
                if (DataHelper.isValidObjectPath(requestData, "params.query.filters.typesCriterion")) {
                    entityType = requestData.params.query.filters.typesCriterion[0];
                }

                if (entityType) {
                    var entityTypeManager = EntityTypeManager.getInstance();

                    if (entityTypeManager) {
                        domain = await entityTypeManager.getDomainByType(entityType);
                    }

                    if (domain) {
                        let dataIndexDomainMappings = SharedUtils.DataObjectFalcorUtil.getDataIndexDomainMappings();
                        if (dataIndexDomainMappings) {
                            let dataIndex = dataIndexDomainMappings[domain];

                            if (!_.isEmpty(dataIndex)) {
                                this.dataIndex = dataIndex;
                                
                                // TODO:: Need to come up with some good solution for dataSubIndex.
                                let pathKeys = SharedUtils.DataObjectFalcorUtil.getPathKeys();
                                if(DataHelper.isValidObjectPath(pathKeys, "dataIndexInfo." + dataIndex + ".dataSubIndexInfo")) {
                                    let dataSubIndexs = Object.keys(pathKeys.dataIndexInfo[dataIndex].dataSubIndexInfo);

                                    if(dataSubIndexs) {
                                        this.dataSubIndex = this.dataSubIndex.indexOf("coalesced") > -1 ? dataSubIndexs.find(v => v.indexOf("coalesced") > -1) : dataSubIndexs.find(v => v.indexOf("coalesced") == -1);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        _executeRequest: function (model, request) {
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _formatResponse: function (request, rawResponsePkg) {
            return rawResponsePkg;
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _validateAutoTriggerChanges: function (requestData, operation, requestId) {
            return true;
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _createRequest: function () {
            if (this.includeTypeExternalName) {
                this.requestData.includeTypeExternalName = true;
            }
            return {
                "operation": this.operation,
                "requestId": this.requestId === undefined ? '' : this.requestId,
                "requestData": this.requestData
            }
        },
        _getLogDetail: function (request) {
            return {
                "operation": request.operation,
                "request": request.requestData,
                "requestId": this.requestId === undefined ? '' : this.requestId,
            };
        },
        _logOnError: function (request, res) {
            if (_.isEmpty(res) || _.isEmpty(res.json) || _.isEmpty(res.json.root)) {
                var message = "RUF_UI_LIQUID_EMPTY_RESPONSE";
                var level = "error";
                var logDetail = this._getLogDetail(request);
                RUFUtilities.Logger.error(message, logDetail, "liquid-manager");
            }
        },
        _handleModelResponse: function (request, modelResponse) {
            var self = this;
            if (modelResponse && modelResponse.then) {
                modelResponse.then(function (resPkg) {
                    self._logOnError(request, resPkg);
                    self.removeFalcorKeys(resPkg);
                    return self._handleResponse(request, resPkg);
                },
                    function (errPkg) {
                        var message = "RUF_UI_LIQUID_ERROR";
                        var logDetail = self._getLogDetail(request);
                        RUFUtilities.Logger.error(message, logDetail, "liquid-manager");
                        return self._handleError(request, errPkg);
                    });
                return true;
            } else {
                if (modelResponse && modelResponse.status && modelResponse.status === "success") {
                    self._logOnError(request, modelResponse);
                    return self._handleResponse(request, modelResponse);
                } else if (modelResponse && modelResponse.status && modelResponse.status === "error") {
                    var message = "RUF_UI_LIQUID_ERROR";
                    var level = "error";
                    var logDetail = self._getLogDetail(request);
                    RUFUtilities.Logger.error(message, logDetail, "liquid");
                    self._handleError(request, modelResponse);
                }
                return false;
            }
            return true;
        },
        _handleResponse: async function (request, responsePkg) {
            if (this.verbose) {
                console.log('_handleResponse called with :', request, responsePkg);
            }
            var formattedResponse = await this._formatResponse(request, responsePkg);
            if (request.applyLocaleCoalesce) {
                formattedResponse = await DataTransformHelper.transformDataToLocaleCoalescedData(formattedResponse, request.originalRequest.requestData);
            }
            if (request.dataSubIndex === "coalescedData") {
                formattedResponse = DataTransformHelper.transformDataToContextCoalescedData(formattedResponse);
            }
            var response = this._createSuccessResponse(request, formattedResponse);
            var utils = SharedUtils.DataObjectFalcorUtil;
            if (utils.compareObjects(request, this.lastRequest)) {
                this._setLastResponse(response);
                this._setLastError(null);
                this._setLoading(false);
            }
            var eventDetail = {
                detail: {
                    'request': request,
                    'response': response
                },
                bubbles: this.bubbles,
                composed: true
            };
            if (this.verbose) {
                //console.log('firing liquid-response event with event detail ', JSON.stringify(eventDetail, null, 4));
                console.log('firing liquid-response event with event detail ', eventDetail);
            }
            this.dispatchEvent(new CustomEvent('response', {
                detail: { 'request': request, 'response': response },
                bubbles: this.bubbles,
                composed: true
            }));
            this.dispatchEvent(new CustomEvent('liquid-response', {
                detail: { 'request': request, 'response': response },
                bubbles: this.bubbles,
                composed: true
            }));
            this._discardRequest(request);

            this._addResponseCount();
            this._handleProgress();
        },
        _handleError: function (request, errorPkg) {
            var errResponse = this._createErrorResponse(request, errorPkg);
            if (this.verbose) {
                Polymer.Base._error('_handleError called with :', errResponse);
            }
            var utils = SharedUtils.DataObjectFalcorUtil;
            if (utils.compareObjects(request, this.lastRequest)) {
                this._setLastError(errResponse);
                this._setLastResponse(null);
                this._setLoading(false);
            }
            var eventDetail = {
                'request': request,
                'response': errResponse
            };
            if (this.verbose) {
                console.log('firing liquid-error event with event detail ', eventDetail);
            }
            // Tests fail if this goes after the normal this.dispatchEvent('error', ...)
            this.dispatchEvent(new CustomEvent('liquid-error', {
                detail: { 'request': request, 'response': errResponse },
                bubbles: this.bubbles,
                composed: true
            }));
            this.dispatchEvent(new CustomEvent('error', {
                detail: { 'request': request, 'response': errResponse },
                bubbles: this.bubbles,
                composed: true
            }));
            this._discardRequest(request);

            this._addResponseCount();
            this._handleProgress();
        },
        /**
          * Content is not appearing - Content development is under progress. 
          */
        removeFalcorKeys: function (obj) {
            for (prop in obj) {
                if (prop === '$__path') {
                    delete obj[prop];
                }
                else if (typeof obj[prop] === 'object') {
                    this.removeFalcorKeys(obj[prop]);
                }
            }
        },
        _addResponseCount: function () {
            if (!this.excludeInProgress) {
                Globals.responseCount++;

                if (this.verbose) {
                    console.log("Response #{0} ------ for liquid name / host: {1} / {2}".format(Globals.responseCount, this.localName, this.domHost.localName));
                }
            }
        },

        _retry: function () {
            Polymer.Async.timeOut.after(300).run(() => {
                if (!Globals.progressBar) {
                    this._retry();
                }
                else {
                    Polymer.Async.timeOut.after(12000).run(() => {
                        if (!Globals.progressBar) return;

                        Globals.progressBar.value = 1000;
                        Polymer.Async.timeOut.after(1000).run(() => {
                            Globals.progressBar.value = 0;
                            Globals.progressBar.secondaryProgress = 0;
                            Globals.progressOver = true;
                        });
                    });
                    return;
                }
            })
        },
        _addRequestCount: function () {
            if (!this.excludeInProgress) {
                if (Globals.requestCount == 0) {
                    if (!Globals.progressBar) {
                        this._retry();
                    } else {
                        Polymer.Async.timeOut.after(12000).run(() => {
                            Globals.progressBar.value = 1000;
                            Polymer.Async.timeOut.after(1000).run(() => {
                                Globals.progressBar.value = 0;
                                Globals.progressBar.secondaryProgress = 0;
                                Globals.progressOver = true;
                            });
                        });
                    }
                }
                Globals.requestCount++;
                if (this.verbose) {
                    console.log("Request #{0} ------ for liquid name / host: {1} / {2}".format(Globals.requestCount, this.localName, this.domHost.localName));
                }
            }
        },
        _handleProgress: function () {
            var updateProgress = this._updateProgressBar;
            var resetProgress = this._resetProgressBar;

            var debounceProgressBar = _.debounce(function () {
                updateProgress(resetProgress);
            }, 200);

            debounceProgressBar();
        },
        _updateProgressBar: function (resetProgress) {
            if (!Globals.progressBar || Globals.progressOver) {
                return;
            }

            if (Globals.requestCount > 0) {
                var step = (Globals.progressBar.max / 10) / (Globals.requestCount);
                Globals.progressBar.value = 200 + Globals.currentProgress + (step * Globals.progressUpdater * Globals.responseCount / Globals.requestCount);
                Globals.progressBar.secondaryProgress = Globals.progressBar.max;//Globals.progressBar.value * 10 * Math.random();
                var debounceProgressBar = _.debounce(function () {
                    resetProgress();
                }, 1000);
                debounceProgressBar();
            }
        },
        _resetProgressBar: function () {
            if (Globals.requestCount == Globals.responseCount) {
                Globals.progressUpdater = Globals.progressUpdater + 0.2;
                Globals.currentProgress = Globals.progressBar.value;
            }
        },
        _createSuccessResponse: function (request, data) {
            return {
                'status': 'success',
                'content': DataHelper.cloneObject(data)
            };
        },
        _createErrorResponse: function (request, reason) {

            var errorMessage = 'Failed to submit request. Please retry after sometime.';
            var errorMessageCode;
            if (reason && reason[0]) {
                var value = reason[0].value;
                if (value) {
                    if (value.message) {
                        errorMessage = value.message;
                    }
                    if (value.messageCode) {
                        errorMessageCode = value.messageCode;
                    }
                }
            }

            var result = {
                'status': 'error',
                'reason': errorMessage
            };
            if (errorMessageCode) {
                result["errorCode"] = errorMessageCode;
            }
            return result;
        },
        _discardRequest: function (request) {
            var requestIndex = this.activeRequests.indexOf(request);
            if (requestIndex > -1) {
                this.splice('activeRequests', requestIndex, 1);
            }
        },
        _requestOptionsChanged: function (reqData, operation, requestId) {
            if (!(reqData === undefined || operation === undefined || requestId === undefined)) {
                this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(this.debounceDuration), () => {
                    if (reqData == null || operation == '') {
                        return;
                    }
                    if (this.auto) {
                        if (this._validateAutoTriggerChanges(reqData, operation, requestId)) {
                            this.generateRequest();
                        }
                    }
                });
            }
        },
        _isDataIndexUpdateRequired: function (reqData) {
            let isDataIndexUpdateRequired = false;
            if (reqData.params && this.dataIndex != "config") {
                let options = DataHelper.isValidObjectPath(reqData, "params.options") ? reqData.params.options : undefined;

                if (typeof options == "undefined" || (options && (typeof options.updateDataIndex == "undefined" || options.updateDataIndex))) {
                    isDataIndexUpdateRequired = true;
                }
            }

            return isDataIndexUpdateRequired;
        }
    };
    /** @polymerBehavior */
    RUFBehaviors.LiquidBaseFalcorBehavior = [RUFBehaviors.LiquidBaseBehavior, RUFBehaviors.LiquidBaseFalcorBehaviorImpl];

</script>