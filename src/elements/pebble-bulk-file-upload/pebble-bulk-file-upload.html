<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/paper-styles/typography.html">
<link rel="import" href="../../../bower_components/paper-ripple/paper-ripple.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">

<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="pebble-bulk-file-upload-icons.html">
<link rel="import" href="pebble-bulk-file-upload-file-item.html">

<!--
`<pebble-bulk-file-upload>` Represents an element which uploads multiple files with drag and drop support.

### Example
<pebble-bulk-file-upload></pebble-bulk-file-upload>

@demo demo/index.html
-->

<dom-module id="pebble-bulk-file-upload">
  <template>
    <style include="pebble-styles-shared">
      :host {
        @apply --layout-vertical;
        display: block;
        position: relative;
        text-align: left;
      }

      :host(:not([nodrop])) {
        border: 1px dashed;
        border-color: var(--divider-color, #666);
        border-radius: 3px;
        overflow: hidden;
        padding: 20px;
        background: var(--palette-pale-grey-two, #f9fbfd);
      }

      :host([dragover-valid]) {
        border-color: var(--primary-color, #00B4F0);
      }

      /*
        Cover the entire element with transparent overlay when dragging files
        over it. Helps to reduce the amount of events fired.
      */
      :host::before {
        @apply --layout-fit;
        content: '';
        display: none;
        z-index: 10;
      }

      :host([dragover])::before {
        display: block;
      }

      #dragRipple {
        color: var(--light-primary-color, #7CD8F7);
        @apply --pebble-bulk-file-upload-drag-ripple;
      }

      #dropLabel {
        @apply --layout-flex;
        @apply --paper-font-body2;
        position: relative;
        margin: 0 .29em;
        font-size: var(--font-size-xl, 20px);
        font-weight: 500;
        color: var(--default-icon-color,#8994a0);
        text-align: center;
      }

      :host([dragover-valid]) #dropLabel {
        color: var(--primary-color, #00B4F0);
        @apply --pebble-bulk-file-upload-drop-label-dragover;
      }

      #dropLabel ::slotted(pebble-icon),
      #dropLabelIcon {
        @apply --pebble-bulk-file-upload-drop-label-icon;
      }

      #fileList {
        position: relative;
        @apply --pebble-bulk-file-upload-file-list;
      }

      #addFiles {
        text-align: center;
        @apply --pebble-bulk-file-upload-button-add-wrapper;
      }

      #addButton[disabled] {
        background: var(--divider-color, #e0e0e0);
        color: var(--disabled-text-color, gray);
        border-color: var(--divider-color, #e0e0e0);
      }
    </style>
    
    <div id="buttons">
      <div id="buttonsPrimary">
        <div id="dropLabel" hidden$="[[nodrop]]">
          <slot name="drop-label-icon">
            <pebble-icon id="dropLabelIcon" class="pebble-xl-icons" icon="pebble-xl-icons:Upload"></pebble-icon>
          </slot>    
          <div class="clearfix"></div>      
          <slot name="drop-label">
            [[_i18nPlural(maxFiles, i18n.dropFiles, i18n.dropFiles.*)]]
          </slot>
        </div>
        <div id="addFiles" on-tap="_onAddFilesClick">
          <slot name="add-button">
            <pebble-button id="addButton" class="btn btn-success m-t-10" button-text="[[_i18nPlural(maxFiles, i18n.addFiles, i18n.addFiles.*)]]" disabled$="[[maxFilesReached]]"></pebble-button>
          </slot>
        </div>
      </div>
    </div>
    <slot name="file-list">
      <div id="fileList">
        <template is="dom-repeat" items="[[files]]" as="file">
          <pebble-bulk-file-upload-file-item file="[[file]]"></pebble-bulk-file-upload-file-item>
        </template>
      </div>
    </slot>
    <slot></slot>
    <input type="file" id="fileInput" on-change="_onFileInputChange" hidden accept$="{{accept}}" multiple$="[[_isMultiple(maxFiles)]]">
    <paper-ripple id="dragRipple" noink></paper-ripple>
  </template>
</dom-module>

<script>

  Polymer({

    is: 'pebble-bulk-file-upload',

    properties: {
      /**
       * Specifies whether or not the element supports files-drop on it for the file upload.
       * By default it is enabled in the desktop and disabled in the touch devices
       * as mobile devices do not support the drag events. Set it to <b>true</b> to disable the 
       * files-drop on all devices. If it is <b>false</b>, files-drop is enabled even in touch devices.
       *
       * @default true in touch-devices, false otherwise.
       */
      nodrop: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },

      /**
       * Indicates the server URL. The default value is an empty string. The value 
       * `_window.location_` is used when it is empty string. 
       */
      target: {
        type: String,
        value: ''
      },

      /**
       * Indicates a HTTP method to send the files. The allowed values are "POST" and "PUT".
       */
      method: {
        type: String,
        value: 'POST'
      },

      /**
       * Indicates key-value map to send to the server. If you set this property as an
       * attribute, use a valid JSON string. For example:
       * ```
       * <pebble-bulk-file-upload headers='{"X-Foo": "Bar"}'></pebble-bulk-file-upload>
       * ```
       */
      headers: {
        type: Object,
        value: {}
      },

      /**
       * Indicates the maximum time in milliseconds for the entire upload process. If it exceeds the
       * the given `timeout` request is aborted. If the set value is "zero", it indicates there is no timeout.
       *
       */
      timeout: {
        type: Number,
        value: 0
      },

      _dragover: {
        type: Boolean,
        value: false,
        observer: '_dragoverChanged'
      },

      /**
       * Indicates the array of files that are either processed, or already uploaded.
       *
       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
       * object with a number of extra properties  to track the upload process:
       * - `uploadTarget`: Indicates the target URL used to upload `this` file.
       * - `elapsed`: Indicates an elapsed time since the upload started.
       * - `elapsedStr`: Indicates human-readable elapsed time.
       * - `remaining`: Indicates number of seconds remaining for the upload to finish.
       * - `remainingStr`: Indicates human-readable remaining time for the upload to finish.
       * - `progress`: Indicates the percentage of the file already uploaded.
       * - `speed`: Indicates the upload speed in kilo-bytes per second.
       * - `size`: Indicates the file size in bytes.
       * - `totalStr`: Indicates the human-readable total size of the file.
       * - `loaded`: Indicates number of "bytes" transferred so far.
       * - `loadedStr`: Indicates human-readable uploaded size at the moment.
       * - `status`: Indicates the status of the upload process.
       * - `error`: Indicates an error message in case the upload is failed.
       * - `abort`: Specifies whether or not the file upload is canceled. It is set to "true", if the upload canceled.
       * - `complete`: Specifies whether or not the file is transferred to the server. It is set to "true", if the file is transferred to the server.
       * - `uploading`: Specifies whether or not the file data is getting transferred to the server. It is set to "true", if the file data is getting transferred to the server.
       */
      files: {
        type: Array,
        notify: true,
        value: function() {
          return [];
        }
      },

      /**
       * Indicates the number of files to upload. By default it is unlimited. If the value is
       * set to one, native file browser prevents selection of multiple files.
       */
      maxFiles: {
        type: Number,
        value: Infinity
      },

      /**
       * Specifies whether or not number of files uploaded reached the maximum limit set.
       */
      maxFilesReached: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        computed: '_maxFilesAdded(maxFiles, files.length)'
      },

      /**
       * Specifies the types of files that the server accepts.
       * Syntax: A comma-separated list of MIME type patterns (wildcards are
       * allowed) or file extensions.
       * Note that MIME types are widely supported while file extensions
       * are only implemented in certain browsers. Therefore, avoid using it.
       * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
       */
      accept: {
        type: String,
        value: ''
      },

      /**
       * Specifies the maximum file size in bytes allowed to upload.
       * Note that it is a client-side constraint and is checked before
       * the request is sent. Do the same validation in
       * the server-side and make sure that they are aligned.
       */
      maxFileSize: {
        type: Number,
        value: Infinity
      },

      /**
       * Specifies if the `dragover` is validated with `maxFiles` and
       * accept properties.
       */
      _dragoverValid: {
        type: Boolean,
        value: false,
        observer: '_dragoverValidChanged'
      },

      /**
       * Specifies the 'name' property at `content-disposition`.
       */
      formDataName: {
        type: String,
        value: 'file'
      },

      /**
       * Prevents upload(s) from immediately uploading upon adding file(s).
       * When set, you must manually trigger the uploads using the `uploadFiles` method.
       */
      noAuto: {
        type: Boolean,
        value: false
      },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
      loadCompleteFilesCount: {
        type: Number,
        value: 0
      },

      validFilesCount: {
        type: Number,
        value: 0
      },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
      succeededFiles: {
        type: Array,
        notify: true,
        value: function() {
          return [];
        }
      },

      /**
       * Specifies whether or not the upload is "S3 upload".
       */
      s3Upload: {
        type: Boolean,
        value: false
      },

      /**
       * Indicates the object that localizes "this" component.
       * To change the default localization, either change the entire
       * "_i18n_"" object or the property you want to modify.
       *
       * The object has the following JSON structure and default values:

    {
      dropFiles: {
       one: 'Drop file here...',
       many: 'Drop files here...'
      },
      addFiles: {
       one: 'Select File',
       many: 'Upload Files'
      },
      cancel: 'Cancel',
      error: {
       tooManyFiles: 'Too Many Files.',
       fileIsTooBig: 'Failed to upload. Max allowed file size is ',
       fileIsEmpty: 'Failed to upload. File is empty.',
       incorrectFileType: 'Incorrect File Type.'
      },
      uploading: {
       status: {
         connecting: 'Connecting...',
         stalled: 'Stalled.',
         processing: 'Processing File...',
         held: 'Queued'
       },
       remainingTime: {
         prefix: 'remaining time: ',
         unknown: 'unknown remaining time'
       },
       error: {
         serverUnavailable: 'Server Unavailable',
         unexpectedServerError: 'Unexpected Server Error',
         forbidden: 'Failed to upload. Retry...'
       }
      },
      units: {
       size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
      },
      formatSize: function(bytes) {
       // returns the size followed by the best suitable unit
      },
      formatTime: function(seconds, [secs, mins, hours]) {
       // returns a 'HH:MM:SS' string
      }
    }

       *
       * @default {English}
       */
      i18n: {
        type: Object,
        value: function() {
          return {
            dropFiles: {
              one: 'Drop file here',
              many: 'Drop files here'
            },
            addFiles: {
              one: 'Upload File',
              many: 'Upload Files'
            },
            cancel: 'Cancel',
            error: {
              tooManyFiles: 'Too Many Files.',
              fileIsTooBig: 'Failed to upload. Max allowed file size is ',
              fileIsEmpty: 'Failed to upload. File is empty.',
              incorrectFileType: 'Incorrect File Type.'
            },
            uploading: {
              status: {
                connecting: 'Connecting...',
                stalled: 'Stalled.',
                processing: 'Uploading File...',
                held: 'Queued'
              },
              remainingTime: {
                prefix: 'remaining time: ',
                unknown: 'unknown remaining time'
              },
              error: {
                serverUnavailable: 'Server Unavailable',
                unexpectedServerError: 'Unexpected Server Error',
                forbidden: 'Failed to upload. Retry...'
              }
            },
            units: {
              size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']
            }
          };
        }
      }
    },

    listeners: {
      'dragover': '_onDragover',
      'dragleave': '_onDragleave',
      'drop': '_onDrop',
      'file-retry': '_onFileRetry',
      'file-abort': '_onFileAbort',
      'file-remove': '_onFileRemove'
    },

    _formatSize: function(bytes) {
      if (typeof this.i18n.formatSize === 'function') {
        return this.i18n.formatSize(bytes);
      }

      // https://wiki.ubuntu.com/UnitsPolicy
      var base = this.i18n.units.sizeBase || 1000;
      var unit = ~~(Math.log(bytes) / Math.log(base));
      var dec = Math.max(0, Math.min(3, unit - 1));
      var size = parseFloat((bytes / Math.pow(base, unit)).toFixed(dec));
      return size + ' ' + this.i18n.units.size[unit];
    },

    _splitTimeByUnits: function(time) {
      var unitSizes = [60, 60, 24, Infinity];
      var timeValues = [0];

      for (var i = 0; i < unitSizes.length && time > 0; i++) {
        timeValues[i] = time % unitSizes[i];
        time = Math.floor(time / unitSizes[i]);
      }

      return timeValues;
    },

    _formatTime: function(seconds, split) {
      if (typeof this.i18n.formatTime === 'function') {
        return this.i18n.formatTime(seconds, split);
      }

      // Fill HH:MM:SS with leading zeros
      while (split.length < 3) {
        split.push(0);
      }

      return split
          .reverse()
          .map(function(number) {
            return (number < 10 ? '0' : '') + number;
          })
          .join(':');
    },

    _formatFileProgress: function(file) {
      return file.totalStr + ': ' +
          file.progress + '% (' +
          (file.loaded > 0 ?
              this.i18n.uploading.remainingTime.prefix + file.remainingStr :
              this.i18n.uploading.remainingTime.unknown) +
          ')';
    },

    _maxFilesAdded: function(maxFiles, numFiles) {
      return maxFiles >= 0 && numFiles > maxFiles;
    },

    _dragRippleAction: function(action, event) {
      var rippleActionEvent = {
        detail: {
          x: event.clientX,
          y: event.clientY
        }
      };

      if (action == 'down') {
        this.$.dragRipple.downAction(rippleActionEvent);

        // paper-ripple currently has hard Ripple.MAX_RADIUS limit of 300, and
        // doesn’t expose Ripple constructor or any other means to modify the
        // limit. Monkey-patching the radius calculation of just added Ripple
        // instance to disable the radius limit.
        //
        // Also fixes the default radius animation formula, which otherwise
        // tends to make the duration too small for large ripples that we have.
        //
        // See:
        // - https://github.com/PolymerElements/paper-ripple/issues/27
        // - https://github.com/PolymerElements/paper-ripple/pull/63
        //
        var lastRipple = this.$.dragRipple.ripples[this.$.dragRipple.ripples.length - 1];
        if (!lastRipple.hasOwnProperty('radius')) {
          Object.defineProperty(lastRipple, 'radius', {
            get: function() {
              var width2 = this.containerMetrics.width * this.containerMetrics.width;
              var height2 = this.containerMetrics.height * this.containerMetrics.height;
              var waveRadius = Math.sqrt(width2 + height2) * 1.1 + 5;

              var duration = 0.9 + 0.2 * (waveRadius / 300);
              var timeNow = this.mouseInteractionSeconds / duration;
              var size = waveRadius * (1 - Math.pow(80, -timeNow));
              return Math.abs(size);
            }
          });
        }
      } else {
        this.$.dragRipple.upAction(rippleActionEvent);
      }
    },

    _onDragover: function(event) {
      event.preventDefault();
      if (!this.nodrop && !this._dragover) {
        this._dragoverValid = !this.maxFilesReached;
        if (this._dragoverValid) {
          this._dragRippleAction('down', event);
        }
        this._dragover = true;
      }
      event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? 'none' : 'copy';
    },

    _onDragleave: function(event) {
      // Dragleave sometimes fired on children, skipping them. Fixes flickeing
      // when quickly dragging over.
      if (event.composedPath()[0] === this) {
        event.preventDefault();
        if (this._dragover && !this.nodrop) {
          this._dragRippleAction('up', event);
          this._dragover = this._dragoverValid = false;
        }
      }
    },

    _onDrop: function(event) {
      if (!this.nodrop) {
        event.preventDefault();
        this._dragRippleAction('up', event);
        this._dragover = this._dragoverValid = false;
        this._dragRippleAction('upAction', event);
        this._addFiles(event.dataTransfer.files);
      }
    },

    // Override for tests
    _createXhr: function() {
      return new XMLHttpRequest();
    },

    _configureXhr: function(xhr) {
      xhr.responseType = 'json';
      if (typeof this.headers == 'string') {
        try {
          this.headers = JSON.parse(this.headers);
        } catch (e) {
          this.headers = undefined;
        }
      }
      for (var key in this.headers) {
        xhr.setRequestHeader(key, this.headers[key]);
      }
      if (this.timeout) {
        xhr.timeout = this.timeout;
      }
    },

    _setStatus: function(file, total, loaded, elapsed) {
      file.elapsed = elapsed;
      file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
      file.remaining = Math.ceil(elapsed * (total / loaded - 1));
      file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
      file.speed = ~~(total / elapsed / 1024);
      file.totalStr = this._formatSize(total);
      file.loadedStr = this._formatSize(loaded);
      file.status = this._formatFileProgress(file);
    },

    /**
     * Can be used to trigger the upload of any files that are not completed.
     *
     * @param {Array} [files] - Files being uploaded. Defaults to all outstanding files
     */
    uploadFiles: function(files) {
      // files = files || this.files;
      // files = files.filter(function(file) {
      //   return !file.complete;
      // });
      Array.prototype.forEach.call(files, this._uploadFile.bind(this));
    },

    _uploadFile: function(file) {
      if (file.uploading) {
        return;
      }

      var ini = Date.now();
      var xhr = file.xhr = this._createXhr(file);

      var stalledId, last;
      // onprogress is called always after onreadystatechange
      xhr.upload.onprogress = function(e) {
        clearTimeout(stalledId);

        last = Date.now();
        var elapsed = (last - ini) / 1000;
        var loaded = e.loaded, total = e.total, progress = ~~(loaded / total * 100);

        file.loaded = loaded;
        file.progress = progress;
        file.indeterminate = loaded <= 0 || loaded >= total;

        if (file.error) {
          file.indeterminate = file.status = undefined;
        } else if (!file.abort) {
          if (progress < 100) {
            this._setStatus(file, total, loaded, elapsed, progress);
            stalledId = setTimeout(function() {
              file.status = this.i18n.uploading.status.stalled;
              this._notifyFileChanges(file);
            }.bind(this), 2000);
          } else {
            file.loadedStr = file.totalStr;
            file.status = this.i18n.uploading.status.processing;
            file.uploading = false;
          }
        }

        this._notifyFileChanges(file);
        this.fire('upload-progress', {file: file, xhr: xhr});
      }.bind(this);

      // More reliable than xhr.onload
      xhr.onreadystatechange = function() {
        if (xhr.readyState == 4) {
          this.loadCompleteFilesCount += 1; 
          clearTimeout(stalledId);
          file.indeterminate = file.uploading = false;
          if (file.abort) {
            this._notifyFileChanges(file);
            return;
          }
          file.status = '';
          // Custom listener can modify the default behavior either
          // preventing default, changing the xhr, or setting the file error
          var evt = this.fire('upload-response', {file: file, xhr: xhr}, {cancelable: true});
          if (evt.defaultPrevented) {
            return;
          }
          if (xhr.status === 0) {
            file.error = this.i18n.uploading.error.serverUnavailable;
          } else if (xhr.status >= 500) {
            file.error = this.i18n.uploading.error.unexpectedServerError;
          } else if (xhr.status >= 400) {
            file.error = this.i18n.uploading.error.forbidden;
          }

          file.complete = !file.error;
          this.fire('upload-' + (file.error ? 'error' : 'success'), {file: file, xhr: xhr});
          this._notifyFileChanges(file);

          if(file.complete) {
            var actualFileName = file.name;

            if(this.s3Upload) {
              actualFileName = file.s3ObjectKey;
            }
            else if(xhr.response && xhr.response.fileName) {
              actualFileName = xhr.response.fileName;
            }

            var fileData = {
              "originalFileName": file.name,
              "fileName": actualFileName
            };

            this.succeededFiles.push(fileData);
          }

          if(this.validFilesCount == this.loadCompleteFilesCount){
              var eventData = {
                  name : "pebble-bulk-file-upload-success",
                  data : this.succeededFiles
              }

              this.fire('bedrock-event',eventData);
              this.set('complete', true);
              this.set('progress', 100);
          }
        }
      }.bind(this);

      var formData = new FormData();

      if(!file.uploadTarget || _.isEmpty(file.uploadTarget)) {
          file.uploadTarget = this.target.replace('<name>', file.name);
      }

      file.formDataName = this.formDataName;
      var evt = this.fire('upload-before', {file: file, xhr: xhr}, {cancelable: true});
      if (evt.defaultPrevented) {
        return;
      }

      formData.append(file.formDataName, file, file.name);

      xhr.open(this.method, file.uploadTarget, true);
      this._configureXhr(xhr);

      file.status = this.i18n.uploading.status.connecting;
      file.uploading = file.indeterminate = true;
      file.complete = file.abort = file.error = false;

      xhr.upload.onloadstart = function() {
        this.fire('upload-start', {file: file, xhr: xhr});
        this._notifyFileChanges(file);
      }.bind(this);

      // Custom listener could modify the xhr just before sending it
      // preventing default
      evt = this.fire('upload-request', {file: file, xhr: xhr, formData: formData}, {cancelable: true});
      if (!evt.defaultPrevented) {
        //Uploaded file in S3 is getting corrupted when sent through form-data...
        //S3 is expeting without form-data.
        //Whereas express file upload is failing without form-data.
        //Hence doing a S3 upload check and sending content appropriately
        if(this.s3Upload) {
          xhr.send(file);
        }
        else {
          xhr.send(formData);
        }
      }
    },

    _retryFileUpload: function(file) {
      var evt = this.fire('upload-retry', {file: file, xhr: file.xhr}, {cancelable: true});
      if (!evt.defaultPrevented) {
        Polymer.Async.microTask.run(() => { 
          this._uploadFile(file)
          });
      }
    },

    _abortFileUpload: function(file) {
      var evt = this.fire('upload-abort', {file: file, xhr: file.xhr}, {cancelable: true});
      if (!evt.defaultPrevented) {
        file.abort = true;
        if (file.xhr) {
          file.xhr.abort();
        }
        this._notifyFileChanges(file);
      }
    },

    _notifyFileChanges: function(file) {
      var p = 'files.' + this.files.indexOf(file) + '.';
      for (var i in file) {
        if (file.hasOwnProperty(i)) {
          this.notifyPath(p + i, file[i]);
        }
      }
    },

    _addFiles: function(files) {
      var totalFiles = this.files.length + files.length;
      if(this._maxFilesAdded(this.maxFiles, totalFiles)) {
        var eventData = {
          name : "pebble-bulk-file-upload-failed",
          data : "Failed to upload. Max files allowed is 350."
        }

        this.fire('bedrock-event',eventData);
        this.set('complete', true);
        this.set('progress', 100);
        return;
      }

      Array.prototype.forEach.call(files, this._addFile.bind(this));

      if(this.s3Upload) {
        var eventData = {
          name : "pebble-bulk-file-upload-started",
          data : files
        }

        this.fire('bedrock-event',eventData);
        this.set('complete', true);
        this.set('progress', 100);
      }
    },

    /**
     * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
     *
     * @param {File} file File being added
     */
    _addFile: function(file) {
      var fileExt = file.name.match(/\.[^\.]*$|$/)[0];
      var re = new RegExp('^(' + this.accept.replace(/[, ]+/g, '|').replace(/\/\*/g, '/.*') + ')$', 'i');
      if (this.accept && !(re.test(file.type) || re.test(fileExt))) {
        this.fire('file-reject', {file: file, error: this.i18n.error.incorrectFileType});
        return;
      }
      
      if(file.size <= 0) {
        file.error = this.i18n.error.fileIsEmpty;
      }
      else if(this.maxFileSize >= 0 && file.size > this.maxFileSize) {
        file.error = this.i18n.error.fileIsTooBig + this._formatSize(this.maxFileSize);
      }
      else {
        this.validFilesCount += 1; 
        file.status = this.i18n.uploading.status.held;
      }

      file.loaded = 0;
      this.unshift('files', file);

      if (!this.noAuto && !file.error) {
        this._uploadFile(file);
      }
    },

    /**
     * Remove file from upload list. Called internally if file upload was canceled.
     * @param {File} file File to remove
     */
    _removeFile: function(file) {
      this.splice('files', this.files.indexOf(file), 1);
    },

    _onAddFilesClick: function() {
      if (Polymer.Gestures.resetMouseCanceller) {
        /*
          With Polymer v1.7.1, the ghost-click prevention cancels the synthetic
          file input click in iOS Safari. This prevents the cancelling.

          See also: https://github.com/Polymer/polymer/issues/4242
        */
        Polymer.Gestures.resetMouseCanceller();
      }

      this.$.fileInput.value = '';
      this.$.fileInput.click();
    },

    _onFileInputChange: function(event) {
      this._addFiles(event.target.files);
    },

    _onFileRetry: function(event) {
      this._retryFileUpload(event.detail.file);
    },

    _onFileAbort: function(event) {
      this._abortFileUpload(event.detail.file);
    },

    _onFileRemove: function(event) {
      event.stopPropagation();
      this._removeFile(event.detail.file);
    },

    _dragoverChanged: function(dragover) {
      this.toggleAttribute('dragover', dragover);
    },

    _dragoverValidChanged: function(dragoverValid) {
      this.toggleAttribute('dragover-valid', dragoverValid);
    },

    _i18nPlural: function(value, plural) {
      return value == 1 ? plural.one : plural.many;
    },

    _isMultiple: function() {
      return this.maxFiles != 1;
    },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
    reset: function () {
      for (var key in this.files) {
          var file = this.files[key];
          file.abort = true;
          if (file.xhr) {
            file.xhr.abort();
        }
      }

      this.files = [];
      this.succeededFiles = [];
      this.loadCompleteFilesCount = 0;

      this.set('error', false);
      this.set('complete', false);
      this.set('progress', 0);
    }
  });

</script>