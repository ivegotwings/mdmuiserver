<!--
`bedrock-helpers` Represents a bunch of helpers that any bedrock, pebble, rock or app can use. 
-->
<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">
<link rel="import" href="../bedrock-externalref-underscore/bedrock-externalref-underscore.html">

<!--<script type="text/javascript" src="data-helper.js" />-->
<script>
    DataHelper = {};

    (function () {
        DataHelper.cloneObject = function (o) {
            return JSON.parse(JSON.stringify(o));
        };

        DataHelper.transformAttributeModelsToUIFormat = function (compositeModel, modelContext) {
            var mergedAttributeModels = {};

            //put default model as base
            if (compositeModel.data && compositeModel.data.attributes) {
                DataHelper._mergeObjects(mergedAttributeModels, compositeModel.data.attributes, true);
            }

            //apply ctx specific model on top of default
            var specificCtxAttributeModels = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(compositeModel,
                modelContext);
            DataHelper._mergeObjects(mergedAttributeModels, specificCtxAttributeModels, true);

            this._fillModels(mergedAttributeModels);

            //console.log(mergedAttributeModels);

            return mergedAttributeModels;
        };

        DataHelper._fillModels = function (attributeModelObjects) {
            for (var attributeName in attributeModelObjects) {
                var model = attributeModelObjects[attributeName];
                for (var prop in model.properties) {
                    model[prop] = model.properties[prop];
                }
                if (model.displayType != 'referenceList') {
                    model.displayType = this._getDisplayType(model.dataType);
                } else {
                    model.referenceEntityTypes = DataHelper._getEntityTypesForLov(model);
                }
                model.name = attributeName;
            }
        };

        DataHelper._getEntityTypesForLov = function (attributeModel) {
            var info = [];
            //find from manage model, looks like this:
            // "referenceEntityInfo": [
            //                     {
            //                         "refRelationshipName": "hasReferenceTo",
            //                         "refEntityType": "color"
            //                     }
            //                 ]
            if (attributeModel.referenceEntityInfo) {
                for (var i = 0; i < attributeModel.referenceEntityInfo.length; i++) {
                    var refInfo = attributeModel.referenceEntityInfo[i];
                    if (refInfo.refRelationshipName == 'hasReferenceTo' && refInfo.refEntityType) {
                        info.push(refInfo.refEntityType);
                    }
                }
            }

            return info;
        };

        DataHelper._getDisplayType = function (dataType) {
            var displayType = 'textbox';

            switch (dataType) {
                case 'boolean':
                    {
                        displayType = 'boolean';
                        break;
                    }
                case 'date':
                    {
                        displayType = 'date';
                        break;
                    }
                case 'datetime':
                    {
                        displayType = 'datetime';
                        break;
                    }
                case 'decimal':
                    {
                        displayType = 'textbox';
                        break;
                    }
            }

            return displayType;
        };

        DataHelper._mergeObjects = function (target, source, addMissing = false) {

            const deepAssign = SharedUtils.DataObjectFalcorUtil.deepAssign;

            if (!target) {
                if (addMissing) {
                    target = {};
                } else {
                    return target;
                }
            }

            if (!source) {
                return target;
            }

            for (var targetObjKey in target) {
                var targetObj = target[targetObjKey];
                var sourceObj = source[targetObjKey];

                if (sourceObj) {
                    targetObj = deepAssign(targetObj, sourceObj);
                }
            }

            if (addMissing) {
                for (var sourceObjKey in source) {
                    var sourceObj = source[sourceObjKey];

                    var targetObj = target[sourceObjKey];

                    if (!targetObj) {
                        target[sourceObjKey] = sourceObj;
                    }
                }
            }

            return target;
        };

        DataHelper.getRelationshipsByCtx = function (entityModel, modelContext) {
            return SharedUtils.DataObjectFalcorUtil.getRelationshipsByCtx(entityModel, modelContext);
        };

        DataHelper.transformAttributeFromUIFormat = function (attributesJSON) {
            var attributes = {};
            for (var i = 0; i < attributesJSON.length; i++) {
                var attributeJSON = attributesJSON[i];
                var attributeValues = [];
                //TODO: Review what to do with governance data
                delete attributeJSON.errors;

                if (Array.isArray(attributeJSON.value)) {
                    //For collection
                    for (var j = 0; j < attributeJSON.value.length; j++) {
                        if (attributeJSON.name) {
                            attributeValues.push({
                                "name": attributeJSON.name,
                                "value": attributeJSON.value[j].name ? attributeJSON.value[j].name : attributeJSON
                                    .value[j],
                                "source": attributeJSON.source,
                                "locale": attributeJSON.locale
                            });
                        }
                    }
                } else {
                    attributeValues.push({
                        "name": attributeJSON.name,
                        "value": attributeJSON.value,
                        "source": attributeJSON.source,
                        "locale": attributeJSON.locale
                    });
                }

                attributes[attributeJSON.name] = {
                    "values": attributeValues
                };
            }
            return attributes;
        };

        DataHelper.findEntityById = function (entitiesExternalFormat, entityId) {
            if (entitiesExternalFormat && entitiesExternalFormat.length) {
                for (var i = 0; i < entitiesExternalFormat.length; i++) {
                    var entity = entitiesExternalFormat[i];
                    if (entityId == entity.id) {
                        return entity;
                    }
                }
            }
            return {};
        };

        DataHelper.prepareCtx = function (dataContext) {
            return {
                "list": dataContext.list,
                "classification": dataContext.classification
            };
        };

        DataHelper.prepareValCtx = function (dataContext) {
            return {
                "source": dataContext.source,
                "locale": dataContext.locale,
                "time": dataContext.time
            };
        };

        DataHelper.getAttributesInManageFormat = function (entity, attributeModels, dataContext) {
            if (!entity) {
                return {};
            }

            if (!entity.data) {
                entity.data = {};
            }

            var contexts = DataHelper.prepareCtx(dataContext);
            var valueContexts = DataHelper.prepareValCtx(dataContext);

            var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity, contexts);

            return DataHelper.transformAttributesToManageFormat(attributes, attributeModels, valueContexts);
        };

        DataHelper.transformAttributesToManageFormat = function (attributes, attributeModels, valueContexts) {
            var attributesInManageFormat = []; //our return value

            for (var attributeModelName in attributeModels) {
                var attributeJSON = {};
                var attributeModel = attributeModels[attributeModelName];
                if (attributeModel.name) {
                    var attribute = attributes[attributeModel.name];
                    if (attribute && attribute.values) {
                        attributeJSON = this._getCurrentValue(attribute.values, valueContexts, attributeModel);
                        if (attributeJSON != undefined && attributeJSON.hasOwnProperty('invalidValue')) {
                            attributeJSON["value"] = attributeJSON.invalidValue;
                        }
                    }
                    if (attributeJSON == undefined || !attributeJSON.hasOwnProperty('value')) {
                        attributeJSON = this._getEmptyValue(valueContexts);
                    }
                    attributeJSON.name = attributeModel.name;
                    attributesInManageFormat.push(attributeJSON);
                }
            }
            //console.log(attributesInManageFormat);
            return attributesInManageFormat;
        };

        DataHelper.transformAttributesToGridFormat = function (attributes, attributeModels, valueContexts) {

            var attributesData = {};

            for (var attributeModelName in attributeModels) {
                var attributeModel = attributeModels[attributeModelName];
                if (attributeModel.name) {
                    var attributeJSON = {};
                    var attribute = attributes[attributeModel.name];

                    if (attribute && attribute.values) {
                        attributeJSON = this._getCurrentValue(attribute.values, valueContexts, attributeModel);
                    }

                    if (attributeJSON == undefined) {
                        attributeJSON = this._getEmptyValue(valueContexts);
                    }

                    attributesData[attributeModel.name] = attributeJSON;
                }
            }

            return attributesData;
        };

        DataHelper.transformEntitySchemaForGrid = function (entities, attributeModels, contextData) {

            var firstDataContext = ContextHelper.getFirstDataContext(contextData);
            var firstValueContext = ContextHelper.getFirstValueContext(contextData);

            if (entities && entities.length) {
                var entitiesToBeRemoved = [];
                for (var i = 0; i < entities.length; i++) {
                    var entity = entities[i];
                    if (typeof (entity) == "object" && entity.data) {
                        var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity,
                            firstDataContext);
                        entity.attributes = this.transformAttributesToGridFormat(attributes, attributeModels,
                            firstValueContext);
                    } else {
                        //if the array has a bad item (non-entity, or entity with no data) then mark it for delete
                        entitiesToBeRemoved.push(entities[i].id);
                    }
                }

                // Todo.. Find a better solution and create a private function
                // Ask Jimmy .... Is this really required?
                entitiesToBeRemoved.forEach(function (entityToBeRemoved) {
                    for (var i = 0; i < entities.length; i++) {
                        if (entities[i].id === entityToBeRemoved) {
                            var currentEntity = entities[i];
                            entities.splice(currentEntity, 1);
                        }
                    }
                });
            }
        };

        DataHelper.transformEntitySchemaToLovSchema = function (entities, lovColumnNameValueCollection) {
            // Note: We will go by the assumption that id or value field is going to be unique
            //       if id or name is provided do not put it into attributes fields

            var formattedEntities = [];

            if (entities && entities.length) {
                var entitiesToBeRemoved = [];

                for (var i = 0; i < entities.length; i++) {
                    if (typeof (entities[i]) == "object") {
                        var formattedEntity = {};

                        Object.keys(lovColumnNameValueCollection).map(function (columnName) {
                            var attributeValue;

                            if (lovColumnNameValueCollection[columnName] == "id") {
                                formattedEntity[columnName] = entities[i].id;
                            } else if (lovColumnNameValueCollection[columnName] == "name") {
                                formattedEntity[columnName] = entities[i].name;
                            } else if (columnName == "type") {
                                var entityTypes = lovColumnNameValueCollection[columnName];

                                if (typeof (entityTypes !== "undefined" && entityTypes instanceof Array)) {
                                    for (j = 0; j < entityTypes.length; j++) {
                                        if (entityTypes[j] === entities[i].type) {
                                            formattedEntity[columnName] = entityTypes[j];
                                        }
                                    }
                                }
                            } else {
                                if (entities[i].data) {
                                    attributeValue = DataHelper._transformEntityAttributesForLovSchema(
                                        entities[i].data
                                        .ctxInfo,
                                        lovColumnNameValueCollection[columnName]);
                                    formattedEntity[columnName] = attributeValue.value;
                                }
                            }
                        });

                        formattedEntities.push(formattedEntity);
                    } else {
                        //if the array has a bad item (non-entity, or entity with no data) then mark it for delete
                        entitiesToBeRemoved.push(i);
                    }
                }

                // Make it Private
                entitiesToBeRemoved.forEach(function (entityToBeRemoved) {
                    for (var i = 0; i < entities.length; i++) {
                        if (entities[i].id === entityToBeRemoved) {
                            var currentEntity = entities[i];
                            entities.splice(currentEntity, 1);
                        }
                    }
                });
            }

            return formattedEntities;
        };

        DataHelper._transformEntityAttributesForLovSchema = function (contexts, attributeName) {
            var attributeValueObject = {};

            for (var i = 0; i < contexts.length; i++) {
                var attributes = contexts[i].attributes

                Object.keys(attributes).map(function (key) {
                    if (key == attributeName && attributes[key].values) {
                        attributeValueObject = attributes[key].values[0];
                    }
                });
            }

            return attributeValueObject;
        };

        DataHelper.transformEntityModelSchemaToLovSchema = function (entityModels, lovColumnNameValueCollection) {
            var formattedEntityModels = [];

            if (entityModels && entityModels.length) {
                var entityModelsToBeRemoved = [];

                for (var i = 0; i < entityModels.length; i++) {
                    if (typeof (entityModels[i]) == "object") {

                        var formattedEntityModel = {};

                        Object.keys(lovColumnNameValueCollection).map(function (columnName) {
                            var attributeValue;

                            if (lovColumnNameValueCollection[columnName] == "id") {
                                formattedEntityModel[columnName] = entityModels[i].id;
                            } else if (lovColumnNameValueCollection[columnName] == "name") {
                                formattedEntityModel[columnName] = entityModels[i].name;
                            } else if (columnName == "type") {
                                formattedEntityModel[columnName] = "";
                                var entityTypes = lovColumnNameValueCollection[columnName];

                                if (typeof (entityTypes !== "undefined" && entityTypes instanceof Array)) {
                                    for (j = 0; j < entityTypes.length; j++) {
                                        if (entityTypes[j] === entityModels[i].type) {
                                            formattedEntityModel[columnName] = entityTypes[j];
                                        }
                                    }
                                }

                            } else {
                                var data = entityModels[i].data;
                                if (typeof (data) !== "undefined") {

                                    attributeValue = DataHelper._transformEntityAttributesForLovSchema(
                                        data.ctxInfo, lovColumnNameValueCollection[columnName]);
                                    formattedEntityModel[columnName] = attributeValue.value;

                                }
                            }
                        });

                        formattedEntityModels.push(formattedEntityModel);
                    } else {
                        entityModelsToBeRemoved.push(i);
                    }
                }

                entityModelsToBeRemoved.forEach(function (entityModelToBeRemoved) {
                    for (var i = 0; i < entityModels.length; i++) {
                        if (entityModels[i].id === entityModelToBeRemoved) {
                            var currentEntityModel = entityModels[i];
                            entityModels.splice(currentEntityModel, 1);
                        }
                    }
                });
            }

            return formattedEntityModels;
        };

        DataHelper.compareObjects = function (firstObject, secondObject) {
            // Create arrays of property names
            var firstObjectProps = Object.getOwnPropertyNames(firstObject);
            var secondObjectProps = Object.getOwnPropertyNames(secondObject);

            // If number of properties is different,
            // objects are not equivalent
            if (firstObjectProps.length != secondObjectProps.length) {
                return false;
            }

            for (var i = 0; i < firstObjectProps.length; i++) {
                var propName = firstObjectProps[i];

                // If values of same property are not equal,
                // objects are not equivalent
                if (firstObject[propName] !== secondObject[propName]) {
                    return false;
                }
            }

            // If we made it this far, objects
            // are considered equivalent
            return true;
        };

        //TODO: Remove this after dimension selector starts using _.isEmpty
        DataHelper.isEmptyObject = function (obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    return false;
                }
            }

            return true;
        };

        DataHelper._getCurrentValue = function (values, valueContexts, model) {

            if ((model.displayType == "textbox" || model.displayType == "referenceList") && model.isCollection) {
                return this._getCurrentValues(values, valueContexts, model);
            }

            var value;
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    //TODO: locale and source case is not matching for what is there in dimension selector and what is coming in data,
                    // need to find a better answer
                    if (valCtx.locale && currentValue.locale && currentValue.locale.toLowerCase() != valCtx.locale
                        .toLowerCase()) {
                        continue;
                    }
                    if (valCtx.source && currentValue.source && currentValue.source.toLowerCase() != valCtx.source
                        .toLowerCase()) {
                        continue;
                    }
                    //TODO: compare for time?
                    value = this.cloneObject(currentValue);
                    break;
                }
            }

            return value;
        };

        DataHelper._getCurrentValues = function (values, valueContexts, model) {

            if (!((model.displayType == "textbox" || model.displayType == "referenceList") && model.isCollection)) {
                return;
            }

            var _values = [];

            if (values) {
                for (var i = 0; i < values.length; i++) {

                    var currentValue = values[i];
                    //TODO: locale and source case is not matching for what is there in dimension selector and what is coming in data,
                    // need to find a better answer
                    if (valCtx.locale && currentValue.locale && currentValue.locale.toLowerCase() != valCtx.locale
                        .toLowerCase()) {
                        continue;
                    }
                    if (valCtx.source && currentValue.source && currentValue.source.toLowerCase() != valCtx.source
                        .toLowerCase()) {
                        continue;
                    }
                    //TODO: compare for time?

                    if (Array.isArray(currentValue.value)) //When save, already array, then no change
                    {
                        _values = _values.concat(currentValue.value);
                    } else if (model.displayType == "referenceList") {
                        _values.push(currentValue.value);
                    } else {
                        //TODO: Clean this up once text collection supports string array as values
                        _values.push(this._getTextCollectonSupportedFormat(currentValue));
                    }
                }
            }

            return {
                "value": _values,
                "source": valueContexts.source,
                "locale": valueContexts.locale
            }
        };

        DataHelper._getTextCollectonSupportedFormat = function (obj) {
            return {
                "name": obj.value,
                "longName": obj.value
            };
        };

        DataHelper._getEmptyValue = function (valueContexts) {
            return {
                "value": "",
                "locale": valueContexts.locale,
                "time": valueContexts.time,
                "source": valueContexts.source
            };
        };

        DataHelper.getParamValue = function (param) {
            var mainApp = document.querySelector('main-app');
            if (mainApp && mainApp.pageRoute && mainApp.pageRoute.__queryParams && param in mainApp.pageRoute
                .__queryParams) {
                return mainApp.pageRoute.__queryParams[param];
            }
        };

        DataHelper._isEqual = function (stooge, clone) {
            return _.isEqual(stooge, clone);
        };

        DataHelper._findItemByKeyValue = function (array, key, value) {
            var elementToReturn = _.filter(array, function (currentElement) {
                if (currentElement[key] === value) {
                    return currentElement;
                }
            });

            return elementToReturn[0];
        };

        DataHelper.getFirstAttributeValue = function (attribute) {
            if (attribute && attribute.values && attribute.values.length > 0) {
                return attribute.values[0].value;
            }
            return null;
        };

        DataHelper.getValue = function (obj, key) {
            var outputObj = {};
            for (var i in obj) {
                if (!obj.hasOwnProperty(i)) continue;
                if (i == key) {
                    return obj[i];
                } else if (typeof obj[i] == 'object') {
                    outputObj = DataHelper.getValue(obj[i], key);
                }
            }
            return outputObj;
        };

        DataHelper.validateGetEntitiesResponse = function (entitiesResponse) {
            if (entitiesResponse && entitiesResponse.content && entitiesResponse.content.entities &&
                !_.isEmpty(entitiesResponse.content.entities)) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetModelsResponse = function (modelsResponse) {
            if (modelsResponse && modelsResponse.content &&
                modelsResponse.content.entityModels && modelsResponse.content.entityModels
                .length >
                0) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetAttributeModelsResponse = function (attributeModelsResponse) {
            if (attributeModelsResponse && attributeModelsResponse.returnValue &&
                attributeModelsResponse.returnValue.attributeModels &&
                !_.isEmpty(attributeModelsResponse.returnValue.attributeModels)) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetAttributeModelsResponse_New = function (attributeModelsResponsee) {
            if (attributeModelsResponsee && attributeModelsResponsee.content &&
                attributeModelsResponsee.content.entityModels && attributeModelsResponsee.content.entityModels
                    .length >0 && !_.isEmpty(attributeModelsResponsee.content.entityModels[0])) {

                return true;
            }
            return false;
        };

        DataHelper._prepareContextGroups = function (lists, classification) {
            if (!classification) {
                classification = "_ALL";
            }

            if (lists && lists instanceof Array) {
                var contexts = [];
                for (var i = 0; i < lists.length; i++) {
                    var ctxContextObject = {};
                    ctxContextObject.list = lists[i].value;
                    ctxContextObject.classification = classification;
                    context.push(ctxContextObject);
                }

                return contexts;
            }
        };

        DataHelper._prepareValueContextGroups = function (sources, locales) {
            var valContexts = [];
            if (sources && locales && sources instanceof Array && locales instanceof Array) {
                for (var i = 0; i < sources.length; i++) {
                    for (var j = 0; j < locales.length; j++) {
                        var valContextObject = {};
                        valContextObject.source = sources[i].value;
                        valContextObject.locale = locales[j].value;
                        valContexts.push(valContextObject);
                    }
                }
                return valContexts;
            }
        };

        DataHelper.getEmptyRelationshipDataObject = function (list, classification, relationship) {

            var relationships = {};

            relationships[relationship] = [];

            return {
                "contexts": [{
                    "context": {
                        "classification": classification,
                        "list": list
                    },
                    "relationships": relationships
                }]
            }
        };

        DataHelper.oneTimeEvent = function (element, type, callback) {
            element.addEventListener(type, function (e) {
                e.target.removeEventListener(e.type, arguments.callee);
                return callback(e);
            });
        };

        DataHelper.getTenantId = function () {
            var tenantId = 'jcp';
            var mainApp = document.querySelector("main-app");
            if (mainApp && mainApp.tenantId) {
                tenantId = mainApp.tenantId;
            }

            return tenantId;
        };

        DataHelper.arrayRemove = function (arr, val) {
            var index = -1;
            index = arr.indexOf(val);
            while (index >= 0) {
                arr.splice(index, 1);
                index = arr.indexOf(val);
            }
        };


        DataHelper.getAttributeValues = function (values, valueContexts) {
            var _values = [];
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    if (valCtx.locale && currentValue.locale && currentValue.locale.toLowerCase() != valCtx.locale
                        .toLowerCase()) {
                        continue;
                    }
                    if (valCtx.source && currentValue.source && currentValue.source.toLowerCase() != valCtx.source
                        .toLowerCase()) {
                        continue;
                    }
                    if (Array.isArray(currentValue.value)) //When save, already array, then no change
                    {
                        _values = _values.concat(currentValue.value);
                    } else {
                        _values.push(currentValue.value);
                    }
                }
            }
            return _values;
        };

        DataHelper.getAttributeNamesFromEntities = function (entities) {
            var loopThroughLength = entities.length; // ToDO: should come from config.
            var attributeNames = [];
            for (var i = 0; i < loopThroughLength; i++) {
                if (entities[i]) {
                    var entity = entities[i];
                    var attributes = entity.data.contexts[0].attributes;
                    var keys = Object.keys(attributes);
                    if (keys && keys.length > 0) {
                        for (var j = 0; j < keys.length; j++) {
                            if (attributeNames.indexOf(keys[j]) == -1) {
                                attributeNames.push(keys[j]);
                            }
                        }
                    }
                }
            }
            return attributeNames;
        };

        DataHelper.TransformGridDataToEntitiesSchema = function (data, dataContext, attributeModels) {
            var entities = [];
            if (data && data.length > 0) {
                for (var i = 0; i < data.length; i++) {
                    var rowData = data[i];
                    var keys = Object.keys(rowData);
                    var attributesJson = [];
                    if (keys && keys.length > 0) {
                        for (var j = 0; j < keys.length; j++) {
                            var key = keys[j];
                            if (attributeModels[key]) {
                                var attribute = {
                                    "name": key,
                                    "value": rowData[key],
                                    "source": dataContext.source,
                                    "locale": dataContext.locale
                                };
                                attributesJson.push(attribute);
                            }
                        }
                        var attributes = DataHelper.transformAttributeFromUIFormat(attributesJson);
                    }
                    var entity = {
                        id: rowData.id,
                        type: dataContext.entityType,
                        properties: {
                            "createdBy": "John Doe"
                        },
                        data: {
                            contexts: [{
                                "context": {
                                    "list": dataContext.list,
                                    "classification": dataContext.classification
                                },
                                "attributes": attributes
                            }]
                        }
                    };
                    entities.push(entity);
                }
            }
            return entities;
        };

    })();
</script>