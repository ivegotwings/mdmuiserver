<!--
`bedrock-helpers` Represents a bunch of helpers that any bedrock, pebble, rock or app can use. 
-->
<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<!--<script type="text/javascript" src="data-helper.js" />-->
<script>
    DataHelper = {};

    (function () {
        DataHelper.cloneObject = function (o) {
            return JSON.parse(JSON.stringify(o));
        };

        DataHelper.transformAttributeModelsToUIFormat = function (compositeModel, modelContext) {
            var mergedAttributeModels = {};

            //put default model as base
            if (compositeModel.data && compositeModel.data.attributes) {
                DataHelper._mergeObjects(mergedAttributeModels, compositeModel.data.attributes, true);
            }

            //apply ctx specific model on top of default
            var specificCtxAttributeModels = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(compositeModel, modelContext);
            DataHelper._mergeObjects(mergedAttributeModels, specificCtxAttributeModels, true);

            this._fillModels(mergedAttributeModels);

            //console.log(mergedAttributeModels);

            return mergedAttributeModels;
        },

            DataHelper._fillModels = function (attributeModelObjects) {
                for (var attributeName in attributeModelObjects) {
                    var model = attributeModelObjects[attributeName];
                    for (var prop in model.properties) {
                        model[prop] = model.properties[prop];
                    }
                    model['displayType'] = this._getDisplayType(model.properties['dataType']);
                    model.name = attributeName;
                }
            },

            DataHelper._getDisplayType = function (dataType) {
                var displayType = 'textbox';

                switch (dataType) {
                    case 'boolean': {
                        displayType = 'boolean';
                        break;
                    }
                    case 'date': {
                        displayType = 'date';
                        break;
                    }
                    case 'datetime': {
                        displayType = 'datetime';
                        break;
                    }
                    case 'decimal': {
                        displayType = 'textbox';
                        break;
                    }
                }

                return displayType;
            },

            DataHelper._mergeObjects = function (target, source, addMissing = false) {

                const deepAssign = SharedUtils.DataObjectFalcorUtil.deepAssign;

                if (!target) {
                    if (addMissing) {
                        target = {};
                    } else {
                        return target;
                    }
                }

                if (!source) {
                    return target;
                }

                for (var targetObjKey in target) {
                    var targetObj = target[targetObjKey];
                    var sourceObj = source[targetObjKey];

                    if (sourceObj) {
                        targetObj = deepAssign(targetObj, sourceObj);
                    }
                }

                if (addMissing) {
                    for (var sourceObjKey in source) {
                        var sourceObj = source[sourceObjKey];

                        var targetObj = target[sourceObjKey];

                        if (!targetObj) {
                            target[sourceObjKey] = sourceObj;
                        }
                    }
                }

                return target;
            },

            DataHelper.getRelationshipsByCtx = function (entityModel, modelContext) {
                return SharedUtils.DataObjectFalcorUtil.getRelationshipsByCtx(entityModel, modelContext);
            },

            DataHelper.transformAttributeFromUIFormat = function (attributesJSON) {
                var attributes = {};
                for (var i = 0; i < attributesJSON.length; i++) {
                    var attributeJSON = attributesJSON[i];
                    var attributeValues = [];
                    //TODO: Review what to do with governance data  
                    delete attributeJSON.errors;

                    if (Array.isArray(attributeJSON.value)) {
                        //For collection
                        for (var j = 0; j < attributeJSON.value.length; j++) {
                            if (attributeJSON.name) {
                                attributeValues.push({
                                    "name": attributeJSON.name,
                                    "value": attributeJSON.value[j].name,
                                    "source": attributeJSON.source,
                                    "locale": attributeJSON.locale
                                });
                            }
                        }
                    } else {
                        attributeValues.push({
                            "name": attributeJSON.name,
                            "value": attributeJSON.value,
                            "source": attributeJSON.source,
                            "locale": attributeJSON.locale
                        });
                    }

                    attributes[attributeJSON.name] = {
                        "values": attributeValues
                    };
                }
                return attributes;
            }

        DataHelper.findEntityById = function (entitiesExternalFormat, entityId) {
            if (entitiesExternalFormat && entitiesExternalFormat.length) {
                for (var i = 0; i < entitiesExternalFormat.length; i++) {
                    var entity = entitiesExternalFormat[i];
                    if (entityId == entity.id) {
                        return entity;
                    }
                }
            }
            return {};
        }

        DataHelper.prepareCtx = function (dataContext) {
            return {
                "list": dataContext.list,
                "classification": dataContext.classification
            };
        };

        DataHelper.prepareValCtx = function (dataContext) {
            return {
                "source": dataContext.source,
                "locale": dataContext.locale,
                "time": dataContext.time
            };
        };

        DataHelper.getAttributesInManageFormat = function (entity, attributeModels, dataContext) {
            if (!entity) {
                return {};
            }

            if (!entity.data) {
                entity.data = {};
            }

            var ctx = DataHelper.prepareCtx(dataContext);
            var valCtx = DataHelper.prepareValCtx(dataContext);

            var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity, ctx);

            return DataHelper.transformAttributesToManageFormat(attributes, attributeModels, valCtx);
        };

        DataHelper.transformAttributesToManageFormat = function (attributes, attributeModels, valCtx) {
            var attributesInManageFormat = []; //our return value

            for (var attributeModelName in attributeModels) {
                var attributeJSON = {};
                var attributeModel = attributeModels[attributeModelName];
                if (attributeModel.name) {
                    var attribute = attributes[attributeModel.name];
                    if (attribute && attribute.values) {
                        attributeJSON = this._getCurrentValue(attribute.values, valCtx, attributeModel);
                        if (attributeJSON != undefined && attributeJSON.hasOwnProperty('invalidValue')) {
                            attributeJSON["value"] = attributeJSON.invalidValue;
                        }
                    }
                    if (attributeJSON == undefined || !attributeJSON.hasOwnProperty('value')) {
                        attributeJSON = this._getEmptyValue(valCtx);
                    }
                    attributeJSON.name = attributeModel.name;
                    attributesInManageFormat.push(attributeJSON);
                }
            }
            //console.log(attributesInManageFormat);
            return attributesInManageFormat;
        };

        DataHelper.transformAttributesToGridFormat = function (attributes, attributeModels, valCtx) {

            var attributesData = {};

            for (var attributeModelName in attributeModels) {
                var attributeModel = attributeModels[attributeModelName];
                if (attributeModel.name) {
                    var attributeJSON = {};
                    var attribute = attributes[attributeModel.name];

                    if (attribute && attribute.values) {
                        attributeJSON = this._getCurrentValue(attribute.values, valCtx, attributeModel);
                    }

                    if (attributeJSON == undefined || !attributeJSON.hasOwnProperty('value')) {
                        attributeJSON = this._getEmptyValue(valCtx);
                    }

                    attributesData[attributeModel.name] = attributeJSON;
                }
            }

            return attributesData;
        };

        DataHelper.transformEntitySchemaForGrid = function (entities, attributeModels, dataContext) {

            var ctx = DataHelper.prepareCtx(dataContext);
            var valCtx = DataHelper.prepareValCtx(dataContext);

            if (entities && entities.length) {
                var entitiesToBeRemoved = [];
                for (var i = 0; i < entities.length; i++) {
                    var entity = entities[i];
                    if (typeof (entity) == "object" && entity.data) {
                        entity.entityType = entity.entityInfo && entity.entityInfo.entityType ? entity.entityInfo.entityType : "";
                        var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity, ctx);
                        entity.attributes = this.transformAttributesToGridFormat(attributes, attributeModels, valCtx);
                    } else {
                        //if the array has a bad item (non-entity, or entity with no data) then mark it for delete
                        entitiesToBeRemoved.push(entities[i].id);
                    }
                }

                // Todo.. Find a better solution and create a private function
                // Ask Jimmy .... Is this really required?
                entitiesToBeRemoved.forEach(function (entityToBeRemoved) {
                    for (var i = 0; i < entities.length; i++) {
                        if (entities[i].id === entityToBeRemoved) {
                            var currentEntity = entities[i];
                            entities.splice(currentEntity, 1);
                        }
                    }
                });
            }
        };

        DataHelper.transformEntitySchemaForLov = function (entities, lovAttributeMap) {
            var lovFormatedData = [];
            if (entities && entities.length) {
                var entitiesToBeRemoved = [];
                for (var i = 0; i < entities.length; i++) {
                    if (typeof (entities[i]) == "object" && entities[i].data) {
                        var lovFormattedEntity = {};
                        Object.keys(lovAttributeMap).map(function (key) {
                            var attributeValue;
                            if (lovAttributeMap[key] == "id") {
                                lovFormattedEntity[key] = entities[i].id;
                            } else {
                                attributeValue = DataHelper.transformAttributesToLovFormat(
                                    entities[i].data
                                        .ctxInfo,
                                    lovAttributeMap[key]);
                                lovFormattedEntity[key] = attributeValue.value;
                            }
                        });
                        lovFormatedData.push(lovFormattedEntity);
                    } else {
                        //if the array has a bad item (non-entity, or entity with no data) then mark it for delete
                        entitiesToBeRemoved.push(i);
                    }
                }
                if (entitiesToBeRemoved && entitiesToBeRemoved.length) {
                    for (var i = 0; i < entitiesToBeRemoved.length; i++) {
                        entities.splice(entitiesToBeRemoved[i], 1);
                    }
                }
            }
            return lovFormatedData;
        };

        DataHelper.transformAttributesToLovFormat = function (ctxInfo, attributeName) {
            var attributeValueObject = {};
            for (var i = 0; i < ctxInfo.length; i++) {
                var attributes = ctxInfo[i].attributes
                Object.keys(attributes).map(function (key) {
                    if (key == attributeName && attributes[key].values) {
                        attributeValueObject = attributes[key].values[0];
                    }
                });
            }
            return attributeValueObject;
        };

        DataHelper.transformEntityModelForLov = function (entityModels, lovAttributeMap) {
            var formattedEntityModels = [];
            if (entityModels && entityModels.length) {
                var entityModelsToBeRemoved = [];
                for (var i = 0; i < entityModels.length; i++) {
                    if (typeof (entityModels[i]) == "object") {

                        var formattedEntityModel = {};
                        Object.keys(lovAttributeMap).map(function (key) {
                            var field = lovAttributeMap[key];
                            formattedEntityModel[key] = entityModels[i][field];
                        });
                        formattedEntityModels.push(formattedEntityModel);

                    } else {
                        entityModelsToBeRemoved.push(i);
                    }
                }

                if (entityModelsToBeRemoved && entityModelsToBeRemoved.length) {
                    for (var i = 0; i < entityModelsToBeRemoved.length; i++) {
                        entityModels.splice(entityModelsToBeRemoved[i], 1);
                    }
                }
            }
            return formattedEntityModels;
        };

        DataHelper.compareObjects = function (firstObject, secondObject) {
            // Create arrays of property names
            var firstObjectProps = Object.getOwnPropertyNames(firstObject);
            var secondObjectProps = Object.getOwnPropertyNames(secondObject);

            // If number of properties is different,
            // objects are not equivalent
            if (firstObjectProps.length != secondObjectProps.length) {
                return false;
            }

            for (var i = 0; i < firstObjectProps.length; i++) {
                var propName = firstObjectProps[i];

                // If values of same property are not equal,
                // objects are not equivalent
                if (firstObject[propName] !== secondObject[propName]) {
                    return false;
                }
            }

            // If we made it this far, objects
            // are considered equivalent
            return true;
        }

        DataHelper.isEmptyObject = function (obj) {
            for (var prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    return false;
                }
            }

            return true;
        }

        DataHelper._getCurrentValue = function (values, valCtx, model) {

            if (model.displayType == "textbox" && model.isCollection) {
                return this._getCurrentValues(values, valCtx, model);
            }

            var value;
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    //TODO: locale and source case is not matching for what is there in dimension selector and what is coming in data,
                    // need to find a better answer
                    if (valCtx.locale && currentValue.locale && currentValue.locale.toLowerCase() != valCtx.locale.toLowerCase()) {
                        continue;
                    }
                    if (valCtx.source && currentValue.source && currentValue.source.toLowerCase() != valCtx.source.toLowerCase()) {
                        continue;
                    }
                    //TODO: compare for time?
                    value = this.cloneObject(currentValue);
                    break;
                }
            }

            return value;
        };

        DataHelper._getCurrentValues = function (values, valCtx, model) {

            if (!(model.displayType == "textbox" && model.isCollection)) {
                return;
            }

            var _values = [];

            if (values) {
                for (var i = 0; i < values.length; i++) {

                    var currentValue = values[i];
                    //TODO: locale and source case is not matching for what is there in dimension selector and what is coming in data,
                    // need to find a better answer
                    if (valCtx.locale && currentValue.locale && currentValue.locale.toLowerCase() != valCtx.locale.toLowerCase()) {
                        continue;
                    }
                    if (valCtx.source && currentValue.source && currentValue.source.toLowerCase() != valCtx.source.toLowerCase()) {
                        continue;
                    }
                    //TODO: compare for time?

                    if (Array.isArray(currentValue.value)) //When save, already array, then no change
                    {
                        _values = _values.concat(currentValue.value);
                    } else {
                        _values.push(this._getTextCollectonSupportedFormat(currentValue));
                    }
                }
            }

            return {
                "value": _values,
                "source": valCtx.source,
                "locale": valCtx.locale
            }
        };

        DataHelper._getTextCollectonSupportedFormat = function (obj) {
            return {
                "name": obj.value,
                "longName": obj.value
            };
        };

        DataHelper._getEmptyValue = function (valCtx) {
            return {
                "value": "",
                "locale": valCtx.locale,
                "time": valCtx.time,
                "source": valCtx.source
            };
        };

        DataHelper.getParamValue = function (param) {
            var mainApp = document.querySelector('main-app');
            if (mainApp && mainApp.pageRoute && mainApp.pageRoute.__queryParams && param in mainApp.pageRoute
                .__queryParams) {
                return mainApp.pageRoute.__queryParams[param];
            }
        };

        DataHelper._isEqual = function (stooge, clone) {
            return _.isEqual(stooge, clone);
        };

        DataHelper._findItemByKeyValue = function (array, key, value) {
            var elementToReturn = _.filter(array, function (currentElement) {
                if (currentElement[key] === value) {
                    return currentElement;
                }
            });

            return elementToReturn[0];
        };
        DataHelper.getFirstAttributeValue = function (attribute) {
            if (attribute && attribute.values && attribute.values.length > 0) {
                return attribute.values[0].value;
            }
            return null;
        };

        DataHelper.getValue = function (obj, key) {
            var outputObj = {};
            for (var i in obj) {
                if (!obj.hasOwnProperty(i)) continue;
                if (i == key) {
                    return obj[i];
                } else if (typeof obj[i] == 'object') {
                    outputObj = DataHelper.getValue(obj[i], key);
                }
            }
            return outputObj;
        };

        DataHelper.validateGetEntitiesResponse = function (entitiesResponse) {
            if (entitiesResponse && entitiesResponse.content && entitiesResponse.content.entities &&
                !_.isEmpty(entitiesResponse.content.entities)) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetModelsResponse = function (modelsResponse) {
            if (modelsResponse && modelsResponse.content &&
                modelsResponse.content.entityModels && modelsResponse.content.entityModels
                    .length >
                0) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetAttributeModelsResponse = function (attributeModelsResponse) {
            if (attributeModelsResponse && attributeModelsResponse.returnValue &&
                attributeModelsResponse.returnValue.attributeModels &&
                !_.isEmpty(attributeModelsResponse.returnValue.attributeModels)) {

                return true;
            }
            return false;
        };

        DataHelper.validateGetAttributeModelsResponse_New = function (attributeModelsResponsee) {
            if (attributeModelsResponsee && attributeModelsResponsee.content &&
                attributeModelsResponsee.content.entityModels && attributeModelsResponsee.content.entityModels
                    .length >
                0) {

                return true;
            }
            return false;
        };

        DataHelper._prepareContextGroups = function (lists, classification) {
            if (!classification) {
                classification =
                    "_ALL";
            }
            if (lists && lists instanceof Array) {
                var ctxGroup = [];
                for (var i = 0; i < lists.length; i++) {
                    var ctxInfoObject = {};
                    ctxInfoObject.list = lists[i].value;
                    ctxInfoObject.classification = classification;
                    ctxGroup.push(ctxInfoObject);
                }
                return ctxGroup;
            }
        };

        DataHelper._prepareValueContextGroups = function (sources, locales) {
            var valueCtxGroup = [];
            if (sources && locales && sources instanceof Array && locales instanceof Array) {
                for (var i = 0; i < sources.length; i++) {
                    for (var j = 0; j < locales.length; j++) {
                        var valueCtxInfoObject = {};
                        valueCtxInfoObject.source = sources[i].value;
                        valueCtxInfoObject.locale = locales[j].value;
                        valueCtxGroup.push(valueCtxInfoObject);
                    }
                }
                return valueCtxGroup;
            }
        };

        DataHelper.getEmptyRelationshipDataObject = function (list, classification, relationship) {
            var ctxGroup = {};
            var relationships = {};

            relationships[relationship] = [];

            return {
                "ctxInfo": [{
                    "ctxGroup": {
                        "classification": classification,
                        "list": list
                    },
                    "relationships": relationships
                }]
            }
        }

        DataHelper.oneTimeEvent = function (element, type, callback) {
            element.addEventListener(type, function (e) {
                e.target.removeEventListener(e.type, arguments.callee);
                return callback(e);
            });
        };

    })();

</script>