<!--
`bedrock-helpers` Represents a bunch of helpers that any bedrock, pebble, rock or app can use. 
-->
<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-merge-helper.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<!--<script type="text/javascript" src="data-helper.js" />-->
<script>
    AttributeHelper = {};

    (function () {

        AttributeHelper.getDisplayType = function (dataType) {
            var displayType = 'textbox';

            //Set to lower case
            dataType =  dataType ? dataType.toLowerCase() : dataType;

            switch (dataType) {
                case 'boolean': {
                    displayType = 'boolean';
                    break;
                }
                case 'date': {
                    displayType = 'date';
                    break;
                }
                case 'datetime': {
                    displayType = 'datetime';
                    break;
                }
                case 'integer':
                case 'string':
                case 'decimal': {
                    displayType = 'textbox';
                    break;
                }
              
            }

            return displayType;
        };

        AttributeHelper.getCurrentValue = function (values, valueContext, model) {
            var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
            if ((displayType == "textbox" || displayType == "referencelist") && model.isCollection) {
                return this.getCurrentValues(values, valueContext, model);
            }

            var value;
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    value = DataHelper.cloneObject(currentValue);
                    break;
                }
            }

            return value;
        };

        AttributeHelper.populateValueContext = function (val, valueContext) {
            for (var valueContextField in valueContext) {
                val[valueContextField] = valueContext[valueContextField];
            }
        };

        AttributeHelper.getCurrentValues = function (values, valueContext, model) {
            var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
            if (!((displayType == "textbox" || displayType == "referencelist") && model.isCollection)) {
                return;
            }

            var _values = [];

            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];

                    if (Array.isArray(currentValue.value)) {
                        //When save, already array, then no change
                        _values = _values.concat(currentValue.value);
                    } else {
                        _values.push(currentValue.value);
                    }
                }
            }

            var val = { "value": _values };
            this.populateValueContext(val, valueContext);
            return val;
        };

        AttributeHelper.getEmptyValue = function (valueContext) {
           var val = { "value": "" };
            this.populateValueContext(val, valueContext);
            return val;
        };

        AttributeHelper.getEmptyValues = function (valueContexts) {
            var values = [];
            valueContexts.forEach(function (valCtx) {
                var val = { "value": "" };
                this.populateValueContext(val, valCtx);
                values.push(val);
            }, this);
            return { "values": values };
        };

        AttributeHelper.getFirstAttributeValue = function (attribute) {
            if (attribute && attribute.values && attribute.values.length > 0) {
                return attribute.values[0].value;
            }
            return null;
        };

        
        AttributeHelper.getAttributeValues = function (values, valueContext) {
            var _values = [];
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    if (valueContext && valueContext.locale && currentValue.locale && currentValue.locale.toLowerCase() != valueContext.locale.toLowerCase()) {
                        continue;
                    }
                    if (valueContext && valueContext.source && currentValue.source && currentValue.source.toLowerCase() != valueContext.source.toLowerCase()) {
                        continue;
                    }
                    if (Array.isArray(currentValue.value)) //When save, already array, then no change
                    {
                        _values = _values.concat(currentValue.value);
                    } else {
                        _values.push(currentValue.value);
                    }
                }
            }

            return _values;
        };

        AttributeHelper.getNestedAttributeValues = function (nestedAttribute) {
            return typeof(nestedAttribute) !== "undefined" ? nestedAttribute.group : [];
        }
    })();
</script>