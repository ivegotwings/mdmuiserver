<!--
`bedrock-helpers` Represents a bunch of helpers that any bedrock, pebble, rock or app can use. 
-->
<!--<link rel="import" href="../../../bower_components/polymer/polymer.html">-->
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-merge-helper.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<!--<script type="text/javascript" src="data-helper.js" />-->
<script>
    window.AttributeHelper = window.AttributeHelper || {};

    (function () {

        AttributeHelper.getDisplayType = function (dataType) {
            var displayType = 'textbox';

            //Set to lower case
            dataType = dataType ? dataType.toLowerCase() : dataType;

            switch (dataType) {
                case 'boolean': {
                    displayType = 'boolean';
                    break;
                }
                case 'date': {
                    displayType = 'date';
                    break;
                }
                case 'datetime': {
                    displayType = 'datetime';
                    break;
                }
                case 'integer':
                case 'string':
                case 'decimal': {
                    displayType = 'textbox';
                    break;
                }

            }

            return displayType;
        };

        AttributeHelper.getCurrentValue = function (values, valueContext, model) {
            var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
            if ((displayType == "textbox" || displayType == "referencelist") && model.isCollection) {
                return this.getCurrentValues(values, valueContext, model);
            }

            var value;
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    if (!currentValue.action && currentValue.action !== "delete") {
                        value = DataHelper.cloneObject(currentValue);
                    }
                    break;
                }
            }

            return value;
        };

        AttributeHelper.populateValueContext = function (val, valueContext) {
            for (var valueContextField in valueContext) {
                val[valueContextField] = valueContext[valueContextField];
            }
        };

        AttributeHelper.getCurrentValues = function (values, valueContext, model) {
            var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
            if (!((displayType == "textbox" || displayType == "referencelist") && model.isCollection)) {
                return;
            }

            var _values = [];

            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];

                    if (!currentValue.action && currentValue.action !== "delete") {
                        if (Array.isArray(currentValue.value)) {
                            //When save, already array, then no change
                            _values = _values.concat(currentValue.value);
                        } else {
                            _values.push(currentValue.value);
                        }
                    }
                }
            }

            var val = { "value": _values };
            this.populateValueContext(val, valueContext);
            return val;
        };


        AttributeHelper.getEmptyValue = function (valueContext, attributeModel) {
            var val = { "value": "", "referenceDataId": "" };
            if (attributeModel && attributeModel.isCollection) {
                val = { "value": [], "referenceDataId": [] };
            }
            this.populateValueContext(val, valueContext);
            return val;
        };

        AttributeHelper.getEmptyValues = function (valueContexts) {
            var values = [];
            valueContexts.forEach(function (valCtx) {
                var val = { "value": "" };
                this.populateValueContext(val, valCtx);
                values.push(val);
            }, this);
            return { "values": values };
        };

        AttributeHelper.getFirstAttributeValue = function (attribute) {
            if (attribute && attribute.values && attribute.values.length > 0) {
                return attribute.values[0].value;
            }
            return null;
        };

        AttributeHelper.getAttributeValues = function (values, valueContext) {
            var _values = [];
            if (values) {
                for (var i = 0; i < values.length; i++) {
                    var currentValue = values[i];
                    if (valueContext && valueContext.locale && currentValue.locale && currentValue.locale.toLowerCase() != valueContext.locale.toLowerCase()) {
                        continue;
                    }
                    if (valueContext && valueContext.source && currentValue.source && currentValue.source.toLowerCase() != valueContext.source.toLowerCase()) {
                        continue;
                    }
                    if (Array.isArray(currentValue.value)) //When save, already array, then no change
                    {
                        _values = _values.concat(currentValue.value);
                    } else {
                        _values.push(currentValue.value);
                    }
                }
            }

            return _values;
        };

        AttributeHelper.getNestedAttributeValues = function (nestedAttribute) {
            return typeof (nestedAttribute) !== "undefined" ? nestedAttribute.group : [];
        };

        AttributeHelper.getAtributeValueForGrid = function (attribute, model) {
            var val = '';
            if (model && attribute) {
                if (model.isCollection) {
                    if (model.dataType === "nested") {
                        val = attribute.group && attribute.group.length > 0 ? attribute.group : '';
                    } else {
                        var values = attribute.values;
                        if (values && values.length) {
                            val = AttributeHelper.getAttributeValues(values).join('||')
                        }
                    }
                } else {
                    val = attribute.values && attribute.values.length ? attribute.values[0].value : '';
                }
            }
            return val;
        };

        AttributeHelper.getPropertyTypeByName = function (propertyName) {
            var dataType = "";
            if (propertyName) {
                switch (propertyName.toLowerCase()) {
                    case "modifieddate":
                    case "createddate":
                        dataType = 'datetime';
                        break;

                    case "createdby":
                    case "modifiedby":
                        dataType = 'string';
                        break;

                    default:
                        break;
                }
            }
            return dataType;
        };

        AttributeHelper.getLocaleCoalescePath = function (attribute) {
            if (attribute && attribute.values && attribute.values.length > 0) {
                var firstValue = attribute.values[0];
                if (firstValue && !_.isEmpty(firstValue.properties) && !_.isEmpty(firstValue.properties.localeCoalescePath)) {
                    return firstValue.properties.localeCoalescePath;
                }
            }

            return undefined;
        };

        AttributeHelper.getContextCoalescePaths = function (attribute, dataContext) {
            var contextCoalescePaths = [];

            if (attribute && attribute.properties) {
                var contextCoalesce = attribute.properties.contextCoalesce;
                if (contextCoalesce && contextCoalesce.length) {
                    if (contextCoalesce.length == 1 && !DataHelper.compareObjects(dataContext, contextCoalesce[0])) {
                        contextCoalesce = contextCoalesce[0];
                        var ctxPath = [];
                        Object.keys(contextCoalesce).forEach(function (ctx) {
                            if (contextCoalesce[ctx]) {
                                ctxPath.push(contextCoalesce[ctx]);
                            }
                        }, this);

                        if (ctxPath && ctxPath.length) {
                            contextCoalescePaths.push(ctxPath.join(', '));
                        }
                    }
                }

                var instanceCoalesce = attribute.properties.instanceCoalesce;
                if (instanceCoalesce && instanceCoalesce.length) {
                    instanceCoalesce = instanceCoalesce[0];
                    if (instanceCoalesce.coalesceSourceName) {
                        contextCoalescePaths.push(instanceCoalesce.coalesceSourceName + " (Global)");
                    }
                }
            }

            return contextCoalescePaths;
        };

        AttributeHelper.getExternalNameAndExternalNameAttr = function (entityModel) {
            if (entityModel && entityModel.data && entityModel.data.attributes) {
                var attributes = entityModel.data.attributes;

                if (attributes) {
                    var attrKeys = Object.keys(attributes);

                    if (attrKeys && attrKeys.length) {
                        for (i = 0; i <= attrKeys.length; i++) {
                            var attr = attributes[attrKeys[i]];
                            if (attr && attr.properties && attr.properties.isExternalName) {
                                var externalName = attr.properties.externalName;
                                return {
                                    "externalNameAttr": attrKeys[i],
                                    "externalName": externalName
                                };
                            }
                        }
                    }
                }
            }
        };

        AttributeHelper.getFallbackLocale = function(path) {
            var delimiterIndex = path.indexOf(">>");

            if(delimiterIndex > 0) {
                return path.slice(0, delimiterIndex).trim();
            }

            return undefined;
        }
    })();

</script>