<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-lov-behavior/bedrock-lov-behavior.html">

<link rel="import" href="../pebble-combo-box/pebble-combo-box.html">

<link rel="import" href="../rock-entity-lov/entity-lov-datasource.html">

<!--
`rock-entity-combo-box` component is used to render entities in lov, it filters data as per filter criteria.

@demo demo/index.html
-->

<dom-module id="rock-entity-combo-box">
    <template>
        <entity-lov-datasource id="entityLovDataSource" request="[[requestData]]" data-source="{{dataSource}}" data-formatter="{{_dataFormatter}}"
            keywords-criterion-builder="{{_keywordsCriterionBuilder}}">
        </entity-lov-datasource>
        <pebble-combo-box id="comboBox" label=[[label]] data-source="{{dataSource}}" page-size="[[pageSize]]" multi-select="[[multiSelect]]"
            show-image="[[showImage]]" show-color="[[showColor]]" no-sub-title="[[noSubTitle]]" show-action-buttons="[[showActionButtons]]"
            is-readonly=[[isReadonly]] selected-ids="{{selectedIds}}" selected-id="{{selectedId}}">
        </pebble-combo-box>
    </template>
    <script>
        Polymer({
            is: 'rock-entity-combo-box',
            properties: {
                requestData: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                /**
                 * Specifies whether or not to generate console logs.
                 */
                verbose: {
                    type: Boolean,
                    value: false
                },
                /*
                 * Indicates the attribute of an entity which will be used as id for the item
                 */
                idField: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as title for the item
                 */
                titlePattern: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as subtitle for the item
                 */
                subTitlePattern: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as image for the item
                 */
                imageField: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as color for the item
                 */
                colorField: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as value for the item
                 */
                valueField: {
                    type: String,
                    value: ""
                },
                /*
                 * Indicates the attribute of an entity which will be used as value for the item
                 */
                typeField: {
                    type: Array,
                    value: []
                },

                _lovColumnNameValueCollection: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                _attributesCriterionBuilder: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                _keywordsCriterionBuilder: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                
                _dataFormatter: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                }
            },

            behaviors: [
                RUFBehaviors.UIBehavior,
                RUFBehaviors.LovBehavior
            ],

            listeners: {
                'comboBox.selection-changed': '_lovSelectionChanged',
                'comboBox.lov-confirm-button-tap': '_onLovConfirmButtonTapped',
                'comboBox.lov-close-button-tap': '_onLovCloseButtonTapped'
            },

            observers: [
                '_prepareAttributes(idField, titlePattern, subTitlePattern, imageField, colorField, valueField, typeField)',
                '_onEntityTypeChange(request.params.query.filters.typesCriterion)'
            ],

            ready: function () {
                this._currentLovElement = ElementHelper.getElement(this, "pebble-combo-box");
                this._keywordsCriterionBuilder = this._prepareKeywordsCriteria.bind(this);
                
                this._prepareAttributeMaps();

                this._dataFormatter = this._getAttributeFormattedData.bind(this);
            },

            _getAttributeFormattedData: function (data) {
                var entities = data.content.entities;
                if (data && data.content) {
                    if (entities) {
                        entities = DataHelper.transformEntitySchemaToLovSchema(entities, this._lovColumnNameValueCollection);
                    }
                }
                return entities;
            },

            _prepareAttributesCriteria: function (searchText) {
                if (searchText) {
                    var attributesCriterion = [];
                    var searchKey = new Object();
                    var searchValue = new Object();
                    searchValue.eq = searchText ? searchText : '';

                    searchKey[this.itemTitle] = searchValue;
                    attributesCriterion.push(searchKey);
                    return attributesCriterion
                }
            },

            _prepareKeywordsCriteria: function (searchText) {
                if (searchText) {
                    var keywordsCriterion = {};

                    keywordsCriterion.keywords = searchText;
                    keywordsCriterion.operator = "and";

                    return keywordsCriterion;
                }
            },

            _onEntityTypeChange: function () {
                this.$$('pebble-combo-box').refreshData();
            }
        });
    </script>
</dom-module>