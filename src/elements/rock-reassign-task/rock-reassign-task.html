<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">

<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../rock-entity-model-lov/rock-entity-model-lov.html">

<link rel="import" href="../pebble-spinner/pebble-spinner.html">

<dom-module id="rock-reassign-task">
    <template>
        <style>
            #buttonContainer{
                margin-top:20px;
                text-align: center;
            }
            .lov-wrapper{
                width: 100%;
                text-align: center;
            }
            .lov-container{
                width:460px;
                display:inline-block;
                padding: 20px;
                margin: 10px 0 0 10px;
                box-shadow: 1px 2px 5px -1px var(--default-border-color, #c1cad4);
                border: var(--box-style_-_border,solid 1px var(--default-border-color, #c1cad4));
                border-radius: var(--box-style_-_border-radius);
            }
        </style>   
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <liquid-entity-model-get id="getWorkflowDefinition" operation="getbyids" request-id="req1"
        on-response="_onDefinitionReceived" on-error="_onDefinitionGetFailed"></liquid-entity-model-get> 
        <liquid-rest id="entityWfAssignment" url="/data/pass-through/entitygovernservice/workflowChangeAssignment" method="POST"
            on-liquid-response="_onAssignmentSuccess" on-liquid-error="_onAssignmentFailure"></liquid-rest>
        <liquid-rest id="asyncEntityWfAssignment" url="/data/pass-through-combined-query/bulkentityservice/createtask" method="POST"
            on-liquid-response="_onAsyncAssignmentSuccess" on-liquid-error="_onAsyncAssignmentFailure"></liquid-rest>
        <div class="lov-wrapper">
            <div class="lov-container">
                <template is="dom-if" if="[[_isUserModelRequestPrepared(_userModelRequestData)]]">
                    <rock-entity-model-lov id="userModelLOV" readonly=[[readonly]] id-field="id"
                        title-pattern="{entity.properties.firstName}" sub-title-pattern="{entity.properties.email}" request-data="[[_userModelRequestData]]"
                        selected-item="{{_selectedUserItem}}" external-data-formatter="[[_entityExternalDataFormatter]]"></rock-entity-model-lov>
                </template>
            </div>
        </div>
        <div id="buttonContainer" >
            <pebble-button id="cancelButton" class="btn btn-secondary m-r-5" button-text="Cancel" on-tap="_onCancelTap" elevation=1 raised></pebble-button>
            <pebble-button id="assign" class="focus btn btn-success" button-text="Confirm" on-tap="_confirm" elevation=1 raised></pebble-button>
        </div>
    </template>

  <script>
      
    class RockReassignTask extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior, RUFBehaviors.ComponentContextBehavior], Polymer.Element) {

        static get is() { return 'rock-reassign-task' }

        static get properties() {
            return {
                _loading: {
                    type: Boolean,
                    value: false
                },
                _userModelRequestData:{
                    type:Object,
                    value:function(){
                        return {}
                    }
                },
                _WorkflowData:{
                    type:Boolean,
                    value:false
                },
                _selectedUserItem:{
                    type:Object,
                    value:function(){
                        return {}
                    },
                    notify:true
                },
                workflowRunningInstance:{
                    type:Object,
                    value:function(){
                        return {};
                    }
                },
                foundWorkflowNames:{
                    type:Array,
                    value:function(){
                        return [];
                    }
                },
                _failedWorkflows: {
                    type: Array,
                    value: function () { return []; }
                },
                _doneWorkflows: {
                    type: Array,
                    value: function () { return []; }
                },
                _responseMessages: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                selectedEntities: {
                    type: Array,
                    value: function() {
                        return [];
                    }
                },
                assignmentAction:{
                    type:String
                },
                workflowName:{
                    type:String
                },
                workflowActivityExternalName:{
                    type:String
                },
                workflowActivityName:{
                    type:String
                },
                _isBulkWFProcess:{
                    type:Boolean,
                    value:false
                }
            }
        }      
         
        connectedCallback() {
            super.connectedCallback();
           
            this._currentWfIndex = 0;
            if(this.assignmentAction == 'reassign'){
                this.set("_isBulkWFProcess", true)
                var workflowDefLiq = this.shadowRoot.querySelector("#getWorkflowDefinition");
                if(workflowDefLiq){
                    workflowDefLiq.requestData = DataRequestHelper.createWorkflowDefinitionGetRequest(this.contextData);
                    if(!workflowDefLiq.requestData.params.query.ids){
                        workflowDefLiq.requestData.params.query.id = this.workflowName+"_workflowDefinition";
                    }
                    workflowDefLiq.generateRequest();
                }
            }else{
                //Prepare users request
                this._prepareUserModelRequest();
            }
        }

        _onDefinitionReceived(e){
            var workflowDefinitionResponse = e.detail.response;
            if (workflowDefinitionResponse && workflowDefinitionResponse.content && workflowDefinitionResponse.content.entityModels && workflowDefinitionResponse.content.entityModels.length > 0) {
                var allowedRoles = [];
                var allowedUsers = [];
                for (var i = 0; i < workflowDefinitionResponse.content.entityModels.length; i++) {
                    var entityModel = workflowDefinitionResponse.content.entityModels[i];
                    var workflowName = entityModel.name;
                    if (entityModel.data && entityModel.data.attributes && entityModel.data.attributes.activities && entityModel.data.attributes.activities.group) {
                        
                        var group = entityModel.data.attributes.activities.group;
                        if(group && group.length > 0){
                            group.forEach(function(groupItem){
                                if(groupItem && groupItem.activityName && groupItem.activityName.values){
                                    for (var valueCount = 0; valueCount < groupItem.activityName.values.length; valueCount++) {
                                        var _value = groupItem.activityName.values[valueCount];
                                        if(_value && _value.value && (this.workflowActivityName == _value.value)){
                                            if(groupItem["allowedRoles"] && groupItem["allowedRoles"]["values"]){
                                                allowedRoles = groupItem["allowedRoles"]["values"];
                                            }
                                            if(groupItem["allowedUsers"] && groupItem["allowedUsers"]["values"]){
                                                allowedUsers = groupItem["allowedUsers"]["values"];
                                            }
                                            break;
                                        }
                                    }
                                }
                            }.bind(this));
                        }
                        
                    }
                }
                allowedRoles = allowedRoles.map((role) => { return role.value; })
                this._prepareUserModelRequest(allowedRoles);
                // var req = DataRequestHelper.createGetModelRequest([], "user");
                // var roles = [];
                // if(allowedRoles && allowedRoles.length > 0){
                //     allowedRoles.forEach(function(role){
                //         if(role && role.value && (roles.indexOf(role.value) == -1)){
                //             roles.push(role.value);
                //         }
                //     }.bind(this));
                //     req.params.query.filters["propertiesCriterion"] = [{
                //                                                 "roles":{
                //                                                     "exacts":roles
                //                                                 }
                //                                             }]
                // };
                // delete  req.params.query.ids;
                // // if(allowedUsers && allowedUsers.length > 0){
                // //     req.params.query.ids = allowedUsers;
                // // }
                // this._requestData = req;
                // this.set("_WorkflowData", workflowDefinitionResponse);
            }
        }
        _onDefinitionGetFailed(e) {
            Polymer.Base._error('workflow definition get failed with error ', e.detail);
        }
        _entityExternalDataFormatter(formattedData, data){
            //Filter current assigned user
            var domHost = this.domHost;
            var assingedUser = "";
            if(!domHost._isBulkWFProcess){
                assingedUser = domHost.workflowRunningInstance[domHost.foundWorkflowNames[domHost._currentWfIndex]].activityAssignedUser;
            }
            var loggedUser = ContextHelper.getFirstUserContext(domHost.contextData);
            var loggedUserId = "";
            if(loggedUser && loggedUser.user){
                loggedUserId = loggedUser.user;
            }
            if(formattedData && formattedData.length > 0){
                formattedData = formattedData.filter( (user) => {
                    //Get firstname & lastname
                    var userData = data.filter((eModel) => { return eModel.id == user.id; });
                    if(userData && userData.length > 0 && userData[0].properties){
                        var userProperties = userData[0].properties
                        if(userProperties.firstName){
                            user.title = userProperties.firstName
                        }else{
                            user.title = "";
                        }
                        if(userProperties.lastName){
                            user.title += " " + userProperties.lastName
                        }
                    }
                    var userId = user.id.replace("_user", "");
                    return (userId != assingedUser) && loggedUserId && (loggedUserId != user.id);
                });
            }
            return formattedData;
        }
        _generateAssignmentRequest() {
            // var entity = this._getEntityObject();
            // var wfCriterion = {};
            // if(this._isBulkWFProcess){
            //     wfCriterion = {
            //         "workflowShortName": this.workflowName,
            //         "workflowActivityName": this.workflowActivityName
            //     }
            // }else{
            //     wfCriterion = this._getWfCriterion(this.workflowRunningInstance[this.foundWorkflowNames[this._currentWfIndex]]);
            // }
            // if (!_.isEmpty(wfCriterion)) {
            //     var req = DataRequestHelper.createWfChangeAssignmentRequest(entity, wfCriterion, this.contextData, "reassign", this._selectedUserItem);

            //     //Add hotline flag if hotline is enabled
            //     if (DataHelper.isHotlineModeEnabled()) {
            //         req.hotline = true;
            //     }

            //     this.set("_wfAssignmentRequest", req);
            //     var liquidWfAssign = this.shadowRoot.querySelector("#entityWfAssignment");
            //     if (liquidWfAssign) {
            //         liquidWfAssign.generateRequest();
            //     }
            // }
            // No selectionMode or selectionMode as count should have selectedEntities to do process
            if(this._isBulkWFProcess && (!this.selectionMode || this.selectionMode == "count") && (!this.selectedEntities || this.selectedEntities.length == 0)) {
                this._message = "Entities not available for the process";
                this._loading = false;
                return;
            }

            var workflowDetails = {
                "workflowShortName": this.workflowName,
                "workflowActivityName": this.workflowActivityName
            };

            //Prepare request without entity
            var workflowAssignmentRequest = DataRequestHelper.createWfChangeAssignmentRequest(null, workflowDetails, this.contextData, this.assignmentAction, this._selectedUserItem);

            //Add hotline flag if hotline is enabled
            if(DataHelper.isHotlineModeEnabled()) {
                workflowAssignmentRequest.hotline = true;
            }

            if(this.selectionMode == "query" || (this.selectionMode == "count" && this.selectedEntities.length > this.syncThreshold)) {

                if(!this.selectionQuery || _.isEmpty(this.selectionQuery)) {
                    this._message = "Selection query not available for the process";
                    this._loading = false;
                    return;
                }

                // workflowAssignmentRequest.params.query = this.selectionQuery;

                //Async process
                workflowAssignmentRequest.params.operationType = "inboundService";

                if(this.selectionQuery.params && this.selectionQuery.params.isCombinedQuerySearch) {
                    workflowAssignmentRequest.params.taskType = "changeAssignment-multi-query";
                    workflowAssignmentRequest.entities = [this.selectionQuery.entity];
                } else {
                    workflowAssignmentRequest.params.taskType = "changeAssignment-query";
                    workflowAssignmentRequest.params.query = this.selectionQuery.params ? this.selectionQuery.params.query : this.selectionQuery;
                }

                //Add clientAttributes
                var valueContext = ContextHelper.getFirstValueContext(this.contextData);
                var userContext = ContextHelper.getFirstUserContext(this.contextData);
                var clientMessage;
                if(this.assignmentAction == "take") {
                    clientMessage = "Workflow '"+ this.workflowExternalName +"' step '" + this.workflowActivityExternalName +"' assignment to '"+ userContext.user +"'";
                } else {
                    clientMessage = "Workflow '"+ this.workflowExternalName +"' step '" + this.workflowActivityExternalName +"' assignment release";
                }

                workflowAssignmentRequest.clientAttributes = {
                    "taskName": {
                        "values": [{
                            "source": valueContext.source,
                            "locale": valueContext.locale,
                            "value": clientMessage
                        }]
                    }
                };
                var asyncEntityWfAssignmentLiq = this.shadowRoot.querySelector("#asyncEntityWfAssignment");
                if (asyncEntityWfAssignmentLiq) {
                    asyncEntityWfAssignmentLiq.requestData = workflowAssignmentRequest;
                    asyncEntityWfAssignmentLiq.generateRequest();
                }
            }
            else { // Sync process
                //Add entities to the request
                var entities = [];
                var entityTypes = [];
                for (var i = 0; i < this.selectedEntities.length; i++) {
                    entities.push({
                        "id": this.selectedEntities[i].id,
                        "type": this.selectedEntities[i].type
                    });

                    if(entityTypes.indexOf(this.selectedEntities[i].type) == -1) {
                        entityTypes.push(this.selectedEntities[i].type);
                    }
                }

                workflowAssignmentRequest["entities"] = entities;
                var entityWfAssignmentLiq = this.shadowRoot.querySelector("#entityWfAssignment");

                if (entityWfAssignmentLiq) {
                    entityWfAssignmentLiq.requestData = workflowAssignmentRequest;
                    entityWfAssignmentLiq.generateRequest();
                }
            }
        }
        _onAsyncAssignmentSuccess(e) {
            var response = e.detail.response && e.detail.response.response ? e.detail.response.response : e.detail.response;
            var request = e.detail.response ? e.detail.response.request : undefined;

            if((!response || _.isEmpty(response)) ||
                (DataHelper.isValidObjectPath(response, "dataObjectOperationResponse.status") && response.dataObjectOperationResponse.status.toLowerCase() == "error") ||
                (response.status && response.status.toLowerCase() == "error")) {
                this._message = "Bulk assignment request failed";
                this._loading = false;
                return;
            }
            
            if(response.status && response.status.toLowerCase() == "success") {
                if(request && request.taskId) {
                    this._taskId = request.taskId;
                }
            }

            this._message = "Assignment request triggered successfully";
            this._triggerFinishStep(true);
        }
        _onAsyncAssignmentFailure (e) {
            this._loading = false;
            this._message = "Failed to perform the workflow assignment. Please contact administrator.";
            this.logError("WorkFlowAssignmentFailure","response",JSON.stringify(e.detail));
        }
        _onAssignmentSuccess(e) {
            this._responseMessages = [];
            var response = e.detail.response;
            var entity = this._getEntityObject();
            if (response && response.response && response.response.status && response.response.status.toLowerCase() == "success" && response.response.statusDetail) {
                var statusDetail = response.response.statusDetail;
                var workflowJson = this.workflowRunningInstance[this.foundWorkflowNames[this._currentWfIndex]];
                if (statusDetail.messages && statusDetail.messages.length > 0) {
                    this._failedWorkflows.push(workflowJson);
                } else if (statusDetail.message) {
                    this._doneWorkflows.push(workflowJson);
                }
            }
            this._currentWfIndex++;
            if (this._currentWfIndex < this.foundWorkflowNames.length) {
                this._generateAssignmentRequest();
            } else if (response.response && response.response.status && response.response.status.toLowerCase() == "success" && response.response.statusDetail) {
                if(response.response.statusDetail.message){
                    this._responseMessages.push({message:response.response.statusDetail.message});
                }
                this._triggerFinishStep();
            }
            else {
                this.showErrorToast("There is a problem with the server.Please try after some time")
            }
        }
        _triggerFinishStep() {
            this._loading = false;
            var actions = [{
                        "name": "goBack",
                        "text": "Take me back to where I started",
                        "isNotApp": true
                    }];
            var data = {
                "messages":this._responseMessages,
                "actions": actions,
                "contextData": this.contextData
            };

            this.businessFunctionData = data;
            var eventName = "onNext";
            var eventDetail = {
                name: eventName
            }

            this.fireBedrockEvent(eventName, eventDetail, {
                    ignoreId: true
            });

            setTimeout(() => {
                var data = {
                    "contextData": this.contextData
                }
                ComponentHelper.fireBedrockEvent("workflow-refresh", data, { ignoreId: true });
                this.refresh();
            }, 5000)
        }
        refresh(invalidateEntityCache = true) {
            if (invalidateEntityCache) {
                //Invalidate entity cache
                var entity = this._getEntityObject();
                LiquidDataObjectUtils.invalidateDataObjectCache(entity);
            }
        }
        _onAssignmentFailure(e) {
            this.logWarning("WorkFlowAssignmentFailure", "response", JSON.stringify(e.detail));
            this.showErrorToast("Failed to perform the workflow assignment. Please contact administrator.");
        }
        _getEntityObject() {
            var itemCtx = ContextHelper.getFirstItemContext(this.contextData);
            var entity = {
                "id": itemCtx.id,
                "type": itemCtx.type
            };
            return entity;
        }
        _getWfCriterion(runtimeInstance) {
            var wfCriterion;
            if (runtimeInstance && runtimeInstance.name && runtimeInstance.activityName) {
                wfCriterion = {
                    "workflowShortName": runtimeInstance.name,
                    "workflowActivityName": runtimeInstance.activityName
                };
            }
            return wfCriterion;
        }
        _prepareUserModelRequest(_allowedRoles){
            var req = DataRequestHelper.createGetModelRequest([], "user");
            var allowedRoles = _allowedRoles ? _allowedRoles : this.workflowRunningInstance[this.foundWorkflowNames[this._currentWfIndex]].activityAllowedRoles;
            
            if(allowedRoles && allowedRoles.length > 0){
                req.params.query.filters["propertiesCriterion"] = [{
                                                            "roles":{
                                                                "exacts":allowedRoles
                                                            }
                                                        }]
            };
            delete req.params.fields.attributes;
            delete req.params.fields.relationships;
            delete  req.params.query.ids;
            req.params.fields.properties = ["_ALL"];
            this.set("_userModelRequestData", req);
        }
        _isUserModelRequestPrepared(){
            if(this._userModelRequestData && !_.isEmpty(this._userModelRequestData)){
                return true;
            }
            return false;
        }
        _confirm(){
            if(this._selectedUserItem && !_.isEmpty(this._selectedUserItem)){
                this._currentWfIndex = 0;
                this._failedWorkflows = [];
                this._doneWorkflows = [];
                this._loading = true;
                this._generateAssignmentRequest();
            }else{
                this.showWarningToast("Please select a user for changing assignment.");
            }
        }

        _onCancelTap(){
            var eventName = "onCancel";
            this.fireBedrockEvent(eventName, {}, {
                ignoreId: true
            });
        }
    }

    customElements.define(RockReassignTask.is, RockReassignTask);  
  </script> 
</dom-module>