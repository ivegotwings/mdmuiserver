<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="../../../bower_components/iron-icons/av-icons.html">

<link rel="import" href="../liquid-entity-get/liquid-entity-get.html">
<link rel="import" href="../liquid-entity-getdata/liquid-entity-getdata.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-image-viewer/pebble-image-viewer.html">
<link rel="import" href="../pebble-toolbar/pebble-toolbar.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="../rock-entity-tofix/rock-entity-tofix.html">

<link rel="import" href="progress-icons.html">
<!--
    `rock-entity-header` Represents entity header in the entity manage app. It contains following items:
      `*` Attributes of the entity that needs display in the header section.
      `*` Percentage completion of the entity with notifications that also indicates warnings.
      `*` Invalid and missed fields of an entity.
      `*` A button toolbar with different actions performed on the entity.
    An element accepts attribute list of the respective entity, entity's profile completion and actions to be
    performed.
@group rock Elements
@element rock-entity-header
@demo demo/index.html
-->
<dom-module id="rock-entity-header">
    <template>
        <style include="pebble-styles-shared"></style>
        <style>
			:host {
				width: 100%;
				display: flex;
                padding: 10px 0;
                box-sizing: border-box;
				--pebble-toolbar-button-icon: {
					padding: 4.5px;
					border: 0px;
					min-width: 2.14em;
					margin: 0px;
					top: 3px;
					color: #616161;
				}
				--pebble-toolbar-menubutton: {
					border: 0px;
				}
				--pebble-button: {
					color: green;
					font-weight: var(--font-medium, 500);
				}
				--pebble-button-iron-icon: {
					height: 16px;
					width: 16px;
					margin-right: 5px;
				}
				--pebble-toolbar-pebble-button-menu-item-icon: {
					width: 16px;
					height: 16px;
				}
				--paper-menu-background-color: #ffffff;
				--pebble-horizontal-divider-color: #616161;
			}
            pebble-toolbar::shadow paper-button-group pebble-button::shadow iron-icon, pebble-button::shadow iron-icon, pebble-toolbar::shadow paper-button-group pebble-button::shadow paper-button{
                width: 16px!important;
                height: 16px!important;
                min-width: 16px;
                margin: 0 10px;
            }

			#headerSection {
				width: 100%;
                display: block;
			}
			
			#attributePanel {
				display: flex;
				flex-wrap: wrap;
				@apply(--layout-horizontal);
				width: 75%;
                float: left;
                margin-top: 4px;
			}
			
			.attribute {
				width: 33%;
                height: 20px;
                line-height: 20px;
                padding-right:30px;
			}
			
			.trim {
				text-overflow: ellipsis;
				overflow: hidden;
				white-space: nowrap;
			}
			
			#attrName {
				width: 282px;
				height: 20px;
				font-family: var(--default-font-family);
				font-size: var(--default-font-size, 14px);
				font-weight: normal;
				font-style: normal;
				font-stretch: normal;
				color: var(--attrpanel-color-text);
				opacity: 0.7;
			}
			
			#attrVal {
				font-size: 13px;
				font-weight: var(--font-medium, 500);
				color: #616161;
			}
			
			#buttonPanel {
				display: inline-block;
                text-align: right;
			}	

            #buttonPanel pebble-button, #buttonPanel pebble-toolbar::shadow paper-toolbar{
                display: inline-block;
                vertical-align: middle;
            }
            #buttonPanel pebble-button{
                margin-right: 10px;
            }

            #buttonPanel pebble-button, #buttonPanel pebble-toolbar::shadow paper-toolbar::shadow .toolbar-tools, #buttonPanel pebble-toolbar::shadow paper-toolbar{
                height: 20px;
                float: left;
            }
            #buttonPanel pebble-toolbar::shadow paper-toolbar::shadow .toolbar-tools{
                padding: 0;
            }
			
		</style>
<div id="headerSection">
    <div id="attributePanel">
        <template is="dom-repeat" items="[[_headerAttributeValues]]">
            <div id="attribute" class$="[[_computeAttributeClass(item)]]">
                <span id="attrName">[[_getAttributeLabel(headerAttributeModelResponse, item)]] :</span>
                <span id="attrVal">[[item.value]]</span>
            </div>
        </template>
    </div>
    <div id="buttonPanel" class="pull-right m-t-15">
        <pebble-button id="pebbleButton" class="iconTextButton" on-click="_openPopover" icon="[[_computeIcon(toFixData.completionPercentage)]]"
            button-text="[[toFixData.completionPercentage]]%"></pebble-button>
        <pebble-popover id="tofixPopover" for="pebbleButton" horizontal-align="right" auto-fit-on-attach no-overlap>
            <rock-entity-tofix data="[[toFixData]]"></rock-entity-tofix>                
        </pebble-popover>
        <pebble-toolbar config-data="[[buttons]]"></pebble-toolbar>
    </div>
</div>
<liquid-entity-getdata auto verbose name="attributeGetDataService" operation="getbyids" 
    request-data="{{headerAttributeRequest}}" last-response="{{headerAttributeResponse}}"></liquid-entity-getdata>

<!--<liquid-entity-get name="headerAttributeGetService" request="[[headerAttributeRequest]]" response="{{headerAttributeResponse}}"></liquid-entity-get>-->
<liquid-entity-get name="headerAttributeModelGetService" request="[[headerAttributeModelRequest]]" response="{{headerAttributeModelResponse}}"></liquid-entity-get>
</template>
<script>
        Polymer({
            is: "rock-entity-header",
            ready: function () {
                this.entityId = this._getEntityId();
                if (this.verbose) {
                    console.log('entity header ready');
                }
            },
            properties: {
                /**
                 * Indicates the attributes that gets displayed in the header section.
                 */
                headerConfig: {
                    type: Array,
                    value: []
                },
                /**
                 * Indicates the buttons that gets displayed in header section toolbar.
                 */
                buttons: {
                    type: Object,
                    value: {}
                },
                /**
                 * Indicates the data of all missing or invalid fields, errors, and warnings of the loaded entity.
                 */
                toFixData: {
                    type: Object,
                    value: function () { return {}; }
                },
                /**
                * Indicates the request object that is passed to the data element to retrive attribute data.
                    Sample: { 
                            action: "getAttributes" 
                            }
                */
                headerAttributeRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }           
                },
                /**
                 * Indicates the response object that is received from the data element for the attribute get request.
                 */
                headerAttributeResponse: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                /**
                * Indicates the request object that is passed to the data element to retrive attribute model data.
                    Sample: { 
                            action: "getAttributeModels" 
                            }
                */
                headerAttributeModelRequest: {
                    type: Object,
                    value: function () {
                        return {
                            action: "getHeaderAttributeModels"
                        };
                    }
                },
                /**
                 * Indicates the response object that is received from the data element for the attribute model get request.
                 */
                headerAttributeModelResponse: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _headerAttributeValues: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                entityId: {
                    type: String
                },
                locale: {
                    type: String
                },
                list: {
                    type: String
                },
                source: {
                    type: String
                },
                /**
                * Indicates whether to write logs or not.
                */
                verbose: {
                    type: Boolean,
                    value: false
                }
            },
            observers: [
                '_headerAttributeResponseChanged(headerAttributeResponse)',
                '_headerAttributeModelResponseChanged(headerAttributeModelResponse)',
                '_headerConfigChanged(headerConfig,locale,list,source)'
            ],
            _headerConfigChanged: function (headerConfig, locale, list, source) {
                if (this.verbose) {
                    console.log('entity header _headerConfigChanged ', JSON.stringify(headerConfig, null, 2));
                }
                if (headerConfig) {
                    var attributeNames = [];
                    for (var i = 0; i < headerConfig.length; i++) {
                        if (headerConfig[i].attributeName) {
                            attributeNames.push(headerConfig[i].attributeName);
                        }
                    }
                    var t = {
                        action: "getHeaderAttributeModels",
                        "attributeNames": attributeNames
                    };
                    this.set("headerAttributeModelRequest", t);
                }
            },
            _headerAttributeModelResponseChanged: function (headerAttributeModelResponse) {
                if (this.verbose) {
                    console.log('entity header _headerAttributeModelResponseChanged ', JSON.stringify(headerAttributeModelResponse, null, 2));
                }
                if (headerAttributeModelResponse && headerAttributeModelResponse.returnValue &&
                    headerAttributeModelResponse.returnValue.attributeModels) {
                    var attributeNames = [];
                    for (var attributeGroupName in headerAttributeModelResponse.returnValue.attributeModels) {
                        for (var attributeName in headerAttributeModelResponse.returnValue.attributeModels[
                            attributeGroupName]) {
                            attributeNames.push(attributeName);
                        }
                    }
                    var req = {
                        "params": {
                            "query": {
                                "ctx": [{
                                    "list": this.list,
                                    "classification": "nivea/niveaBodyCare/niveaBody/nbodyEssential/nbody/ess/nourishingMilkDry"
                                }],
                                "valCtx": [{
                                    "source": this.source,
                                    "locale": this.locale
                                }],
                                "id": this.entityId,
                                "filters": {
                                    "attributesCriterion": [],
                                    "relationshipsCriterion": [],
                                    "typesCriterion": ["nart"]
                                }
                            },
                            "fields": {
                                "ctxTypes": [
                                    "properties"
                                ],
                                "attributes": attributeNames,
                                "relationships": [
                                    "ALL"
                                ]
                            },
                            "options": {
                                "totalRecords": 1,
                                "includeRequest": false
                            }
                        }
                    };
                    this.set("headerAttributeRequest", req);
                    //this.set("attributeRequest.attributeNames", attributeNames);
                }
            },
            _headerAttributeResponseChanged: function (headerAttributeResponse) {
                if (this.verbose) {
                    console.log('entity header _headerAttributeResponseChanged ', JSON.stringify(headerAttributeResponse, null, 2));
                }
                var attributesData = [];
                var locale = this.locale,
                    time = 'now',
                    source = this.source;
                if (headerAttributeResponse && headerAttributeResponse.content && headerAttributeResponse.content
                    .entities && this.entityId in headerAttributeResponse.content.entities &&
                    this.headerAttributeModelResponse && this.headerAttributeModelResponse.returnValue &&
                    this.headerAttributeModelResponse.returnValue.attributeModels) {
                    var contextKey = Object.keys(headerAttributeResponse.content.entities[this.entityId].data
                        .ctxInfo)[0];
                    var attributes = headerAttributeResponse.content.entities[this.entityId].data.ctxInfo[
                        contextKey].attributes;
                    //values = DataHelper.transformAttributeToUIFormat(attributes, this.headerAttributeModelResponse.returnValue.attributeModels, locale, time, source);
                    var attributeModels = this.headerAttributeModelResponse.returnValue.attributeModels;
                    for (var attributeGroupName in attributeModels) {
                        for (var attributeModelName in attributeModels[attributeGroupName]) {
                            var attributeJSON = undefined;
                            var attributeModel = attributeModels[attributeGroupName][attributeModelName];
                            if (attributeModel.name) {
                                var attribute = attributes[attributeModel.name];
                                if (attribute && attribute.values) {
                                    attributeJSON = DataHelper._getCurrentValue(attribute.values, locale,
                                        time, source);
                                }
                                if (attributeJSON == undefined) {
                                    attributeJSON = DataHelper._getEmptyValue(locale, time, source);
                                }
                                attributeJSON.name = attributeModel.name;
                                attributesData.push(attributeJSON);
                            }
                        }
                    }
                }
                this.set("_headerAttributeValues", attributesData);
            },
            _getAttributeLabel: function (attributeModelResponse, attributeValue) {
                var configItem = this._getConfigItem(this.headerConfig, attributeValue.name);
                if (configItem && configItem.label) {
                    return configItem.label;
                }
                var attributeModel = this._getAttributeModel(attributeModelResponse, attributeValue.name)
                if (attributeModel && attributeModel.longName) {
                    return attributeModel.longName;
                }
            },
            _getAttributeValue: function (values, configItem) {
                var attrValue = "";
                for (var i = 0; i < values.length; i++) {
                    var attributes = values[i].attributes;
                    for (var j = 0; j < attributes.length; j++) {
                        if (attributes[j].name == configItem.attributeName) {
                            attrValue = attributes[j].value;
                        }
                    }
                }
            },
            _getAttributeModel: function (attributeModelResponse, attributeName) {
                if (attributeName && attributeModelResponse && attributeModelResponse.returnValue &&
                    attributeModelResponse.returnValue.attributeModels) {
                    for (var attributeGroupName in attributeModelResponse.returnValue.attributeModels) {
                        if (attributeName in attributeModelResponse.returnValue.attributeModels[
                            attributeGroupName]) {
                            return attributeModelResponse.returnValue.attributeModels[attributeGroupName][
                                attributeName
                            ];
                        }
                    }
                }
            },
            _computeIcon: function (percentage) {
                var per = Math.round(percentage / 10) * 10;
                return "pebble-md-icons:Percentage";
            },
            _openPopover: function () {
                this.$.tofixPopover.show();
            },
            _computeAttributeClass: function (attributeValue) {
                var configItem = this._getConfigItem(this.headerConfig, attributeValue.name);
                if (configItem) {
                    if (configItem.noTrim) {
                        return "attribute";
                    } else {
                        return "attribute trim";
                    }
                }
            },
            _getConfigItem: function (headerConfig, attributeName) {
                for (var i = 0; i < headerConfig.length; i++) {
                    if (headerConfig[i].attributeName == attributeName) {
                        return headerConfig[i];
                    }
                }
            },
            _getEntityId: function () {
                var mainApp = document.querySelector('main-app');
                if (mainApp && mainApp.pageRoute && mainApp.pageRoute.__queryParams && "id" in mainApp.pageRoute.__queryParams) {
                    return mainApp.pageRoute.__queryParams['id'];
                }
            }
        })
    </script>
</dom-module>