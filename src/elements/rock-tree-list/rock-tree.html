
<link rel="import" href="../../../bower_components/polymer/polymer.html" />
<link rel="import" href="rock-tree-list.html" />
<link rel="import" href="../../../bower_components/px-polymer-font-awesome/polymer-font-awesome.html" />
<!--

@element rock-tree
@blurb Element providing a tree list
@homepage index.html
@demo demo/index.html
-->



<dom-module id="rock-tree">
    <template>

        <style>
     .list-inline{margin:0;padding:0;list-style:none}
     .list-inline>li{display:inline-block}
     body,html{font:GE Inspira Sans;overflow:hidden}
     ul{margin-left:0;margin-bottom:0;padding-left:1rem}
     :host{width:100%}
     .search{background-color:#fff;display:-webkit-flex;display:-ms-flexbox;display:flex}
     .search .icon{color:#7c7c84;height:1rem}
     .search .icon iron-icon{height:1.33333rem;cursor:pointer}
     .search .input{width:100%}
     .search .input input{padding:.46667rem;width:90%;outline:0;border:0;height:1.06667rem}
     .search #searchInput::-ms-clear{display:none;width:0;height:0}

   </style>


        <div class="search">
            <div class="input">
                <input id="searchInput" type="text" value="{{initialSearchKeyword::input}}" placeholder="Type In A Search Term...">
            </div>
            <template is="dom-if" if="{{_isSearchKeywordTrue(searchKeyword)}}">
                <div class="icon"><iron-icon icon="clear" class="fa-x" on-click="_resetSearch" id="searchIcon"></iron-icon></div>
            </template>
        </div>
        <ul style="margin-top:40px;">
            <template is="dom-repeat" items="{{nav}}">
                <rock-tree-list nav-item="[[item]]" selected="{{selected}}" search-keyword="{{searchKeyword}}" item-path="[[index]].children" selected-elem="{{selectedElem}}"></rock-tree-list>
            </template>
        </ul>
    </template>
</dom-module>
<script>
  Polymer({
    is: 'rock-tree',

    /**
    * The component's properties.
    *
    * @property properties
    */
    properties: {

      /**
      * The name of the currently selected item.
      *
      * @property selected
      * @type String
      */
      selected: {
        type: String,
        notify: true,
        observer: '_selectedChange'
      },
      /**
      * A reference to the selected element.
      *
      * @property selectedElem
      * @type String
      */
      selectedElem: {
        type: Object,
        notify: true
      },

      /**
      * The user's active search. Triggers a navigation rebuild.
      *
      * @property searchKeyword
      * @type String
      */
      searchKeyword: {
        type: String,
        value: '',
        notify:true,
        observer: '_callNavRebuild'
      },
      initialSearchKeyword: {
        type: String,
        observer: '_calculateDebounce'
      },
      /**
      * The initial navigation in array form.
      *
      * @property initialNav
      * @type Array
      */
      initialNav: {
        type: Array,
        value: function() {return [];}
      },

      /**
      * A model of the current navigation (with search filters or other mutations
      * applied by this component's methods). Calculated with changes from the base
      * property `initialNav` which is defined by this component's parent.
      *
      * @property nav
      * @type Object
      */
      nav: {
        type: Object,
        notify: true
      },

      /**
      * The name of the actively-selected item. Used to communicate state changes
      * to the outside world and bring outside state changes in to the component.
      *
      * @property activeName
      * @type String
      */
      activeName: {
        type: String,
        value: '',
        notify: true
      },

      searchDebounceVal: {
        type: Number,
        value: ''
      }
    },

    /** Observe property changes */
    observers: [
      '_computedNav(initialNav, searchKeyword)',
      '_activeItemChange(activeName)'
    ],

    /** Bind events to handler methods */
    listeners: {
      'rock-tree-list-selected-item-changed' : '_launchSelectedChange'
    },
    /*
    * The search debounce needs to be calculated -
    * it needs to be much lower if the user is deleting something,
    * and much higher if the user is typing more.
    *
    * @method _calculateDebounce
    * @prop {string} newVal - the new search keyword val
    * @prop {string} oldVal - the old search keyword val
    *
     */
    _calculateDebounce: function(newVal, oldVal) {
      var ADD = 250,
          REMOVE = 50;
     this.set('searchDebounceVal', (newVal > oldVal) ? ADD : REMOVE);
     this.set('searchKeyword', this.initialSearchKeyword);
    },
    /*
    *
    * Checks whether there's anything in the search keyword
    * @method _isSearchKeywordTrue
    *
     */
    _isSearchKeywordTrue: function() {
      return this.searchKeyword;
    },
    /**
    * Recursively searches the model for the item passed, and returns an array
    * of item paths, starting with the selected item and continuing along its
    * path of parent items to the top-level nav item.
    *
    * Each path in the array will be in string notation - for example, 0.children.3.children.3
    *
    * @method _findItemTrail
    * @prop {Object} navArr - The nav model the search through
    * @prop {String} selectedItem - The name of the selected item
    * @prop {String} path - Optional, a base path to search along. Useful for
    *                       when this function calls itself recursively.
    * @returns {Array} itemsPath - An array of item paths
    */
    _findItemTrail: function(navArr, selectedItem, path) {
      var i,
          len,
          oldPath,
          arr;

      for (i = 0, len = navArr.length; i < len; i++) {
        if (navArr[i].children) {
          oldPath = path;
          path = (path)?path:'';
          path += i.toString() + '.children.';

          //this will return null when it can't find anything, but if it does find something, we grab the array its returned, push that into another array, and return that.
          arr = this._findItemTrail(navArr[i].children, selectedItem, path);
          if (arr !== null) {
            navArr[i].path = path.substr(0,path.length - 7);
            arr.push(navArr[i]);
            //this is the final return, after the recursion is done
            return arr;
          } else {
            //we found nothing, we don't need this path. reset.
            path = oldPath;
          }
        }

        if (navArr[i].repoName === selectedItem) {
          path += i.toString();
          //this.set('nav.' + path +'.selected',true);
          this.set('selected', 'nav.' + path);
          navArr[i].path = path;
          //this will return into the recursion.
          return [navArr[i]];
        }
      }
      //this will only hit if we didn't find anything in the recursive search.
      return null;
    },

    /**
    * Recursively searches the model for the item passed, and returns a path to
    * the item in string notation - for example, 0.children.3.children.3
    *
    * @method _findItemPath
    * @prop {Object} navArr - The nav model the search through
    * @prop {String} selectedItem - The name of the selected item
    * @prop {String} path - Optional, a base path to search along. Useful for
    *                       when this function calls itself recursively.
    * @returns {String} itemPath - The item's path as a string
    */
    _findItemPath: function(navArr, selectedItem, path) {
      var i,
          len,
          foundPath;

      for (i = 0, len = navArr.length; i < len; i++) {
        if (navArr[i].children) {
          var oldPath = path;
          path = (path)?path:'';
          path += i.toString() + '.children.';

          foundPath = this._findItemPath(navArr[i].children, selectedItem, path);
          if (foundPath === null) {
            //we found nothing, we don't need this path. reset.
            path = oldPath;
          } else {
            //this is the final return
            return foundPath;
          }
        }

        if (navArr[i].repoName === selectedItem) {
          //this will return into the recursion.
          return path + i.toString();
        }
      }
      //this will only hit if we didn't find anything in the recursive search.
      return null;
    },

    /***************************************************************************
    * SELECT AND DESELECT ITEMS
    *
    * When a nav item needs to be selected, or the path to it needs to be opened,
    * these methods trigger notifications to specific paths to ensure the right
    * items are marked as selected/opened.
    ***************************************************************************/

    /**
    * Loops through the trail (array) given to it, and sets the opened property
    * on each item
    *
    * @method _changeOpenedProperty
    * @param {Array} trail - An array of item paths, starting with the selected
    *                        item and continuing along its path of items to the
    *                        top-level nav item.
    */
    _changeOpenedProperty: function(trail) {
      if (typeof trail === 'string') {
        this.set('nav.' + trail + '.opened', true);
      } else {
        if (trail && trail.length) {
          trail.forEach(function(item) {
            this.set('nav.' + item.path + '.opened', true);
          }.bind(this));
        }
      }
    },

    /**
    * Called when the "rock-tree-list-selected-item-changed" event is fired. This event
    * is triggered by an item being clicked on, or when external state changes
    * and other methods sync it to update the internal state.
    *
    * After the event fires, this method does the following:
    *
    * 1. Sets the name and type properties of the selected item on rock-tree
    *
    * 2. Sets the new route, potentially triggering an external notification
    *
    * 3. Removes all the opened=true properties on the arrows, finds the trail from
    *    the selected item up to the root, and sets opened=true on the correct arrows
    *
    * 4. Sets the item as the selected item.
    *
    * @method _launchSelectedChange
    * @prop {Event} selectedItemEvt - An event (or event-like) object containing
    *                                 the details about the newly selected item.
    */
    _launchSelectedChange: function(selectedItemEvt) {
      var item = selectedItemEvt.detail;
      this.set('name', item.selectedItem);
      //load the correct url into the iframe, and set the window.history change.
      this._setRoute(item.selectedItem);
      //the trail is path from the top menu to the selected item - needed so we can set opened=true on the arrow that are part of the path.
      //and make sure to change our selected property.
      this._setSelected(selectedItemEvt);
    },

    /**
    * Sets the selected property to the path specified in the event.
    *
    * @method _setSelected
    */
    _setSelected: function(evt) {
      if (evt.detail.path) {
        this.set('selected', 'nav.'+ evt.detail.path);
      }
    },

    /**
    * Called as an observer on selected, expects a newVal and oldVal, and uses both
    * of those to set the rights paths for what is/isn't selected.
    *
    * Tells the new item it is selected, and tells the old item to unselect itself.
    *
    * The template is watching the .selected property, and will pick this change
    * up, since we are using the specific path to notify Polymer of the change.
    *
    * Once the change is picked up, the selected class is automatically added or
    * remove the correct item.
    *
    * @method _selectedChange
    * @prop {String} newVal - Path the newly selected item
    * @prop {String} oldVal - Path the previously selected item
    */
    _selectedChange: function(newVal, oldVal) {
      var newPath = newVal  + '.selected',
          oldPath = oldVal  + '.selected';

      if (oldVal) {
        this.set(oldPath, false);
      }

      this.set(newPath, true);
    },

    /**
    * Called when the 'X' button is pressed in the search bar. Resets the searchKeyword
    * property
    *
    * @method _resetSearch
    */
    _resetSearch: function() {
      this.set('initialSearchKeyword','');
      this.$.searchInput.focus();
    },

    /**
    * Called when the searchKeyword is changed, and sets off the nav rebuild process.
    *
    * @method _callNavRebuild
    */
    _callNavRebuild: function() {
      if (this.searchKeyword) {
        this.set('nav', this.nav);
      }
    },

    /**
    * Called when the search Keyword is changed to call the filter on the nav.
    * To ensure we don't do this on every single key down, we have a debounce in place.
    *
    * @method _computedNav
    * @prop {Object} navArr - The initial navigation object to filter on
    * @prop {String} searchKeyword - The string to filter the navigation with
    */
    _computedNav: function(navArr, searchKeyword) {
      //if there's no searchKeyword, nothing needs to be rebuild. return the existing nav.
      if (searchKeyword === '') {
        this.set('nav', this.initialNav);
        return;
      }

      this.debounce('navBuild', function() {
        //call the filter with the search keyword
        this.set('nav', this._buildNav(navArr, searchKeyword));
      }, 250);
    },

    /**
    * Called when a search keyword is entered, and builds (and returns) a new nav
    * object that only contains the search query.
    *
    * @method _buildNav
    * @prop {Object} navArr - The initial navigation object to filter on
    * @prop {String} searchKeyword - The string to filter the navigation with
    */
    _buildNav: function(navArr, searchKeyword) {
      var foundItems = [],
      lowercaseArray;
      for (var i = 0, len=navArr.length; i < len; i++) {
        //build our initial object and populate it.
        var currentObj = {};
        currentObj.text = navArr[i].text;
        currentObj.icon = navArr[i].icon;
        currentObj.src = navArr[i].src;
        currentObj.selected = navArr[i].selected;
        currentObj.opened = true;
        //if the item has children (ie children), recurse and if another array with children is returned, insert that into the object.
        if (navArr[i].children) {
          var tempArr = this._buildNav(navArr[i].children, searchKeyword);
          if (tempArr.length) {
            currentObj['children'] = tempArr;
          }
        }
        //lowercase both the search keyword, and link text, and compare - if there's a match, push it into the array.
        if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) !== -1  ||
        currentObj.children) {
          foundItems.push(currentObj);
        }
        lowercaseArray=[];
      }
      //returns a rebuilt, filtered nav
      return foundItems;
    }

  });
</script>
