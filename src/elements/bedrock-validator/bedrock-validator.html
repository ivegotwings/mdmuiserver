<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../bedrock-helpers/validation-helper.html">

<dom-module id="bedrock-validator">

    <script src="../../../bower_components/moment/moment.js"></script>

    <script>
        /**
         * `bedrock-validator` validates user input against a specified validation condition.
         *
         * @demo demo/index.html
         */



        Polymer({
            is: 'bedrock-validator',

            properties: {
                // property using which regular expressions can be passed for validation
                pattern:{
                    type: String,
                    notify:true
                },
                // input to be validated
                input:{
                    type: String,
                    notify:true,
                    observer: 'inputChanged'
                },
                // type/name of validator to be used. If multiple validators, then it can be passed as comma separated string. Possible validation types: required, minLength, maxLength, range, email, pattern, decimalPrecision, timeRange, dateRange,fileExtension. (Some common validation types like required, minLength and maxLength can be directly passed as attributes. No need to add them in type)
                type:{
                    type:String,
                    notify:true
                },
                // type of validator to be used if required to be passed as an Array. Either this or type should be used not both.
                typeArray:{
                    type:Array,
                    notify:true,
                    value: function () {
                        return [];
                    }
                },
                // boolean flag to know if data is successfully validated or not
                invalid:{
                    type:Boolean,
                    value:false,
                    notify:true,
                    reflectToAttribute:true
                },
                //error message to be shown
                errorMessage:{
                    type: String,
                    notify:true,
                    value: ''
                },
                // min value to be used in range validator
                min:{
                    type: String,
                    notify:true
                },
                //max value to be used in range validator
                max:{
                    type: String
                },
                // minimum length of text allowed
                minLength:{
                    type: Number,
                    notify:true
                },
                // maximum length of text allowed
                maxLength:{
                    type: Number,
                    notify:true
                },
                //decimal precision
                precision:{
                    type: Number
                },
                //boolean which tells if the input is required or not
                required:{
                    type: Boolean,
                    value: false
                },
                // date format
                dateFormat:{
                    type:String
                },
                validationErrors:{
                    type:Array,
                    value:function () {
                        return [];
                    },
                    notify: true
                },
                showError:{
                    type:Boolean,
                    value: false,
                    notify:true
                }
            },
            // observer on input. It is called whenever any change is made to input
            inputChanged: function (input) {
                this.validate(input);
            },
            // function to validate the input. It calls the required validator based on the validation type given
            validate: function(input) {
                this.errorMessage='';
                this.validationErrors=[];
                this.invalid=false;
                if(this.required){
                    if(!ValidationHelper.requiredValidator(input)) {
                        this.invalid =true;
                        this.push('validationErrors', "Required");
                    }
                }
                if(this.minLength && input){
                    if(!ValidationHelper.minLengthValidator(input, this.minLength)) {
                        this.invalid =true;
                        this.push('validationErrors', "Length shouldn't be smaller than " + this.minLength);
                    }
                }
                if(this.maxLength && input){
                    if(!ValidationHelper.maxLengthValidator(input, this.maxLength)) {
                        this.invalid =true;
                        this.push('validationErrors', "Length shouldn't be greater than " + this.maxLength);
                    }
                }
                var types;
                if(this.type) {
                    types = this.type.split(",");
                } else if(this.typeArray) {
                    types=this.typeArray;
                }
                if(types && types.length>0){
                    for (var i = 0; i < types.length; i++) {
                        var invalid = false;
                        if(types[i]=='required' && !this.required){
                            if(!ValidationHelper.requiredValidator(input)) {
                                this.invalid =true;
                                this.push('validationErrors', "Required");
                            }
                        } else if(input) {
                            switch (types[i]) {
                                case 'range':
                                    invalid = !ValidationHelper.numberRangeValidator(input, this.min, this.max);
                                    this.push('validationErrors',"Value should be between  " + this.min + " and " + this.max );
                                    break;
                                case 'rangeTo':
                                    invalid = !ValidationHelper.numberRangeValidator(input, '', this.max);
                                    this.push('validationErrors', "Value should be smaller than " + this.max);
                                    break;
                                case 'rangeFrom':
                                    invalid = !ValidationHelper.numberRangeValidator(input, this.min, '');
                                    this.push('validationErrors',  "Value should be greater than " + this.min);
                                    break;
                                case 'email':
                                    invalid = !ValidationHelper.emailValidator(input);
                                    this.push('validationErrors', "Invalid Email");
                                    break;
                                case 'pattern':
                                    invalid = !ValidationHelper.regexValidator(input, this.pattern);
                                    this.push('validationErrors', "Text doesn't match the required pattern");
                                    break;
                                case 'decimalPrecision':
                                    invalid = !ValidationHelper.decimalPrecisionValidator(input, this.precision);
                                    this.push('validationErrors', "Value should have a decimal precision of " + this.precision);
                                    break;
                                case 'fileExtension':
                                    var allowedFiles = [".png",".doc", ".docx", ".pdf",".xls",".xlsx",".txt"];
                                    invalid = !ValidationHelper.fileExtensionValidator(input,allowedFiles);
                                    this.push('validationErrors', "File with the given extension is not supported");
                                    break;
                                case 'timeRange':
                                    invalid =  !ValidationHelper.dateRangeValidator(input,this.dateFormat, this.min, this.max);
                                    this.push('validationErrors', "Time should be between "+ ValidationHelper.getDateByFormat(this.min,this.dateFormat) +" and "+ getDateByFormat(this.max,this.dateFormat));
                                    break;
                                case 'dateRange':
                                    invalid =  !ValidationHelper.dateRangeValidator(input,this.dateFormat, this.min, this.max);
                                    this.push('validationErrors', "Date should be between "+ ValidationHelper.getDateByFormat(this.min,this.dateFormat) +" and "+ getDateByFormat(this.max,this.dateFormat));
                                    break;
                            }
                        }
                        if (invalid) {
                            this.invalid = true;
                        }
                    }
                }
                if(this.invalid){
                    this._refreshValidationErrors();
                    if(this.showError){
                        for(var j=0;j<this.validationErrors.length;j++){
                            this.errorMessage+=this.validationErrors[j]+". "
                        }
                    }
                }
            },
            attached: function() {
                this.validate(this.input);
            },
            _refreshValidationErrors: function () {
                var val=this.validationErrors;
                this.validationErrors=[];
                this.validationErrors=val;
            }


        });
    </script>
</dom-module>