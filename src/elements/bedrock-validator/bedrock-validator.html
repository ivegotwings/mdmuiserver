<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../bedrock-helpers/validation-helper.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">

<dom-module id="bedrock-validator">

    <script src="../../../bower_components/moment/moment.js"></script>

    <script>
/**
* `bedrock-validator` Represents a component that validates the user input against a specified validation condition.
*
* @demo demo/index.html
*/
        Polymer({
            is: 'bedrock-validator',

            properties: {
                // Indicates the pattern using which a regular expressions is passed for validation.
                pattern:{
                    type: String,
                    notify:true
                },
                // Indicates allowed values for pattern invalid message
                allowedInput: {
                    type: String,
                    value: null
                },
                // Indicates an input that needs validation.
                input:{
                    type: String,
                    notify:true,
                    observer: 'inputChanged'
                },
                // Indicates an input data type.
                inputDataType:{
                    type: String
                },
                // Indicates the type of the validator. 
                // Multiple validators are passed as comma separated strings. 
                // Possible validation types are required, minLength, maxLength, range, email, pattern, decimalPrecision, timeRange, dateRange, and fileExtension. 
                // Some common validation types like required, minLength, and maxLength are directly passed as attributes. There is no need to add them in the type.
                type:{
                    type:String,
                    notify:true
                },
                // Indicates the type of validator to be used if the type `required` is passed as an array. You can use either this or the `type`. You cannot use both.
                typeArray:{
                    type:Array,
                    notify:true,
                    value: function () {
                        return [];
                    }
                },
                // Indicates whether or not the data is successfully validated.
                invalid:{
                    type:Boolean,
                    value:false,
                    notify:true,
                    reflectToAttribute:true
                },
                // Indicates an error message.
                errorMessage:{
                    type: String,
                    notify:true,
                    value: ''
                },
                warningMessage: {
                    type: String,
                    notify: true,
                    value: ''
                },
                // Indicates the minimum value allowed in the range validator.
                min:{
                    type: String,
                    notify:true
                },
                //Indicates the maximum value allowed in the range validator.
                max:{
                    type: String
                },
                // Indicates the minimum length of the text allowed.
                minLength:{
                    type: Number,
                    notify:true
                },
                // Indicates the maximum length of the text allowed.
                maxLength:{
                    type: Number,
                    notify:true
                },
                //Indicates the decimal precision.
                precision:{
                    type: Number
                },
                //Specifies whether or not the input is required.
                required:{
                    type: Boolean,
                    value: false
                },
                // Specifies the date format.
                dateFormat:{
                    type:String
                },
                // Indicates an array of validation errors.
                validationErrors:{
                    type:Array,
                    value:function () {
                        return [];
                    },
                    notify: true,
                    observer: '_validationErrorsChanged'
                },
                validationWarnings: {
                    type: Array,
                    value: function () {
                        return [];
                    },
                    notify: true,
                    observer: '_validationWarningsChanged'
                },
                // Specifies whether or not to show the errors.
                showError:{
                    type:Boolean,
                    value: false,
                    notify:true
                },
         /**
           * Content development is under progress.
           */
                minInclusive: {
                    type: Boolean,
                    value: false
                },
         /**
           * Content development is under progress.
           */
                maxInclusive: {
                    type: Boolean,
                    value: false
                }
            },
            // Can be used to observe the input. It is invoked whenever any input is changed.
            inputChanged: function (input) {
                this.validate(input);
            },            
            // Can be used to validate the input. It invokes the required validator based on the given validation type.
            validate: function(input) {
                this.errorMessage='';
                this.validationErrors = [];
                this.validationWarnings = [];
                this.invalid=false;
                var _greaterEqual = "greater than or equal to ";
                var _greater = "greater than ";
                var _lesserEqual = "less than or equal to ";
                var _lesser = "less than ";
                var inputDataType = "";

                if(this.inputDataType){
                    inputDataType = this.inputDataType.toLowerCase();
                }
                if(this.required){
                    if(!ValidationHelper.requiredValidator(input)) {
                        this.invalid =true;
                        this.push('validationErrors', "Required");
                    }
                }

                if(input && inputDataType){
                    
                    if(inputDataType == "boolean")
                    {
                        if(!ValidationHelper.booleanValidator(input))
                        {
                            this.invalid =true;
                            this.push('validationErrors', "Provide boolean value");
                        }
                    }
                    if(inputDataType == "integer")
                    {
                        if(!ValidationHelper.integerValidator(input))
                        {
                            this.invalid =true;
                            this.push('validationErrors', "Provide integer value");
                        }
                    }
                    if(inputDataType == "decimal")
                    {
                        if(!ValidationHelper.decimalValidator(input))
                        {
                            this.invalid =true;
                            this.push('validationErrors', "Provide decimal value");
                        }
                    }
                    if(this.pattern) {
                        if (!ValidationHelper.regexValidator(input, this.pattern)) {
                            this.invalid = true;
                            var msg = "Text doesn't match the required pattern.";
                            if (this.allowedInput) {
                                msg += " Allowed values are - " + this.allowedInput;
                            }
                            this.push('validationErrors', msg);
                        }
                    }
                    if(inputDataType == "decimal" && this.precision)
                    {                    
                        if(!ValidationHelper.decimalPrecisionValidator(input, this.precision))
                        {
                            this.invalid =true;
                            this.push('validationErrors', "Value should have a decimal precision of " + this.precision);
                        }
                    }
                    if(inputDataType == "date" || inputDataType == "datetime")
                    {
                        //Convert date and do rest of the process
                        input = FormatHelper.convertFromISODateTime(input, this.inputDataType, this.dateFormat);

                        this.min = FormatHelper.convertFromISODateTimeToClientFormat(this.min, inputDataType);
                        this.max = FormatHelper.convertFromISODateTimeToClientFormat(this.max, inputDataType);

                        if(!ValidationHelper.dateTimeValidator(input, this.inputDataType.toLowerCase(), this.dateFormat))
                        {
                            this.invalid =true;
                            this.push('validationErrors', "Provide valid date");
                        } 
                        if (this.min && this.max && (!ValidationHelper.dateRangeValidator(input,this.dateFormat, this.min, this.max, this.minInclusive, this.maxInclusive))) 
                        {
                            this.invalid =true;
                            var message = "Value should be " + (this.minInclusive ? _greaterEqual : _greater) + ValidationHelper.getDateByFormat(this.min,this.dateFormat) + " and " + 
                            (this.maxInclusive ? _lesserEqual : _lesser) + ValidationHelper.getDateByFormat(this.max,this.dateFormat);
                            this.push('validationErrors', message);
                        } 
                        else if(!this.min && this.max && (!ValidationHelper.dateRangeValidator(input, this.dateFormat,'', this.max, this.minInclusive, this.maxInclusive))) 
                        {
                            this.invalid = true;
                            message = "Value should be " + (this.maxInclusive ? _lesserEqual : _lesser) + this.max;
                        } 
                        else if (this.min && !this.max && (!ValidationHelper.dateRangeValidator(input, this.dateFormat, this.min, '' , this.minInclusive, this.maxInclusive))) 
                        {
                            this.invalid = true;
                            message = "Value should be " + (this.minInclusive ? _greaterEqual : _greater) + this.min;
                        }
                    }
                    if(this.minLength){
                        var validateInput = ValidationHelper.minLengthValidator(input, this.minLength);
                        if(!validateInput || Array.isArray(validateInput)) {
                            var errorMessage = "Length shouldn't be smaller than " + this.minLength
                            this.invalid =true;
                            if(Array.isArray(input)){
                                errorMessage +=" for values at position " + validateInput.join(" , ");
                            }
                            this.push('validationErrors', errorMessage);
                        }
                    }
                    if(this.maxLength){
                        var validateInput = ValidationHelper.maxLengthValidator(input, this.maxLength);
                        if(!validateInput || Array.isArray(validateInput)) {
                            var errorMessage = "Length shouldn't be greater than " + this.maxLength
                            this.invalid =true;
                            if(Array.isArray(input)){
                                errorMessage +=" for values at position " + validateInput.join(" , ");
                            }
                            this.push('validationErrors', errorMessage);
                        }
                    }

                    // Range validation                
                    if((inputDataType == "decimal" || inputDataType == "integer") && (this.min || this.max))
                    {
                        var message = "";
                        if(this.min && this.max && (!ValidationHelper.numberRangeValidator(input, this.min, this.max, this.minInclusive, this.maxInclusive))) {                                     
                            this.invalid = true;
                            message = "Value should be " + (this.minInclusive ? _greaterEqual : _greater) + this.min + " and " + (this.maxInclusive ? _lesserEqual : _lesser) + this.max;
                        } else if(!this.min && this.max && (!ValidationHelper.numberRangeValidator(input, '', this.max, this.minInclusive, this.maxInclusive))) {
                            this.invalid = true;
                            message = "Value should be " + (this.maxInclusive ? _lesserEqual : _lesser) + this.max;
                        } else if (this.min && !this.max && (!ValidationHelper.numberRangeValidator(input, this.min, '' , this.minInclusive, this.maxInclusive))) {
                            this.invalid = true;
                            message = "Value should be " + (this.minInclusive ? _greaterEqual : _greater) + this.min;
                        }

                        if(message!="") {
                            this.push('validationErrors', message);  
                        }                        
                    }
                }

                var types;
                if(this.type) {
                    types = this.type.split(",");
                } else if(this.typeArray) {
                    types=this.typeArray;
                }
                if(types && types.length>0){
                    for (var i = 0; i < types.length; i++) {
                        var invalid = false;
                        if(types[i]=='required' && !this.required){
                            if(!ValidationHelper.requiredValidator(input)) {
                                this.invalid =true;
                                this.push('validationErrors', "Required");
                            }
                        } else if(input) {                           
                            switch (types[i]) {                               
                                case 'email':
                                    invalid = !ValidationHelper.emailValidator(input);
                                    if(invalid) {
                                        this.push('validationErrors', "Invalid Email");
                                    }
                                    break;
                                case 'fileExtension':
                                    var allowedFiles = [".png",".doc", ".docx", ".pdf",".xls",".xlsx",".txt"];
                                    invalid = !ValidationHelper.fileExtensionValidator(input,allowedFiles);
                                    if(invalid) {
                                        this.push('validationErrors', "File with the given extension is not supported");
                                    }
                                    break; 
                            }
                        }
                        if (invalid) {
                            this.invalid = true;
                        }
                    }
                }
                if(this.invalid){
                    this._refreshValidationMessages();
                }
            },
         /**
           * Content development is under progress.
           */
            attached: function() {
                this.validate(this.input);
            },
            _refreshValidationMessages: function () {
                //Errors
                var errors = this.validationErrors;
                this.validationErrors = [];
                this.validationErrors = errors;

                //Warnings
                var warnings = this.validationWarnings;
                this.validationWarnings = [];
                this.validationWarnings = warnings;
            },

            _validationErrorsChanged:function(){
                this._validationMessagesChanged(this.validationErrors);
            },

            _validationWarningsChanged:function(){
                this._validationMessagesChanged(this.validationWarnings, false);
            },

            _validationMessagesChanged: function (validationMessages, isError = true) {
                var message = "";
                if (this.showError) {
                    for (var i = 0; i < validationMessages.length; i++) {
                        message += validationMessages[i] + ". "
                    }
                }

                if (isError) {
                    this.errorMessage = message
                } else {
                    this.warningMessage = message;
                }

                if (validationMessages && validationMessages.length) {
                    this.invalid = true;
                }
                else {
                    this.invalid = false;
                }
            }
        }) //semi colon has to be removed for setTimeout
    </script>
</dom-module>