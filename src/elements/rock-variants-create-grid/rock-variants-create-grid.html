<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-grid/remote-data.html">

<!--
` rock-variants-create-grid` component is used to render all possible variants in grid based on the options selected.

@demo demo/index.html
-->

<dom-module id="rock-variants-create-grid">
    <template>
        <style include="pebble-styles-shared"></style>
        <p>You select <b>{{_attributesCountText}}</b> as possible options. We have created <b>[[totalVariants]]</b> potential
            [[leafEntityDetails.entityType]] options for you. All new [[leafEntityDetails.entityType]]s in the list below will be created unless you
            want to delete the [[leafEntityDetails.entityType]]s from this list.
        </p>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="{{attributeModelRequest}}" on-response="_onCompositeModelGetResponse" exclude-in-progress></liquid-entity-model-composite-get>
        <liquid-entity-data-get  id="getData" operation="getbyids" request-data="[[_request]]" last-response="{{remoteData}}"
            on-response="_onGetResponse">
        </liquid-entity-data-get>
        <rock-grid title="Variant Options" id="variantGrid" data="{{data}}" config="{{gridConfig}}"
             page-size="15"></rock-grid>
        <div id="content-actions" align="center">
            <pebble-button class="action-button btn btn-secondary" id="skip" button-text="Cancel" raised on-tap="_onCancelTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>
    </template>

    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'rock-variants-create-grid',
                properties: {
                    /**
                    * Indicates the identification of the entity for which the variants are shown.
                    */
                    entityId: {
                        type: String
                    },
                    /**
                     * Indicates the locale dimension for which the attributes are managed.
                     */
                    locale: {
                        type: String
                    },
                    /**
                     * Indictaes the list for which the attributes are managed.
                     */
                    list: {
                        type: String
                    },
                    /**
                     * Indictaes the classification for which the attributes are managed.
                     */
                    classification: {
                        type: String,
                        value: "_ALL"
                    },
                    /**
                     * Indictaes the source dimension for which the attributes are managed.
                     */
                    source: {
                        type: String
                    },
                    /**
                     * Specifies the configuration object that to be passed to grid.
                     */
                    gridConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    // List of attributes present in variant definition
                    attributesList: {
                        type: Array
                    },
                    variantDefinition: {
                        type: Object
                    },
                    _currentIndex: {
                        type: Number,
                        value: 0
                    },
                    //List of leaf entities which are child of parent entity
                    leafEntities: {
                        type: Array,
                        observer: '_leafEntitiesChanged'
                    },
                    //Total possible number of variants
                    totalVariants: {
                        type: Number,
                        value: 1
                    }
                },
                behaviors: [
                    RUFBehaviors.UIBehavior
                ],
                ready:function () {
                    this.gridConfig=this.getParentAppConfig('rock-entity-variant','rock-variants-create-grid','createVariantsGridConfig');
                    this.variantDefinition=this.getParentAppConfig('rock-entity-variant', 'rock-variants-create-grid', 'variantDefinitionUI');
                },
                observers:[
                    '_onDefinitionRender(variantDefinition,entityId,entityType,gridConfig)'
                ],
                _onDefinitionRender: function () {
                    var sourceAttrs = [];
                    var targetAttrs = [];
                    var medAttrs = [];
                    var leafEntity;
                    var max = 0;
                    if (this.variantDefinition && this.variantDefinition.levels) {
                        this.variantDefinition.levels.forEach(function (level) {
                            if (level.index > max) {
                                max = level.index;
                                leafEntity = {index: level.index, entityType: level.entityType};
                            }
                            for (var i = 0; i < level.dimensionAttributes.length; i++) {
                                sourceAttrs.push(level.dimensionAttributes[i].sourceAttribute);
                                targetAttrs.push(level.dimensionAttributes[i].targetAttribute);
                                if (level.index == 1) {
                                    medAttrs.push(level.dimensionAttributes[i].targetAttribute);
                                } else if (level.index == 2) {
                                    medAttrs.push(level.dimensionAttributes[i].sourceAttribute);
                                }
                            }
                        });
                        this.attributesIndexMapping = [sourceAttrs, medAttrs, targetAttrs];
                        this.attributesList = sourceAttrs;
                        this.targetAttributesList = targetAttrs;
                        var columns=this.targetAttributesList.map(function (attribute) {
                           return {"header":attribute,"name":attribute}
                        });
                        this.gridConfig.tabular.columns=this.gridConfig.tabular.columns.concat(columns);
                        this.leafEntityDetails = leafEntity;
                        this._getAttributeModels(this.variantDefinition);
                        var liquidGet = this.$.getData;
                        this._request = this._getGridRequest(this.entityId, this.entityType, 0);
                        if (liquidGet) {
                            liquidGet.generateRequest();
                        }
                    }
                },
                _getGridRequest: function (id, type,index) {
                    var attributes=this.attributesIndexMapping[index];
                    var relatedAttributes=[];
                    if(index<this.leafEntityDetails.index){
                      relatedAttributes=this.attributesIndexMapping[index+1];
                    }
                    var req = {
                        "params": {
                            "query": {
                                "ctx": [
                                    {
                                        "classification": this.classification,
                                        "list": this.list
                                    }
                                ],
                                "valCtx": [
                                    { "locale": this.locale, "source": this.source }
                                ],
                                "filters": {
                                    "typesCriterion": [this.entityType]
                                },
                                "id": id
                            },
                            "fields": {
                                "ctxTypes": [
                                    "properties"
                                ],
                                relationships: [
                                    "isChildOf"
                                ],
                                relatedEntityAttributes: relatedAttributes,
                                attributes: attributes
                            }
                        }
                    };
                    if (id instanceof Array) {
                        delete req.params.query.id;
                        req.params.query.ids = id;
                    }
                    if (type) {
                        req.params.query.filters.typesCriterion = [type];
                    }
                    return req;
                },
                _getRelatedEntities: function (entity) {
                    var relatedEntities=[];
                    if (entity && entity.data && entity.data.ctxInfo) {
                        var ctx = {"list":this.list,"classification":this.classification};
                        var relationshipsList;
                        for (var i = 0; i < entity.data.ctxInfo.length; i++) {
                            var ctxData = entity.data.ctxInfo[i];
                            var compareResult = DataObjectFalcorUtil.compareCtx(ctxData.ctxGroup, ctx);
                            if (compareResult) {
                                relationshipsList = ctxData.relationships;
                                break;
                            }
                        }
                        if (relationshipsList) {
                            var isChildRelationshipEntities = relationshipsList["isChildOf"];
                            if (isChildRelationshipEntities) {
                                isChildRelationshipEntities.forEach(function (relationshipEntity) {
                                    if (relationshipEntity.relTo) {
                                        relatedEntities.push(relationshipEntity.relTo);
                                    }
                                });
                            }
                        }
                    }
                    return relatedEntities;
                },
                _getAttributeValues: function (entity) {
                    var dataContext = {
                        "list": this.list,
                        "classification": this.classification,
                        "source": this.source,
                        "time": "now",
                        "locale": this.locale
                    };
                    this.attributeValues = [];
                    var text = "";
                    if (entity.data) {
                        var ctx = DataHelper.prepareCtx(dataContext);
                        var valCtx = DataHelper.prepareValCtx(dataContext);
                        var attributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(entity, ctx);
                        var totalVariants = 1;
                        for (var i = 0; i < this.attributesList.length; i++) {
                            var attribute = attributes[this.attributesList[i]];
                            if (attribute && attribute.values) {
                                var values = DataHelper.getAttributeValues(attribute.values, valCtx);
                                this.push('attributeValues', {
                                    "name": this.attributesList[i],
                                    "values": values
                                });
                                totalVariants = totalVariants * values.length;
                                text += values.length + " " + this.attributesList[i] + " and";
                            }
                        }
                    }
                    this._attributesCountText = text.substring(0, text.lastIndexOf("and"));
                    this.totalVariants = totalVariants;

                },
                _onGetResponse: function (e) {
                    var respData = e.detail.response;
                    var index;
                    if (respData) {
                        if (respData.content && respData.content.entities) {
                            var relatedEntities=[];
                            var entities = respData.content.entities;
                            if(entities[0].entityInfo.entityType==this.entityType){
                                var entity = entities[0];
                                this._getAttributeValues(entity);
                                relatedEntities = this._getRelatedEntities(entity);
                            } else{
                                for (var i = 0; i < entities.length; i++) {
                                    var entity = entities[i];
                                    var relEnts = this._getRelatedEntities(entity);
                                    relatedEntities = relatedEntities.concat(relEnts);
                                }
                            }
                            if(relatedEntities.length) {
                                var type = relatedEntities[0].entityInfo.entityType;
                                if (relatedEntities[0].entityInfo.entityType == this.leafEntityDetails.entityType) {
                                    this.leafEntities = relatedEntities;
                                    return;
                                } else {
                                    if (!this.entities) {
                                        this.entities = {};
                                    }
                                    for (var i = 0; i < this.variantDefinition.levels.length; i++) {
                                        if (this.variantDefinition.levels[i].entityType == relatedEntities[0].entityInfo.entityType) {
                                            this.entities[this.variantDefinition.levels[i].index] = relatedEntities;
                                            index=this.variantDefinition.levels[i].index;
                                            break;
                                        }
                                    }
                                }
                                var ids = relatedEntities.map(function (ent) {
                                    return ent.id;
                                });
                                if (ids.length > 0) {
                                    this._request = this._getGridRequest(ids, type,index);
                                    this.$.getData.generateRequest();
                                }
                            } else {
                                this.leafEntities = [];
                            }
                        }
                    }
                },
                _onCancelTap: function (e) {
                    //raise event with name given for onbackAction in configuration
                    var eventName = "onCancel";
                    var eventDetail = {
                        name: eventName
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },
                _onSaveTap: function (e) {
                    var eventName = "onComplete";
                    var eventDetail = {
                        name: eventName,
                        data: this.selectedOptions
                    };
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },
                _leafEntitiesChanged: function () {
                    var data = [];
                    var n = this.attributeValues.length;
                    var nameArray = [];
                    var valuesArray = [];
                    for (var i = 0; i < n; i++) {
                        nameArray.push(this.attributeValues[i].name);
                        valuesArray.push(this.attributeValues[i].values);
                    }
                    var combinations = this.getAllCombinations(valuesArray);
                    for (var i = 0; i < this.totalVariants; i++) {
                        data[i] = {};
                        for (var j = 0; j < nameArray.length; j++) {
                            data[i][nameArray[j]] = combinations[i][j];
                            data[i]["status"] = "New";
                        }
                    }
                    //TODO take this.leafEntities and replace those combinations with the present entities data
                    this.data = data;
                },
                // Function to get all combinations of multiple arrays
                getAllCombinations: function (arraysToCombine) {
                    var divisors = [];
                    for (var i = arraysToCombine.length - 1; i >= 0; i--) {
                        divisors[i] = divisors[i + 1] ? divisors[i + 1] * arraysToCombine[i + 1].length : 1;
                    }
                    function getPermutation(n, arraysToCombine) {
                        var result = [],
                            curArray;
                        for (var i = 0; i < arraysToCombine.length; i++) {
                            curArray = arraysToCombine[i];
                            result.push(curArray[Math.floor(n / divisors[i]) % curArray.length]);
                        }
                        return result;
                    }
                    var numPerms = arraysToCombine[0].length;
                    for (var i = 1; i < arraysToCombine.length; i++) {
                        numPerms *= arraysToCombine[i].length;
                    }
                    var combinations = [];
                    for (var i = 0; i < numPerms; i++) {
                        combinations.push(getPermutation(i, arraysToCombine));
                    }
                    return combinations;
                },
                _getAttributeModels:function (variantDefinition) {
                    if (!variantDefinition || !Object.keys(variantDefinition).length) {
                        return;
                    }
                    var types=this.variantDefinition.levels.map(function (level) {
                        return level.entityType;
                    });
                    types.unshift(this.entityType);
                    var req = {
                        "params": {
                            "query": {
                                "ctx": [{
                                    "list": this.list,
                                    "classification": this.classification
                                }
                                ],
                                "locale": this.locale,
                                "name": this.leafEntityDetails.entityType,
                                "filters": {
                                    "typesCriterion": [types]
                                }
                            },
                            "fields": {
                                "ctxTypes": [
                                    "properties"
                                ],
                                "attributes": this.targetAttributesList
                            }
                        }
                    };
                    this.set("attributeModelRequest", req);
                    var liquidModelGet = this.$$("[name=compositeAttributeModelGet]");
                    if (liquidModelGet) {
                        liquidModelGet.generateRequest();
                    }
                },
                _onCompositeModelGetResponse: function (e) {
                    if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                        var ctx = {
                            "list": this.list,
                            "classification": this.classification
                        };
                        this._attributeModels = DataHelper.transformAttributeModelsToUIFormat(e.detail.response.content.entityModels[0], ctx);
                    }
                },
            });
        })();
    </script>
</dom-module>