<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html">
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="../pebble-tag-item/pebble-tag-item.html">

<!--
`pebble-tags` Represents a group of tag items which together can form a selection.

@demo demo/index.html
-->
<dom-module id="pebble-tags">
  <template>
    <style include="pebble-styles-shared"></style>    
    <style>
       :host {
        display: inline-flex;
        display: -webkit-inline-flex;
        /*padding: 1%;*/
        /*box-sizing: border-box;
        font-family: 'Roboto', 'Noto', sans-serif;*/
      }
      
      .clearfix:after {
        content: " ";
        display: block;
        height: 0;
        clear: both;
      }

      .more-values-message {
        display:inline-block;        
        height: 25px;
        padding-top: 8px;
        font-size: 12px;
        color: blue;
        cursor: pointer;
      }
      
    </style>
    <div>
      <template is="dom-repeat" items="{{tags}}" >
        <template is="dom-if" if="[[_showItem(index, displayLimit)]]">
          <pebble-tag-item  class$="tag[[index]]" size="{{size}}" disable-delete="{{disableDelete}}" index="{{index}}"  options="{{item.options}}"
            name$="{{item.name}}" long-name="{{item.longName}}" value="{{item.value}}" edit-mode="{{item.editMode}}" is-non-editable="{{isNonEditable}}"  icon="[[item.icon]]" src="[[item.src]]" display-type="{{item.displayType}}" tag-color="[[item.color]]"></pebble-tag-item>
        </template>
      </template>
      <span class="more-values-message" hidden$="[[!_enableShowMore]]" on-tap="_onTapShowMore">[[_limitMessage]]</span>
    </div>
  </template>
  <script>

  Polymer({

    is: 'pebble-tags',

    properties: {

      /**
       * Indicates the list of strings that holds the tags. Values in this array must be identical. Avoid duplicates due to the definition of tags. Icons for individual tag can also be passed in this list.
       */
      tags:{
        type:Array,
        notify: true,
        value:function(){return []}
      },
      /**
        * Specifies whether or not the deletion of a tag is allowed.
       */
      disableDelete: {
        type: Boolean,
        value: false
      },
      /**
        * Specifies whether or not the value of the tag is editable.
       */
      isNonEditable: {
        type: Boolean,
        value: false
      },
       /**
        * Specifies whether or not adding more tags is allowed.
       */
      disableAdd: {
        type: Boolean,
        value: false
      },
      /**
       *  Indicates the reference to the currently opened tag.
       */
      currentTag:{
          type:Object,
          notify:true
      },

      /**
       * Indicates how many tags should display initially
       * Default is 0 for no limit
       */
      displayLimit: {
        type: Number,
        value: 0
      },

      _enableShowMore: {
        type: Boolean,
        value: false
      },

      _limitMessage: {
        type: String,
        values: "more values..."
      }
    },
    listeners: {
        'tag-item-remove': '_onTagItemRemove',
        'tag-item-opened':'_onTagItemOpened'
    },

    observers: [
      '_onTagsChange(tags.*)'
    ],

    // Element Behavior
    /**
     * Can be used to add a new tag to the list.
     *
     * @param {JSON} the tag that needs to be added.
     */
    addTag: function(tag){
      if(!this.disableAdd) {
        if (typeof(this.tags) == 'undefined'){
          this.tags = [];
        }
        if (typeof tag != "object"){
          alert('bad tag object');
          return;
        }
        else {
          for(var i=0;i<this.tags.length;i++) {
            if(this.tags[i].name == tag.name) {
              alert(tag.name + ': tag alerady added');
              return;
            }
          }
        }

        this.push('tags', tag);
          if(!this.isNonEditable) {
              this.async(function () {
                  var tagItem = this.$$('pebble-tag-item[name=' + tag.name + ']');
                  if (tagItem) {
                      tagItem._makeEditable();
                  }
              });
          }
      }
    },
    
    /**
     * Handler for 'tag-item-remove' event, which is fired when a <tag-item> is being removed.
     *
     * @param {Object} event object.
     */
    _onTagItemRemove: function(e) {
         this.splice('tags', e.detail.index, 1);
    },
    _onTagItemOpened:function (e) {
        this.currentTag=e.detail;
        this.fire('tag-item-added',e.detail);
    },

    _showItem: function(index){
      if(index < this.displayLimit || this.displayLimit == 0)
      {
        return true;
      }
      
      this._enableShowMore = true;
      return false;      
    },

    _onTapShowMore: function() {
      this._enableShowMore = false;
      this.displayLimit = 0;
    },

    _onTagsChange: function() {
      this._limitMessage = this.tags.length - this.displayLimit + " more values...";
    }

  });

</script>
</dom-module>
