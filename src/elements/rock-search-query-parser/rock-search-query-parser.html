<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/constant-helper.html">

<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<script src="./search-query-parser.js"></script>

<!--

`rock-search-query-parser` Represents the element to be used to parse the query given in search box in entity-discovery page and return the search filters required to prepare request Object for get entities.

@demo demo/index.html
-->

<dom-module id="rock-search-query-parser">
  <template>
    <liquid-entity-model-composite-get name="compositeAttributeModelGet" on-entity-model-composite-get-response="_onCompositeModelGetResponse">
    </liquid-entity-model-composite-get>
  </template>
  <script>
    class RockSearchQueryParser extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior, RUFBehaviors.ComponentContextBehavior],
      Polymer.Element) {
      static get is() {
        return "rock-search-query-parser";
      }
      static get properties() {
        return {
          contextData: {
            type: Object,
            value: function () {
              return {};
            }
          },
          query: {
            type: String,
            value: ""
          },

          parsedQuery: {
            type: Object,
            value: function () {
              return {};
            }
          },
          _entityAttributes: {
            type: Object,
            value: function () {
              return {};
            }
          },
          _relationshipAttributes: {
            type: Object,
            value: function () {
              return {};
            }
          },
          _relatedEntityAttributes: {
            type: Object,
            value: function () {
              return {};
            }
          },
          _relToEntityTypes: {
            type: Array,
            value: function () {
              return [];
            }
          },
          searchFilters: {
            type: Object,
            value: function () {
              return {};
            }
          },
          filterCriterionKey: {
            type: String,
            value: "attributesCriterion"
          },
          //Relationship name is notified from query builder
          relationshipName: {
            type: String,
            value: ""
          }
        }
      }
      get compositeAttributeModelGetLiq() {
        this._compositeAttributeModelGetLiq = this._compositeAttributeModelGetLiq || this.shadowRoot.querySelector(
          "[name=compositeAttributeModelGet]");
        return this._compositeAttributeModelGetLiq;
      }

      parseQueryToFilters(query) {
        let parsedQuery = this.parseQuery(query);
        this.transformQueryToFilters(parsedQuery);
      }

      parseQuery(query) {
        this.set("query", query);
        let parsedQuery = queryParser.parse(query);
        return parsedQuery;
      }

      transformQueryToFilters(queryObject) {
        let clonedContextData = DataHelper.cloneObject(this.contextData);
        let itemContexts = [];
        let itemContext = {};

        let entityTypes = queryObject.entityData && queryObject.entityData.types ? queryObject.entityData.types : [];
        this.searchFilters["typesCriterion"] = entityTypes;

        let searchQuery = queryObject.searchQuery ? queryObject.searchQuery : undefined;
        this.searchFilters["searchQuery"] = searchQuery;

        let workflowCriterion = queryObject.workflowCriterion ? queryObject.workflowCriterion : undefined;
        this.searchFilters["workflowCriterion"] = workflowCriterion;

        let attributeNames = queryObject.entityData && queryObject.entityData.attributes ? this._getAttributeNames(
          queryObject.entityData.attributes) : ["_ALL"];
        itemContext.attributeNames = attributeNames;
        this._entityAttributes = queryObject.entityData && queryObject.entityData.attributes ? queryObject.entityData
          .attributes : undefined;

        let relationshipName = queryObject.entityRelationships && queryObject.entityRelationships.relationshipName ?
          queryObject.entityRelationships.relationshipName : undefined;
        this.searchFilters["relationshipName"] = relationshipName;
        if (relationshipName) {
          if (relationshipName.indexOf("!%&") > -1) {
            relationshipName = relationshipName.replace(/!%&/g, "");
          }
          itemContext.relationships = [relationshipName];
          this._relationshipAttributes = queryObject.entityRelationships && queryObject.entityRelationships.attributes ?
            queryObject.entityRelationships.attributes : undefined;
          let relationshipAttributes = this._relationshipAttributes ? this._getAttributeNames(this._relationshipAttributes) :
            ["_ALL"];
          itemContext.relationshipAttributes = relationshipAttributes;

          this._relatedEntityAttributes = undefined;
          this._relToEntityTypes = [];
          if (queryObject.entityRelationships && queryObject.entityRelationships.relatedEntityData) {
            this._relatedEntityAttributes = queryObject.entityRelationships.relatedEntityData.attributes ?
              queryObject.entityRelationships.relatedEntityData.attributes : undefined;
            let relEntityAttributes = this._relatedEntityAttributes ? this._getAttributeNames(this._relatedEntityAttributes) :
              undefined;

            if (relEntityAttributes) {
              itemContext.attributeNames = itemContext.attributeNames.concat(relEntityAttributes);
            }

            this._relToEntityTypes = queryObject.entityRelationships.relatedEntityData.types || [];
            entityTypes = entityTypes.concat(this._relToEntityTypes);
          }
        }

        if (entityTypes && entityTypes.length > 0) {
          this._currentIndex = entityTypes.length;
          this._currentItems = [];
          for (let i = 0; i < entityTypes.length; i++) {
            let entityType = entityTypes[i];

            itemContext.type = entityType;

            itemContexts.push(itemContext);
            clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = itemContexts;

            let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(clonedContextData);

            if (this.compositeAttributeModelGetLiq && compositeModelGetRequest) {
              this.compositeAttributeModelGetLiq.requestData = compositeModelGetRequest;
              this.compositeAttributeModelGetLiq.generateRequest();
            }
          }
        }
      }

      _onCompositeModelGetResponse(e) {
        if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
          let attributeModels = DataTransformHelper.transformAttributeModels(e.detail.response.content.entityModels[
            0], this.contextData);

          let entityType = e.detail.response.content.entityModels[0] ? e.detail.response.content.entityModels[0].name :
            undefined;

          if (entityType) {
            this._relationshipModels = this._relationshipModels || {};
            this._relationshipModels[entityType] = DataTransformHelper.transformRelationshipModels(e.detail.response
              .content.entityModels[0], this.contextData);
          }

          if (this._currentIndex == 1) {
            this._currentItems = [];
          }

          this.push('_currentItems', attributeModels);

          if (this._currentItems.length == this._currentIndex) {
            let compositeModelsWithNestedAttrs = [];
            for (let i = 0; i < this._currentItems.length; i++) {
              let currentItem = this._currentItems[i];
              if (currentItem) {
                let keys = Object.keys(currentItem);
                if (keys && keys.length > 0) {
                  for (let j = 0; j < keys.length; j++) {
                    let key = keys[j];
                    if (!(compositeModelsWithNestedAttrs.find(obj => obj.name === key))) {
                      if (currentItem[key].dataType == "nested") {
                        let nestedAttributeItems = [];
                        nestedAttributeItems = DataHelper.getNestedAttributeItems(currentItem[key], true, true);
                        if (nestedAttributeItems.length > 0) {
                          compositeModelsWithNestedAttrs = compositeModelsWithNestedAttrs.concat(
                            nestedAttributeItems)
                        }
                      } else {
                        compositeModelsWithNestedAttrs.push(currentItem[key]);
                      }
                    }
                  }
                }
              }
            }
            //Delete the model only if source and destination type is not equal. Done for supporting
            //relationship from and to the same entity type.
            let relationshipName = this.searchFilters.relationshipName;
            if (relationshipName && !_.isEmpty(this._relToEntityTypes)) {
              if (relationshipName.indexOf("!%&") > -1) {
                 relationshipName = relationshipName.replace(/!%&/g, "");
              }
              let relModel = this._relationshipModels[this._relToEntityTypes[0]][relationshipName].find((relModel) => {
                return relModel.id === this.relationshipName;
              });
              if (relModel == undefined) {
                delete this._relationshipModels[this._relToEntityTypes[0]];
              } else {
                if (DataHelper.isValidObjectPath(relModel, 'properties.relatedEntityInfo.0.relEntityType') &&
                  relModel.properties.relatedEntityInfo[0].relEntityType != this._relToEntityTypes[0]) {
                  delete this._relationshipModels[this._relToEntityTypes[0]];
                }
              }
            }
            let attrsCriterion = this._prepareAttrsCriterion(compositeModelsWithNestedAttrs, this._entityAttributes);
            let relationshipsCriterion = this._prepareRelationshipsCriterion(this._relationshipModels, this._relationshipAttributes,
              this._relatedEntityAttributes, this._relToEntityTypes, compositeModelsWithNestedAttrs);
            this.searchFilters[this.filterCriterionKey] = !_.isEmpty(attrsCriterion) ? attrsCriterion : undefined;
            this.searchFilters["relationshipsCriterion"] = !_.isEmpty(relationshipsCriterion) ? [
              relationshipsCriterion
            ] : undefined;
            this.searchFilters["compositeModels"] = compositeModelsWithNestedAttrs;
            this.searchFilters["relationshipModels"] = this._mergeRelationships(this._relationshipModels);
            this.fireBedrockEvent('on-search-filters', this.searchFilters);
          }
        }
      }

      _prepareAttrsCriterion(attributeModels, attributes) {
        if (attributes && attributes.length > 0) {
          let prefix = /^\*/i;
          let suffix = /^.+\*$/gm;
          let selectedContext = ContextHelper.getDataContexts(this.contextData);
          for (let i = 0; i < attributes.length; i++) {
            let attribute = attributes[i];
            for (let attrName in attribute) {
              let attrModel = attributeModels.find(obj => obj.name === attrName);
              let attrVal = attribute[attrName];

              if (attrModel) {
                let displayType = attrModel.displayType.toLowerCase();
                let dataType = ConstantHelper.getDataTypeConstant(attrModel.dataType.toLowerCase());
                if (dataType === "_DECIMAL" || dataType === "_INTEGER") {
                  displayType = "numeric";
                }
                let keys = Object.keys(attrVal);
                let isPartialSearch = false;

                if (keys && keys.length > 0) {
                  for (let j = 0; j < keys.length; j++) {
                    let key = keys[j];
                    let val = attrVal[key];
                    let isPrefixed = prefix.test(val);
                    let isSuffixed = suffix.test(val);
                    if (isPrefixed || isSuffixed) {
                      isPartialSearch = true;
                    }

                    let operator;
                    let splitQueryByAnd = val.toLowerCase().split(' and ');
                    let splitQueryByOr = val.toLowerCase().split(' or ');
                    let containsStr = val;

                    if (splitQueryByAnd.length > 1) {
                      operator = "_AND";
                      containsStr = splitQueryByAnd;
                    } else if (splitQueryByOr.length > 1) {
                      operator = "_OR";
                      containsStr = splitQueryByOr;
                    }

                    if (containsStr instanceof Array) {
                      containsStr = containsStr.join(' ');
                    }

                    if (isPartialSearch) {
                      attrVal["contains"] = containsStr;
                      if (operator) attrVal["operator"] = operator;
                      delete attrVal[key];
                    } else {
                      if (val.indexOf("!%&") > -1) {
                        attrVal["hasvalue"] = val == "!%&has value!%&" ? true : false;
                        delete attrVal[key];
                      }else if (displayType === "path") {
                        if (key === "equals") {
                            attrVal["eq"] = '\"' + containsStr + '\"*';
                          }
                          delete attrVal[key];
                        }
                       else if (displayType === "referencelist" || displayType === "textbox" || displayType === "path") {
                        if (key === "equals") {
                          let valSplitByOr = val.split(' or ');
                          let valSplitByAnd = val.split(' and ');

                          if (valSplitByAnd.length > 1) {
                            attrVal["exacts"] = valSplitByAnd;
                            attrVal["operator"] = "_AND"
                          } else if (valSplitByOr.length > 1) {
                            attrVal["exacts"] = valSplitByOr;
                            attrVal["operator"] = "_OR"
                          } else {
                            attrVal["exact"] = containsStr;
                          }
                          delete attrVal[key];
                        }
                      } else if (displayType === "numeric") {
                        if (key === "equals") {
                          let valSplitByOr = val.split(' or ');
                          let valSplitByAnd = val.split(' and ');

                          if (valSplitByAnd.length > 1) {
                            attrVal["eq"] = valSplitByAnd;
                            attrVal["operator"] = "_AND"
                          } else if (valSplitByOr.length > 1) {
                            attrVal["eq"] = valSplitByOr;
                            attrVal["operator"] = "_OR"
                          } else {
                            attrVal["eq"] = containsStr;
                          }
                          delete attrVal[key];
                        }
                      } else if (displayType === "boolean") {
                        attrVal["eq"] = containsStr;
                        delete attrVal[key];
                      } else if (displayType === "richtexteditor") {
                        attrVal["contains"] = containsStr;
                        attrVal["operator"] = operator;
                        delete attrVal[key];
                      } else if (displayType === "datetime") {
                        if (key === "gte") {
                          attrVal[key] = moment(attrVal[key]).startOf("day").format(FormatHelper.getISODateTimeFormat());
                        } else if (key === "lte") {
                          attrVal[key] = moment(attrVal[key]).endOf("day").format(FormatHelper.getISODateTimeFormat());
                        } else if (key === "equals") {
                          attrVal["gte"] = moment(attrVal[key]).startOf("day").format(FormatHelper.getISODateTimeFormat());
                          attrVal["lte"] = moment(attrVal[key]).endOf("day").format(FormatHelper.getISODateTimeFormat());
                          delete attrVal[key];
                        }
                      } else if (displayType === "date") {
                        let isoFormatDate = moment(attrVal[key], "MM/DD/YYYY", true).format("YYYY-MM-DD");
                        if (key === "equals") {
                          attrVal["gte"] = isoFormatDate;
                          attrVal["lte"] = isoFormatDate;
                          delete attrVal[key];
                        } else {
                          attrVal[key] = isoFormatDate;
                        }
                      } else {
                        if (operator) {
                          attrVal["contains"] = containsStr;
                          attrVal["operator"] = operator;
                        } else {
                          attrVal["exact"] = containsStr;
                        }
                        delete attrVal[key];
                      }
                    }
                  }
                  attrVal["type"] = isPartialSearch ? "_STRING" : dataType;
                  let defaultValCtx = DataHelper.getDefaultValContext();
                  if (!attrModel.isLocalizable) {
                    attrVal["valueContexts"] = [defaultValCtx];
                  }
                }
              } else {
                //TODO: Need to change. 
                // Temperory fix. When search filters have context specific attribute and context is removed/changed
                // from dimension selector, we don't get model for that attribute.
                // request attributes criterion will go with empty object for this attribute, request throws error.
                // To handle this, when attribute model not found, sending it as contains search for that attribute
                if (attrVal["equals"]) {
                  attrVal["contains"] = attrVal["equals"];
                  attrVal["type"] = "_STRING";
                  delete attrVal["equals"];
                }
              }

              if (attrName.indexOf(".") > -1) {
                let attrLevels = attrName.split(".");
                let nestedAttributeObj = {};
                if (attrLevels.length > 0) {
                  for (let j = attrLevels.length; j > 0; j--) {
                    let keyIndex = j - 1;
                    let _currentLevel = attrLevels[keyIndex];
                    if (_.isEmpty(nestedAttributeObj)) {
                      let attrData = attrVal["contains"];
                      if (attrData && (attrData.indexOf("!%&") > -1)) {
                        attrVal = {};
                        attrVal["hasvalue"] = attrData == "!%&has value!%&" ? true : false;
                      }
                      nestedAttributeObj[_currentLevel] = attrVal;
                    } else {
                      nestedAttributeObj = {
                        "attributes": [nestedAttributeObj]
                      };
                      let clonedNestedAttribute = DataHelper.cloneObject(nestedAttributeObj);
                      nestedAttributeObj[_currentLevel] = clonedNestedAttribute;
                      if (nestedAttributeObj["attributes"] != undefined) {
                        delete nestedAttributeObj["attributes"];
                      }
                    }
                  }
                  attribute = nestedAttributeObj;
                }
              }

              attributes[i] = attribute;
            }
          }
        }
        return attributes;
      }

      _prepareRelationshipsCriterion(relationshipModels, relationshipAttributes, relatedEntityAttributes,
        relToEntityTypes, compositeModels) {
        let relType = this.searchFilters["relationshipName"];
        let relationshipsCriterion = {};
        let isNoRelationshipSearchRequest = undefined;

        if (relType) {
          let rel = undefined;
          if (relType.indexOf("!%&") > -1) {
            isNoRelationshipSearchRequest = true;
            relType = relType.replace(/!%&/g, "");
          }

          if (!_.isEmpty(relationshipModels)) {
            for (let entityType in relationshipModels) {
              if (relationshipModels[entityType] && relationshipModels[entityType][relType] && relationshipModels[
                  entityType][relType].length > 0) {

                rel = relationshipModels[entityType][relType].find((relModel) => {
                  return relModel.id === this.relationshipName;
                });
              }
            }
          }
          relationshipsCriterion[relType] = relationshipsCriterion[relType] || {};
          let relOwnership = rel && rel.properties ? rel.properties.relationshipOwnership : undefined;
          if (!_.isEmpty(relToEntityTypes)) {
            relationshipsCriterion[relType] = relationshipsCriterion[relType] || {};
            if (isNoRelationshipSearchRequest) {
              relationshipsCriterion[relType]["hasvalue"] = false;
            } else {
              relationshipsCriterion[relType]["relTo"] = {
                "type": relToEntityTypes[0]
              };
            }

            relationshipsCriterion[relType]["query"] = {
              "filters": {
                "typesCriterion": relToEntityTypes
              }
            };

            if (!_.isEmpty(relatedEntityAttributes)) {
              let relEntityAttrsCriterion = this._prepareAttrsCriterion(compositeModels, relatedEntityAttributes);

              relationshipsCriterion[relType].query.filters[this.filterCriterionKey] = relEntityAttrsCriterion;
            } else {
              if (relOwnership !== "whereused") {
                delete relationshipsCriterion[relType]["query"];
              }
            }
          }
          if (rel && rel.attributes) {
            let relData = {};
            relData.data = {};
            relData.data.attributes = rel.attributes;
            let relationshipAttrModels = DataTransformHelper.transformAttributeModels(relData, this.contextData);
            let keys = Object.keys(relationshipAttrModels);
            let relationshipAttributeModels = [];
            if (keys && keys.length > 0) {
              for (let i = 0; i < keys.length; i++) {
                relationshipAttributeModels.push(relationshipAttrModels[keys[i]]);
              }
            }
            let relationshipAttrsCriterion = this._prepareAttrsCriterion(relationshipAttributeModels,
              relationshipAttributes);
            relationshipsCriterion[relType] = relationshipsCriterion[relType] || {};
            relationshipsCriterion[relType]["attributes"] = relationshipAttrsCriterion;
          }
        }

        return relationshipsCriterion;
      }

      _getAttributeNames(attributes) {
        let attributeNames = [];
        for (let i = 0; i < attributes.length; i++) {
          let attribute = attributes[i];
          for (let attrName in attribute) {
            if (attrName.indexOf(".") > -1) {
              attrName = attrName.split(".")[0];
            }
            attributeNames.push(attrName);
          }
        }
        return attributeNames;
      }

      formatValue(value) {
        let valSplitByOr = value.split(' or ');
        let valSplitByAnd = value.split(' and ');

        let values = valSplitByAnd.length > 1 ? valSplitByAnd : valSplitByOr.length > 1 ? valSplitByOr : [];

        if (!_.isEmpty(values)) {
          for (let i = 0; i < values.length; i++) {
            values[i] = this._formatValue(values[i]);
          }

          value = valSplitByAnd.length > 1 ? values.join(' and ') : valSplitByOr.length > 1 ? values.join(' or ') :
            value;
        } else {
          value = this._formatValue(value);
        }

        return value;
      }

      _formatValue(value) {
        let prefix = /^\'|"/i;
        let suffix1 = /^.+\'$/gm;
        let suffix2 = /^.+\"$/gm;

        if (prefix.test(value)) {
          value = value.replace(/^.|$/g, '')
        }
        if (suffix1.test(value) || suffix2.test(value)) {
          value = value.replace(/^|.$/g, '')
        }

        return value;
      }

      _mergeRelationships(relationshipModels) {
        let mergedRelationships = {};
        Object.keys(relationshipModels).forEach(function (entityType) {
          mergedRelationships = DataMergeHelper.mergeRelationships(mergedRelationships, relationshipModels[
            entityType], true);
        });

        return mergedRelationships;
      }
    }
    customElements.define(RockSearchQueryParser.is, RockSearchQueryParser);
  </script>
</dom-module>