<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/adamantium-editor/adamantium-editor.html">

<link rel="import" href="../bedrock-validator/bedrock-validator.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<!--
`pebble-richtexteditor` Represents an element that allows plain-text editing with multiple lines.
 
@demo demo/index.html 
-->

<dom-module id="pebble-richtexteditor">
  <template>
        
    <style include="pebble-styles-shared">
      label {
        font-size:var(--default-font-size, 12px) !important;
        color:var(--input-label-color,#96b0c6);
        line-height: 17px;
        margin-top: 17px;
      } 
      #editorInput {
        cursor: auto;
      }   
      #viewBox {
        max-height: 25vh;
        overflow: scroll;
      }
      
    </style>
        
    <div hidden$="[[readOnly]]">
        <label hidden$="[[!label]]" aria-hidden="true">[[label]]</label>
        <adamantium-editor id="editorInput"></adamantium-editor>        
    </div> 
    <div hidden$="[[!readOnly]]">
      <label hidden$="[[!label]]" aria-hidden="true">[[label]]:</label>
      <div id="viewBox"></div>
    </div>
    <bedrock-validator show-error="[[showError]]" validation-errors="{{validationErrors}}" input="[[value]]" pattern="[[pattern]]" min-length="[[minlength]]" max-length="[[maxlength]]"  precision="[[precision]]" required="[[required]]"
                        invalid="{{invalid}}" error-message="{{errorMessage}}" min="[[min]]" max="[[max]]"  type="[[validationType]]" type-array="[[validationTypeArray]]"
    ></bedrock-validator>
  </template>

  <script>
   Polymer({
            is: 'pebble-richtexteditor',
            ready: function() {
                var target = this.$.editorInput.$.editorBody;
                var observer = new MutationObserver(function (mutations) {
                    this.debounce("hold for html", function () {           
                        this.value = target.innerHTML;                         
                    }.bind(this), 1000);
                }.bind(this));
                var config = { attributes: true, childList: true, characterData: true, subtree: true };
                observer.observe(target, config);
            },

            attached: function(){
              this.$.editorInput.$.bodyWordCount.setAttribute("style","display:none");
              
              if(this.readOnly) {
                this._setViewModeValue();
              } else {
                this._setInnerHtml();
              }
            },
            properties: { 
                /**
                * Indicates the label for the richtexteditor.
                * It allows to add descriptive text for the richtexteditor to inform the user about the type of data 
                * expected in the richtexteditor. 
                */
                label: {
                  type: String
                },
               
                /**
                * Indicates the html output from the richtexteditor.
                */
                value: {
                    type: String,
                    notify: true,
                    observer: '_setInnerHtml'
                },

                /**
                * Specifies whether or not the richtexteditor is non-editable. 
                * Set it to <b>true</b> to make the textbox read-only.
                */
                readOnly: {
                  type: Boolean,
                  value: false,                 
                  observer: '_onReadOnlySet'

                }
            },            
                   
            _onReadOnlySet: function() {
                if(this.readOnly == true){
                  this._setViewModeValue();
                   //this.$.editorInput.setAttribute("style", "pointer-events:none");
                } else {
                  this._setInnerHtml();
                   //this.$.editorInput.setAttribute("style", "pointer-events:auto");
                }   
                
            },
 
            _isEncoded: function(val) {
                var rHTMLEncoded = /&[^\s]*/;
                return rHTMLEncoded.test(val) ;
            },

            _decode: function(str) {
              return str.replace(/&#(\d+);/g, function(match, dec) {
                return String.fromCharCode(dec);
              });
            },
    
            _setInnerHtml: function(){               
              var editorBody = this.$.editorInput.$.editorBody;  

              //Return without doing anything for unchanged value
              if(this.value == editorBody.innerHTML) {
                return;
              }

              if(this.value == ""){
                editorBody.innerHTML = "";
              }          
                                   
              editorBody.innerHTML = this._getEncodedValue(this.value);
            },

            _setViewModeValue: function() {
              this.$.viewBox.innerHTML = this._getEncodedValue(this.value);
            },
 
            _getEncodedValue: function(pVal) {
              var val = pVal;
              if(this._isEncoded(val)) {
                  val = this._decode(val);  
              }
              return val;
            }
            
        });
  </script>

</dom-module>