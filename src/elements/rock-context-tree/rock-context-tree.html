<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-app-context-behavior/bedrock-app-context-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-styles-scroll-bar.html" />
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../../../src/elements/pebble-checkbox/pebble-checkbox.html">


<!--
`rock-context-tree` Represents a component that renders the list of contexts in a hierarchical tree format.

@demo demo/index.html
-->

<dom-module id="rock-context-tree">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            :host {
                display: block;
                height: 100%;
            }

            .contextTree {
                overflow-y: auto;
                overflow-x: hidden;
                height: 100%;
            }

            .search-container {
                position: relative;
                display: block;
                width: 100%;
                padding: 10px 10px 0 10px;
                margin-bottom: 5px;
            }

            .checkbox-label-color {
                --pebble-checkbox-label-color: #75808b;
            }

            .resetsearch {
                position: absolute;
                right: 10px;
                bottom: -12px;
                font-size: var(--font-size-xs, 10px);
                color: var(--link-text-color, #036Bc3);
            }
            .status-text{
                float: left;
                margin-left: 15px;
                font-weight: var(--font-medium);
            }

            .resetsearch pebble-button {
                height: auto;
                --pebble-button: {
                    font-size: var(--font-size-xs, 10px)!important;
                    height: auto;
                    padding-bottom: 0;
                }
                --pebble-icon-dimension: {
                    width: 12px;
                    height: 12px;
                }
                --pebble-button-left-icon: {
                    margin-right: 5px;
                }
            }
        </style>
        <div class="base-grid-structure">
            <div class="base-grid-structure-child-1">
                    <p class="status-text" hidden$=[[!showContextText]]>[[selectedContextText]]</p>
                <div class="search-container">

                    <template is="dom-if" if="{{_showSearchBar}}">
                        <rock-search-bar id="searchBar" placeholder="Enter Search text" hide-rbl="true"></rock-search-bar>
                        <div class="resetsearch" hidden$="[[!_resetSearchEnabled]]">
                            <pebble-button icon="pebble-icon:reset" class="btn-link pebble-icon-color-blue" on-tap="resetSearch" button-text="Reset Search"></pebble-button>
                        </div>
                    <bedrock-pubsub event-name="rock-search" handler="_onSearch" target-id="searchBar"></bedrock-pubsub>
                    </template>
                </div>
            </div>
            <div hidden$="[[_contextsDataFound]]" class="status-error">No Contexts Found</div>
            <div class="base-grid-structure-child-2">
                <pebble-tree id="contextTree" class="contextTree" data="{{contextsData}}" check-child-nodes="[[checkChildNodes]]"
                    default-child-depth="10" selected-items="{{selectedItems}}" selected-item="{{_selectedItem}}" multi-select="[[multiSelect]]"
                    disable-child-node="[[disableChildNode]]" check-parent-nodes="[[checkParentNodes]]" select-parent-item="[[selectParentItem]]" leaf-node-only="[[leafNodeOnly]]" show-warning-on-unselect="[[showWarningOnUnselect]]"></pebble-tree>
            </div>
        </div>
        <bedrock-pubsub event-name="tree-node-child-list-refreshed" handler="_childListRefreshed"></bedrock-pubsub>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
    <liquid-rest id="entityModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_entityModelRequest}}"
        on-liquid-response="_onEntityModelGetResponse" on-liquid-error="_onEntityModelGetError"></liquid-rest>
    </liquid-rest> 

    <liquid-entity-data-get id="initiateSearch" operation="initiatesearch" request-data="{{request}}" last-response="{{initiateSearchResponse}}"
    on-error="_onGetSearchError" on-response="_onInitiateSearchResponse" exclude-in-progress></liquid-entity-data-get>
<liquid-entity-data-get id="getSearchResultDetail" operation="getsearchresultdetail" request-data="{{request}}" request-id="[[initiateSearchResponse.content.requestId]]"
    last-response="{{getEntitySearchResultsResponse}}" on-error="_onGetSearchError" on-response="_onGetSearchResultDetailResponse"
    exclude-in-progress></liquid-entity-data-get>


    </template>
    <script>
        class RockContextTree extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior,RUFBehaviors.ComponentContextBehavior,RUFBehaviors.ComponentConfigBehavior], Polymer.OptionalMutableData(Polymer.Element)) {
            static get is() {
                return "rock-context-tree";
            }

            static get properties() {
                return {
                    request: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _isSearchMode: {
                        type: Boolean,
                        value: false
                    },

                    _loading: {
                        type: Boolean,
                        value: false
                    },

                    _showSearchBar: {
                        type: Boolean,
                        value: false
                    },

                    _contextsDataFound: {
                        type: Boolean,
                        value: true
                    },

                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _currentNode: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    rootNode: {
                        type: String
                    },

                    selectedContextsData: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },

                    selectedItems: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },

                    _selectedItem: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },

                    multiSelect: {
                        type: Boolean,
                        value: true
                    },

                    contextsData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _selectedContextsDataPath: {
                        type: Array
                    },

                    /**
                    * Specifies whether or not only leaf-node selection is enabled.
                    */
                    leafNodeOnly: {
                        type: Boolean,
                        value: false
                    },

                    hideLeafNodeCheckbox: {
                        type: Boolean,
                        value: false
                    },

                    enableNodeClick: {
                        type: Boolean,
                        value: false
                    },

                    _rootNodeGetRequest: {
                        type: Object
                    },

                    isModelTree: {
                        type: Boolean,
                        value: false
                    },

                    rootNodeData: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },
                    pathEntityType:{
                        type:String,
                        value:""
                    },
                    pathRelationshipName:{
                        type:String,
                        value:""
                    },
                    checkChildNodes:{
                        type:Boolean,
                        value:false
                    },
                    checkParentNodes: {
                        type: Boolean,
                        value: false
                    },
                    appName: {
                        type: String,
                        value: ""
                    },
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    readonly: {
                        type: Boolean,
                        value: false
                    },
                    request: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    showWarningOnUnselect:{
                        type:Boolean,
                        value:true

                    },
                    selectedContextText:{
                        type:String,
                        value:""
                    },
                    currentEntityContexts:{
                        type:Array,
                        value:[]
                    },
                    selectParentItem:{
                        type: Boolean,
                        value:true
                    },
                    _reqData:{
                        type:Object,
                        value:{}
                    },
                    showContextText:{
                        type:Boolean,
                        value:false
                    },
                    contextTypes:{
                        type:Array,
                        value:[]
                    },
                    elementInfo:{
                        type:Array,
                        value:[]
                    }

                }
            }
            static get observers() {
                return [
                    '_onSelectedItemsChange(selectedItems.*, _selectedItem)'
                ];
            }

            constructor() {
                super();
            }

            ready() {
                super.ready();
            }

            connectedCallback() {
                super.connectedCallback();

                this.addEventListener("tree-node-expanded", this._treeNodeExpanded);
                this.addEventListener("tree-node-clicked", this._treeNodeClicked);
            }

            disconnectedCallback() {
                super.disconnectedCallback();

                this.removeEventListener("tree-node-expanded", this._treeNodeExpanded);
                this.removeEventListener("tree-node-clicked", this._treeNodeClicked);
            }

            _onSearch(e) {
                this._searchClicked = true;
                this._isSearchMode = !_.isEmpty(e.detail.query);
                this.executeRequest(e.detail.query);
            }

            resetSearch() {
                this._isSearchMode = false;
                this.executeRequest("");
                this._searchBarElement = this.shadowRoot.querySelector("#searchBar");
                this._searchBarElement.clear();
                this._searchBarElement.$.input.value = "";
            }

            _onSelectedItemsChange(selectedItems, _selectedItem) {
                //Set the output
                if (selectedItems != undefined || _selectedItem != undefined) {
                    if (this.multiSelect) {
                        this.selectedContextsData = this.selectedItems;
                    } else {
                        this.selectedContextsData = [this._selectedItem];
                    }
                    let contextsCount = 0;
                    let newContextsCount = 0;
                    let removedContextsCount = 0;

                    let itemExistCount = 0;
                    let selectedItems = this.selectedItems;
                    let preSelectedItems = this.currentEntityContexts;
                    for(let i = 0;i<selectedItems.length;i++){
                        let valuePath = selectedItems[i].valuePath;
                        if(preSelectedItems.indexOf(valuePath) == -1){
                            newContextsCount++; 
                        }else{
                            itemExistCount++; 
                        }
                    }
                    removedContextsCount = (preSelectedItems.length-itemExistCount);
                    let _selectedContextText = this.selectedItems.length + " contexts selected";
                    if(newContextsCount > 0){
                        _selectedContextText += " ( " + newContextsCount + " new )"
                    }
                    if(removedContextsCount > 0){
                        _selectedContextText += " ( " + removedContextsCount + " removed )"
                    } 
                    this.selectedContextText = _selectedContextText;
                }
            }

            _clearSelectedItems() {
                this.selectedItems = [];
            }

            reloadTree() {
                let domainContexts = ContextHelper.getDomainContexts(this.contextData);
                let domain = domainContexts[0]["domain"];
                if (!_.isEmpty(domain)) {
                    if(_.isEmpty(this.appName)){
                        this.appName = ComponentHelper.getCurrentActiveAppName();
                    }
                    this._processContextModel(domain)
                }
            }

            async _processContextModel(domain) {
                let entityContextModel = await ContextModelManager.getByDomain(domain);
                if(entityContextModel) {
                    let contexts = "data" in entityContextModel ? entityContextModel.data.contexts : undefined;
                    let _ctxKeys = [];

                    this._contextHierarchyInfo = DataHelper.isValidObjectPath(entityContextModel, "properties.coalesceInfo") && entityContextModel.properties.coalesceInfo;

                    if (!_.isEmpty(this._contextHierarchyInfo)) {
                        this._contextHierarchyInfo.sort(function(a,b) {
                            if(a.sequence && b.sequence) {
                                return a.sequence - b.sequence;
                            }
                        });
                        this.elementInfo["nonRootContextKey"] = [];
                        this._contextHierarchyInfo.forEach(function(ctx) {
                            if(ctx.contextKey){
                                this.contextTypes.push(ctx.contextKey)
                                if(ctx.parentContextKey){
                                    this.elementInfo["dependencyRelationship"] =  ctx.contextRelationship
                                    this.elementInfo["nonRootContextKey"].push(ctx.contextKey);
                                }else{
                                    this.elementInfo["rootContextKey"] = ctx.contextKey
                                }
                            }
                        }, this);
                    }
                    let ctxIds = [];
                    if(!_.isEmpty(this.contextTypes)){
                        this.contextTypes.forEach(function(type) {
                            ctxIds.push(type + "_entityManageModel");
                        });
                    }
                    if (ctxIds && ctxIds.length) {
                        this._entityModelRequest = {
                            "params": {
                                "query": {
                                    "ids": ctxIds,
                                    "filters": {
                                        "typesCriterion": [
                                            "entityManageModel"
                                        ]
                                    }
                                },
                                "fields": {
                                    "attributes": [
                                        "_ALL"
                                    ],
                                    "relationships": [
                                        "_ALL"
                                    ],
                                    "relationshipAttributes": [
                                        "_ALL"
                                    ]
                                }
                            }
                        };

                        let entityModelGetComponent = this.$$("#entityModelGet");

                        if (entityModelGetComponent) {
                            entityModelGetComponent.generateRequest();
                        } else {
                            this.logError(this.appName + "-Context Selector - Entity model get liquid not found");
                        }
                    }
                } else {
                    this.logError(this.appName + "-Context Selector - There are no context models available for domain " + domain, {}, true);
                }
            }

            _onEntityModelGetResponse(e) {
                let response = e.detail.response.response;
                if (response && !_.isEmpty(response.entityModels)) {
                    this._prepareDynamicConfigBasedOnModelForContextsTreeToBeRendered(response.entityModels);
                } else {
                    this.logError(this.appName + "-Context Selector - Entity Model get response exception", e.detail, true);
                }
            }
            
            _prepareDynamicConfigBasedOnModelForContextsTreeToBeRendered(entityModels) {
                if (entityModels && entityModels.length) {
                    let types = this.contextTypes;
                    let requireAttribute = [];
                    entityModels.forEach((entityModel) => {
                        let externalAttrName = undefined;
                        let externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);
                        if (externalNameAndExternalNameAttr) {
                            externalAttrName = externalNameAndExternalNameAttr.externalNameAttr;
                            this.elementInfo.push({
                                "name":entityModel.name,
                                "externalAttrName":externalAttrName
                            })
                            if(requireAttribute.indexOf(externalAttrName) == -1){
                                requireAttribute.push(externalAttrName);
                            }
                        }
                    })
                    let reqData = {
                        "params": {
                            "query": {
                                "filters": {
                                    "typesCriterion": types
                                },
                                "valueContexts": []
                            },
                            "fields": {
                                "attributes": requireAttribute
                            }
                        }
                    };
                    reqData.params.query.valueContexts.push(DataHelper.getDefaultValContext());
                    reqData.params.fields.relationships = [this.elementInfo["dependencyRelationship"]];
                    this._selectedContextsDataPath = this.selectedContextsData;
                    this.selectedContextsData = [];
                    this._reqData = reqData;
                    this.executeRequest()
                }
            }

            executeRequest(searchKeyword) {
                let req = DataHelper.cloneObject(this._reqData);
                if (searchKeyword) {
                    req.params.query.filters.keywordsCriterion = { "operator": "_AND", "keywords": searchKeyword };
                }
                this.set('request', req);
                this.shadowRoot.querySelector("#initiateSearch").generateRequest();
            }

            _onInitiateSearchResponse(e) {
                this._currentRecord = 0;
                this._totalRecords = this.initiateSearchResponse.content.totalRecords;
                this._contextsDataList = [];
                this._currentNode = {};
                this._contextsDataIndex = 0;
                this._currentIndex = 0;
                this._makeNextBatchSearchDetailCall();
            }

            _makeNextBatchSearchDetailCall() {
                let start = this._currentRecord;
                let end = this._currentRecord + 200;
                if (start > this._totalRecords) {
                    return;
                }
                if (end > this._totalRecords) {
                    end = this._totalRecords;
                }
                let getDetailOptions = { 'from': start, 'to': end };
                this.set('request.params.options', getDetailOptions);
                let liqGetSearchResultDetail = this.shadowRoot.querySelector('#getSearchResultDetail');
                liqGetSearchResultDetail.generateRequest();
            }

            _onGetSearchResultDetailResponse(e) {
                this._showSearchBar = true;
                let res = e.detail.response;
                let contextsData = res.content.entities;
                this._contextsDataFound = true;
                if (this._searchClicked && _.isEmpty(contextsData)) {
                    this._contextsDataFound = false;
                }
                let rootContextKey = this.elementInfo["rootContextKey"];
                let nonRootContextKey = this.elementInfo["nonRootContextKey"];
                let rootContextExternalAttrName = this.elementInfo.filter(elem =>{
                    if(elem.name == rootContextKey){
                        return elem.externalAttrName;
                    }
                })
                let nonRootContextExternalAttrName = this.elementInfo.filter(elem =>{
                    if(elem.name == nonRootContextKey){
                        return elem.externalAttrName;
                    }
                })

                let rootContextLists = contextsData.filter((rootContext) =>{
                    if(rootContext.type == rootContextKey){
                        let externalNameAttr = EntityHelper.getAttribute(rootContext, rootContextExternalAttrName);
                        let externamName = AttributeHelper.getFirstAttributeValue(externalNameAttr);
                        rootContext.text = (externamName || rootContext.name) + " (" + rootContext.type + ")"
                        rootContext.value = rootContext.name;
                        return rootContext;
                    }
                })
                let nonRootContextLists = contextsData.filter((nonRootContext) =>{
                    if(nonRootContextKey.indexOf(nonRootContext.type) > -1){
                        //If any non-root context node does not have any relationship,than that node should not appear in tree.
                        if(DataHelper.isValidObjectPath(nonRootContext, "data.relationships") && !_.isEmpty(nonRootContext.data.relationships)){
                            let externalNameAttr = EntityHelper.getAttribute(nonRootContext, nonRootContextExternalAttrName);
                            let externamName = AttributeHelper.getFirstAttributeValue(externalNameAttr);
                            nonRootContext.text = (externamName || nonRootContext.name) + " (" + nonRootContext.type + ")"
                            nonRootContext.value = nonRootContext.name;
                            return nonRootContext;
                        }
                    }
                })
                for (let rootIndex in rootContextLists) {
                    let currentRootContext = rootContextLists[rootIndex];
                    let currentRootContextId = currentRootContext.id;
                    let currentRootContextName = currentRootContext.name;
                    let filteredNonRootContext = nonRootContextLists.filter((nonRootContext) => {
                        let currentNonRootContextName = nonRootContext.name
                        if(DataHelper.isValidObjectPath(nonRootContext, "data.relationships")){
                            let NonRootContextRelationships = nonRootContext.data.relationships[this.elementInfo["dependencyRelationship"]];
                                if(NonRootContextRelationships.length > 0){
                                    for (let relIndex in NonRootContextRelationships) {
                                        let currentRelationshipId = NonRootContextRelationships[relIndex].id;
                                        if(currentRelationshipId == currentRootContextId){
                                            this._selectedContextsDataPath.forEach((selectedContext) => {
                                                if(selectedContext[0].indexOf(currentNonRootContextName) > -1){
                                                    selectedContext.unshift(currentRootContextName)
                                                }
                                            })
                                            return nonRootContext;
                                        };
                                    }
                                }
                        }
                    });
                    
                    if(filteredNonRootContext.length > 0){
                        currentRootContext.children = filteredNonRootContext;
                    }
                }
                let _currentEntityContexts = [];
                this._selectedContextsDataPath.forEach((path) =>{
                    _currentEntityContexts.push(path.join("#@#"))
                })
                this.currentEntityContexts = undefined;
                this.currentEntityContexts = _currentEntityContexts;

                this._contextsDataList = this._contextsDataList.concat(rootContextLists);

                this._currentRecord += 200;
                if (this._currentRecord < this._totalRecords) {
                    this._makeNextBatchSearchDetailCall();
                } else {
                    this._contextsDataList.sort(function (a, b) { return (a.text > b.text) ? 1 : ((b.text > a.text) ? -1 : 0); });
                    if (!this._currentNode || _.isEmpty(this._currentNode)) {
                        if (this.isModelTree && this.rootNodeData && !_.isEmpty(this.rootNodeData)) {
                            this.rootNodeData.children = this._contextsDataList;
                            this.contextsData = [this.rootNodeData];
                        } else {
                            this.contextsData = this._contextsDataList;
                        }
                        this._checkForSelectedContext();
                    }
                }
                this._searchClicked = false;
                // if(!this._isSearchMode){
                    this.showContextText = true;
            }

            //If _selectedCOntextsPaths available, then only pre selection process triggers
            _checkForSelectedContext() {
                if (this.contextsData.length == 0 || !this._selectedContextsDataPath || !this._selectedContextsDataPath.length || this._contextsDataIndex == this._selectedContextsDataPath.length) {
                    return;
                }
                if (!this._currentContext) {
                    this._contextsDataIndex = 0;
                    this._currentIndex = 0;
                }
                this._currentContext = this._selectedContextsDataPath[this._contextsDataIndex];
                let name = this._currentContext[this._currentIndex];
                if (this._currentIndex == 0) {
                    this._currentNode = this.shadowRoot.querySelector("#contextTree").getElementNodeByPath(name);
                } else if (this._currentIndex == this._currentContext.length) {
                    this._currentNode.selectItem();
                    this._contextsDataIndex++;
                    this._currentIndex = 0;
                    this._checkForSelectedContext();
                    return;
                } else {
                    let childNodes = this._currentNode.getChildNodes();
                    let matchedChild;
                    for (let i in childNodes) {
                        if (childNodes[i].nodeData.value == name) {
                            matchedChild = childNodes[i];
                            break;
                        }
                    }
                    if (matchedChild) {
                        this._currentNode = matchedChild;
                    } else {
                        this._contextsDataIndex++;
                        this._currentIndex = 0;
                        this._checkForSelectedContext();
                        return;
                    }
                }
                this._currentIndex++;
                if (this._currentNode) {
                    if (this._currentNode.expanded) {
                        this._checkForSelectedContext();
                    } else {
                        this._currentNode.expand();
                    }
                }
            }

            _treeNodeExpanded(e) {
                 this._currentNode = e.detail;
                if (!this._currentNode.nodeData.children || this._currentNode.nodeData.children.length == 0) {
                    this._currentNode.changeToLeafMode();
                }
                this._currentNode.refreshChildList();
                
            }

            _treeNodeClicked(ev) {
            }

            _childListRefreshed() {
                this._checkForSelectedContext();
            }
        }

        customElements.define(RockContextTree.is, RockContextTree);
    </script>
</dom-module>
