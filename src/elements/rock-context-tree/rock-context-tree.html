<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-app-context-behavior/bedrock-app-context-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-scroll-bar.html" />
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../../../src/elements/pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-icons.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-grid-layout.html">


<!--
`rock-context-tree` Represents a component that renders the list of contexts in a hierarchical tree format.

@demo demo/index.html
-->

<dom-module id="rock-context-tree">
    <template>
        <style include="bedrock-style-common bedrock-style-scroll-bar bedrock-style-grid-layout bedrock-style-icons">
            :host {
                display: block;
                height: 100%;
            }

            .contextTree {
                overflow-y: auto;
                overflow-x: hidden;
                height: 100%;
            }

            .search-container {
                position: relative;
                display: block;
                width: 100%;
                padding: 10px 10px 0 10px;
                margin-bottom: 5px;
            }

            .checkbox-label-color {
                --pebble-checkbox-label-color: #75808b;
            }

            .resetsearch {
                position: absolute;
                right: 10px;
                bottom: -12px;
                font-size: var(--font-size-xs, 10px);
                color: var(--link-text-color, #036Bc3);
            }

            .status-error {
                color: var(--palette-pinkish-red);
            }

            .status-text {
                float: left;
                font-size: var(--font-size-sm);
                margin-left: 15px;
                font-weight: var(--font-medium);
            }

            .resetsearch pebble-button {
                height: auto;

                --pebble-button: {
                    font-size: var(--font-size-xs, 10px) !important;
                    height: auto;
                    padding-bottom: 0;
                }

                --pebble-icon-dimension: {
                    width: 12px;
                    height: 12px;
                }

                --pebble-button-left-icon: {
                    margin-right: 5px;
                }
            }
        </style>
        <div class="base-grid-structure">
            <div class="base-grid-structure-child-1">
                <div class="search-container">
                    <rock-search-bar id="searchBar" placeholder="Enter Search text" hide-rbl="true"></rock-search-bar>
                    <div class="resetsearch" hidden$="[[!_resetSearchEnabled]]">
                        <pebble-button icon="pebble-icon:reset" class="btn-link pebble-icon-color-blue" on-tap="resetSearch" button-text="Reset Search"></pebble-button>
                    </div>
                    <bedrock-pubsub event-name="rock-search" handler="_onSearch" target-id="searchBar"></bedrock-pubsub>
                </div>
                <p class="status-text" hidden$=[[!showContextText]]>[[selectedContextText]]</p>
            </div>
            <div hidden$="[[_contextsDataFound]]" class="status-error">No Contexts Found</div>
            <div class="base-grid-structure-child-2">
                <pebble-tree id="contextTree" class="contextTree" data="{{contextsData}}" check-child-nodes="[[checkChildNodes]]" default-child-depth="10" selected-items="{{selectedItems}}" selected-item="{{_selectedItem}}" multi-select="[[multiSelect]]" disable-child-node="[[disableChildNode]]" check-parent-nodes="[[checkParentNodes]]" select-parent-item="[[selectParentItem]]" leaf-node-only="[[leafNodeOnly]]" show-warning-on-unselect="[[showWarningOnUnselect]]"></pebble-tree>
            </div>
        </div>
        <bedrock-pubsub event-name="tree-node-selected" handler="_onContextItemSelected"></bedrock-pubsub>
        <bedrock-pubsub event-name="tree-node-de-selected" handler="_onContextItemDeSelected"></bedrock-pubsub>
        <pebble-spinner active="[[loading]]"></pebble-spinner>
        <liquid-entity-model-get id="entityModelGet" operation="getbyids" request-data="{{_entityModelRequest}}" on-liquid-response="_onEntityModelGetResponse" on-liquid-error="_onEntityModelGetError"></liquid-entity-model-get>
        </liquid-rest>
        <liquid-entity-data-get id="initGetEntitySearch" operation="initiatesearch" on-response="_initContextSearchResponse" on-error="_onGetSearchError" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-data-get id="getEntitySearchResults" operation="getsearchresultdetail" on-response="_getContextSearchResultResponse" on-error="_onGetSearchError" exclude-in-progress include-type-external-name></liquid-entity-data-get>
        <liquid-entity-data-get id="relatedEntityGet" operation="getbyids" on-response="_getRelatedEntitiesResponse" on-error="_onGetRelatedEntitiesError" exclude-in-progress include-type-external-name></liquid-entity-data-get>
    </template>
    <script>
        class RockContextTree extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior, RUFBehaviors.ComponentContextBehavior, RUFBehaviors.ComponentConfigBehavior], Polymer.OptionalMutableData(Polymer.Element)) {
            static get is() {
                return "rock-context-tree";
            }

            static get properties() {
                return {
                    _isSearchMode: {
                        type: Boolean,
                        value: false
                    },

                    loading: {
                        type: Boolean,
                        value: false
                    },

                    _contextsDataFound: {
                        type: Boolean,
                        value: true
                    },

                    selectedContextsData: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },

                    selectedItems: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },

                    _selectedItem: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },

                    multiSelect: {
                        type: Boolean,
                        value: true
                    },

                    contextsData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    entityCurrentContexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    /**
                    * Specifies whether or not only leaf-node selection is enabled.
                    */
                    leafNodeOnly: {
                        type: Boolean,
                        value: false
                    },
                    checkChildNodes: {
                        type: Boolean,
                        value: false
                    },
                    checkParentNodes: {
                        type: Boolean,
                        value: false
                    },
                    appName: {
                        type: String,
                        value: ""
                    },
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    showWarningOnUnselect: {
                        type: Boolean,
                        value: true
                    },
                    selectedContextText: {
                        type: String,
                        value: ""
                    },
                    currentEntityContexts: {
                        type: Array,
                        value: []
                    },
                    selectParentItem: {
                        type: Boolean,
                        value: true
                    },
                    showContextText: {
                        type: Boolean,
                        value: false
                    },
                    contextTypes: {
                        type: Array,
                        value: []
                    },
                    _contextHierarchy: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    }
                }
            }
            static get observers() {
                return [
                    '_onSelectedItemsChange(selectedItems.*, _selectedItem)'
                ];
            }

            constructor() {
                super();
            }

            connectedCallback() {
                super.connectedCallback();

                this.addEventListener("tree-node-expanded", this._treeNodeExpanded);
            }

            disconnectedCallback() {
                super.disconnectedCallback();

                this.removeEventListener("tree-node-expanded", this._treeNodeExpanded);
            }

            _onSearch(e) {
                this._searchClicked = true;
                this._isSearchMode = !_.isEmpty(e.detail.query);
                this.loading= true;
                this.executeRequest("", e.detail.query);
            }

            get contextTree() {
                this._contextTree = this._contextTree || this.shadowRoot.querySelector("#contextTree");
                return this._contextTree;
            }

            resetSearch() {
                this._isSearchMode = false;
                this._clearSelectedItems();
                this.loading= true;
                this.executeRequest("");
                this._searchBarElement = this.shadowRoot.querySelector("#searchBar");
                this._searchBarElement.clear();
                this._searchBarElement.$.input.value = "";
            }

            _onSelectedItemsChange(selectedItems, _selectedItem) {
                //Set the output
                if (selectedItems != undefined || _selectedItem != undefined) {
                    let currentSelectedItems = _.uniq(this.selectedItems, function(item, key, id) {
                        return item.id;
                    });
                    if (this.multiSelect) {
                        this.selectedContextsData = DataHelper.cloneObject(currentSelectedItems);
                    } else {
                        this.selectedContextsData = !_.isEmpty(this._selectedItem) ? [this._selectedItem] : [];
                    }
                    let contextsCount = 0;
                    let newContextsCount = 0;
                    let removedContextsCount = 0;

                    let itemExistCount = 0;
                    
                    let preSelectedItems = this.currentEntityContexts;
                    for (let i = 0; i < currentSelectedItems.length; i++) {
                        let value = currentSelectedItems[i].value;
                        if (preSelectedItems.indexOf(value) == -1) {
                            newContextsCount++;
                        } else {
                            itemExistCount++;
                        }
                    }
                    removedContextsCount = (preSelectedItems.length - itemExistCount);
                    let _selectedContextText = currentSelectedItems.length + " contexts selected";
                    if (newContextsCount > 0) {
                        _selectedContextText += " ( " + newContextsCount + " new )"
                    }
                    if (removedContextsCount > 0) {
                        _selectedContextText += " ( " + removedContextsCount + " removed )"
                    }
                    this.selectedContextText = _selectedContextText;
                }
            }

            _clearSelectedItems() {
                this.selectedItems = [];
            }

            async reloadTree() {
                this.loading = true;
                this.currentEntityContexts = [];
                let domain = "";
                let domainContext = ContextHelper.getFirstDomainContext(this.contextData);
                if (domainContext) {
                    domain = domainContext.domain;
                } else {
                    let itemContext = ContextHelper.getFirstItemContext(this.contextData);
                    let entityTypeManager = EntityTypeManager.getInstance();
                    if (entityTypeManager && itemContext) {
                        domain = await entityTypeManager.getDomainByType(itemContext.type);
                    }
                }

                if (!_.isEmpty(domain)) {
                    if (_.isEmpty(this.appName)) {
                        this.appName = ComponentHelper.getCurrentActiveAppName();
                    }
                    this._processContextModel(domain)
                }
            }

            async _processContextModel(domain) {
                let _ctxKeys = [];

                let contextHierarchyInfo = await ContextModelManager.getContextHeirarchyInfoBasedOnDomain(domain);
                this.contextTypes = await ContextModelManager.getContextTypesBasedOnDomain(domain);
                let contextHierarchy = {};
                if (!_.isEmpty(this.contextTypes)) {
                    this.contextTypes.forEach(function (type) {
                        let ctxObj = contextHierarchyInfo.find(obj => obj.contextKey === type);
                        if (ctxObj) {
                            contextHierarchy[type] = ctxObj;
                            let childCtxObjects = contextHierarchyInfo.filter(obj => obj.parentContextKey === type);

                            if(!_.isEmpty(childCtxObjects)) {
                                ctxObj.childCtxObjects = childCtxObjects;
                            }
                        }
                    }, this);

                    this.set("_contextHierarchy", contextHierarchy);

                    this._entityModelRequest = DataRequestHelper.createGetManageModelRequest(this.contextTypes);

                    let entityModelGetComponent = this.$$("#entityModelGet");

                    if (entityModelGetComponent) {
                        entityModelGetComponent.generateRequest();
                    } else {
                        this.logError(this.appName + "-Context Selector - Entity model get liquid not found");
                    }
                } else {
                    this.logError(this.appName + "-Context Selector - There are no context types available for domain " + domain, {}, true);
                }
            }

            _onEntityModelGetResponse(e) {
                if (DataHelper.isValidObjectPath(e, "detail.response.content.entityModels")) {
                    this._prepareDynamicConfigBasedOnModelForContextsTreeToBeRendered(e.detail.response.content.entityModels);
                } else {
                    this.logError(this.appName + "-Context Selector - Entity Model get response exception", e.detail, true);
                }
            }

            _prepareDynamicConfigBasedOnModelForContextsTreeToBeRendered(entityModels) {
                if (entityModels && entityModels.length) {
                    let modelsData = {};
                    entityModels.forEach((entityModel) => {
                        let externalAttrName = undefined;
                        let externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);
                        let ctxKey = entityModel.id.replace("_entityManageModel", "");
                        modelsData[ctxKey] = {};
                        if (externalNameAndExternalNameAttr) {
                            externalAttrName = externalNameAndExternalNameAttr.externalNameAttr;
                            modelsData[ctxKey]["externalAttrName"] = externalAttrName;
                        }
                    }, this);

                    this.set("_modelsData", modelsData);
                    this.executeRequest()
                }
            }

            _getParentContextTypes() {
                let contextTypes = [];
                if(!_.isEmpty(this._contextHierarchy)) {
                    for(let entityType in this._contextHierarchy) {
                        if(_.isEmpty(this._contextHierarchy[entityType].parentContextKey)) {
                            contextTypes.push(entityType);
                        }
                    }
                }

                return contextTypes;
            }

            executeRequest(parentNode, searchKeyword) {
                let types = [];
                let relationshipsCriterion = [];
                let parentContextData = parentNode ? parentNode.nodeData : undefined;
                if(!_.isEmpty(parentContextData)) {
                    let ctxObj = this._contextHierarchy[parentContextData.type];
                    let childCtxObjects = ctxObj ? ctxObj.childCtxObjects : undefined;
                    if(childCtxObjects) {
                        childCtxObjects.forEach(function(childCtxObj) {
                            types.push(childCtxObj.contextKey);
                            let relType = childCtxObj.contextRelationship;
                            let relCriterion = {};
                            relCriterion[relType] = {"relTo": { "id": parentContextData.id, "type": parentContextData.type } };
                            relationshipsCriterion.push(relCriterion);
                        }, this);
                    }
                } else {
                    types = this._getParentContextTypes();
                }

                if(_.isEmpty(types) && !_.isEmpty(parentNode)) {
                    parentNode.changeToLeafMode();
                    parentNode.set('nodeData.children', []);
                    parentNode.refreshChildList();
                    this.loading = false;
                    return;
                }
                let contextData = DataHelper.cloneObject(this.contextData);
                let attributeNames = [];
                let relationships = [];
                if(searchKeyword) {
                    types = this.contextTypes;
                }
                types.forEach(function(type) {
                    attributeNames.push(this._modelsData[type].externalAttrName);
                    let ctxObj = this._contextHierarchy[type];
                    let relName = ctxObj ? ctxObj.contextRelationship : undefined;
                    if(relName) {
                        relationships.push(relName);
                    }
                }, this);
                let itemContext = { "attributeNames": attributeNames, "type": types, "relationships": relationships };
                if(!_.isEmpty(relationshipsCriterion)) {
                    itemContext.relationshipsCriterion = relationshipsCriterion;
                }
                if (searchKeyword) {	
                    delete itemContext.relationshipsCriterion;	
                }

                contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
                contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                let req = DataRequestHelper.createEntityGetRequest(contextData);

                if (searchKeyword) {
                    req.params.query.filters.keywordsCriterion = { "operator": "_AND", "keywords": searchKeyword };
                }

                let initGetEntitySearchLiquid = this.shadowRoot.querySelector("#initGetEntitySearch");

                if (initGetEntitySearchLiquid) {
                    initGetEntitySearchLiquid.requestData = req;
                    initGetEntitySearchLiquid.generateRequest();
                }
            }

            _initContextSearchResponse(e) {
                if (DataHelper.isValidObjectPath(e, "detail.response.content.requestId")) {
                    let getEntitySearchResultsLiquid = this.shadowRoot.querySelector("#getEntitySearchResults");
                
                    if (getEntitySearchResultsLiquid) {
                        getEntitySearchResultsLiquid.requestId = e.detail.response.content.requestId;
                        getEntitySearchResultsLiquid.requestData = e.detail.request.requestData;
                        getEntitySearchResultsLiquid.generateRequest();
                    }
                }
            };

            _onEntityInitSearchError(e) {
                console.logError('Context initiate search failed', e.detail);
            }

            _getContextSearchResultResponse(e) {
                let currentNode;
                if(DataHelper.isValidObjectPath(e, "detail.request.requestData.params.query.filters.relationshipsCriterion.0")) {
                    let relationshipCriterion = e.detail.request.requestData.params.query.filters.relationshipsCriterion[0];
                    currentNode = this._getCurrentNode(relationshipCriterion);
                }
                if (DataHelper.isValidObjectPath(e, "detail.response.content.entities")) {
                    let entities = e.detail.response.content.entities;
                    if(!_.isEmpty(entities)) {
                        this._contextsDataFound = true;
                        let allNodes = this._transformEntitiesToNodes(entities);
                        allNodes.sort(function (a, b) { return (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : 0); });

                        if(this._isSearchMode && DataHelper.isValidObjectPath(e, "detail.request.requestData.params.query.filters.keywordsCriterion.keywords")) {
                            let searchText = e.detail.request.requestData.params.query.filters.keywordsCriterion.keywords;
                            this._filterNodesBasedOnKeyword(searchText, allNodes);
                        }

                        this._selectedDataContexts = [];
                        if(currentNode) {
                            if (!allNodes.length) {
                                currentNode.changeToLeafMode();
                            }

                            allNodes.forEach(function(node) {
                                let existingNode = this.contextsData.find(obj => obj.id === node.id);
                                if(existingNode) {
                                    let index = this.contextsData.indexOf(existingNode);
                                    this.splice('contextsData', index, 1);
                                }
                                let existingSelectedItem = this.selectedItems.find(obj => obj.id === node.id);
                                if(existingSelectedItem) {
                                    let index = this.selectedItems.indexOf(existingSelectedItem);
                                    this.splice('selectedItems', index, 1);
                                }
                                this.entityCurrentContexts.forEach((selectedContext) => {
                                    if (selectedContext && selectedContext[0] === node.name) {
                                        let selectedCtx = DataHelper.cloneObject(selectedContext);
                                        selectedCtx.unshift(currentNode.nodeData.name);
                                        this._selectedDataContexts.push(selectedCtx);
                                    }
                                })
                            }, this);

                            if(this._isSearchMode) {
                                this.contextTree.refreshTree();
                            }

                            currentNode.set('nodeData.children', allNodes);
                            currentNode.refreshChildList();
                        } else {
                            allNodes.forEach(function(node) {
                                this.entityCurrentContexts.forEach((selectedContext) => {
                                    if (selectedContext && selectedContext[0] === node.name) {
                                        this._selectedDataContexts.push(selectedContext);
                                    }
                                })
                            }, this);
                            this.contextsData = allNodes;
                            if(this._isSearchMode) {
                                this._expandAllNodes(allNodes);
                            }
                        }

                        this.currentEntityContexts = this.currentEntityContexts || [];
                        this._selectedDataContexts.forEach((contexts) => {
                            contexts.forEach((context) => {
                                if(this.currentEntityContexts.indexOf(context) < 0) {
                                    this.currentEntityContexts.push(context);
                                }
                            }, this);
                        }, this);

                        this.loading = false;

                        this._checkForSelectedContext();

                        this._searchClicked = false;
                        this.showContextText = true;

                        return;
                    } else {
                        if(currentNode) {
                            currentNode.changeToLeafMode();
                            currentNode.set('nodeData.children', []);
                            currentNode.refreshChildList();
                            this.loading = false;
                            return;
                        }
                    }
                }

                this.contextsData = [];
                this.loading = false;
                this.showContextText = false;
                this._contextsDataFound = false;
            }

            _onSearchResultError(e) {
                console.logError('Context search result get failed', e.detail);
            }

            _getCurrentNode(relationshipCriterion) {
                let currentNode;
                let rel = Object.keys(relationshipCriterion)[0];
                let currentNodeId;
                if(DataHelper.isValidObjectPath(relationshipCriterion[rel], "relTo.id")) {
                    currentNodeId = relationshipCriterion[rel].relTo.id;
                }
                if(currentNodeId) {
                    currentNode = this.contextTree.getElementNodeById(currentNodeId);
                }

                return currentNode;
            }

            _filterNodesBasedOnKeyword(searchText, allNodes) {
                if(searchText.substr(searchText.length - 1, 1) == '*'){
                    searchText = searchText.substr(0, searchText.length-2);
                }
                if(searchText.substr(0, 1) == '*'){
                    searchText = searchText.substr(1, searchText.length-2);
                }
                allNodes = allNodes.filter(searchItem => {
                    let _searchTarget = searchItem.value ? searchItem.value : searchItem.text;
                    if(_searchTarget) {
                        _searchTarget = _searchTarget.replace(/[{(/)}\[\]]/g, ' ');
                    }
                    return (_searchTarget.search(new RegExp(searchText, "i")) > -1);
                }, this);
            }

            _transformEntitiesToNodes(entities) {
                let allNodes = [];
                entities.forEach(function (entity) {
                    let nodeData = {
                        "id": entity.id,
                        "name": entity.name,
                        "type": entity.type
                    };
                    let ctxObj = this._contextHierarchy[entity.type];
                    let externalAttrName = this._modelsData[entity.type].externalAttrName;
                    let parentContextKey = ctxObj.parentContextKey;
                    let contextRelation = ctxObj.contextRelationship;
                    let externalNameAttr = EntityHelper.getAttribute(entity, externalAttrName);
                    let externamName = AttributeHelper.getFirstAttributeValue(externalNameAttr);
                    let entityTypeExternalName = entity.typeExternalName || entity.type;
                    nodeData.text = (externamName || entity.name) + " (" + entityTypeExternalName + ")";
                    nodeData.value = externamName || entity.name;

                    if(contextRelation && DataHelper.isValidObjectPath(entity, "data.relationships." + contextRelation + ".0")) {
                        let relObj = entity.data.relationships[contextRelation][0];
                        if(DataHelper.isValidObjectPath(relObj, "relTo.id")) {
                            nodeData.parentNodeId = relObj.relTo.id;
                            nodeData.parentNodeType = relObj.relTo.type;
                        }
                    }
                    allNodes.push(nodeData);
                }, this);

                return allNodes;
            }

            //If _selectedCOntextsPaths available, then only pre selection process triggers
            _checkForSelectedContext() {
                if (this.contextsData.length == 0 || !this._selectedDataContexts || !this._selectedDataContexts.length || this._contextsDataIndex == this._selectedDataContexts.length) {
                    return;
                }
                
                this._selectedDataContexts.forEach((selectedContextsPaths) => {
                    let contextPath = selectedContextsPaths.join("#@#");
                    let node = this.contextTree.getElementNodeByPath(contextPath);

                    if(node) {
                        node.selectItem();
                        node.expand();
                    }
                }, this);
            }

            _treeNodeExpanded(e) {
                let node = e.detail;
                if (!node.nodeData.children || node.nodeData.children.length == 0) {
                    this.loading = true;
                    this.executeRequest(node);
                }
            }

            _onContextItemSelected(e) {
                if(this._isSearchMode && DataHelper.isValidObjectPath(e, "detail.data.nodeData.parentNodeId")) {
                    let selectedNodeParentNodeId = e.detail.data.nodeData.parentNodeId;
                    let existingSelectedItem = this.selectedItems.find(obj => obj.id === selectedNodeParentNodeId);
                    let parentNodeData = e.detail.data.nodeData;
                    if(!existingSelectedItem) {
                        this.loading = true;
                        this._requestForRelatedEntity(parentNodeData);
                    }
                }
            }

            _onContextItemDeSelected(e) {
                if(this._isSearchMode && DataHelper.isValidObjectPath(e, "detail.data.nodeData.id")) {
                    let deSelectedNodeDataId = e.detail.data.nodeData.id;
                    let existingSelectedItems = this.selectedItems.filter(function(obj) {
                        if(obj.parentNodeId === deSelectedNodeDataId) {
                            return true;
                        }
                    }, this);
                    if(!_.isEmpty(existingSelectedItems)) {
                        existingSelectedItems.forEach((selectedItem) => {
                            let selectedItemIndex = this.selectedItems.indexOf(selectedItem);
                            if(selectedItemIndex > -1) {
                                this.splice("selectedItems", selectedItemIndex, 1);
                            }
                        }, this);
                    }
                }
            }

            _requestForRelatedEntity(parentNodeData) {
                let type = parentNodeData.parentNodeType;
                let itemContext = {"id": parentNodeData.parentNodeId, "type": type, "attributeNames": [this._modelsData[type].externalAttrName] };
                let contextData = DataHelper.cloneObject(this.contextData);
                contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
                contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                let req = DataRequestHelper.createEntityGetRequest(contextData);

                let relatedEntityGetLiquid = this.shadowRoot.querySelector("#relatedEntityGet");

                if (relatedEntityGetLiquid) {
                    relatedEntityGetLiquid.requestData = req;
                    relatedEntityGetLiquid.generateRequest();
                }
            }

            _getRelatedEntitiesResponse(e) {
                if(DataHelper.isValidObjectPath(e, "detail.response.content.entities.0")) {
                    let entities = e.detail.response.content.entities;
                    let nodes = this._transformEntitiesToNodes(entities);
                    this.push("selectedItems", nodes[0]);
                }
                this.loading = false;
            }

            _expandAllNodes(nodes) {
                nodes.forEach((node) => {
                    let ctxObj = this._contextHierarchy[node.type];
                    let childCtxObjects = ctxObj ? ctxObj.childCtxObjects : undefined;
                    if(!_.isEmpty(childCtxObjects)) {
                        let currentNode = this.contextTree.getElementNodeById(node.id);
                        if(currentNode) {
                            currentNode.expand();
                        }
                    }
                }, this);
            }
        }

        customElements.define(RockContextTree.is, RockContextTree);
    </script>
</dom-module>