<link rel="import" href="../../../bower_components/polymer/polymer.html" />
<link rel="import" href="../../../bower_components/iron-list/iron-list.html" />

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../rock-search-bar/rock-search-bar.html" />
<link rel="import" href="pebble-tree-node.html" />

<!--
`pebble-tree` Represents an element that displays a list of nodes in a tree structure.

### Example

        <pebble-tree data="[[data]]"
                     selected-item="{{selectedItem}}" 
                     selected-items="{{selectedItems}}" 
                     multi-select 
                     enable-search>
        </pebble-tree>

### Styling
The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
--pebble-tree | Mixin applied to tree | {}
--pebble-tree-parent-list | Mixin applied to parent tree list | {}
--pebble-tree-nodeitem | Mixin applied to tree list item | {}
--pebble-tree-nodeitem-hover | Mixin applied to tree list item hover | {}
--pebble-tree-nodeitem-active | Mixin applied to tree list item active | {}
--pebble-tree-nodeitem-selected | Mixin applied to tree list item active | {}
--pebble-tree-node | Mixin applied to inner tree list | {}
--pebble-tree-node-arrow | Mixin applied to tree list arrow | {}
--pebble-tree-checkbox | Mixin applied to tree list item checkbox | {}
--pebble-tree-icon | Mixin applied to tree list item icon | {}
--pebble-tree-height | The max-height of pebble-tree | 500px
--pebble-tree-checkbox-size | The size of tree list item checkbox | 12px
--pebble-tree-checkbox-color | The color of tree list item checkbox | #0a9ec1
--pebble-tree-checkbox-border-color | The border color of tree list item checkbox | #aaaaaa
--pebble-tree-checkbox-checkmark-color | The checkmark color of tree list item checkbox | ``
--pebble-tree-icon-width | The tree list item icon width | 16px
--pebble-tree-icon-height | The tree list item icon height | 16px
--pebble-tree-icon-fill-color | The tree list item icon fill color | #0a9ec1
--pebble-tree-icon-stroke-color | The tree list item icon stroke color | ``
--pebble-tree-search-text-color | The text color of search box | ``
--pebble-tree-search-font-family | The text font style of search box | ``

@group Pebble Elements
@element pebble-tree
@demo demo/index.html
-->

<dom-module id="pebble-tree">
	<template>
		<style is="custom-style" include="pebble-styles-shared">
			:host {
				display: block;
				background-color: #ffffff;
				color: #000000;
				/*padding: 12px 2px;*/
				/*border: 1px solid #eaeaea;*/
				border-radius: 2px;
				margin: 12px;
				font-size: var(--default-font-size, 14px);
				cursor: default;
				@apply(--pebble-tree);
			}

			iron-list {
				max-height: var(--pebble-tree-height, 500px);
			}

			ul {
				margin-left: 0;
				padding-left: 10px;
				@apply(--pebble-tree-parent-list)
			}

            pebble-tree-node {
				li {
					@apply(--pebble-tree-nodeitem);
				}
				li:hover,
				li a:hover {
					@apply(--pebble-tree-nodeitem-hover);
				}
				li:active {
					@apply(--pebble-tree-nodeitem-active);
				}
				.selected {
					@apply(--pebble-tree-nodeitem-selected);
				}
				ul {
					@apply(--pebble-tree-node);
				}
				.arrow-down,
				.arrow-right {
					@apply(--pebble-tree-node-arrow);
				}
				--tree-checkbox-size: var(--pebble-tree-checkbox-size);
				--tree-checkbox-color: var(--pebble-tree-checkbox-color);
				--tree-checkbox-border-color: var(--pebble-tree-checkbox-border-color);
				--tree-checkbox-checkmark-color: var(--pebble-tree-checkbox-checkmark-color);
				@apply(--pebble-tree-checkbox);
				--tree-icon-width: var(--pebble-tree-icon-width);
				--tree-icon-height: var(--pebble-tree-icon-height);
				--tree-icon-fill-color: var(--pebble-tree-icon-fill-color);
				--tree-icon-stroke-color: var(--pebble-tree-icon-stroke-color);
				@apply(--pebble-tree-icon);
			}

			rock-search-bar {
				margin-left: 5px;
				display: inline-flex;
                display: -webkit-inline-flex;
				width: calc( 100% - 10px);
				height: 32px;
				border: 1px solid var(--cloudy-blue-color,#c1cad4);
                --search-text-color: var(--pebble-tree-search-text-color);
                --default-font-family: var(--pebble-tree-search-font-family);
            }
		</style>
		<template is="dom-if" if="{{enableSearch}}">
			<rock-search-bar placeholder="Enter search text" query="{{searchKeyword}}"></rock-search-bar>
		</template>
		<ul>
            <iron-list items="{{_nav}}" as="item" index-as="index">
                <template>
					<pebble-tree-node disabled="[[disabled]]" item-path$="[[index]]" default-child-depth="[[defaultChildDepth]]"  default-expand-depth ="[[defaultExpandDepth]]" node-data="{{item}}" selected-item="{{selectedItem}}"
									  selected-items="{{selectedItems}}" indeterminate-items="{{indeterminateItems}}"  multi-select="[[multiSelect]]"
									  selected-node="{{selectedNode}}" selected-nodes="{{selectedNodes}}"
									  tree="[[tree]]" check-child-nodes="[[checkChildNodes]]" check-parent-nodes="[[checkParentNodes]]" addable-levels="[[addableLevels]]"></pebble-tree-node>
				</template>
			</iron-list>
		</ul>
	</template>
</dom-module>
<script>
  Polymer({
    is: 'pebble-tree',

    properties: {

      /**
      * Indicates a currently selected item.
      */
      selectedItem: {
        type: Object,
	    notify:true
      },

      /**
       * Indicates a currently selected item list.
       */
      selectedItems: {
        type: Array,
        value: function() {return [];},
	    notify:true
      },
		/**
       * Indicates  list of items for which atleast one of the child element is selected.
       */
        indeterminateItems: {
        type: Array,
        value: function() {return [];},
		notify:true
      },
	  /**
	   * Indicates a reference to the selected element's node.
	   *
	   * @property selectedElem
	   * @type Object
	   */
	  selectedNode: {
	  	type: Object,
	    notify:true
	  },
	/**
	 * Indicates a reference to the list of selected elements' node. 
     * A node which is not yet rendered in the `dom` does not appear in this list. 
     * For example, element A has five child elements. 
     * Just selecting the element A does not select all five child elements. 
     * You need to expand the same so that these elements get added to the `dom`. 
     * That makes these elements a part of `selectedNodes` list.
	 *
	 * @property selectedElem
	 * @type Object
	 */
	selectedNodes: {
        type: Array,
        value: function() {return [];},
        notify:true
	},

      /**
      * Indicates a keyword for the search.
      */
      searchKeyword: {
        type: String,
        value: ''
      },

      /**
      * Indicates an initial navigation in the form of an array.
      */
      data: {
        type: Array,
        value: function() {return [];}
      },

      /**
      * Specifies a model of the current navigation with search filters or other mutations
      * applied by this component's methods. This is calculated with the changes from the base
      * property `data` which is defined by this component's parent.
      *
      */
      _nav: {
        type: Object
      },
      /**
       * Indicates a boolean flag to make the tree as either multi-select or single-select.
       */
      multiSelect: {
        type: Boolean,
        value: false
      },

      /**
       * Specifies whether or not to show the search box.
       */
      enableSearch: {
        type: Boolean,
        value: false
      },
        /**
         * Specifies the default depth to which the tree is expanded by default.
         */
		defaultExpandDepth :{
          type: Number,
		  value:0
		},
        /**
         * Specifies whether or not the child elements are selected based on the parent elements.
         */
		checkChildNodes:{
          type:Boolean,
		  value:false
		},
        /**
         * Specifies whether parent elements are selected or not on selecting the child elements.
         */
        checkParentNodes:{
            type:Boolean,
            value:false
        },
		/**
		* Indicates a reference to the tree.
		*/
		tree:{
			type:Object,
			value: function () {
				return this;
            }
		},
        /**
         * Specifies the level at which add buttons are present so that the new child elements can be added. 
         * 
         */
		addableLevels:{
		    type:Array,
			value:function () {
				return [];
            }
		},
        /**
         * Specifies whether the tree is disabled or not
         */
        disabled:{
            type:Boolean,
            value:false
		},
		defaultChildDepth:{
		    type:Number,
			value:0
		}
    },

    /** Observe property changes */
    observers: [
      '_computedNav(data, searchKeyword)'
    ],
    listeners:{
      'item-selected':'itemSelected'
	},
    /**
    * Fired when the search keyword is changed to call the filter on the `nav`.
    * You need to have debounce in place so that you don't do this on every single key down.
    *
    */
    _computedNav: function(navArr, searchKeyword) {
      //Clear selection before updating the items
      this.clearSelectedItems();
      this.clearSelectedItem();

      if (searchKeyword === '') {
        this.set('_nav', this.data);
        return;
      }

      this.debounce('navBuild', function() {
        this.set('_nav', this._buildNav(navArr, searchKeyword));
      }, 50);
    },

    /**
    * Fired when a search keyword is entered. It builds and returns a new `nav`
    * object that only contains the search query.
    *
    */
    _buildNav: function(navArr, searchKeyword) {
        var foundItems = [],
        lowercaseArray;
        for (var i = 0, len=navArr.length; i < len; i++) {
          //build our initial object and populate it.
          var currentObj = {};
          currentObj.text = navArr[i].text;
          currentObj.icon = navArr[i].icon;
          currentObj.src = navArr[i].src;
          currentObj.expanded = true;

          //if the item has children (ie children), recurse and if another array with children is returned, insert that into the object.
          if (navArr[i].children && navArr[i].children.length > 0) {
            var tempArr = this._buildNav(navArr[i].children, searchKeyword);
            if (tempArr.length) {
              currentObj['children'] = tempArr;
            }
          }

          //lowercase both the search keyword, and link text, and compare - if there's a match, push it into the array.
          if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1 && !navArr[i].children || currentObj.children) {
            foundItems.push(currentObj);
          }
          lowercaseArray=[];
        }

        //returns a rebuilt, filtered nav
        return foundItems;
    },

    /**
     * Can be used to clear the selected item list and checkbox selection.
     */
    clearSelectedItems: function(){
        this.selectedItems = [];
        this.indeterminateItems = [];
        this.selectedNodes = [];
    },

    /**
     * Can be used to clear the selected item and style.
     */
    clearSelectedItem: function(){
        this.selectedItem = '';
        this.selectedNode=null;
        //Clear selected item
        var item = this.querySelector('.selected');
        if(item)
        {
          item.classList.remove('selected');
        }
    },

      _resizeIronList : function() {
          var ironList = Polymer.dom(this.root).node.querySelector("iron-list")
              || Polymer.dom(this).node.querySelector("iron-list");
          ironList.notifyResize();
      },
      /**
       * Can be used to get the element from the given path in the tree.
       */
	  getElementByPath: function (path) {
		  var indices=path.split(".");
		  var elem=this._nav[indices[0]];
		  for(var i=1;i<indices.length;i++){
		      elem=elem.children[indices[i]];
		  }
		  return elem;
      },
      /**
       * Can be used to get the element's node from the given path in the tree.
       *     
       */
	  getElementNodeByPath: function (path, node) {
          if(node) {
              return Polymer.dom(node.root).querySelector("pebble-tree-node[item-path='" + path + "']");
          }
          else {
              return Polymer.dom(this.root).querySelector("pebble-tree-node[item-path='" + path + "']") || this.querySelector("pebble-tree-node[item-path='" + path + "']")  ;
          }
      },
      /**
       * Can be used to get the parent's object for a given child node.
       */
	  getParentItemForNode: function (node) {
		  return node.getParent();
      },
      /**
       * Can be used to check if a given node is parent node of another node.
       */
	  checkIfParentNode: function (parentNode, childNode) {
        var parentItem=childNode.getParent();
         return (parentItem && parentItem==parentNode.nodeData);
      },
      /**
       * Can be used to check if the given two nodes are each other's siblings.
       */
	  checkIfSiblingNodes: function (node1,node2) {
		  var parent1= node1.getParent();
		  var parent2=node2.getParent();
		  return parent1==parent2;
      },
	  /**
       * Can be used to check if the given element is parent element of another element.
       */
	  checkIfParentElement: function (parent, child) {
        var parentItemPaths=this.getElementPathByText(parent.text);
        var childItemPaths=this.getElementPathByText(child.text);
        for(var i=0;i<parentItemPaths.length;i++){
            for(var j=0;j<childItemPaths.length;j++){
                var lastIndex = childItemPaths[j].lastIndexOf(".");
				if(parentItemPaths[i]==childItemPaths[j].substring(0,lastIndex)){
				    return true;
				}
            }
		}
         return false;
      },
	  /**
       * Can be used to check if there is a parent element with the given text to 
       * another element with the given text.
       */
	  checkIfParentElementByText: function (parentText, childText) {
        var parentItemPaths=this.getElementPathByText(parentText);
        var childItemPaths=this.getElementPathByText(childText);
        for(var i=0;i<parentItemPaths.length;i++){
            for(var j=0;j<childItemPaths.length;j++){
                var lastIndex = childItemPaths[j].lastIndexOf(".");
				if(parentItemPaths[i]==childItemPaths[j].substring(0,lastIndex)){
				    return true;
				}
            }
		}
         return false;
      },
      /**
       * Can be used to check if the given two elements are each other's siblings.
       */
	  checkIfSiblingElements: function (element1,element2) {
		  var element1Paths= this.getElementPathByText(element1.text);
		  var element2Paths=this.getElementPathByText(element2.text);
          for(var i=0;i<element1Paths.length;i++){
              for(var j=0;j<element2Paths.length;j++){
                  var lastIndex1 = element1Paths[i].lastIndexOf(".");
                  var lastIndex2 = element2Paths[j].lastIndexOf(".");
                  if(lastIndex1==-1 && lastIndex2==-1 ){
                      return true;
                  }  else if(lastIndex1==-1 || lastIndex2==-1){
                      continue;
				  }
                  if(element1Paths[i].substring(0,lastIndex1)==element2Paths[j].substring(0,lastIndex2)){
                      return true;
				  }
              }
          }
          return false;
      },
      /**
       * Can be used to check if there are sibling elements with the given text.
       */
	  checkIfSiblingElementsByText: function (text1,text2) {
		  var element1Paths= this.getElementPathByText(text1);
		  var element2Paths=this.getElementPathByText(text2);
          for(var i=0;i<element1Paths.length;i++){
              for(var j=0;j<element2Paths.length;j++){
                  var lastIndex1 = element1Paths[i].lastIndexOf(".");
                  var lastIndex2 = element2Paths[j].lastIndexOf(".");
                  if(lastIndex1==-1 && lastIndex2==-1 ){
                      return true;
                  }  else if(lastIndex1==-1 || lastIndex2==-1){
                      continue;
				  }
                  if(element1Paths[i].substring(0,lastIndex1)==element2Paths[j].substring(0,lastIndex2)){
                      return true;
				  }
              }
          }
          return false;
      },
      /**
       * Can be used to find the path of an element from its text.
       */
	  getElementPathByText: function (text) {
	      var paths=[];
		  this._checkText(paths,text,this._nav,"");
		  return paths;
      },
      /**
       * Can be used to find the element's node from its text.
       */
	  getElementNodeByText: function (text) {
		 var paths=this.getElementPathByText(text);
          var nodes=[];
          if(paths && paths.length>0){
              for(var i=0;i<paths.length;i++) {
                  nodes.push(this.getElementNodeByPath(path));
              }
          }
		 return nodes;
      },
      /**
       * Can be used to find the elements's data from its text.
       */
      getElementByText: function (text) {
          var paths=this.getElementPathByText(text);
          var elements=[];
          if(paths && paths.length>0){
              for(var i=0;i<paths.length;i++) {
                  elements.push(this.getElementByPath(paths[i]));
              }
          }
          return elements;
      },
      _checkText: function (paths,text,nav,path) {
          if(!path){
              path="";
          }
          for(var i=0;i<nav.length;i++){
              var currentPath=path==""?path+i:path+"."+i;
              if(nav[i].text==text){
                  paths.push(currentPath);
              } else{
                  if(nav[i].children){
                      this._checkText(paths,text,nav[i].children,currentPath);
                  }
              }
          }
      },

      /**
       * Can be used to find the path of an element from its value. 
       * The value is custom or user-defined data associated with a given node.
       */
      getElementPathByValue: function (value) {
          return this._checkValue(value,this._nav,"");
      },
      /**
       * Can be used to find the element's node from its value.
       */
	  getElementNodeByValue: function (value) {
          var path=this.getElementPathByValue(value);
          if(path){
              return this.getElementNodeByPath(path);
          }
      },

      /**
       * Can be used to find the element's data from its value.
       */
	  getElementByValue: function (value) {
          var path=this.getElementPathByValue(value);
          if(path){
              return this.getElementByPath(path);
          }
      },

      _checkValue: function (value,nav,path) {
          if(!path){
              path="";
          }
          for(var i=0;i<nav.length;i++){
              var currentPath=path==""?path+i:path+"."+i;
              if(nav[i].value==value){
                  return currentPath;
              } else{
                  if(nav[i].children){
                      var res=this._checkValue(value,nav[i].children,currentPath);
                      if(res!=currentPath){
                          return res;
                      }
                  }
              }
          }
          return path;
      }



  });
</script>