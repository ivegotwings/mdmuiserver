<link rel="import" href="../../../bower_components/polymer/polymer.html" />
<link rel="import" href="../../../bower_components/iron-list/iron-list.html" />
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/debounce.html">

<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="pebble-tree-node.html" />
<link rel="import" href="../rock-search-bar/rock-search-bar.html" />

<!--
`pebble-tree` Represents an element that displays a list of nodes in a tree structure.

### Example

        <pebble-tree data="[[data]]"
                     selected-item="{{selectedItem}}" 
                     selected-items="{{selectedItems}}" 
                     multi-select 
                     enable-search>
        </pebble-tree>

### Styling
The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
--pebble-tree | Mixin applied to tree | {}
--pebble-tree-parent-list | Mixin applied to parent tree list | {}
--pebble-tree-nodeitem | Mixin applied to tree list item | {}
--pebble-tree-nodeitem-hover | Mixin applied to tree list item hover | {}
--pebble-tree-nodeitem-active | Mixin applied to tree list item active | {}
--pebble-tree-nodeitem-selected | Mixin applied to tree list item active | {}
--pebble-tree-node | Mixin applied to inner tree list | {}
--pebble-tree-node-arrow | Mixin applied to tree list arrow | {}
--pebble-tree-checkbox | Mixin applied to tree list item checkbox | {}
--pebble-tree-icon | Mixin applied to tree list item icon | {}
--pebble-tree-height | The max-height of pebble-tree | 500px
--pebble-tree-checkbox-size | The size of tree list item checkbox | 12px
--pebble-tree-checkbox-color | The color of tree list item checkbox | #0a9ec1
--pebble-tree-checkbox-border-color | The border color of tree list item checkbox | #aaaaaa
--pebble-tree-checkbox-checkmark-color | The checkmark color of tree list item checkbox | ``
--pebble-tree-icon-width | The tree list item icon width | 16px
--pebble-tree-icon-height | The tree list item icon height | 16px
--pebble-tree-icon-fill-color | The tree list item icon fill color | #0a9ec1
--pebble-tree-icon-stroke-color | The tree list item icon stroke color | ``
--pebble-tree-search-text-color | The text color of search box | ``
--pebble-tree-search-font-family | The text font style of search box | ``

@group Pebble Elements
@element pebble-tree
@demo demo/index.html
-->

<dom-module id="pebble-tree">
    <template>
            <style include="bedrock-style-common">
                 :host {
                    display: block;
                    background-color: var(--palette-white, #ffffff);
                    color: var(--border-black, #000);
                    border-radius: 2px;
                    font-size: var(--default-font-size, 14px);
                    cursor: default;
                    @apply --pebble-tree;
                }

                iron-list {
                    max-height: var(--pebble-tree-height, 500px);
                }

                ul {
                    margin-left: 0;
                    padding-left: 0;
                    @apply --pebble-tree-parent-list;
                }

                rock-search-bar {
                    display: inline-flex;
                    display: -webkit-inline-flex;
                    width: 100%;
                    height: 32px;
                }
                
            </style>
        <template is="dom-if" if="{{enableSearch}}">
            <rock-search-bar placeholder="Enter search text" query="{{searchKeyword}}"></rock-search-bar>
        </template>
        <ul>
            <template is="dom-repeat" id="treeNodesList" items="{{_nav}}">
                <pebble-tree-node disabled="[[disabled]]" item-path="[[index]]" search-keyword="[[searchKeyword]]" default-child-depth="[[defaultChildDepth]]"
                    default-expand-depth="[[defaultExpandDepth]]" node-data="{{item}}" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                    indeterminate-items="{{indeterminateItems}}" multi-select="[[multiSelect]]" selected-node="{{selectedNode}}"
                    selected-nodes="{{selectedNodes}}" tree="[[tree]]" check-child-nodes="[[checkChildNodes]]" check-parent-nodes="[[checkParentNodes]]"
                    addable-levels="[[addableLevels]]" value-path="[[item.value]]" leaf-node-only="[[leafNodeOnly]]" expand-collapse-icon-object="[[expandCollapseIconObject]]">
                </pebble-tree-node>
            </template>
        </ul>
    </template>
</dom-module>
<script>
    Polymer({
        is: 'pebble-tree',

        properties: {

            /**
            * Indicates the currently selected item.
            */
            selectedItem: {
                type: Object,
                notify: true
            },

            /**
             * Indicates the currently selected item list.
             */
            selectedItems: {
                type: Array,
                value: function () { return []; },
                notify: true
            },
            /**
           * Indicates  list of items for which at least one of the child element is selected.
           */
            indeterminateItems: {
                type: Array,
                value: function () { return []; },
                notify: true
            },
            /**
             * Indicates a reference to the selected element's node.
             *
             * @property selectedElem
             * @type Object
             */
            selectedNode: {
                type: Object,
                notify: true
            },
            /**
             * Indicates a reference to the list of selected elements' node. 
             * A node which is not yet rendered in the `dom` does not appear in this list. 
             * For example : Element A has five child elements. 
             * If you just select the element A, it does not select all five child elements. 
             * You must expand the element A so that these elements get added to the `dom`. 
             * That makes these elements a part of `selectedNodes` list.
             *
             * @property selectedElem
             * @type Object
             */
            selectedNodes: {
                type: Array,
                value: function () { return []; },
                notify: true
            },

            /**
            * Indicates a keyword for the search.
            */
            searchKeyword: {
                type: String,
                value: ''
            },

            /**
            * Indicates an initial navigation in the form of an array.
            */
            data: {
                type: Array,
                value: function () { return []; }
            },

            /**
            * Specifies a model of the current navigation with search filters or other mutations
            * applied by this component's methods. This is calculated with the changes from the base
            * property `data` which is defined by this component's parent.
            *
            */
            _nav: {
                type: Object
            },
            /**
             * Indicates a boolean flag to make the tree as either multi-select or single-select.
             */
            multiSelect: {
                type: Boolean,
                value: false
            },

            /**
             * Specifies whether or not to show the search box.
             */
            enableSearch: {
                type: Boolean,
                value: false
            },
            /**
             * Specifies the default depth to which the tree is expanded by default.
             */
            defaultExpandDepth: {
                type: Number,
                value: 0
            },
            /**
             * Specifies whether or not the child elements are selected based on the parent elements.
             */
            checkChildNodes: {
                type: Boolean,
                value: false
            },
            /**
             * Specifies whether or not the parent elements are made indeterminate based on the child elements selection.
             */
            checkParentNodes: {
                type: Boolean,
                value: false
            },
            /**
            * Indicates a reference to the tree.
            */
            tree: {
                type: Object,
                value: function () {
                    return this;
                }
            },
            /**
             * Specifies the level at which add buttons are present so that the new child elements can be added. 
             * 
             */
            addableLevels: {
                type: Array,
                value: function () {
                    return [];
                }
            },
            /**
             * Specifies whether the tree is disabled or not
             */
            disabled: {
                type: Boolean,
                value: false
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            defaultChildDepth: {
                type: Number,
                value: 0
            },
            /**
            * Specifies whether or not only leaf-node selection is enabled.
            */
            leafNodeOnly: {
                type: Boolean,
                value: false
            },
            /**
            * Specifies expand / collapse icons
            */
            expandCollapseIconObject: {
                type: Object,
                value: function(){
                    return {}
                }
            }
        },

        /** Observe property changes */
        observers: [
            '_computedNav(data, searchKeyword)'
        ],
        behaviors: [
            RUFBehaviors.UIBehavior
        ],
        listeners: {
            'item-selected': '_itemSelected'
        },
        /** Can be used re-render the tree. */
        refreshTree: function () {
            this.shadowRoot.querySelector("#treeNodesList").render();
        },
        /**
        * Fired when the search keyword is changed to call the filter on the `nav`.
        * You need to have debounce in place so that you don't do this on every single key down.
        *
        */
        _computedNav: function (navArr, searchKeyword) {
            if (!(navArr === undefined || searchKeyword === undefined)) {
                if (searchKeyword === '') {
                    this.set('_nav', this.data);
                    this.refreshTree();
                    return;
                }
                this._debouncer = Polymer.Debouncer.debounce(this._debouncer, Polymer.Async.timeOut.after(50), () => {
                    this.set('_nav', this._buildNav(navArr, searchKeyword));
                    this.refreshTree();
                });
            }
        },

        /**
        * Fired when a search keyword is entered. It builds and returns a new `nav`
        * object that only contains the search query.
        *
        */
        _buildNav: function (navArr, searchKeyword) {
            if (!navArr) {
                return [];
            }
            if (!searchKeyword || searchKeyword == "") {
                return navArr;
            }
            var foundItems = [];
            for (var i = 0; i < navArr.length; i++) {
                var childMatch = false;
                if (navArr[i].children) {
                    childMatch = this._checkChildMatch(navArr[i].children, searchKeyword);
                }
                if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1 || childMatch) {
                    foundItems.push(navArr[i]);
                }
            }

            //returns a rebuilt, filtered nav
            return foundItems;
        },
        _checkChildMatch: function (navArr, searchKeyword) {
            if (!navArr) {
                return false;
            }
            var childMatch = false;
            for (var i = 0; i < navArr.length; i++) {
                if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1) {
                    return true;
                } else {
                    if (navArr[i].children) {
                        childMatch = this._checkChildMatch(navArr[i].children, searchKeyword);
                    }
                    if (childMatch) {
                        return true;
                    }
                }
            }
            return false;
        },

        /**
         * Can be used to clear the selected item list and checkbox selection.
         */
        clearSelectedItems: function () {
            this.selectedItems = [];
            this.indeterminateItems = [];
            this.selectedNodes = [];
        },

        /**
         * Can be used to clear the selected item and style.
         */
        clearSelectedItem: function () {
            this.selectedItem = '';
            this.selectedNode = null;
            //Clear selected item
            var item = this.querySelector('.selected');
            if (item) {
                item.classList.remove('selected');
            }
        },
        /**
         * Can be used to get the element from the given path in the tree.
         */
        getElementByPath: function (path) {
            var indices = path.split(".");
            var elem = this._nav[indices[0]];
            for (var i = 1; i < indices.length; i++) {
                elem = elem.children[indices[i]];
            }
            return elem;
        },
        /**
         * Can be used to get the element's node from the given path in the tree.
         *     
         */
        getElementNodeByPath: function (path) {
            var paths = path.split("#@#");
            if (paths && paths.length > 0) {
                var currentNode = this;
                var currentPath = "";
                for (var i = 0; i < paths.length; i++) {
                    currentPath = currentPath + paths[i];
                    var selector = "pebble-tree-node[value-path='" + currentPath + "']";
                    var node = ElementHelper.getElement(currentNode, selector);
                    currentNode = node;
                    currentPath = currentPath + "#@#";
                }
                return currentNode;
            }
        },
        /**
         * Can be used to get the parent's object for a given child node.
         */
        getParentItemForNode: function (node) {
            return node.getParent();
        },
        /**
         * Can be used to check if a given node is parent node of another node.
         */
        checkIfParentNode: function (parentNode, childNode) {
            var parentItem = childNode.getParent();
            return (parentItem && parentItem == parentNode.nodeData);
        },
        /**
         * Can be used to check if the given two nodes are each other's siblings.
         */
        checkIfSiblingNodes: function (node1, node2) {
            var parent1 = node1.getParent();
            var parent2 = node2.getParent();
            return parent1 == parent2;
        },
        /**
         * Can be used to check if the given element is parent element of another element.
         */
        checkIfParentElement: function (parent, child) {
            var parentItemPaths = this.getElementPathByText(parent.text);
            var childItemPaths = this.getElementPathByText(child.text);
            for (var i = 0; i < parentItemPaths.length; i++) {
                for (var j = 0; j < childItemPaths.length; j++) {
                    var lastIndex = childItemPaths[j].lastIndexOf(".");
                    if (parentItemPaths[i] == childItemPaths[j].substring(0, lastIndex)) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * Can be used to check if there is a parent element with the given text to 
         * another element with the given text.
         */
        checkIfParentElementByText: function (parentText, childText) {
            var parentItemPaths = this.getElementPathByText(parentText);
            var childItemPaths = this.getElementPathByText(childText);
            for (var i = 0; i < parentItemPaths.length; i++) {
                for (var j = 0; j < childItemPaths.length; j++) {
                    var lastIndex = childItemPaths[j].lastIndexOf(".");
                    if (parentItemPaths[i] == childItemPaths[j].substring(0, lastIndex)) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * Can be used to check if the given two elements are each other's siblings.
         */
        checkIfSiblingElements: function (element1, element2) {
            var element1Paths = this.getElementPathByText(element1.text);
            var element2Paths = this.getElementPathByText(element2.text);
            for (var i = 0; i < element1Paths.length; i++) {
                for (var j = 0; j < element2Paths.length; j++) {
                    var lastIndex1 = element1Paths[i].lastIndexOf(".");
                    var lastIndex2 = element2Paths[j].lastIndexOf(".");
                    if (lastIndex1 == -1 && lastIndex2 == -1) {
                        return true;
                    } else if (lastIndex1 == -1 || lastIndex2 == -1) {
                        continue;
                    }
                    if (element1Paths[i].substring(0, lastIndex1) == element2Paths[j].substring(0, lastIndex2)) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * Can be used to check if there are sibling elements with the given text.
         */
        checkIfSiblingElementsByText: function (text1, text2) {
            var element1Paths = this.getElementPathByText(text1);
            var element2Paths = this.getElementPathByText(text2);
            for (var i = 0; i < element1Paths.length; i++) {
                for (var j = 0; j < element2Paths.length; j++) {
                    var lastIndex1 = element1Paths[i].lastIndexOf(".");
                    var lastIndex2 = element2Paths[j].lastIndexOf(".");
                    if (lastIndex1 == -1 && lastIndex2 == -1) {
                        return true;
                    } else if (lastIndex1 == -1 || lastIndex2 == -1) {
                        continue;
                    }
                    if (element1Paths[i].substring(0, lastIndex1) == element2Paths[j].substring(0, lastIndex2)) {
                        return true;
                    }
                }
            }
            return false;
        },
        /**
         * Can be used to find the path of an element from its text.
         */
        getElementPathByText: function (text) {
            var paths = [];
            this._checkText(paths, text, this._nav, "");
            return paths;
        },
        /**
         * Can be used to find the element's node from its text.
         */
        getElementNodeByText: function (text) {
            var paths = this.getElementPathByText(text);
            var nodes = [];
            if (paths && paths.length > 0) {
                for (var i = 0; i < paths.length; i++) {
                    nodes.push(this.getElementNodeByPath(path));
                }
            }
            return nodes;
        },
        /**
         * Can be used to find the elements's data from its text.
         */
        getElementByText: function (text) {
            var paths = this.getElementPathByText(text);
            var elements = [];
            if (paths && paths.length > 0) {
                for (var i = 0; i < paths.length; i++) {
                    elements.push(this.getElementByPath(paths[i]));
                }
            }
            return elements;
        },
        _checkText: function (paths, text, nav, path) {
            if (!path) {
                path = "";
            }
            for (var i = 0; i < nav.length; i++) {
                var currentPath = path == "" ? path + i : path + "." + i;
                if (nav[i].text == text) {
                    paths.push(currentPath);
                } else {
                    if (nav[i].children) {
                        this._checkText(paths, text, nav[i].children, currentPath);
                    }
                }
            }
        },

        /**
         * Can be used to find the path of an element from its value. 
         * The value is custom or user-defined data associated with a given node.
         */
        getElementPathByValue: function (value) {
            return this._checkValue(value, this._nav, "");
        },
        /**
         * Can be used to find the element's node from its value.
         */
        getElementNodeByValue: function (value) {
            var path = this.getElementPathByValue(value);
            if (path) {
                return this.getElementNodeByPath(path);
            }
        },

        /**
         * Can be used to find the element's data from its value.
         */
        getElementByValue: function (value) {
            var path = this.getElementPathByValue(value);
            if (path) {
                return this.getElementByPath(path);
            }
        },

        _checkValue: function (value, nav, path) {
            if (!path) {
                path = "";
            }
            for (var i = 0; i < nav.length; i++) {
                var currentPath = path == "" ? path + i : path + "." + i;
                if (nav[i].value == value) {
                    return currentPath;
                } else {
                    if (nav[i].children) {
                        var res = this._checkValue(value, nav[i].children, currentPath);
                        if (res != currentPath) {
                            return res;
                        }
                    }
                }
            }
            return path;
        },
        _itemSelected: function (e) {
            var eventName = "tree-node-selected";
            var eventDetail = {
                name: eventName,
                data: e.detail.data
            }
            this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
        }
    });

</script>