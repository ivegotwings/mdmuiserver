<link rel="import" href="../../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html"/>
<link rel="import" href="../../../bower_components/iron-list/iron-list.html"/>
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html"/>
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<!--
`pebble-tree-node` Represents an individual tree list that is combined to make rock-tree.

@group Pebble Elements
@element pebble-tree-node
@demo demo/index.html
-->
<dom-module id="pebble-tree-node">
    <template>
        <style is="custom-style" include="pebble-styles-shared">
            .flex {
                display: flex;
                align-items: center;
            }
            .check-box-wrapper{
                margin-bottom: 6px;
            }
            li {
                list-style: none;
                margin: 1px;
                padding: 2px;
                @apply(--pebble-tree-nodeitem);
            }

            li:hover,
            li a:hover {
                color: #0a9ec1;
                cursor: pointer;
                @apply(--pebble-tree-nodeitem-hover);
            }

            li:active {
                color: #086e87;
                @apply(--pebble-tree-nodeitem-active);
            }

            .selected {
                color: #0a9ec1;
                background-color: #eaeaea;
                border-left: 5px solid #0a9ec1;
                padding: 5px;
                @apply(--pebble-tree-nodeitem-selected);
            }

            ul {
                padding: 2px;
                margin-left: 0;
                padding-left: 30px;
                @apply(--pebble-tree-node);
            }

            .arrow-down,
            .arrow-right {
                width: 0;
                height: 0;
                border-top: 5px solid transparent;
                border-bottom: 5px solid transparent;
                border-left: 8px solid;
                padding-right: 2px;
                margin-right: 5px;
                color: #0a9ec1;
                @apply(--pebble-tree-node-arrow);
            }

            .arrow-down {
                -webkit-transform: rotate(90deg);
                transform: rotate(90deg)
            }

            pebble-checkbox {
                --pebble-checkbox-size: var(--tree-checkbox-size, 14.5px);
                --pebble-checkbox-unchecked-color: var(--tree-checkbox-border-color, #aaaaaa);
                --pebble-checkbox-checked-color: var(--tree-checkbox-color, #0a9ec1);
                --pebble-checkbox-checkmark-color: var(--tree-checkbox-checkmark-color);
                @apply(--pebble-tree-checkbox);
            }

            iron-icon {
                --iron-icon-width: var(--tree-icon-width, 16px);
                --iron-icon-height: var(--tree-icon-height, 16px);
                --iron-icon-fill-color: var(--tree-icon-fill-color, #0a9ec1);
                --iron-icon-stroke-color: var(--tree-icon-stroke-color);
                @apply(--pebble-tree-icon);
            }

            pebble-button.iconButton {
                margin-right: 3px;
                --pebble-button: {
                    height: 28px;
                    min-width: 0.5em;
                    padding: 0.2em 0.2em 0.3em 0.2em;
                    color: #0a9ec1;
                }
            }
            .right{
                margin-left: auto;
            }
            pebble-horizontal-divider {
                --pebble-horizontal-divider-color: var(--divider-color, #eaeaea);
                /*--pebble-horizontal-divider: {*/
                    /*margin-bottom: 1px;*/
                    /*margin-top: 1px;*/
                    /*@apply(--guideme-horizontal-divider);*/
                /*}*/
            }



        </style>
        <template is="dom-if" if="[[!hasChildren(nodeData.*)]]"  >
            <li class="flex">
                <div class="check-box-wrapper" on-tap = "_itemClick">
                    <pebble-checkbox hidden="[[!multiSelect]]" disabled="[[disabled]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*)]]"></pebble-checkbox>
                </div>
                <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]" hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                <a class$="nav-lnk" on-tap="_itemClick" >[[nodeData.text]]</a>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
        </template>
        <template is="dom-if" if="[[hasChildren(nodeData.*)]]" >
            <div><pebble-horizontal-divider hidden="[[!showHorizontalDivider]]"></pebble-horizontal-divider></div>
            <li class="flex">
                <pebble-button class="iconButton" icon$="[[_expandClass(expanded)]]"  hidden="[[!multiSelect]]" on-click="_toggle" ></pebble-button>
                <div class="check-box-wrapper" on-tap = "_itemClick">
                    <pebble-checkbox hidden="[[!multiSelect]]" disabled="[[disabled]]" indeterminate="[[_isIndeterminate(nodeData,indeterminateItems,indeterminateItems.*)]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*)]]"></pebble-checkbox>
                </div>
                <div on-click="_toggle" class="flex">
                    <div id="arrow" hidden="[[multiSelect]]" class$="[[_arrowClass(expanded)]] arrow"
                         ></div>
                    <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]"
                               hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                    <div>[[nodeData.text]]</div>
                </div>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
            <div ><pebble-horizontal-divider hidden="[[!showHorizontalDivider]]"></pebble-horizontal-divider></div>
        </template>
        <iron-collapse id="collapse" opened$="[[expanded]]">
            <ul class="flex" hidden="[[!nodeData.addNewItem]]">
                <pebble-checkbox disabled="[[disabled]]" checked="{{newItemChecked}}"  hidden="[[!multiSelect]]"></pebble-checkbox>
                <pebble-textbox id="newItem" disabled="[[disabled]]" label="text input" no-label-float
                                on-change="_keyPressed" ></pebble-textbox>
            </ul>
            <template is="dom-if" if="[[hasChildren(nodeData.*)]]" >
            <ul>
                <iron-list items="[[nodeData.children]]" as="item" index-as="index" >
                    <template>
                        <pebble-tree-node disabled="[[disabled]]"  node-data="{{item}}" default-expand-depth ="[[defaultExpandDepth]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                                           indeterminate-items="{{indeterminateItems}}"  multi-select="[[multiSelect]]"
                                           parent-item="{{nodeData}}" item-path$="[[_setItemPath(index)]]" selected-node="{{selectedNode}}" selected-nodes="{{selectedNodes}}"
                                           tree="[[tree]]" check-child-nodes="[[checkChildNodes]]" show-horizontal-divider="[[showHorizontalDivider]]" addable-levels="[[addableLevels]]">
                        </pebble-tree-node>
                    </template>
                </iron-list>
            </ul>
            </template>
        </iron-collapse>
    </template>
    <script>

        Polymer({

            is: 'pebble-tree-node',

            properties: {

                /**
                 * Indicates a navigation item.
                 */
                nodeData: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the parent of current navigation item.
                 */
                parentItem: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the currently selected item.
                 */
                selectedItem: {
                    type: Object,
                    notify: true
                },

                /**
                 * Indicates the currently selected item list.
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates  list of items for which atleast 1 of the child elements are selected .
                 */
                indeterminateItems: {
                    type: Array,
                    notify: true,
                    value: function() {return [];}
                },
                /**
                 * A reference to the selected element's node.
                 *
                 * @property selectedNode
                 * @type Object
                 */
                selectedNode: {
                    type: Object,
                    notify: true
                },
                /**
                 * A reference to the list of  selected elements' node. A node which is not yet rendered in the dom won't come in this list. For example, suppose element A has 5 child Elements. We select element A so the 5 child elements get selected but unless it is expanded once these elements node won't be added to dom and hence won't be a part of selectedNodes list.
                 *
                 * @property selectedNodes
                 * @type Object
                 */
                selectedNodes: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Path of the item which can be used to traverse to the element
                 *
                 * @property itemPath
                 * @type String
                 */
                itemPath:{
                    type:String
                },
                /**
                 * Specifies the default depth to which the tree will be expanded by default
                 */
                defaultExpandDepth :{
                    type: Number,
                    value:0
                },
                /**
                 * Specifies whether the current node is in expand mode or collapsed mode
                 */
                expanded:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies whether child elements are selected  or not on selecting parent elements
                 */
                checkChildNodes:{
                    type:Boolean,
                    value:false
                },
                /**
                 * A reference to the tree
                 */
                tree:{
                    type:Object,
                    value: function () {
                        return this;
                    }
                },
                /**
                 * Specifies whether or not to show horizental divider for parent nodes
                 */
                showHorizontalDivider:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies the level at which add buttons should be present so that new child elements can be added. e.g [1,2]
                 */
                addableLevels:{
                    type:Array,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Specifies whether the tree is disabled or not
                 */
                disabled:{
                    type:Boolean,
                    value:false
                }
            },
            observers:[
                '_defaultExpandDepthChanged(defaultExpandDepth,itemPath)',
                '_nodeDataExpandedChanged(nodeData.expanded)'
            ],

            /**
             *  Can be used to return `arrow-down`, if `item.expanded` is <b>true</b>. Otherwise,
             *  `arrow-right` is returned.
             *
             **/
            _arrowClass: function (item) {
                return (item) ? 'arrow-down' : 'arrow-right';
            },
            _expandClass: function (item) {
                return (item) ? 'expand-more' : 'pebble-icons:ExpandLess';
            },
            _isSelected : function(item,selectedItems) {
                if(selectedItems.indexOf(item) > -1){
                    if(this.selectedNodes.indexOf(this)==-1){
                        this.selectedNodes.push(this);
                    }
                    return true;
                } else {
                    var index=this.selectedNodes.indexOf(this);
                    if(index>-1){
                        this.splice('selectedNodes',index,1);
                    }

                    return false;
                }
            },
            _isIndeterminate: function (item,indeterminateItems) {
               return indeterminateItems.indexOf(item)>-1;
            },
            /**
             *  select the current Item. If checkChildNodes is set to true select child nodes also and make parent node indeterminate unless all the sibling nodes are also selected.
             */
            selectItem: function(){
                if(!this.disabled) {
                    var nodeData = this.nodeData;
                    if (this.selectedItems.indexOf(nodeData) == -1) {
                        this.push('selectedItems', nodeData);
                        this.selectedNodes.push(this);
                        if (this.checkChildNodes) {
                            if (this._hasChildren(nodeData)) {
                                this.checkAllChildNodes(nodeData);
                            }
                            if (this._allSiblingsSelected()) {
                                this.getParentNode().selectItem();
                            } else {
                                this._makeParentIndeterminate();
                            }
                        }
                        var indeterminateIndex = this.indeterminateItems.indexOf(nodeData);
                        if (indeterminateIndex > -1) {
                            this.splice('indeterminateItems', indeterminateIndex, 1);
                        }
                    }
                    this._notifySelectedItemChanges();
                }
            },
            /**
             *  Deselect the current Item. If checkChildNodes is set to true, deselect child nodes also and make parent node determinate unless at least 1 sibling nodes is selected.
             */
            deSelectItem: function () {
                if(!this.disabled) {
                    var index = this.selectedItems.indexOf(this.nodeData);
                    if (index > -1) {
                        this.splice('selectedItems', index, 1);
                    }
                    var nodeIndex = this.selectedNodes.indexOf(this);
                    if (nodeIndex > -1) {
                        this.splice('selectedNodes', nodeIndex, 1);
                    }
                    if (this.checkChildNodes) {
                        if (this._hasChildren(this.nodeData)) {
                            this.unCheckAllChildNodes(this.nodeData);
                        }
                        this._changeParentDeterminateState();
                    }
                    this._notifySelectedItemChanges();
                }
            },
            /**
             *  select all the child nodes without affecting the state of the parent node
             */
            checkAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    if(this.selectedItems.indexOf(children[i])==-1) {
                        this.push('selectedItems',children[i]);
                    }
                    if(this._hasChildren(children[i])) {
                        this.checkAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Deselect all the child nodes without affecting the state of the parent node
             */
            unCheckAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    var index=this.selectedItems.indexOf(children[i]);
                    if(index>-1) {
                        this.splice('selectedItems',index,1);
                    }
                    if(this._hasChildren(children[i])) {
                        this.unCheckAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  select all the child nodes and also change the state of parent element depending on the state of sibling elements. This will work only if the child elements are loaded in the dom.If not, use the checkAllChildNodes method
             */
            selectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    if(childNodes[i]) {
                        childNodes[i].selectItem();
                    }
                }
            },
            /**
             *  Deselect all the child nodes and also change the state of parent element depending on the state of sibling elements.This will work only if child elements are loaded in the dom.If not, use the unCheckAllChildNodes method
             */
            deSelectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    childNodes[i].deSelectItem();
                }
            },
            /**
             * Get all the child nodes of the current element.
             */
            getChildNodes: function () {
              var children=this.nodeData.children;
              var path=this.itemPath;
              var childNodes=[];
              for(var i=0;i<children.length;i++){
                  var childPath=path+"."+i;
                  childNodes.push(this.querySelector("pebble-tree-node[item-path='" + childPath + "']")) ;
              }
              return childNodes;
            },
            /**
             * Fired when an item is clicked. It sets the selected item and its style.
             */
            _itemClick: function (evt) {
                var nodeData=this.nodeData;
                if(this.multiSelect){
                    if (!this._isSelected(nodeData, this.selectedItems)) {
                        this.selectItem();
                    } else {
                        this.deSelectItem();
                    }
                } else {
                    var target = evt.target;
                    var prevSelectedItem = document.querySelector('.selected')
                    if (prevSelectedItem) {
                        prevSelectedItem.classList.remove('selected');
                    }
                    target.classList.add('selected');
                    this.selectedItem =nodeData;
                    this.selectedNode=this;
                    evt.preventDefault();
                }
            },

            /**
             * Fired when an item is added or removed from the selected item list.
             */
            _notifySelectedItemChanges: function () {
                var temp = this.selectedItems;
                this.selectedItems = undefined;
                this.selectedItems = temp;
                var temp1 = this.indeterminateItems;
                this.indeterminateItems = undefined;
                this.indeterminateItems = temp1;
            },


            /**
             * Fired when a menu is clicked on. It toggles the menu, and ensures the arrows on the menu are correct.
             */
            _toggle: function (evt) {
                this.$$('#collapse').toggle();
                this.expanded=!this.expanded;
                //To resize iron-list when navigation menu toggles
                this._resizeIronList();
                this.set('nodeData.addNewItem', false);
            },

            _addNewElement: function (evt) {
                if(!this.disabled) {
                    if (!this.expanded) {
                        this._toggle();
                    }
                    this.tree._resizeIronList();
                    this.async(function () {
                        var newItem = this.$$('#newItem');
                        if (newItem) {
                            newItem.focus();
                        }
                    });
                    this.set('nodeData.addNewItem', true);
                }
            },

            /**
             * Fired when enter key is pressed after creating a new node
             */
            _keyPressed: function (e) {
                var value = this.$$('#newItem').value;
                var newItem = {};
                newItem.text = value;
                if(!this.nodeData.children){
                    this.nodeData.children=[];
                }
                this.set('nodeData.addNewItem', false);
                this.$$('#newItem').value = '';
                this.unshift('nodeData.children', newItem);
                this._resizeIronList();
                this.async(function () {
                    if(this.newItemChecked){
                        this.getElementNodeByPath(this.itemPath+".0").selectItem();
                        this.newItemChecked=false;
                    } else{
                        this.getElementNodeByPath(this.itemPath+".0")._changeParentDeterminateState();
                    }
                });
                this.fire('new-item-added', {nodeData:newItem, path:this.itemPath + ".0"});
            },

            /**
             * Can be used to clear the selected item list and checkbox selection.
             */
            clearSelectedItems: function () {
                this.selectedItems = [];
                this.selectedNodes = [];
                this.indeterminateItems=[];
                //Clear selected items
                var selectionCheckboxList = this.querySelectorAll('pebble-checkbox');
                for (var idx = 0; idx < selectionCheckboxList.length; idx++) {
                    selectionCheckboxList[idx].checked = false;
                }
            },

            /**
             * Can be used to clear the selected item and style.
             */
            clearSelectedItem: function () {
                this.selectedItem = {};
                this.selectedNode=null;
                //Clear selected item
                var item = this.querySelector('.selected');
                if (item) {
                    item.classList.remove('selected');
                }
            },

            /**
             * Can be used to check whether the given item has children.
             */
            _hasChildren: function (item) {
                return item.hasChildren || (item.children && item.children.length > 0);
            },
            /**
             * Can be used to check whether the current node has children.
             */
            hasChildren: function () {
                return this.nodeData.hasChildren || (this.nodeData.children && this.nodeData.children.length > 0);
            },
            /**
             * Can be used to check whether icon has passed.
             */
            _iconPassed: function (item) {
                if (item.icon || item.src) {
                    return true;
                }
                return false;
            },

            _resizeIronList : function() {
                var ironList = Polymer.dom(this.root).querySelector("iron-list")
                    || Polymer.dom(this).querySelector("iron-list");
                if(ironList) {
                    ironList.notifyResize();
                }
            },
            /**
             *  get Parent element of the current item
             *
             */
            getParent: function () {
                if(this.parentItem.hasOwnProperty("text")) {
                    return this.parentItem;
                } else {
                    return null;
                }
            },
            /**
             *  get Parent node of the current node
             *
             */
            getParentNode: function () {
                var lastIndex = this.itemPath.lastIndexOf(".");
                var parentPath = this.itemPath.substring(0, lastIndex);
                return this.tree.getElementNodeByPath(parentPath);
            },
            _makeParentIndeterminate: function () {
                var parent= this.getParent();
                var index=this.selectedItems.indexOf(parent);
                if (index>-1){
                    this.splice('selectedItems',index,1);
                }
                if(parent &&  this.indeterminateItems.indexOf(parent)==-1) {
                    this.push('indeterminateItems', parent);
                    var parentNode=this.getParentNode();
                    parentNode._makeParentIndeterminate();
                }
            },
            _changeParentDeterminateState: function () {
                var parent= this.getParent();
                if(parent) {
                    var children = parent.children;
                    for(var i=0;i<children.length;i++){
                      if(this.selectedItems.indexOf(children[i]) > -1 || this.indeterminateItems.indexOf(children[i]) > -1 ){
                          this._makeParentIndeterminate();
                          return;
                      }
                    }
                    var parentNode = this.getParentNode();
                    var index = this.indeterminateItems.indexOf(parent);
                    if(index>-1) {
                        this.splice('indeterminateItems', index, 1);
                        parentNode._changeParentDeterminateState();
                    } else{
                        var selIndex=this.selectedItems.indexOf(parent);
                        if(selIndex>-1){
                            this.splice('selectedItems', selIndex, 1);
                            parentNode._changeParentDeterminateState();
                        }
                    }
                }
            },
            _setItemPath: function (index) {
                return this.itemPath+"."+index;
            },
            /**
             * Get the element's node from the tree given its path
             */
            getElementNodeByPath: function (path) {
                return this.tree.querySelector("pebble-tree-node[item-path='" + path + "']") ;
            },
            _defaultExpandDepthChanged: function (defaultExpandDepth,itemPath) {
                var currentLevel=(itemPath.length+1)/2;
                if(defaultExpandDepth>=currentLevel){
                    this.expanded=true;
                }
            },
            _nodeDataExpandedChanged: function (expanded) {
                if(expanded){
                    this.expanded=true;
                }
            },
            _allSiblingsSelected: function () {
                var parent = this.getParent();
                if (parent) {
                    var children = parent.children;
                    for (var i = 0; i < children.length; i++) {
                        if (this.selectedItems.indexOf(children[i]) == -1) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },
            /*
             *  Check if current level is addable nor not
             */
            isNotAddable: function (addableLevels) {
                var currentLevel=(this.itemPath.length+1)/2;
                if(this.addableLevels.indexOf(currentLevel)>-1){
                    return false;
                }
                return true;
            }
        });

    </script>
</dom-module>