<link rel="import" href="../../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html"/>
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html"/>
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<!--
`pebble-tree-node` Represents an individual tree list that is combined to make `rock-tree`.

@group Pebble Elements
@element pebble-tree-node
@demo demo/index.html
-->
<dom-module id="pebble-tree-node">
    <template>
        <style is="custom-style" include="pebble-styles-shared">
            .flex {
                display: flex;
                display: -webkit-flex; /* Safari */
                align-items: center;
                -webkit-align-items: center; /* Safari 7.0+ */
            }
            
            li {
                list-style: none;
                margin: 1px;
                padding: 2px;
                @apply(--pebble-tree-nodeitem);
            }

            li:hover,
            li a:hover {
                color: #0a9ec1;
                cursor: pointer;
                @apply(--pebble-tree-nodeitem-hover);
            }

            li:active {
                color: #086e87;
                @apply(--pebble-tree-nodeitem-active);
            }

            .selected {
                color: #0a9ec1;
                background-color: #eaeaea;
                border-left: 5px solid #0a9ec1;
                padding: 5px;
                @apply(--pebble-tree-nodeitem-selected);
            }

            ul {
                margin-left: 0;
                padding-left: 5px;
                @apply(--pebble-tree-node);
            }

            .arrow-down,
            .arrow-right {
                width: 0;
                height: 0;
                border-top: 5px solid transparent;
                border-bottom: 5px solid transparent;
                border-left: 8px solid;
                padding-right: 2px;
                margin-right: 5px;
                color: #0a9ec1;
                @apply(--pebble-tree-node-arrow);
            }

            .arrow-down {
                -webkit-transform: rotate(90deg);
                -ms-transform: rotate(90deg)
                transform: rotate(90deg)
            }

            pebble-checkbox {
                --pebble-checkbox-size: var(--tree-checkbox-size, 16px);
                --pebble-checkbox-unchecked-color: var(--tree-checkbox-border-color, #aaaaaa);
                --pebble-checkbox-checked-color: var(--tree-checkbox-color, #0a9ec1);
                --pebble-checkbox-checkmark-color: var(--tree-checkbox-checkmark-color);
            }

            iron-icon {
                --iron-icon-width: var(--tree-icon-width, 16px);
                --iron-icon-height: var(--tree-icon-height, 16px);
                --iron-icon-fill-color: var(--tree-icon-fill-color, #0a9ec1);
                --iron-icon-stroke-color: var(--tree-icon-stroke-color);
                @apply(--pebble-tree-icon);
            }

            pebble-button.iconButton {
                margin-right: 3px;
                --pebble-button: {
                    height: 28px;
                    min-width: 0.5em;
                    padding: 0.2em 0.2em 0.3em 0.2em;
                    color: #0a9ec1;
                }
            }
            .right{
                margin-left: auto;
            }
            .node-border {
                border-top: 1px solid #d2dbe4;
            }
            .nodetext{
                font-weight:bold;
            }
        </style>
        <template is="dom-if" if="[[!hasChildren(nodeData.*,itemPath)]]"  >
            <li class$="[[_getNodeClass(nodeData)]] p-l-30">
                <div class="check-box-wrapper p-l-20 p-r-10" on-tap = "_itemClick">
                    <pebble-checkbox hidden="[[!multiSelect]]" disabled="[[disabled]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*)]]"></pebble-checkbox>
                </div>
                <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]" hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                <a class$="nav-lnk" on-tap="_itemClick" >[[nodeData.text]]</a>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
        </template>
        <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]" >
            <li class$="[[_getNodeClass(nodeData)]]">
                <pebble-button class="iconButton" icon$="[[_expandClass(expanded)]]"  hidden="[[!multiSelect]]" on-click="_toggle" ></pebble-button>
                <div class="check-box-wrapper" on-tap = "_itemClick">
                    <pebble-checkbox hidden="[[!multiSelect]]" disabled="[[disabled]]" indeterminate="[[_isIndeterminate(nodeData,indeterminateItems,indeterminateItems.*)]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*)]]"></pebble-checkbox>
                </div>
                <div on-click="_toggle" class="flex">
                    <div id="arrow" hidden="[[multiSelect]]" class$="[[_arrowClass(expanded)]] arrow"
                        ></div>
                    <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]"
                            hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                    <div class="nodetext p-5">[[nodeData.text]]</div>
                </div>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
        </template>
        <iron-collapse id="collapse" opened$="[[expanded]]">
            <ul class="flex" hidden="[[!nodeData.addNewItem]]">
                <pebble-checkbox disabled="[[disabled]]" checked="{{newItemChecked}}"  hidden="[[!multiSelect]]"></pebble-checkbox>
                <pebble-textbox id="newItem" disabled="[[disabled]]" label="text input" no-label-float
                                on-change="_keyPressed" ></pebble-textbox>
            </ul>
            <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]" >
            <ul>
                    <template is="dom-repeat" id="childList"  items="[[_getChildren(searchKeyword,nodeData.*)]]" >
                        <pebble-tree-node disabled="[[disabled]]"  node-data="{{item}}" search-keyword="[[searchKeyword]]" default-expand-depth ="[[defaultExpandDepth]]" default-child-depth="[[defaultChildDepth]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                                           indeterminate-items="{{indeterminateItems}}"  multi-select="[[multiSelect]]"
                                           parent-item="{{nodeData}}" item-path$="[[_setItemPath(index)]]" selected-node="{{selectedNode}}" selected-nodes="{{selectedNodes}}"
                                           tree="[[tree]]" check-child-nodes="[[checkChildNodes]]" check-parent-nodes="[[checkParentNodes]]" addable-levels="[[addableLevels]]">
                        </pebble-tree-node>
                    </template>
            </ul>
            </template>
        </iron-collapse>
    </template>
    <script>

        Polymer({

            is: 'pebble-tree-node',

            properties: {

                /**
                 * Indicates the navigation item.
                 */
                nodeData: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the parent of current navigation item.
                 */
                parentItem: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the currently selected item.
                 */
                selectedItem: {
                    type: Object,
                    notify: true
                },

                /**
                 * Indicates the currently selected item-list.
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the list of items for which atleast one of the child elements are selected.
                 */
                indeterminateItems: {
                    type: Array,
                    notify: true,
                    value: function() {return [];}
                },
                /**
                 * Indicates the reference to the selected element's node.
                 *
                 * @property selectedNode
                 * @type Object
                 */
                selectedNode: {
                    type: Object,
                    notify: true
                },
                /**
                 * Indicates the reference to the list of selected elements' node. A node which is not yet rendered in the `dom` does not appear in this list. 
                 * For example, element A has five child elements. 
                 * Just selecting the element A does not select all five child elements. 
                 * You need to expand the same so that these elements get added to the `dom`. 
                 * That makes these elements a part of `selectedNodes` list.
                 *
                 * @property selectedNodes
                 * @type Object
                 */
                selectedNodes: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the path of the item which is used to traverse to the element.
                 *
                 * @property itemPath
                 * @type String
                 */
                itemPath:{
                    type:String,
                    observer: '_itemPathChanged'
                },
                /**
                 * Specifies the default depth to which the tree will be expanded by default.
                 */
                defaultExpandDepth :{
                    type: Number,
                    value:0
                },
                /**
                 * Specifies whether the current node is in expand mode or collapsed mode.
                 */
                expanded:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies whether child elements are selected or not on selecting the parent elements.
                 */
                checkChildNodes:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies whether parent elements are selected or not on selecting the child elements.
                 */
                checkParentNodes:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Indicates a reference to the tree.
                 */
                tree:{
                    type:Object,
                    value: function () {
                        return this;
                    }
                },
                /**
                 * Specifies the level at which add buttons should be present so that new child elements can be added. 
                 */
                addableLevels:{
                    type:Array,
                    value: function () {
                        return [];
                    }
                },
                defaultChildDepth:{
                    type:Number,
                    value:0
                },
                /**
                 * Specifies whether the tree is disabled or not
                 */
                disabled:{
                    type:Boolean,
                    value:false
                }
            },
            observers:[
                '_defaultExpandDepthChanged(defaultExpandDepth,itemPath)',
                '_nodeDataExpandedChanged(nodeData.expanded)'
            ],
            /**
             *  Can be used to return `arrow-down`, if `item.expanded` is <b>true</b>. Otherwise,
             *  `arrow-right` is returned.
             *
             **/
            _arrowClass: function (item) {
                return (item) ? 'arrow-down' : 'arrow-right';
            },
            _expandClass: function (item) {
                return (item) ? 'pebble-icons:Collapse' : 'pebble-icons:ExpandLess';
            },
            _isSelected : function(item,selectedItems) {
                if(selectedItems.indexOf(item) > -1){
                    if(this.selectedNodes.indexOf(this)==-1){
                        this.selectedNodes.push(this);
                        if (this.checkChildNodes) {
                            if (this._hasChildren(item)) {
                                this.checkAllChildNodes(item);
                            }
                            if (this._allSiblingsSelected()) {
                                var parentNode=this.getParentNode();
                                if(parentNode) {
                                    parentNode.selectItem();
                                }
                            } else {
                                this._makeParentIndeterminate();
                            }
                            this._notifySelectedItemChanges();
                        }
                    }
                    return true;
                } else {
                    var index=this.selectedNodes.indexOf(this);
                    if(index>-1){
                        this.splice('selectedNodes',index,1);
                    }

                    return false;
                }
            },
            _isIndeterminate: function (item,indeterminateItems) {
               return indeterminateItems.indexOf(item)>-1;
            },
            /**
             *  Can be used to select the current Item. 
             *  If `checkChildNodes` is set to true, then make sure to 
             *  select the child nodes and make the parent node as indeterminate unless all the sibling nodes are also selected.
             */
            selectItem: function(){
                if(!this.disabled) {
                    var nodeData = this.nodeData;
                    if (this.selectedItems.indexOf(nodeData) == -1) {
                        this.push('selectedItems', nodeData);
                        this.selectedNodes.push(this);
                        if (this.checkChildNodes) {
                            if (this._hasChildren(nodeData)) {
                                this.checkAllChildNodes(nodeData);
                            }
                            if (this._allSiblingsSelected()) {
                                var parentNode= this.getParentNode();
                                if(parentNode) {
                                    parentNode.selectItem();
                                }
                            } else {
                                this._makeParentIndeterminate();
                            }
                        }
                        if(this.checkParentNodes) {
                            if (this._allSiblingsSelected()) {
                                var parentNode= this.getParentNode();
                                if(parentNode) {
                                    parentNode.selectItem();
                                }
                            } else {
                                this._makeParentIndeterminate();
                            }
                        }
                        var indeterminateIndex = this.indeterminateItems.indexOf(nodeData);
                        if (indeterminateIndex > -1) {
                            this.splice('indeterminateItems', indeterminateIndex, 1);
                        }
                    }
                    this.fire('item-selected', {data: this});
                    this._notifySelectedItemChanges();
                }
            },
            /**
             *  Can be used de-select the current Item. If `checkChildNodes` is set to true, then make sure to 
             *  de-select the child nodes and make the parent node as determinate unless at least one sibling node is selected.
             */
            deSelectItem: function () {
                if(!this.disabled) {
                    var index = this.selectedItems.indexOf(this.nodeData);
                    if (index > -1) {
                        this.splice('selectedItems', index, 1);
                    }
                    var nodeIndex = this.selectedNodes.indexOf(this);
                    if (nodeIndex > -1) {
                        this.splice('selectedNodes', nodeIndex, 1);
                    }
                    if (this.checkChildNodes) {
                        if (this._hasChildren(this.nodeData)) {
                            this.unCheckAllChildNodes(this.nodeData);
                        }
                        this._changeParentDeterminateState();
                    }
                    this._notifySelectedItemChanges();
                }
            },
            /**
             *  Can be used to select all the child nodes without affecting the state of the parent node.
             */
            checkAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    if(this.selectedItems.indexOf(children[i])==-1) {
                        this.push('selectedItems',children[i]);
                    }
                    if(this._hasChildren(children[i])) {
                        this.checkAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes without affecting the state of the parent node.
             */
            unCheckAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    var index=this.selectedItems.indexOf(children[i]);
                    if(index>-1) {
                        this.splice('selectedItems',index,1);
                    }
                    if(this._hasChildren(children[i])) {
                        this.unCheckAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to select all the child nodes and also change the state of parent element depending on the state of the sibling elements. 
             *  This works only if the child elements are loaded in the `dom`. If not, use the `checkAllChildNodes` method.
             */
            selectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    if(childNodes[i]) {
                        childNodes[i].selectItem();
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes and also change the state of the parent elements depending on the state of sibling elements.
             *  This works only if child elements are loaded in the `dom`. If not, use the `unCheckAllChildNodes` method.
             */
            deSelectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    childNodes[i].deSelectItem();
                }
            },
            /**
             * Can be used to get all the child nodes of the current element.
             */
            getChildNodes: function () {
              var children=this.nodeData.children;
              var path=this.itemPath;
              var childNodes=[];
              for(var i=0;i<children.length;i++){
                  var childPath=path+"."+i;
                  childNodes.push(this.querySelector("pebble-tree-node[item-path='" + childPath + "']")) ;
              }
              return childNodes;
            },
            /**
             * Fired when an item is clicked. It sets the selected item and its style.
             */
            _itemClick: function (evt) {
                var nodeData=this.nodeData;
                if(this.multiSelect){
                    if (this.selectedItems.indexOf(nodeData)==-1) {
                        this.selectItem();
                    } else {
                        this.deSelectItem();
                    }
                } else {
                    var target = evt.target;
                    var prevSelectedItem = document.querySelector('.selected')
                    if (prevSelectedItem) {
                        prevSelectedItem.classList.remove('selected');
                    }
                    target.classList.add('selected');
                    this.selectedItem =nodeData;
                    this.selectedNode=this;
                    evt.preventDefault();
                }
            },

            /**
             * Fired when an item is added or removed from the selected item list.
             */
            _notifySelectedItemChanges: function () {
                var temp = this.selectedItems;
                this.selectedItems = undefined;
                this.selectedItems = temp;
                var temp1 = this.indeterminateItems;
                this.indeterminateItems = undefined;
                this.indeterminateItems = temp1;
            },


            /**
             * Fired when a menu is clicked on. It toggles the menu, and ensures the arrows on the menu are correct.
             */
            _toggle: function (evt) {
                this.fire('tree-node-expanded',this);
                this.$$('#collapse').toggle();
                this.expanded=!this.expanded;
                this.set('nodeData.addNewItem', false);
            },

            _addNewElement: function (evt) {
                if(!this.disabled) {
                    if (!this.expanded) {
                        this._toggle();
                    }
                    this.async(function () {
                        var newItem = this.$$('#newItem');
                        if (newItem) {
                            newItem.focus();
                        }
                    });
                    this.set('nodeData.addNewItem', true);
                }
            },

            /**
             * Fired when enter key is pressed after creating a new node
             */
            _keyPressed: function (e) {
                var value = this.$$('#newItem').value;
                var newItem = {};
                newItem.text = value;
                if(!this.nodeData.children){
                    this.nodeData.children=[];
                }
                this.set('nodeData.addNewItem', false);
                this.$$('#newItem').value = '';
                this.unshift('nodeData.children', newItem);
                this.async(function () {
                    if(this.newItemChecked){
                        this.tree.getElementNodeByPath(this.itemPath+".0").selectItem();
                        this.newItemChecked=false;
                    } else{
                        this.tree.getElementNodeByPath(this.itemPath+".0")._changeParentDeterminateState();
                    }
                });
                this.refreshChildList();
                this.fire('new-item-added', {nodeData:newItem, path:this.itemPath + ".0"});
            },

            /**
             * Can be used to clear the selected item list and checkbox selection.
             */
            clearSelectedItems: function () {
                this.selectedItems = [];
                this.selectedNodes = [];
                this.indeterminateItems=[];
                //Clear selected items
                var selectionCheckboxList = this.querySelectorAll('pebble-checkbox');
                for (var idx = 0; idx < selectionCheckboxList.length; idx++) {
                    selectionCheckboxList[idx].checked = false;
                }
            },

            /**
             * Can be used to clear the selected item and style.
             */
            clearSelectedItem: function () {
                this.selectedItem = {};
                this.selectedNode=null;
                //Clear selected item
                var item = this.querySelector('.selected');
                if (item) {
                    item.classList.remove('selected');
                }
            },

            /**
             * Can be used to check whether the given item has children.
             */
            _hasChildren: function (item) {
                return item.hasChildren || (item.children && item.children.length > 0);
            },
            /**
             * Can be used to check whether the current node has children.
             */
            hasChildren: function () {
                if(this.itemPath) {
                    var currentLevel = (this.itemPath.length + 1) / 2;
                }
                if(currentLevel<=this.defaultChildDepth){
                    return true;
                }
                return this.nodeData.children && this.nodeData.children.length > 0;
            },
            /**
             * Can be used to check whether an icon is passed.
             */
            _iconPassed: function (item) {
                if (item.icon || item.src) {
                    return true;
                }
                return false;
            },
            /**
             *  Can be used to get the parent element of the current item.
             *
             */
            getParent: function () {
                if(this.parentItem.hasOwnProperty("text")) {
                    return this.parentItem;
                } else {
                    return null;
                }
            },
            /**
             *  Can be used to get the parent node of the current node.
             *
             */
            getParentNode: function () {
                var lastIndex = this.itemPath.lastIndexOf(".");
                var parentPath = this.itemPath.substring(0, lastIndex);
                return this.tree.getElementNodeByPath(parentPath);
            },
            _makeParentIndeterminate: function () {
                var parent= this.getParent();
                var index=this.selectedItems.indexOf(parent);
                if (index>-1){
                    this.splice('selectedItems',index,1);
                }
                if(parent &&  this.indeterminateItems.indexOf(parent)==-1) {
                    this.push('indeterminateItems', parent);
                    var parentNode=this.getParentNode();
                    if(parentNode) {
                        parentNode._makeParentIndeterminate();
                    }
                }
            },
            _changeParentDeterminateState: function () {
                var parent= this.getParent();
                if(parent) {
                    var children = parent.children;
                    for(var i=0;i<children.length;i++){
                      if(this.selectedItems.indexOf(children[i]) > -1 || this.indeterminateItems.indexOf(children[i]) > -1 ){
                          this._makeParentIndeterminate();
                          return;
                      }
                    }
                    var parentNode = this.getParentNode();
                    var index = this.indeterminateItems.indexOf(parent);
                    if(index>-1) {
                        this.splice('indeterminateItems', index, 1);
                        if(parentNode) {
                            parentNode._changeParentDeterminateState();
                        }
                    } else{
                        var selIndex=this.selectedItems.indexOf(parent);
                        if(selIndex>-1){
                            this.splice('selectedItems', selIndex, 1);
                            if(parentNode) {
                                parentNode._changeParentDeterminateState();
                            }
                        }
                    }
                }
            },
            _setItemPath: function (index) {
                return this.itemPath+"."+index;
            },
            /**
             * Can be used to get the element's node from its path in the tree.
             */
            getElementNodeByPath: function (path) {
                return this.tree.querySelector("pebble-tree-node[item-path='" + path + "']") ;
            },
            _defaultExpandDepthChanged: function (defaultExpandDepth,itemPath) {
                var currentLevel=(itemPath.length+1)/2;
                if(defaultExpandDepth>=currentLevel){
                    this.expanded=true;
                }
            },
            _nodeDataExpandedChanged: function (expanded) {
                if(expanded){
                    this.expanded=true;
                }
            },
            _allSiblingsSelected: function () {
                var parent = this.getParent();
                if (parent) {
                    var children = parent.children;
                    for (var i = 0; i < children.length; i++) {
                        if (this.selectedItems.indexOf(children[i]) == -1) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },
            /*
             *  Can be used to check if current level is addable nor not.
             */
            isNotAddable: function (addableLevels) {
                var currentLevel=(this.itemPath.length+1)/2;
                if(this.addableLevels.indexOf(currentLevel)>-1){
                    return false;
                }
                return true;
            },
            _getChildren:function (searchKeyword) {
                    var navArr=this.nodeData.children;
                    if(!navArr){
                        return [];
                    }
                    if(!searchKeyword || searchKeyword==""){
                        return navArr;
                    }
                    var foundItems=[];
                    var len=navArr.length;
                    for (var i = 0;  i < len; i++) {
                        if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1 ) {
                            foundItems.push(navArr[i]);
                            continue;
                        }
                        var childMatch=false;
                        if (navArr[i].children) {
                            childMatch = this.tree._checkChildMatch(navArr[i].children, searchKeyword);
                        }
                        if (childMatch) {
                            foundItems.push(navArr[i]);
                        }
                    }
                    if(foundItems.length>0){
                            this.expanded = true;
                    }
                    return foundItems;
            },
            /*
             * Refresh the tree node in case there in any change in the children data
             */
            refreshChildList:function () {
                this.$$("#childList").render();
            },
            _getNodeClass: function(nodeData) {
                if(nodeData.border) {
                    return "flex node-border";
                }
                else {
                    return "flex";
                }
            },
            _itemPathChanged: function(itemPath) {
                this.fire('node-expanded',this);
            }
        });

    </script>
</dom-module>