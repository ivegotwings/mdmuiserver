<link rel="import" href="../../../bower_components/polymer/polymer.html"/>
<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html"/>
<link rel="import" href="../../../bower_components/iron-icon/iron-icon.html"/>
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">

<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<!--
`pebble-tree-node` Represents an individual tree list that is combined to make the `rock-tree`.

@group Pebble Elements
@element pebble-tree-node
@demo demo/index.html
-->
<dom-module id="pebble-tree-node">
    <template>
        <style is="custom-style" include="pebble-styles-shared">
            .flex {
                display: -webkit-box;
                display: -webkit-flex;
                display: -ms-flexbox;
                display: flex;
                align-items: center;
                -webkit-align-items: center; /* Safari 7.0+ */
            }
            
            li {
                list-style: none;
                -webkit-transition: all 0.3s;
                -moz-transition: all 0.3s;
                -o-transition: all 0.3s;
                transition: all 0.3s;
            }

            li:hover,
            li a:hover {
                color: var(--dropdown-selected-font, #036bc3);
                cursor: pointer;
                @apply(--pebble-tree-nodeitem-hover);
            }

            li:active {
                color: #086e87;
                @apply(--pebble-tree-nodeitem-active);
            }

            .selected {
                color: var(--dropdown-selected-font, #036bc3);
                background-color: #eaeaea;
                border-left: 5px solid var(--dropdown-selected-font, #036bc3);
                padding: 5px;
                @apply(--pebble-tree-nodeitem-selected);
            }

            ul {
                margin: 5px 0 5px 0;
                @apply(--pebble-tree-node);
            }

            .arrow-down,
            .arrow-right {
                width: 0;
                height: 0;
                border-top: 5px solid transparent;
                border-bottom: 5px solid transparent;
                border-left: 8px solid;
                padding-right: 2px;
                margin-right: 5px;
                color: #0a9ec1;
                @apply(--pebble-tree-node-arrow);
            }

            .arrow-down {
                -webkit-transform: rotate(90deg);
                -ms-transform: rotate(90deg)
                transform: rotate(90deg)
            }

            pebble-button.iconButton {
                --pebble-button: {
                    height: 30px;
                    min-width: 0.5em;
                    padding: 0.2em 0.2em 0.3em 0.2em;
                    color: var(--primary-icon-color, #75808b);
                }
            }
            .right{
                margin-left: auto;
            }
            .node-border {
                border-top: 1px solid var(--default-border-color, #c1cad4);
                border-bottom: 1px solid var(--default-border-color, #c1cad4);
                margin-top: -1px;
            }
            .nodetext{
                font-weight:bold;
            }
            .check-box-wrapper{
                margin: 4px 10px 0 15px;
            }
            iron-icon{
                height: 16px !important;
                width: 16px !important;
            }
        </style>
        <template is="dom-if" if="[[!hasChildren(nodeData.*,itemPath)]]"  >
            <li class$="[[_getNodeClass(nodeData)]]">
                <div class="check-box-wrapper">
                    <pebble-checkbox on-tap = "_itemClick"  disabled="[[disabled]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*,selectedItem)]]"></pebble-checkbox>
                </div>
                <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]" hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                <a class$="nav-lnk"  >[[nodeData.text]]</a>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
        </template>
        <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]" >
            <li class$="[[_getNodeClass(nodeData)]]">
                <pebble-button class="iconButton pebble-md-icons" icon$="[[_expandClass(expanded)]]"  on-click="_toggle" ></pebble-button>
                <template is="dom-if" if="[[!leafNodeOnly]]">
                    <div class="check-box-wrapper" >
                        <pebble-checkbox  on-tap = "_itemClick" disabled="[[disabled]]" indeterminate="[[_isIndeterminate(nodeData,indeterminateItems,indeterminateItems.*)]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*,selectedItem)]]"></pebble-checkbox>
                    </div>
                </template>
                <div  class="flex">
                    <!--<div id="arrow" on-click="_toggle" hidden="[[multiSelect]]" class$="[[_arrowClass(expanded)]] arrow"-->
                        <!--&gt;</div>-->
                    <iron-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]"
                            hidden="[[!_iconPassed(nodeData)]]"></iron-icon>
                    <div class="nodetext">[[nodeData.text]]</div>
                </div>
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-button class="iconButton" icon="icons:add-circle" on-tap="_addNewElement"></pebble-button>
                </div>
            </li>
        </template>
        <iron-collapse id="collapse" opened$="[[expanded]]">
            <ul class="flex" hidden="[[!nodeData.addNewItem]]">
                <pebble-checkbox disabled="[[disabled]]" checked="{{newItemChecked}}"  hidden="[[!multiSelect]]"></pebble-checkbox>
                <pebble-textbox id="newItem" disabled="[[disabled]]" label="text input" no-label-float
                                on-change="_keyPressed" ></pebble-textbox>
            </ul>
            <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]" >
            <ul>
                <pebble-spinner active="[[_loading]]"></pebble-spinner>
                <template is="dom-repeat" id="childList"  items="[[_getChildren(searchKeyword,nodeData.*)]]" >
                        <pebble-tree-node disabled="[[disabled]]"  node-data="{{item}}" search-keyword="[[searchKeyword]]" default-expand-depth ="[[defaultExpandDepth]]" default-child-depth="[[defaultChildDepth]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                                           indeterminate-items="{{indeterminateItems}}"  multi-select="[[multiSelect]]"
                                           parent-item="{{nodeData}}" parent-tree-node="[[_setParentTreeNode()]]" item-path$="[[_setItemPath(index)]]" value-path$="[[item.valuePath]]" selected-node="{{selectedNode}}" selected-nodes="{{selectedNodes}}"
                                           tree="[[tree]]" check-child-nodes="[[checkChildNodes]]"  check-parent-nodes="[[checkParentNodes]]" addable-levels="[[addableLevels]]">
                        </pebble-tree-node>
                    </template>
            </ul>
            </template>
        </iron-collapse>
    </template>
    <script>

        Polymer({

            is: 'pebble-tree-node',

            properties: {

                /**
                 * Indicates the navigation item.
                 */
                nodeData: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the parent of current navigation item.
                 */
                parentItem: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the currently selected item.
                 */
                selectedItem: {
                    type: Object,
                    notify: true,
                    value:function () {
                        return {};
                    }
                },

                /**
                 * Indicates the currently selected item-list.
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the list of items for which atleast one of the child elements are selected.
                 */
                indeterminateItems: {
                    type: Array,
                    notify: true,
                    value: function() {return [];}
                },
                /**
                 * Indicates the reference to the selected element's node.
                 *
                 * @property selectedNode
                 * @type Object
                 */
                selectedNode: {
                    type: Object,
                    notify: true
                },
                /**
                 * Indicates the reference to the list of selected elements' node. A node which is not yet rendered in the `dom` does not appear in this list. 
                 * For example, element A has five child elements. 
                 * Just selecting the element A does not select all five child elements. 
                 * You need to expand the same so that these elements get added to the `dom`. 
                 * That makes these elements a part of `selectedNodes` list.
                 *
                 * @property selectedNodes
                 * @type Object
                 */
                selectedNodes: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the path of the item which is used to traverse to the element.
                 *
                 * @property itemPath
                 * @type String
                 */
                itemPath:{
                    type:String
                },
                /**
                 * Indicates the value path of the item which is used to traverse to the element.
                 *
                 * @property valuePath
                 * @type String
                 */
                valuePath:{
                    type:String
                },
                /**
                 * Specifies the default depth to which the tree will be expanded by default.
                 */
                defaultExpandDepth :{
                    type: Number,
                    value:0
                },
                /**
                 * Specifies whether the current node is in the "expand" or "collapsed" mode.
                 */
                expanded:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies whether child elements are selected or not on selecting the parent elements.
                 */
                checkChildNodes:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies whether child elements are selected or not on selecting the parent elements.
                 */
                checkParentNodes:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Indicates a reference to the tree.
                 */
                tree:{
                    type:Object,
                    value: function () {
                        return this;
                    }
                },
                /**
                 * Specifies the level at which add buttons should be present so that new child elements can be added. 
                 */
                addableLevels:{
                    type:Array,
                    value: function () {
                        return [];
                    }
                },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
                defaultChildDepth:{
                    type:Number,
                    value:0
                },
                /**
                 * Specifies whether or not the tree is disabled.
                 */
                disabled:{
                    type:Boolean,
                    value:false
                },
                /**
                 * Specifies the parent node of the current node in tree.
                 **/
                parentTreeNode: {
                    type: Element
                },
                /**
                 * Indicates that pushing of items in control is in progress
                 */
                _loading: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /**
                * Specifies whether or not only leaf-node selection is enabled.
                */
                leafNodeOnly:{
                    type:Boolean,
                    value:false
                }
            },
            observers:[
                '_defaultExpandDepthChanged(defaultExpandDepth,itemPath)',
                '_nodeDataExpandedChanged(nodeData.expanded)'
            ],
            behaviors: [
                RUFBehaviors.UIBehavior
            ],
            /**
             *  Can be used to return `arrow-down`, if `item.expanded` is <b>true</b>. Otherwise,
             *  `arrow-right` is returned.
             *
             **/
            _arrowClass: function (item) {
                return (item) ? 'arrow-down' : 'arrow-right';
            },
            _expandClass: function (item) {
                return (item) ? 'pebble-sm-icons:Expand' : 'pebble-sm-icons:Collapse';
            },
            _isSelected : function(item,selectedItems) {
                if(!this.multiSelect){
                    return (this.selectedItem==this.nodeData);
                }
                if(selectedItems.indexOf(item) > -1){
                    if(this.selectedNodes.indexOf(this)==-1){
                        this.selectedNodes.push(this);
                        if(this.checkParentNodes){
                            this._makeParentIndeterminate();
                            this._notifySelectedItemChanges();
                        } else if (this.checkChildNodes) {
                            if (this._hasChildren(item)) {
                                this.checkAllChildNodes(item);
                            }
                            if (this._allSiblingsSelected()) {
                                var parentNode=this.getParentNode();
                                if(parentNode) {
                                    parentNode.selectItem();
                                }
                            } else {
                                this._makeParentIndeterminate();
                            }
                            this._notifySelectedItemChanges();
                        }
                    }
                    return true;
                } else {
                    var index=this.selectedNodes.indexOf(this);
                    if(index>-1){
                        this.splice('selectedNodes',index,1);
                    }

                    return false;
                }
            },
            _isIndeterminate: function (item,indeterminateItems) {
               return indeterminateItems.indexOf(item)>-1;
            },
            /**
             *  Can be used to select the current Item. 
             *  If `checkChildNodes` is set to true, then make sure to 
             *  select the child nodes and make the parent node as indeterminate unless all the sibling nodes are also selected.
             */
            selectItem: function(){
                if(!this.disabled) {
                    var nodeData = this.nodeData;
                    this.nodeData.valuePath=this.valuePath;
                    if(!this.multiSelect){
                        this.selectedItem = nodeData;
                        this.selectedNode = this;
                        this.indeterminateItems=[];
                        if(this.checkParentNodes){
                            this._makeParentIndeterminate();
                        }
                    } else {
                        if (this.selectedItems.indexOf(nodeData) == -1) {
                            this.push('selectedItems', nodeData);
                            this.selectedNodes.push(this);
                            if (this.checkParentNodes) {
                                this._makeParentIndeterminate();
                            } else if (this.checkChildNodes) {
                                if (this._hasChildren(nodeData)) {
                                    this.checkAllChildNodes(nodeData);
                                }
                                if (this._allSiblingsSelected()) {
                                    var parentNode = this.getParentNode();
                                    if (parentNode) {
                                        parentNode.selectItem();
                                    }
                                } else {
                                    this._makeParentIndeterminate();
                                }
                                var indeterminateIndex = this.indeterminateItems.indexOf(nodeData);
                                if (indeterminateIndex > -1) {
                                    this.splice('indeterminateItems', indeterminateIndex, 1);
                                }
                            }
                        }
                        this._notifySelectedItemChanges();
                    }
                }
            },
            /**
             *  Can be used de-select the current Item. If `checkChildNodes` is set to true, then make sure to 
             *  de-select the child nodes and make the parent node as determinate unless at least one sibling node is selected.
             */
            deSelectItem: function () {
                if(!this.disabled) {
                    if(!this.multiSelect){
                        this.selectedItem={};
                        this.selectedNode=undefined;
                        if (this.checkParentNodes) {
                            this._changeParentDeterminateState();
                        }
                    } else {
                        var index = this.selectedItems.indexOf(this.nodeData);
                        if (index > -1) {
                            this.splice('selectedItems', index, 1);
                        }
                        var nodeIndex = this.selectedNodes.indexOf(this);
                        if (nodeIndex > -1) {
                            this.splice('selectedNodes', nodeIndex, 1);
                        }
                        if (this.checkParentNodes) {
                            this._changeParentDeterminateState();
                        } else if (this.checkChildNodes) {
                            if (this._hasChildren(this.nodeData)) {
                                this.unCheckAllChildNodes(this.nodeData);
                            }
                            this._changeParentDeterminateState();
                        }
                        this._notifySelectedItemChanges();
                    }
                }
            },
            /**
             *  Can be used to select all the child nodes without affecting the state of the parent node.
             */
            checkAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    if(this.selectedItems.indexOf(children[i])==-1) {
                        this.push('selectedItems',children[i]);
                    }
                    if(this._hasChildren(children[i])) {
                        this.checkAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes without affecting the state of the parent node.
             */
            unCheckAllChildNodes: function (nodeData) {
                var children=nodeData.children;
                for(var i=0;i<children.length;i++){
                    var index=this.selectedItems.indexOf(children[i]);
                    if(index>-1) {
                        this.splice('selectedItems',index,1);
                    }
                    if(this._hasChildren(children[i])) {
                        this.unCheckAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to select all the child nodes and also change the state of parent element depending on the state of the sibling elements. 
             *  This works only if the child elements are loaded in the `dom`. If not, use the `checkAllChildNodes` method.
             */
            selectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    if(childNodes[i]) {
                        childNodes[i].selectItem();
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes and change the state of the parent elements depending on the state of sibling elements.
             *  This works only if the child elements are loaded in the `dom`. If not, use the `unCheckAllChildNodes` method.
             */
            deSelectChildNodes: function () {
                var childNodes=this.getChildNodes();
                for(var i=0;i<childNodes.length;i++){
                    childNodes[i].deSelectItem();
                }
            },
            /**
             * Can be used to get all the child nodes of the current element.
             */
            getChildNodes: function () {
              var children=this.nodeData.children;
              var path=this.itemPath;
              var childNodes=[];
              for(var i=0;i<children.length;i++){
                  var childPath=path+"."+i;
                  var childNode=this.$$("pebble-tree-node[item-path='" + childPath + "']");
                  if(childNode) {
                      childNodes.push(childNode);
                  }
              }
              return childNodes;
            },
            /**
             * Fired when an item is clicked. It sets the selected item and its style.
             */
            _itemClick: function (evt) {
                var nodeData=this.nodeData;
                if(this.multiSelect){
                    if (this.selectedItems.indexOf(nodeData)==-1) {
                        this.selectItem();
                        this.fire('item-selected', {data: this});
                    } else {
                        this.deSelectItem();
                    }
                } else {
                    if(this.selectedItem ==nodeData){
                        this.deSelectItem();
                    } else {
                       this.selectItem();
                    }
                }
            },

            /**
             * Fired when an item is added or removed from the selected item list.
             */
            _notifySelectedItemChanges: function () {
                var temp = this.selectedItems;
                this.selectedItems = undefined;
                this.selectedItems = temp;
                var temp1 = this.indeterminateItems;
                this.indeterminateItems = undefined;
                this.indeterminateItems = temp1;
            },


            /**
             * Fired when a menu is clicked on. It toggles the menu, and ensures the arrows on the menu are correct.
             */
            _toggle: function (evt) {
                this.fire('tree-node-expanded',this);
                this.$$('#collapse').toggle();
                this.expanded=!this.expanded;
                this.set('nodeData.addNewItem', false);
            },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
            expand: function (evt) {
                this.fire('tree-node-expanded',this);
                if(!this.expanded) {
                    this.$$('#collapse').toggle();
                    this.expanded = true;
                    this.set('nodeData.addNewItem', false);
                }
            },

            _addNewElement: function (evt) {
                if(!this.disabled) {
                    if (!this.expanded) {
                        this._toggle();
                    }
                    this.async(function () {
                        var newItem = this.$$('#newItem');
                        if (newItem) {
                            newItem.focus();
                        }
                    });
                    this.set('nodeData.addNewItem', true);
                }
            },

            /**
             * Fired when enter key is pressed after creating a new node
             */
            _keyPressed: function (e) {
                var value = this.$$('#newItem').value;
                var newItem = {};
                newItem.text = value;
                if(!this.nodeData.children){
                    this.nodeData.children=[];
                }
                this.set('nodeData.addNewItem', false);
                this.$$('#newItem').value = '';
                this.unshift('nodeData.children', newItem);
                this.async(function () {
                    if(this.newItemChecked){
                        this.getElementNodeByPath(this.itemPath+".0").selectItem();
                        this.newItemChecked=false;
                    } else{
                        this.getElementNodeByPath(this.itemPath+".0")._changeParentDeterminateState();
                    }
                });
                this.refreshChildList();
                this.fire('new-item-added', {nodeData:newItem, path:this.itemPath + ".0"});
            },

            /**
             * Can be used to clear the selected item list and checkbox selection.
             */
            clearSelectedItems: function () {
                this.selectedItems = [];
                this.selectedNodes = [];
                this.indeterminateItems=[];
                //Clear selected items
                var selectionCheckboxList = this.querySelectorAll('pebble-checkbox');
                for (var idx = 0; idx < selectionCheckboxList.length; idx++) {
                    selectionCheckboxList[idx].checked = false;
                }
            },

            /**
             * Can be used to clear the selected item and style.
             */
            clearSelectedItem: function () {
                this.selectedItem = {};
                this.selectedNode=null;
                //Clear selected item
                var item = this.querySelector('.selected');
                if (item) {
                    item.classList.remove('selected');
                }
            },

            /**
             * Can be used to check whether the given item has children.
             */
            _hasChildren: function (item) {
                return item.hasChildren || (item.children && item.children.length > 0);
            },
            /**
             * Can be used to check whether the current node has children.
             */
            hasChildren: function () {
                if(this.itemPath) {
                    var currentLevel = (this.itemPath.length + 1) / 2;
                }
                if(!this._changeToLeafMode &&currentLevel<=this.defaultChildDepth){
                    return true;
                }
                return this.nodeData.children && this.nodeData.children.length > 0;
            },
            /**
             * Can be used to check whether an icon is passed.
             */
            _iconPassed: function (item) {
                if (item.icon || item.src) {
                    return true;
                }
                return false;
            },
            /**
             *  Can be used to get the parent element of the current item.
             *
             */
            getParent: function () {
                if(this.parentItem.hasOwnProperty("text")) {
                    return this.parentItem;
                } else {
                    return null;
                }
            },
            /**
             *  Can be used to get the parent node of the current node.
             *
             */
            getParentNode: function () {
                var lastIndex = this.valuePath.lastIndexOf("#@#");
                var parentPath = this.valuePath.substring(0, lastIndex);
                return this.tree.getElementNodeByPath(parentPath);
            },
            _makeParentIndeterminate: function () {
                var parent= this.getParent();
                var index=this.selectedItems.indexOf(parent);
                if (index>-1){
                    this.splice('selectedItems',index,1);
                }
                if(parent &&  this.indeterminateItems.indexOf(parent)==-1) {
                    this.push('indeterminateItems', parent);
                    var parentNode=this.getParentNode();
                    if(parentNode) {
                        parentNode._makeParentIndeterminate();
                    }
                }
            },
            _changeParentDeterminateState: function () {
                var parent= this.getParent();
                if(parent) {
                    var children = parent.children;
                    for(var i=0;i<children.length;i++){
                      if(this.selectedItems.indexOf(children[i]) > -1 || this.indeterminateItems.indexOf(children[i]) > -1 ){
                          this._makeParentIndeterminate();
                          return;
                      }
                    }
                    var parentNode = this.getParentNode();
                    var index = this.indeterminateItems.indexOf(parent);
                    if(index>-1) {
                        this.splice('indeterminateItems', index, 1);
                        if(parentNode) {
                            parentNode._changeParentDeterminateState();
                        }
                    } else{
                        var selIndex=this.selectedItems.indexOf(parent);
                        if(selIndex>-1){
                            this.splice('selectedItems', selIndex, 1);
                            if(parentNode) {
                                parentNode._changeParentDeterminateState();
                            }
                        }
                    }
                }
            },
            _setItemPath: function (index) {
                return this.itemPath+"."+index;
            },
            /**
             * Can be used to get the element's node from its path in the tree.
             */
            getElementNodeByPath: function (path) {
                return this.tree.querySelector("pebble-tree-node[item-path='" + path + "']") ;
            },
            _defaultExpandDepthChanged: function (defaultExpandDepth,itemPath) {
                var currentLevel=(itemPath.length+1)/2;
                if(defaultExpandDepth>=currentLevel){
                    this.expanded=true;
                }
            },
            _nodeDataExpandedChanged: function (expanded) {
                if(expanded){
                    this.expanded=true;
                }
            },
            _allSiblingsSelected: function () {
                var parent = this.getParent();
                if (parent) {
                    var children = parent.children;
                    for (var i = 0; i < children.length; i++) {
                        if (this.selectedItems.indexOf(children[i]) == -1) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },
            /*
             *  Can be used to check if the current level is addable nor not.
             */
            isNotAddable: function (addableLevels) {
                var currentLevel=(this.itemPath.length+1)/2;
                if(this.addableLevels.indexOf(currentLevel)>-1){
                    return false;
                }
                return true;
            },
            _getChildren:function (searchKeyword) {
                    var navArr=this.nodeData.children;
                    var children = [];
                    if(!searchKeyword || searchKeyword==""){
                        children = navArr;
                    }
                    var foundItems=[];
                    if(navArr && navArr.length > 0) {
                        var len=navArr.length;
                        for (var i = 0;  i < len; i++) {
                            if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1 ) {
                                foundItems.push(navArr[i]);
                                continue;
                            }
                            var childMatch=false;
                            if (navArr[i].children) {
                                childMatch = this.tree._checkChildMatch(navArr[i].children, searchKeyword);
                            }
                            if (childMatch) {
                                foundItems.push(navArr[i]);
                            }
                        }
                    }
                    if(foundItems.length>0){
                            this.expanded = true;
                    }
                    children = foundItems;

                    if(children.length > 0) {
                        for(var i=0; i < children.length; i++) {
                            var child = children[i];
                            child.valuePath = this._computeValuePath(child);
                        }
                    }
                    return children;
            },
            /*
             * Can be used to refresh the tree node if there are any changes in the "child" node data.
             */
            refreshChildList:function () {
                this.$$("#childList").render();
                this._loading=false;
                this.fireBedrockEvent('tree-node-child-list-refreshed',this,{"ignoreId":true});
            },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
            changeToLeafMode:function () {
              this._changeToLeafMode=true;
            },
            _getNodeClass: function(nodeData) {
                if(nodeData.border) {
                    return "flex node-border";
                }
                else {
                    return "flex";
                }
            },
            _computeValuePath: function(nodeData) {
                return this.valuePath + "#@#" + nodeData.value;
            },
            _setParentTreeNode: function() {
                return this;
            },
            /**
             * Can be used to collapse the current node.
             **/
            collapse: function() {
                this.expanded = false;
            },
            /**
             * Can be used to select the parent node of the current node.
             **/
            selectParentNode: function() {
                var parentNode = this.getParentNode();
                if(parentNode) {
                    parentNode.selectItem();
                }
            },
             /**
             * Can be used to select all parent nodes, grand parent nodes of the current node
             **/
            selectAllParentNodes: function() {
                var parentNode = this.getParentNode();
                if(parentNode) {
                    parentNode.selectItem();
                    parentNode.selectAllParentNodes();
                }
            },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
            isTreeNodeSelected: function (nodeData) {
                var data=this.selectedItems.find(function (item) {
                    if(item.text==nodeData.text) {
                        if (nodeData.value || data.value) {
                            return nodeData.value == data.value;
                        }
                        return true;
                    } else{
                        return false;
                    }
                })
            },
          /**
            * <b><i>Content development is under progress... </b></i> 
            */
            startLoading:function () {
                this._loading=true;
            }
        });

    </script>
</dom-module>