<link rel="import" href="../../../bower_components/polymer/polymer.html" />
<link rel="import" href="../../../bower_components/iron-collapse/iron-collapse.html" />
<link rel="import" href="../../../bower_components/paper-input/paper-input.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-horizontal-divider/pebble-horizontal-divider.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../rock-search-bar/rock-search-bar.html" />
<!--
`pebble-tree-node` Represents an individual tree list that is combined to make the `rock-tree`.

@group Pebble Elements
@element pebble-tree-node
@demo demo/index.html
-->
<dom-module id="pebble-tree-node">
    <template>
        <style include="bedrock-style-common">
            :host {
                @apply --pebble-tree-node;
            }

            .flex {
                display: -webkit-box;
                display: -webkit-flex;
                display: -ms-flexbox;
                display: flex;
                align-items: center;
                -webkit-align-items: center;
                /* Safari 7.0+ */
            }

            li {
                list-style: none;
                -webkit-transition: all 0.3s;
                -moz-transition: all 0.3s;
                -o-transition: all 0.3s;
                transition: all 0.3s;
                align-items: flex-start!important;
                -webkit-align-items: flex-start !important;
                @apply --pebble-tree-node-list;
            }

            li:hover,
            li a:hover {
                color: var(--dropdown-selected-font, #036bc3);
                cursor: pointer;
                @apply --pebble-tree-nodeitem-hover;
            }

            li:active {
                color: var(--active-icon-color, #036bc3);
                @apply --pebble-tree-nodeitem-active;
            }

            .selected {
                color: var(--dropdown-selected-font, #036bc3);
                background-color: #eaeaea;
                border-left: 5px solid var(--dropdown-selected-font, #036bc3);
                padding: 5px;
                @apply --pebble-tree-nodeitem-selected;
            }

            ul {
                margin: 5px 0 5px 0;
                padding-left: 23px;
                @apply --pebble-tree-node;
            }

            .tree-node-holder {
                @apply --pebble-tree-node-holder;
            }

            .arrow-down,
            .arrow-right {
                width: 0;
                height: 0;
                border-top: 5px solid transparent;
                border-bottom: 5px solid transparent;
                border-left: 8px solid;
                padding-right: 2px;
                margin-right: 5px;
                color: var(--palette-azure, #0bb2e8);
                @apply --pebble-tree-node-arrow;
            }

            .arrow-down {
                -webkit-transform: rotate(90deg);
                -ms-transform: rotate(90deg);
            }

            pebble-button.iconButton {
                --pebble-button: {
                    padding-left: 0px;
                    padding-top: 0;
                    padding-right: 0;
                    padding-bottom: 0;
                    height: auto;
                    min-width: auto;
                    margin-left: 0px;
                    margin-right: 0px;
                    margin-top: 0px;
                    margin-bottom: 0px;
                    color: var(--primary-icon-color, #75808b);
                }
            }

            .right {
                margin-left: auto;
            }

            .node-border {
                border-top: 1px solid var(--default-border-color, #c1cad4);
                border-bottom: 1px solid var(--default-border-color, #c1cad4);
                margin-top: -1px;
            }

            .nodetext {
                letter-spacing: 0.3px;
                margin-left: 10px;
                @apply --pebble-tree-node-nodetext;
            }

            .highlight-node {
                color: var(--palette-cerulean, #036bc3);
            }

            .check-box-wrapper {
                margin: 0 0px 0 23px;
            }
            pebble-icon + .check-box-wrapper {
                margin: 0 0px 0 10px;
            } 
            .leaf-node-active .check-box-wrapper{
                margin:0px;
            }       

            .pagination pebble-button {
                letter-spacing: 0.3px;
                margin-left: 10px;
                color: var(--palette-cerulean, #036bc3);
                @apply --pebble-tree-node-pagination-button;
            }

            .hidden {
                visibility: hidden;
            }

            .visible {
                visibility: visible; 
            }

            .detailtext {
                font-size: 11px;
                color: var(--text-primary-color, #364653);
                margin-left: 10px;
            }
        </style>
        <template is="dom-if" if="[[!hasChildren(nodeData.*,itemPath)]]">
            <li class$="[[_getNodeClass(nodeData)]] [[_getLeafNodeClass()]]">
                <div class="check-box-wrapper">
                    <pebble-checkbox on-tap="_itemClick" disabled="[[disabled]]" checked="[[_isSelected(nodeData,selectedItems,selectedItems.*,selectedItem)]]"></pebble-checkbox>
                </div>
                <pebble-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]" hidden="[[!_iconPassed(nodeData)]]"></pebble-icon>
                <div class="nodetext">
                    <a class$="nav-lnk" on-tap="_itemTextClick">[[nodeData.text]]</a>
                </div>
                <div class="flex">
                    <div class$="detailtext nodetext [[detailClass]]" id="[[nodeData.id]]"></div>
                </div>  
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-icon class="iconButton" icon="pebble-icon:action-add-fill" on-tap="_addNewElement"></pebble-icon>
                </div>
            </li>
        </template>
        <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]">
            <li class$="[[_getNodeClass(nodeData)]]">
                <pebble-icon class="iconButton pebble-icon-size-14" icon$="[[_expandClass(expanded)]]" on-click="_toggle"></pebble-icon>
                <template is="dom-if" if="[[!leafNodeOnly]]">
                    <div class="check-box-wrapper">
                        <pebble-checkbox on-tap="_itemClick" disabled$="[[_isDisabled(nodeData,selectedItems,selectedItems.*,selectedItem)]]" indeterminate="[[_isIndeterminate(nodeData,indeterminateItems,indeterminateItems.*)]]"
                            checked="[[_isSelected(nodeData,selectedItems,selectedItems.*,selectedItem)]]"></pebble-checkbox>
                    </div>
                </template>
                <div class="flex">
                    <!--<div id="arrow" on-click="_toggle" hidden="[[multiSelect]]" class$="[[_arrowClass(expanded)]] arrow"-->
                    <!--&gt;</div>-->
                    <pebble-icon src="[[nodeData.src]]" icon="[[nodeData.icon]]" hidden="[[!_iconPassed(nodeData)]]"></pebble-icon>
                    <div class$="nodetext [[_getSelectedNodeClass(highlightNode)]]" on-tap="_itemTextClick">
                        <!--<pebble-button class="iconButton pebble-icon-size-16 m-r-5" icon="pebble-icon:view-dashboard"></pebble-button>-->[[nodeData.text]]</div>
                </div>
                <div class="flex">
                    <div class$="detailtext nodetext [[detailClass]]" id="[[nodeData.id]]"></div>
                </div>                
                <div class="right" hidden="[[isNotAddable(addableLevels)]]">
                    <pebble-icon class="iconButton" icon="pebble-icon:action-add-fill" on-tap="_addNewElement"></pebble-icon>
                </div>
            </li>
        </template>
        <iron-collapse id="collapse" opened$="[[expanded]]">
            <ul class="flex" hidden$="[[!nodeData.addNewItem]]">
                <pebble-checkbox disabled$="[[disabled]]" checked="{{newItemChecked}}" hidden="[[!multiSelect]]"></pebble-checkbox>
                <pebble-textbox id="newItem" disabled="[[disabled]]" label="text input" no-label-float on-change="_keyPressed"></pebble-textbox>
            </ul>
            <template is="dom-if" if="[[hasChildren(nodeData.*,itemPath)]]">
                <ul class="tree-node-holder">
                    <pebble-spinner active="[[_loading]]"></pebble-spinner>
                    <template is="dom-if" if="[[nodeData.searchNode]]">
                        <div>
                            <rock-search-bar id="nodeSearch" placeholder="Enter search text" query="{{nodeData.searchKeyword}}"></rock-search-bar>
                            <bedrock-pubsub event-name="rock-search" handler="_onSearch" target-id="nodeSearch"></bedrock-pubsub>
                        </div>
                    </template>
                    <template is="dom-if" if="{{paginationObj.prevTitle}}">
                        <div class="pagination">
                            <pebble-button button-text="{{paginationObj.prevTitle}}" on-tap="_onPaginationPrevHandler"></pebble-button>
                        </div>
                    </template>
                    <template is="dom-repeat" id="childList" items="[[_getChildren(searchKeyword,nodeData.children)]]">
                        <pebble-tree-node disabled="[[disabled]]" node-data="{{item}}" search-keyword="[[searchKeyword]]" default-expand-depth="[[defaultExpandDepth]]"
                            default-child-depth="[[defaultChildDepth]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}"
                            indeterminate-items="{{indeterminateItems}}" multi-select="[[multiSelect]]" parent-item="{{nodeData}}"
                            parent-tree-node="[[_setParentTreeNode()]]" item-path$="[[_setItemPath(index)]]" value-path$="[[item.valuePath]]"
                            selected-node="{{selectedNode}}" selected-nodes="{{selectedNodes}}" tree="[[tree]]" check-child-nodes="[[checkChildNodes]]"
                            check-parent-nodes="[[checkParentNodes]]" addable-levels="[[addableLevels]]" leaf-node-only="[[leafNodeOnly]]"
                            expand-collapse-icon-object="[[expandCollapseIconObject]]" disable-child-node="[[disableChildNode]]">
                        </pebble-tree-node>
                    </template>
                    <template is="dom-if" if="{{paginationObj.nextTitle}}">
                        <div class="pagination">
                            <pebble-button button-text="{{paginationObj.nextTitle}}" on-tap="_onPaginationNextHandler"></pebble-button>
                        </div>
                    </template>
                </ul>
            </template>
        </iron-collapse>
        <bedrock-pubsub on-bedrock-event-detailresponsereceived="_onDetailResponse" name="bedrock-event-detailresponsereceived"></bedrock-pubsub>
    </template>
    <script>
        Polymer({

            is: 'pebble-tree-node',

            properties: {

                /**
                 * Indicates the navigation item.
                 */
                nodeData: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the parent of current navigation item.
                 */
                parentItem: {
                    type: Object,
                    value: function () {
                        return {};
                    },
                    notify: true
                },
                /**
                 * Indicates the currently selected item.
                 */
                selectedItem: {
                    type: Object,
                    notify: true,
                    value: function () {
                        return {};
                    }
                },

                /**
                 * Indicates the currently selected item-list.
                 */
                selectedItems: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the list of items for which atleast one of the child elements are selected.
                 */
                indeterminateItems: {
                    type: Array,
                    notify: true,
                    value: function () { return []; }
                },
                /**
                 * Indicates the reference to the selected element's node.
                 *
                 * @property selectedNode
                 * @type Object
                 */
                selectedNode: {
                    type: Object,
                    notify: true
                },
                /**
                 * Indicates the reference to the list of selected elements' node. A node which is not yet rendered in the `dom` does not appear in this list. 
                 * For example, element A has five child elements. 
                 * Just selecting the element A does not select all five child elements. 
                 * You need to expand the same so that these elements get added to the `dom`. 
                 * That makes these elements a part of `selectedNodes` list.
                 *
                 * @property selectedNodes
                 * @type Object
                 */
                selectedNodes: {
                    type: Array,
                    notify: true,
                    value: function () {
                        return [];
                    }
                },
                /**
                 * Indicates the path of the item which is used to traverse to the element.
                 *
                 * @property itemPath
                 * @type String
                 */
                itemPath: {
                    type: String
                },
                /**
                 * Indicates the value path of the item which is used to traverse to the element.
                 *
                 * @property valuePath
                 * @type String
                 */
                valuePath: {
                    type: String
                },
                
                detailClass: {
                    type: String,
                    value: 'hidden'
                },
                /**
                 * Specifies the default depth to which the tree will be expanded by default.
                 */
                defaultExpandDepth: {
                    type: Number,
                    value: 0
                },
                /**
                 * Specifies whether the current node is in the "expand" or "collapsed" mode.
                 */
                expanded: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Specifies whether child elements are selected or not on selecting the parent elements.
                 */
                checkChildNodes: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Specifies whether child elements are selected or not on selecting the parent elements.
                 */
                checkParentNodes: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Indicates a reference to the tree.
                 */
                tree: {
                    type: Object,
                    value: function () {
                        return this;
                    }
                },
                /**
                 * Specifies the level at which add buttons should be present so that new child elements can be added. 
                 */
                addableLevels: {
                    type: Array,
                    value: function () {
                        return [];
                    }
                },
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                defaultChildDepth: {
                    type: Number,
                    value: 0
                },
                /**
                 * Specifies whether or not the tree is disabled.
                 */
                disabled: {
                    type: Boolean,
                    value: false
                },
                /**
                 * Specifies the parent node of the current node in tree.
                 **/
                parentTreeNode: {
                    type: Element
                },
                /**
                 * Indicates that pushing of items in control is in progress
                 */
                _loading: {
                    type: Boolean,
                    value: false,
                    reflectToAttribute: true
                },
                /**
                * Specifies whether or not only leaf-node selection is enabled.
                */
                leafNodeOnly: {
                    type: Boolean,
                    value: false
                },
                highlightNode: {
                    type: Boolean,
                    value: function () {
                        return false;
                    },
                    notify: true
                },
                searchNode: {
                    type: Boolean,
                    value: false
                },
                expandCollapseIconObject: {
                    type: Object
                },
                paginationObj: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                disableChildNode:{
                    type: Boolean,
                    value: false
                }
            },
            observers: [
                '_defaultExpandDepthChanged(defaultExpandDepth,itemPath)',
                '_nodeDataExpandedChanged(nodeData.expanded)'
            ],
            behaviors: [
                RUFBehaviors.UIBehavior
            ],

            attached() {
                this._collapse = this.shadowRoot.querySelector('#collapse');
            },
            /**
             *  Can be used to return `arrow-down`, if `item.expanded` is <b>true</b>. Otherwise,
             *  `arrow-right` is returned.
             *
             **/
            _arrowClass: function (item) {
                return (item) ? 'arrow-down' : 'arrow-right';
            },
            _getLeafNodeClass:function(){
                return (this.leafNodeOnly == true)? 'leaf-node-active' : 'leaf-node-inactive';
             },
            _expandClass: function (item) {
                // if(this.expandCollapseIconObject){
                //     return (item) ? this.expandCollapseIconObject.expand : this.expandCollapseIconObject.collapse;
                // }
                return (item) ? 'pebble-icon:action-expand' : 'pebble-icon:action-scope-take-selection';
            },
            _getSelectedNodeClass: function (_highlight) {
                if (this.highlightNode) {
                    return 'highlight-node';
                }
                return "";
            },
            _isDisabled: function(item){
                if(this.disabled || item.isDisabled){
                    return true;
                }
                return false;

            },
            _isSelected: function (item) {
                if (!this.multiSelect && !this.disableChildNode) {
                    return (this.selectedItem == this.nodeData);
                }
                if (this.selectedItems != undefined && item) {
                    if (this.selectedItems.indexOf(item) > -1) {
                        if (this.selectedNodes.indexOf(this) == -1) {
                            this.selectedNodes.push(this);
                            if (this.checkParentNodes) {
                                this._makeParentIndeterminate();
                            } else if (this.checkChildNodes && !this.leafNodeOnly) { // If tree is enabled for multi-select and if it is leaf node only it should not select parent nodes. This is temp fix.
                                if (this._hasChildren(item)) {
                                    this.checkAllChildNodes(item);
                                }
                                if (this._allSiblingsSelected()) {
                                    var parentNode = this.getParentNode();
                                    if (parentNode) {
                                        parentNode.selectItem();
                                    }
                                } else {
                                    this._makeParentIndeterminate();
                                }
                            }
                        }
                        return true;
                    } else {
                        var index = this.selectedNodes.indexOf(this);
                        if (index > -1) {
                            this.splice('selectedNodes', index, 1);
                        }
                        return false;
                    }
                } else {
                    return false;
                }
            },
            _isIndeterminate: function (item, indeterminateItems) {
                if (indeterminateItems != undefined) {
                    return indeterminateItems.indexOf(item) > -1;
                }

            },
            _getDetailClass: function(nodeData) {
                var checked = this._isSelected(nodeData);
                this.detailClass = checked ? 'visible' : 'hidden';
            },
            
            _onDetailResponse: function(e) {
                var detail = e.detail;
                Object.keys(detail).forEach(key => {
                    if (this.nodeData.id === key) {
                        this.nodeData.valuePath = detail[key];
                        this.$$('#' + this.nodeData.id).innerHTML = "( " + detail[key] + " )";
                    }
                })
            },
            /**
             *  Can be used to select the current Item. 
             *  If `checkChildNodes` is set to true, then make sure to 
             *  select the child nodes and make the parent node as indeterminate unless all the sibling nodes are also selected.
             */
            selectItem: function () {
                if (!this.disabled) {
                    var nodeData = this.nodeData;
                    this.nodeData.valuePath = this.valuePath;
                    if (!this.multiSelect) {
                        this.selectedItem = nodeData;
                        this.selectedNode = this;
                        this.indeterminateItems = [];
                        if(this.disableChildNode){
                            this.push('selectedItems', nodeData);
                            if (this._hasChildren(nodeData)) {
                                this.checkAllChildNodes(nodeData);
                            }
                        }
                        if (this.checkParentNodes) {
                            this._makeParentIndeterminate();
                        }
                    } else {                
                        if (this.selectedItems.indexOf(nodeData) == -1) {
                            this.push('selectedItems', nodeData);
                            this.selectedNodes.push(this);
                            if (this.checkParentNodes) {
                                this._makeParentIndeterminate();
                            }
                        }
                        if (this.checkChildNodes && !this.leafNodeOnly) { // If tree is enabled for multi-select and if it is leaf node only it should not select parent nodes. This is temp fix.
                                if (this._hasChildren(nodeData)) {
                                    this.checkAllChildNodes(nodeData);
                                }
                                if (this._allSiblingsSelected()) {
                                    var parentNode = this.getParentNode();
                                    if (parentNode) {
                                        parentNode.selectItem();
                                    }
                                } else {
                                    this._makeParentIndeterminate();
                                }
                                var indeterminateIndex = this.indeterminateItems.indexOf(nodeData);
                                if (indeterminateIndex > -1) {
                                    this.splice('indeterminateItems', indeterminateIndex, 1);
                                }
                        }
                    }
                }
            },
            /**
             *  Can be used de-select the current Item. If `checkChildNodes` is set to true, then make sure to 
             *  de-select the child nodes and make the parent node as determinate unless at least one sibling node is selected.
             */
            deSelectItem: function () {
                if (!this.disabled) {
                    if (!this.multiSelect) {
                        this.selectedItem = {};
                        this.selectedNode = undefined;
                        if (this.checkParentNodes) {
                            this._changeParentDeterminateState();
                        }
                    } else {
                        var index = this.selectedItems.indexOf(this.nodeData);
                        if (index > -1) {
                            this.splice('selectedItems', index, 1);
                        }
                        var nodeIndex = this.selectedNodes.indexOf(this);
                        if (nodeIndex > -1) {
                            this.splice('selectedNodes', nodeIndex, 1);
                        }
                        if (this.checkParentNodes) {
                            this._changeParentDeterminateState();
                        } else if (this.checkChildNodes) {
                            if (this._hasChildren(this.nodeData)) {
                                this.unCheckAllChildNodes(this.nodeData);
                            }
                            this._changeParentDeterminateState();
                        }
                    }
                }
            },
            /**
             *  Can be used to select all the child nodes without affecting the state of the parent node.
             */
            checkAllChildNodes: function (nodeData) {
                var children = nodeData.children;
                for (var i = 0; i < children.length; i++) {
                    if (this.selectedItems.indexOf(children[i]) == -1) {
                        if(this.disableChildNode){
                            children[i]["isDisabled"] = true;
                        }
                        this.push('selectedItems', children[i]);
                    }
                    if (this._hasChildren(children[i])) {
                        this.checkAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes without affecting the state of the parent node.
             */
            unCheckAllChildNodes: function (nodeData) {
                var children = nodeData.children;
                for (var i = 0; i < children.length; i++) {
                    var index = this.selectedItems.indexOf(children[i]);
                    if (index > -1) {
                        this.splice('selectedItems', index, 1);
                    }
                    if (this._hasChildren(children[i])) {
                        this.unCheckAllChildNodes(children[i]);
                    }
                }
            },
            /**
             *  Can be used to select all the child nodes and also change the state of parent element depending on the state of the sibling elements. 
             *  This works only if the child elements are loaded in the `dom`. If not, use the `checkAllChildNodes` method.
             */
            selectChildNodes: function () {
                var childNodes = this.getChildNodes();
                for (var i = 0; i < childNodes.length; i++) {
                    if (childNodes[i]) {
                        childNodes[i].selectItem();
                    }
                }
            },
            /**
             *  Can be used to de-select all the child nodes and change the state of the parent elements depending on the state of sibling elements.
             *  This works only if the child elements are loaded in the `dom`. If not, use the `unCheckAllChildNodes` method.
             */
            deSelectChildNodes: function () {
                var childNodes = this.getChildNodes();
                for (var i = 0; i < childNodes.length; i++) {
                    childNodes[i].deSelectItem();
                }
            },
            /**
             * Can be used to get all the child nodes of the current element.
             */
            getChildNodes: function () {
                var children = this.nodeData.children;
                var path = this.itemPath;
                var childNodes = [];
                for (var i = 0; i < children.length; i++) {
                    var childPath = path + "." + i;
                    var childNode = this.shadowRoot.querySelector("pebble-tree-node[item-path='" + childPath + "']");
                    if (childNode) {
                        childNodes.push(childNode);
                    }
                }
                return childNodes;
            },

            /**
             * Fired when an item text is clicked.
             */
            _itemTextClick: function (evt) {
                this.dispatchEvent(new CustomEvent('tree-node-clicked', { detail: { data: this }, bubbles: true, composed: true }));
            },
            /**
             * Fired when search node query updated
             */
            _onSearch: function (ev) {
                this.dispatchEvent(new CustomEvent('node-search-updated', { detail: { data: this, query: ev.detail.query }, bubbles: true, composed: true }));
            },
            /**
             * Fired when next pagination node clicked
             */
            _onPaginationNextHandler: function (ev) {
                this.dispatchEvent(new CustomEvent('node-pagination-handler', { detail: { data: this, mode: "NEXT" }, bubbles: true, composed: true }));
            },
            /**
             * Fired when prev pagination node clicked
             */
            _onPaginationPrevHandler: function (ev) {
                this.dispatchEvent(new CustomEvent('node-pagination-handler', { detail: { data: this, mode: "PREV" }, bubbles: true, composed: true }));
            },
            /**
             * Fired when an item is clicked. It sets the selected item and its style.
             */
            _itemClick: function (evt) {
                if(this.nodeData.isDisabled){
                    return;
                }
                var nodeData = this.nodeData;
                if (this.multiSelect) {
                    if (this.selectedItems.indexOf(nodeData) == -1) {
                        this.selectItem();
                        this.dispatchEvent(new CustomEvent('item-selected', { detail: { data: this }, bubbles: true, composed: true }));
                    } else {
                        this.deSelectItem();
                    }
                } else {
                    if(this.disableChildNode && this.selectedItems.length > 0){
                            this.selectedItems.forEach(element => {
                                if(!this.disabled){
                                    element.isDisabled = false;
                                }
                            });
                    }
                    if(this.disableChildNode){
                        this.set("selectedItems",[]);
                        this.set("indeterminateItems",[]);
                    }
                    if (this.selectedItem == nodeData) {
                        this.deSelectItem();
                    } else {
                        this.selectItem();
                    }
                }
                this._getDetailClass(nodeData);
            },


            /**
             * Fired when a menu is clicked on. It toggles the menu, and ensures the arrows on the menu are correct.
             */
            _toggle: function (evt) {
                this.dispatchEvent(new CustomEvent('tree-node-expanded', { detail: this, bubbles: true, composed: true }));
                this._collapse.toggle();
                this.expanded = !this.expanded;
                this.set('nodeData.addNewItem', false);
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            expand: function (evt) {
                this.dispatchEvent(new CustomEvent('tree-node-expanded', { detail: this, bubbles: true, composed: true }));
                if (!this.expanded) {
                    this._collapse.toggle();
                    this.expanded = true;
                    this.set('nodeData.addNewItem', false);
                }
            },

            get newItem() {
                this._newItem = this._newItem || this.shadowRoot.querySelector('#newItem');
                return this._newItem;
            },

            _addNewElement: function (evt) {
                if (!this.disabled) {
                    if (!this.expanded) {
                        this._toggle();
                    }
                    Polymer.Async.microTask.run(() => {
                        if (this.newItem) {
                            this.newItem.focus();
                        }
                    });
                    this.set('nodeData.addNewItem', true);
                }
            },

            /**
             * Fired when enter key is pressed after creating a new node
             */
            _keyPressed: function (e) {
                const newItem = this.newItem;
                var value = newItem.value;
                newItem.text = value;
                if (!this.nodeData.children) {
                    this.nodeData.children = [];
                }
                this.set('nodeData.addNewItem', false);
                newItem.value = '';
                this.unshift('nodeData.children', newItem);
                Polymer.Async.microTask.run(() => {
                    if (this.newItemChecked) {
                        this.getElementNodeByPath(this.itemPath + ".0").selectItem();
                        this.newItemChecked = false;
                    } else {
                        this.getElementNodeByPath(this.itemPath + ".0")._changeParentDeterminateState();
                    }
                });
                this.refreshChildList();
                this.dispatchEvent(new CustomEvent('new-item-added', { detail: { nodeData: newItem, path: this.itemPath + ".0" }, bubbles: true, composed: true }));
            },

            /**
             * Can be used to clear the selected item list and checkbox selection.
             */
            clearSelectedItems: function () {
                this.selectedItems = [];
                this.selectedNodes = [];
                this.indeterminateItems = [];
                //Clear selected items
                var selectionCheckboxList = this.querySelectorAll('pebble-checkbox');
                for (var idx = 0; idx < selectionCheckboxList.length; idx++) {
                    selectionCheckboxList[idx].checked = false;
                }
            },

            /**
             * Can be used to clear the selected item and style.
             */
            clearSelectedItem: function () {
                this.selectedItem = {};
                this.selectedNode = null;
                //Clear selected item
                var item = this.querySelector('.selected');
                if (item) {
                    item.classList.remove('selected');
                }
            },

            /**
             * Can be used to check whether the given item has children.
             */
            _hasChildren: function (item) {
                return item.hasChildren || (item.children && item.children.length > 0);
            },
            /**
             * Can be used to check whether the current node has children.
             */
            hasChildren: function () {
                if (this.itemPath) {
                    var currentLevel = (this.itemPath.length + 1) / 2;
                }
                if (!this._changeToLeafMode && currentLevel <= this.defaultChildDepth) {
                    return true;
                }
                return this.nodeData.children && this.nodeData.children.length > 0;
            },
            /**
             * Can be used to check whether an icon is passed.
             */
            _iconPassed: function (item) {
                if (item.icon || item.src) {
                    return true;
                }
                return false;
            },
            /**
             *  Can be used to get the parent element of the current item.
             *
             */
            getParent: function () {
                if (this.parentItem.hasOwnProperty("text")) {
                    return this.parentItem;
                } else {
                    return null;
                }
            },
            /**
             *  Can be used to get the parent node of the current node.
             *
             */
            getParentNode: function () {
                var lastIndex = this.valuePath.lastIndexOf("#@#");
                var parentPath = this.valuePath.substring(0, lastIndex);
                return this.tree.getElementNodeByPath(parentPath);
            },
            _makeParentIndeterminate: function () {
                var parent = this.getParent();
                var index = this.selectedItems.indexOf(parent);
                if (index > -1) {
                    this.splice('selectedItems', index, 1);
                }
                if (parent && this.indeterminateItems.indexOf(parent) == -1) {
                    this.push('indeterminateItems', parent);
                    var parentNode = this.getParentNode();
                    if (parentNode) {
                        parentNode._makeParentIndeterminate();
                    }
                }
            },
            _changeParentDeterminateState: function () {
                var parent = this.getParent();
                if (parent) {
                    var children = parent.children;
                    for (var i = 0; i < children.length; i++) {
                        if (this.selectedItems.indexOf(children[i]) > -1 || this.indeterminateItems.indexOf(children[i]) > -1) {
                            this._makeParentIndeterminate();
                            return;
                        }
                    }
                    var parentNode = this.getParentNode();
                    var index = this.indeterminateItems.indexOf(parent);
                    if (index > -1) {
                        this.splice('indeterminateItems', index, 1);
                        if (parentNode) {
                            parentNode._changeParentDeterminateState();
                        }
                    } else {
                        var selIndex = this.selectedItems.indexOf(parent);
                        if (selIndex > -1) {
                            this.splice('selectedItems', selIndex, 1);
                            if (parentNode) {
                                parentNode._changeParentDeterminateState();
                            }
                        }
                    }
                }
            },
            _setItemPath: function (index) {
                return this.itemPath + "." + index;
            },
            /**
             * Can be used to get the element's node from its path in the tree.
             */
            getElementNodeByPath: function (path) {
                return this.tree.querySelector("pebble-tree-node[item-path='" + path + "']");
            },
            _defaultExpandDepthChanged: function (defaultExpandDepth, itemPath) {
                if (!(defaultExpandDepth === undefined || itemPath === undefined)) {
                    var currentLevel = (itemPath.length + 1) / 2;
                    if (defaultExpandDepth >= currentLevel) {
                        this.expanded = true;
                    }
                }
            },
            _nodeDataExpandedChanged: function (expanded) {
                if (expanded) {
                    this.expanded = true;
                }
            },
            _allSiblingsSelected: function () {
                var parent = this.getParent();
                if (parent) {
                    var children = parent.children;
                    for (var i = 0; i < children.length; i++) {
                        if (this.selectedItems.indexOf(children[i]) == -1) {
                            return false;
                        }
                    }
                    return true;
                }
                return false;
            },
            /*
             *  Can be used to check if the current level is addable nor not.
             */
            isNotAddable: function (addableLevels) {
                var currentLevel = (this.itemPath.length + 1) / 2;
                if (this.addableLevels.indexOf(currentLevel) > -1) {
                    return false;
                }
                return true;
            },
            _getChildren: function (searchKeyword) {
                var navArr = this.nodeData.children;
                if (!navArr || _.isEmpty(navArr)) {
                    return [];
                }

                var children = [];
                if (!searchKeyword || searchKeyword == "") {
                    children = navArr;
                } else {
                    var foundItems = [];
                    var len = navArr.length;
                    for (var i = 0; i < len; i++) {
                        if (navArr[i].text.toLowerCase().indexOf(searchKeyword.toLowerCase()) != -1) {
                            foundItems.push(navArr[i]);
                            continue;
                        }
                        var childMatch = false;
                        if (navArr[i].children) {
                            childMatch = this.tree._checkChildMatch(navArr[i].children, searchKeyword);
                        }
                        if (childMatch) {
                            foundItems.push(navArr[i]);
                        }
                    }
                    if (foundItems.length > 0) {
                        this.expanded = true;
                    }
                    children = foundItems;
                }

                if (children.length > 0) {
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        child.valuePath = this._computeValuePath(child);
                    }
                }
                if(this._isSelected(this.nodeData)){
                    this.selectItem();
                }
                return children;
            },
            /*
             * Can be used to refresh the tree node if there are any changes in the "child" node data.
             */
            refreshChildList: function () {
                var _children = this.nodeData.children;
                this.set("nodeData.children", []);
                this.set("nodeData.children", _children);
                this.shadowRoot.querySelector("#childList").render();
                this._loading = false;
                this.fireBedrockEvent('tree-node-child-list-refreshed', this, { "ignoreId": true });
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            changeToLeafMode: function () {
                this._changeToLeafMode = true;
            },
            _getNodeClass: function (nodeData) {
                if (nodeData.border) {
                    return "flex node-border";
                }
                else {
                    return "flex";
                }
            },
            _computeValuePath: function (nodeData) {
                return this.valuePath + "#@#" + nodeData.value;
            },
            _setParentTreeNode: function () {
                return this;
            },
            /**
             * Can be used to collapse the current node.
             **/
            collapse: function () {
                this.expanded = false;
            },
            /**
             * Can be used to select the parent node of the current node.
             **/
            selectParentNode: function () {
                var parentNode = this.getParentNode();
                if (parentNode) {
                    parentNode.selectItem();
                }
            },
            /**
            * Can be used to select all parent nodes, grand parent nodes of the current node
            **/
            selectAllParentNodes: function () {
                var parentNode = this.getParentNode();
                if (parentNode) {
                    parentNode.selectItem();
                    parentNode.selectAllParentNodes();
                }
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            isTreeNodeSelected: function (nodeData) {
                var data = this.selectedItems.find(function (item) {
                    if (item.text == nodeData.text) {
                        if (nodeData.value || data.value) {
                            return nodeData.value == data.value;
                        }
                        return true;
                    } else {
                        return false;
                    }
                })
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            startLoading: function () {
                this._loading = true;
            }
        });
    </script>
</dom-module>