<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-grid-datasource-behavior/bedrock-grid-datasource-behavior.html">
<link rel="import" href="../bedrock-logger-behavior/bedrock-logger-behavior.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">


<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->
<dom-module id="entity-relationship-grid-datasource">
    <template>
        <style include="bedrock-style-common"></style>

        <template is="dom-if" if="{{hasComponentErrored(isComponentErrored)}}">
            <div id="error-container"></div>
        </template>

        <template is="dom-if" if="{{!hasComponentErrored(isComponentErrored)}}">
            <template is="dom-if" if="[[!_isDataObjectTypeModel()]]">
                <liquid-entity-data-get id="getEntityRelationships" operation="getbyids" request-data="[[request]]" last-response="{{entityRelationshipsResponse}}"
                    exclude-in-progress include-type-external-name>
                </liquid-entity-data-get>
            </template>
            <template is="dom-if" if="[[_isDataObjectTypeModel()]]">
                <liquid-entity-model-get id="getEntityModelRelationships" operation="getbyids" request-data="[[request]]" last-response="{{entityRelationshipsResponse}}"
                    exclude-in-progress include-type-external-name>
                </liquid-entity-model-get>
            </template>
        </template>
    </template>
    <script>
        Polymer({
            is: 'entity-relationship-grid-datasource',
            properties: {
                applyContextCoalesce: {
                    type: Boolean,
                    value: false
                },
                dataObjectType: {
                    type: String,
                    value: "entity"
                },
                _success: {
                    type: Function
                },
                _error: {
                    type: Function
                },
                _options: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                }
            },

            behaviors: [
                RUFBehaviors.GridDataSourceBehavior,
                RUFBehaviors.AppBehavior,
                RUFBehaviors.LoggerBehavior
            ],
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            ready: function () {
                this.rDataSource = this._dataSource.bind(this);
            },

            _dataSource: function (options, success, error) {
                // Attach one-time event
                this._success = success;
                this._error = error;

                // Set Options
                this._options = options;

                this._generateRequest();                
            },

            _generateRequest: function (retryCount = 5) {                
                if (!this.liqElementType) {
                    // if liquid element not found, retry for retryCount times                         
                    if (retryCount) {
                        Polymer.Async.timeOut.after(ConstantHelper.MILLISECONDS_30).run(() => {
                            this._generateRequest(retryCount--);
                        });
                    } else {
                        this.logError("ENTITY-RELATIONSHIP-GRID_DATASOURCE:- Not able to access liquid element from DOM", "", true);
                    }                        
                } else {
                    // if liquid element found
                    let liquidElement = this.liqElementType;

                    liquidElement.returnObjectsCollectionName = 'entities';

                    DataHelper.oneTimeEvent(liquidElement, 'response', this._onRelationshipsReponse.bind(this));

                    // Set Range
                    var requestOptions = this._prepareRequestOptions(this._options);
                    this.request.params.options = requestOptions;

                    if (this.applyContextCoalesce) {
                        liquidElement.useDataCoalesce = true;
                    }

                    // Make Request
                    liquidElement.generateRequest();
                }
            },

            get liqElementType() {
                return this.dataObjectType && this.dataObjectType.toLowerCase() == "entitymodel" ? this.shadowRoot.querySelector('#getEntityModelRelationships') : this.shadowRoot.querySelector('#getEntityRelationships');
            },

            _onRelationshipsReponse: async function (event) {
                var totalRelCount = undefined;

                // Format ResponseData
                var entityRelationships = await this._formatResponse(this.entityRelationshipsResponse, event);
                if (typeof (entityRelationships) == 'undefined') {
                    entityRelationships = [];
                } else {
                    //Get the total count of relationships
                    var resp = this.entityRelationshipsResponse;
                    if (resp) {
                        if (resp.content && resp.content.entities) {
                            var entities = resp.content.entities;
                            if (entities && entities.length > 0) {
                                var entity = entities[0];
                                var relationshipsTotalCount = entity.relationshipsTotalCount;
                                if (relationshipsTotalCount && event.detail.request) {
                                    var currentRel = event.detail.request.requestData.params.fields.relationships[0];
                                    totalRelCount = relationshipsTotalCount[currentRel];
                                }
                                var attributes = {};
                                if (DataHelper.isValidObjectPath(entity, "data.attributes")) {
                                    attributes = entity.data.attributes;
                                }
                                var eventDetail = {
                                    "attributes": attributes
                                }
                                this.fireBedrockEvent("relationshipsGet", eventDetail, { ignoreId: true });
                            }
                        }
                    }
                }

                // UpdateCurrent RecordSize
                this._updateCurrentRecordSize(this._options, entityRelationships, totalRelCount, totalRelCount);

                // Invoke Callback
                this._success(entityRelationships);
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            resetDataSource: function () {
                this._resetDataSource();
            },

            _isDataObjectTypeModel: function () {
                if (!_.isEmpty(this.dataObjectType) && this.dataObjectType.toLowerCase() == "entitymodel") {
                    return true;
                }
                return false;
            }
        });
    </script>
</dom-module>