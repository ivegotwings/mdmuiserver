<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-grid-datasource-behavior/bedrock-grid-datasource-behavior.html">
<link rel="import" href="../bedrock-helpers/constant-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">

<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">

<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->
<dom-module id="entity-search-grid-datasource">
    <template>
        <liquid-entity-data-get id="initiateSearchResult" operation="initiatesearch" request-data="[[_initSearchRequest]]" last-response="{{_initSearchResponse}}"
            on-error="_onSearchError"  data-index$="[[dataIndex]]" data-sub-index$="[[dataSubIndex]]" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-data-get id="getSearchResultDetail" operation="getsearchresultdetail" apply-locale-coalesce="[[applyLocaleCoalesce]]" request-data="[[_searchResultRequest]]" request-id="[[_initSearchResponse.content.requestId]]"
            last-response="{{searchResultResponse}}" exclude-in-progress include-type-external-name data-index$="[[dataIndex]]" data-sub-index$="[[dataSubIndex]]"></liquid-entity-data-get>
    </template>
    <script>
        Polymer({
            is: 'entity-search-grid-datasource',
            properties: {
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                attributeModels: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                contextData: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },

                isCombinedGet: {
                    type: Boolean,
                    value: false
                },


                rDataSource: {
                    type: Object,
                    notify: true
                },

                applyContextCoalesce: {
                    type: Boolean,
                    value: false
                },

                _liquidInitSearchElement: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },

                _liquidGetSearchElement: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                _options: {
                    type: Object,
                    value: function () {
                        return {}
                    }
                },
                _totalCount: {
                    type: Number,
                    notify: true,
                    value: 0
                },
                 _originalRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _initSearchRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                _searchResultRequest: {
                    type: Object,
                    value: function () {
                        return {};
                    }
                },
                relatedEntitySearchEnabled: {
                    type: Boolean,
                    value: false
                },
                applyLocaleCoalesce: {
                    type: Boolean,
                    value: false
                },
                dataIndex: {
                    type: String,
                    value: "entityData"
                },
                dataSubIndex: {
                    type: String,
                    value: "data"
                }
            },

            behaviors: [
                RUFBehaviors.GridDataSourceBehavior
            ],

            created() {
                this.rDataSource = this._dataSource.bind(this);
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            ready: function () {
                this._liquidInitSearchElement = Polymer.dom(this).node.shadowRoot.querySelector(
                    "liquid-entity-data-get[id='initiateSearchResult']");
                this._liquidGetSearchElement = Polymer.dom(this).node.shadowRoot.querySelector(
                    "liquid-entity-data-get[id='getSearchResultDetail']");

                if (this.applyContextCoalesce) {
                    this._liquidInitSearchElement.useDataCoalesce = true;
                    this._liquidGetSearchElement.useDataCoalesce = true;
                }
            },
            /**
              * <b><i>Content development is under progress... </b></i> 
              */
            resetDataSource: function () {
                this._resetDataSource();
            },

            _dataSource: function (options, success, error) {
                // Bind Reponse Methods
                DataHelper.oneTimeEvent(this._liquidInitSearchElement, 'response', this._onInitSearchResponse.bind(
                    this));

                DataHelper.oneTimeEvent(this._liquidGetSearchElement, 'response', this._onGetSearchResponse.bind(
                    this, success, error));

                // Set Options
                this._options = options;

                // Set Range
                var requestOptions = this._prepareRequestOptions(this._options);

                if (this._options.sortOrder && this._options.sortOrder.length && this.attributeModels) {
                    //TODO:: Currently only single column sorting is supported so always need to take care about last sort order object.
                    var sortOrder = this._options.sortOrder[this._options.sortOrder.length - 1];

                    var attributes = [];
                    var attributeModel = this.attributeModels[sortOrder.path];
                    var property = {};

                    var direction = "_ASC";
                    if (sortOrder.direction && attributeModel) {

                        if (sortOrder.direction == "asc") {
                            direction = "_ASC";
                        } else if (sortOrder.direction == "desc") {
                            direction = "_DESC";
                        }

                        property[sortOrder.path] = direction;
                        property["sortType"] = ConstantHelper.getDataTypeConstant(attributeModel.dataType);
                        attributes.push(property);
                        this.request.params["sort"] = { "attributes": attributes };
                    }
                } else {
                    //TEMP": Vishal - REMOVED DEFAULT SORTING TILL RDF FIXES SORT PERF ISSUE
                    // this.request.params["sort"] = {
                    //     "properties": [
                    //         {
                    //             "modifiedDate": "_DESC",
                    //             "sortType": "_DATETIME"
                    //         }
                    //     ]
                    // };
                }

                this.set("request.params.options", requestOptions);

                this._originalRequest = DataHelper.cloneObject(this.request);

                var dataContexts = ContextHelper.getDataContexts(this.contextData);

                var requestParams = this._getRequestParams(this.request);

                if (!_.isEmpty(dataContexts) && _.isEmpty(requestParams.query.filters.attributesCriterion) &&  _.isEmpty(requestParams.query.filters.relationshipsCriterion)) {
                    requestParams.query.filters.excludeNonContextual = true;
                }

                this._initSearchRequest = DataHelper.cloneObject(this.request);

                var initSearchRequestParams = this._getRequestParams(this._initSearchRequest);

                delete initSearchRequestParams.fields;

                if(this._isRelatedEntitySearch(initSearchRequestParams)) {
                    initSearchRequestParams.isRelatedEntitySearch = true;

                    var requestParams = this._getRequestParams(this.request);
                    requestParams.isRelatedEntitySearch = true;
                }

                if(!_.isEmpty(dataContexts)) {
                    initSearchRequestParams.query.filters.nonContextual = false;
                    initSearchRequestParams.options.contextExactMatch = true;
                }

                // Initiate Request only for First Time.
                if (!this._isRequestInitiated) {
                    this._liquidInitSearchElement.generateRequest();
                } else {
                    this._generateSearchResultRequest();
                }
            },


            _onInitSearchResponse: function (e) {
                this._totalCount = this._resultRecordSize = e.detail.response.content.totalRecords;

                this._generateSearchResultRequest();
            },

            _generateSearchResultRequest: function() {
                this._searchResultRequest = {
                    "params" : this._getRequestParams(this._originalRequest)
                };
                this._searchResultRequest.params.options = this._prepareRequestOptions(this._options);

                delete this._searchResultRequest.params.query.filters.attributesCriterion;
                delete this._searchResultRequest.params.query.filters.relationshipsCriterion;
                delete this._searchResultRequest.params.query.filters.keywordsCriterion;

                DataRequestHelper.addDefaultContext(this.request);
                DataRequestHelper.addDefaultContext(this._searchResultRequest);

                this._liquidGetSearchElement.generateRequest();
                this._isRequestInitiated = true;
            },

            _onGetSearchResponse: async function (success, error) {
                if (this.searchResultResponse.status == "success") {
                    // Format ResponseData
                    var searchResults = await this._formatResponse(this.searchResultResponse);
                    if (typeof (searchResults) == 'undefined') {
                        searchResults = [];
                    }

                    // UpdateCurrent RecordSize
                    this._updateCurrentRecordSize(this._options, searchResults, this._totalCount, this._resultRecordSize);

                    // Invoke Callback
                    success(searchResults);
                } else {
                    error();
                }
            },

            _onSearchError: function (e) {
                var reason = e.detail.response.reason;
                //this.showErrorToast(reason, 10000);   //TODO: Find a way to display reason 
            },

             _getRequestParams : function(request) {
                 if (this.isCombinedGet) {
                     if (request && request.entity && request.entity.data && request.entity.data.jsonData) {
                         var searchQueries = request.entity.data.jsonData.searchQueries;
                         for (var i = 0; i < searchQueries.length; i++) {
                             if (searchQueries[i].serviceName === "entityservice") {
                                 return searchQueries[i].searchQuery;
                             }
                         }
                     }
                 } else {
                     return request.params;
                 }
             },

             _isRelatedEntitySearch: function(params) {
                 if(this.relatedEntitySearchEnabled && params && params.query && params.query.filters && params.query.filters.relationshipsCriterion
                    && params.query.filters.relationshipsCriterion.length > 0) {
                        for(let i=0; i< params.query.filters.relationshipsCriterion.length; i++) {
                            var relCriterion = params.query.filters.relationshipsCriterion[i];
                            for(let relType in relCriterion) {
                                if(!_.isEmpty(relCriterion[relType].query)) {
                                    //means this is related entity search
                                    return true;
                                }
                            }
                        }
                    }
             }

        });
    </script>
</dom-module>