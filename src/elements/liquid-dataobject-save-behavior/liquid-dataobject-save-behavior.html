<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../liquid-base-falcor-behavior/liquid-base-falcor-behavior.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<link rel="import" href="../bedrock-helpers/component-helper.html">

<script>
    /*
     * <b><i>Content development is under progress... </b></i>
     * @polymerBehavior RUFBehaviors.LiquidDataObjectSaveBehavior
     * @demo demo/index.html 
     */   
    window.RUFBehaviors = window.RUFBehaviors || {};

    var liquidDataObjectSaveBehavior = {
          /**
            * Content is not appearing - Content development is under progress. 
            */

        attached: function() {
        },
          /**
            * Content is not appearing - Content development is under progress. 
            */

        ready: function() {
        },
        properties: {
          /**
            * Content is not appearing - Content development is under progress. 
            */

            dataIndex: {
                type: String,
                value: 'Unknown'
            },

            dataSubIndex: {
                type: String,
                value: 'Unknown'
            },

            _pathKeys: {
                type: Object,
                value: function() {
                    return this._getDataObjectPathKeys();
                }
            }
        },
        _executeRequest: function (model, request) {
            var op = request.operation;

            if (op === 'create') {
                return this._callCreate(model, request);
            }
            else if (op === 'update') {
                return this._callUpdate(model, request);
            }
            else if (op === 'delete') {
                return this._callDelete(model, request);
            }
            else {
                throw 'exception: operation ' + op + ' is not supported in ' + this.is + ' element.';
            }
        },
        _formatResponse: function(request, rawResponsePkg) {
            var op = request.operation;

            if(!rawResponsePkg) {
                return rawResponsePkg;
            }

            if (op === 'update') {
                var statusResponse = rawResponsePkg;

                if(!rawResponsePkg.status) {
                    statusResponse = { 'msg': "entity submitted for save successfully", 'reqTrackingId': 100 };
                }

                if(this.verbose) {
                    console.log('save entity call raw response ', rawResponsePkg);
                    var model = RUFBehaviors.DataChannel.getModel(this.dataIndex);
                    console.log('model cache after save call', model.getCache());
                }

                return statusResponse;
            }
            else if (op === "create") {
                var statusResponse = rawResponsePkg;

                if(!rawResponsePkg.status) {
                    statusResponse = { 'msg': "entities submitted for save successfully", 'reqTrackingId': 100 };
                }

                if(this.verbose) {
                    console.log('save entity call raw response ', rawResponsePkg);
                    var model = RUFBehaviors.DataChannel.getModel(this.dataIndex);
                    console.log('model cache after save call', model.getCache());
                }

                return statusResponse;
            }
            else {
                return rawResponsePkg;
            }
        },
        _callCreate: function(model, request) {
            var jsonEnvelopeCreateResponse = this._createJsonEnvelope(request, model, "create");
            var jsonEnvelope = jsonEnvelopeCreateResponse.jsonEnvelope;

            if(jsonEnvelope === {}) {
                return;
            }

            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataSubIndex = this.dataSubIndex;
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];

            var dataObjectTypes = jsonEnvelopeCreateResponse.dataObjectTypes;

            if(this.verbose) {
                console.log('dataobject json envelope', jsonEnvelope);
                console.log('model cache before save call', model.getCache());
            }

            var functionPath =  LiquidDataObjectUtils.setDataSubIndexInPath([pathKeys.root, this.dataIndex, dataObjectTypes, "create"], this.dataIndex, this.dataSubIndex);

            return model.call(functionPath, [jsonEnvelope], [], []);
        },
        _callUpdate: function(model, request) {
            var jsonEnvelopeCreateResponse = this._createJsonEnvelope(request, model, "update");
            var jsonEnvelope = jsonEnvelopeCreateResponse.jsonEnvelope;

            if(jsonEnvelope === {}) {
                return;
            }

            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataSubIndex = this.dataSubIndex;            
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];

            var dataObjectIds = jsonEnvelopeCreateResponse.dataObjectIds;
            var dataObjectTypes = jsonEnvelopeCreateResponse.dataObjectTypes;

            if(this.verbose) {
                console.log('dataobject json envelope', jsonEnvelope);
                console.log('model cache before save call', model.getCache());
            }

            var functionPath = LiquidDataObjectUtils.setDataSubIndexInPath([pathKeys.root, this.dataIndex, dataObjectTypes, pathKeys.byIds, dataObjectIds, "update"], this.dataIndex, this.dataSubIndex);

            return model.call(functionPath, [jsonEnvelope], [], []);
        },
        _callDelete: function(model, request) {
            var jsonEnvelopeCreateResponse = this._createJsonEnvelope(request, model, "delete");
            var jsonEnvelope = jsonEnvelopeCreateResponse.jsonEnvelope;

            if(jsonEnvelope === {}) {
                return;
            }

            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];

            var dataObjectIds = jsonEnvelopeCreateResponse.dataObjectIds;
            var dataObjectTypes = jsonEnvelopeCreateResponse.dataObjectTypes;

            if(this.verbose) {
                console.log('dataobject json envelope', jsonEnvelope);
                console.log('model cache before save call', model.getCache());
            }

            var functionPath = LiquidDataObjectUtils.setDataSubIndexInPath([pathKeys.root, this.dataIndex, dataObjectTypes, pathKeys.byIds, dataObjectIds, "delete"], this.dataIndex, this.dataSubIndex);            

            return model.call(functionPath, [jsonEnvelope], [], []);
        },
        _createJsonEnvelope: function(request, model, operation) {
            var reqData = request.requestData;
            var pathKeys = this._pathKeys;
            var dataIndex = this.dataIndex;
            var dataSubIndex = this.dataSubIndex;
            var dataIndexInfo = pathKeys.dataIndexInfo[dataIndex];

            if(!_.isEmpty(dataIndexInfo.dataSubIndexInfo) && !_.isEmpty(this.dataSubIndex)) {
                dataIndexInfo = dataIndexInfo.dataSubIndexInfo[this.dataSubIndex];
            }

            if(reqData === undefined || !Object.keys(reqData[dataIndexInfo.collectionName]).length) {
                return {};
            }

            var dataObjects = reqData[dataIndexInfo.collectionName];

            if(this.verbose) {
                console.log('Request for save data objects call...data objects: ', dataObjects);
            }

            var jsonEnvelope = { "json": {} };
            jsonEnvelope.json[pathKeys.root] = {};
            var dataObjectsBaseJson = jsonEnvelope.json[pathKeys.root][dataIndex] = {};

            if(!_.isEmpty(dataSubIndex)) {
                jsonEnvelope.json[pathKeys.root][dataIndex] = {}
                dataObjectsBaseJson = jsonEnvelope.json[pathKeys.root][dataIndex][dataSubIndex] = {};
            }

            if (reqData.clientState) { 
                jsonEnvelope.json.clientState = reqData.clientState;
            } else {
                jsonEnvelope.json.clientState = {};
                jsonEnvelope.json.clientState.notificationInfo = {};
                jsonEnvelope.json.clientState.notificationInfo.showNotificationToUser = true;
            }

            if(reqData.hotline) {
                jsonEnvelope.json.clientState.hotline = reqData.hotline;
            }

            jsonEnvelope.json.clientState.notificationInfo.context = {};
            var currentActiveApp = ComponentHelper.getCurrentActiveApp();
            if(currentActiveApp) {
                jsonEnvelope.json.clientState.notificationInfo.context.appInstanceId = currentActiveApp.id;
            }

            if(dataObjects.length == 0) {
                var reason = { 'status': 'error', 'msg': 'No data objects found for save' };
                return reason;
            }

            var dataObjectIds = [];
            var dataObjectTypes = [];

            for(var i = 0; i < dataObjects.length; i++) {
                var dataObject = dataObjects[i];
                var dataObjectId = dataObject.id;
                var dataObjectType = dataObject.type;

                if(operation == 'update') {
                    //Check whether relationships process is requested...
                    //If yes, populate original relIds in order to return back all the relIds from nodeJs to solve falcor issue
                    var basePath = [pathKeys.root, dataIndex, dataObjectType, pathKeys.byIds, dataObjectId, 'data', 'contexts'];
                    this._prepareOriginalRelIdsForRelationshipsSave(dataObject, model, basePath)
                }

                var dataObjectTypeJson = SharedUtils.DataObjectFalcorUtil.getOrCreate(dataObjectsBaseJson, dataObjectType, {});
                dataObjectsByIdJson = SharedUtils.DataObjectFalcorUtil.getOrCreate(dataObjectTypeJson, pathKeys.byIds, {});
                dataObjectsByIdJson[dataObjectId] = dataObject; //SharedUtils.DataObjectFalcorUtil.boxDataObject(dataObject, SharedUtils.DataObjectFalcorUtil.boxJsonObject);

                dataObjectIds.push(dataObjectId);

                if(dataObjectTypes.indexOf(dataObjectType) === -1) {
                    dataObjectTypes.push(dataObjectType);
                }
            }

            return { 'jsonEnvelope': jsonEnvelope, 'dataObjectIds': dataObjectIds, 'dataObjectTypes': dataObjectTypes };
        },
        _prepareOriginalRelIdsForRelationshipsSave: function (dataObject, model, basePath) {
            if(dataObject.data && dataObject.data.relationships) {
                var relTypeKeys = [];
                var rels = dataObject.data.relationships;
                if (!_.isEmpty(rels)) {
                    relTypeKeys = Object.keys(rels);
                    var originalRelIds = rels['originalRelIds'] = {};
                    var utils =SharedUtils.DataObjectFalcorUtil;

                    var contextPath;
                    var contexts = dataObject.data.contexts;
                    if(contexts && contexts.length > 0) {
                        //TODO:: Prepare path for the requested context...
                        //Currently it is not implemented hence considering self context key
                        var selfCtxKey = utils.createSelfCtxKey();
                        contextPath = utils.mergePathSets(basePath, selfCtxKey);

                    }
                    else {
                        var selfCtxKey = utils.createSelfCtxKey();
                        contextPath = utils.mergePathSets(basePath, selfCtxKey);
                    }

                    for (let relTypeKey of relTypeKeys) {
                        var relTypeData = rels[relTypeKey];
                        var relIdsPath = utils.mergePathSets(contextPath, ['relationships', relTypeKey, 'relIds']);
                        var relIdsJson = model.getCache(relIdsPath);    //get original rel ids from local cache

                        if(relIdsJson) {
                            var originalRelIdsForType;
                            var pathObject = relIdsJson;

                            //Walk through relIdsJson and get originalRelIds
                            for(let pathItem of relIdsPath) {
                                pathObject = pathObject[pathItem];

                                if(!pathObject) {
                                    break;
                                }

                                if(pathItem == 'relIds') {
                                    originalRelIdsForType = pathObject.value;
                                }
                            }

                            if(originalRelIdsForType) {
                                originalRelIds[relTypeKey] = originalRelIdsForType;
                            }
                        }
                    }
                }
            }
        },
        _getDataObjectPathKeys: function() {
            return SharedUtils.DataObjectFalcorUtil.getPathKeys();
        }
    };

    RUFBehaviors.LiquidDataObjectSaveBehavior = [RUFBehaviors.LiquidBaseFalcorBehavior, liquidDataObjectSaveBehavior];
</script>