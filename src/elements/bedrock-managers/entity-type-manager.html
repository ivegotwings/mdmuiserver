<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">

<script>

    'use strict';

    class EntityTypeManager {
        constructor() {
            if (!RUFUtilities.entityTypeManager) {
                RUFUtilities.entityTypeManager = this;
            }
            this.entityTypeByIds;
            this.promiseResolve;
            return RUFUtilities.entityTypeManager;
        }
        static getInstance() {
            if (!RUFUtilities.entityTypeManager) {
                RUFUtilities.entityTypeManager = new EntityTypeManager();;
            }
            return RUFUtilities.entityTypeManager;
        }
        _generateRequest() {
            var liquidEntityCustomElement = customElements.get("liquid-entity-model-get");
            var liquidEntityModelGet = new liquidEntityCustomElement();
            liquidEntityModelGet.addEventListener("response", this._onResponse.bind(this));
            liquidEntityModelGet.addEventListener("error", this._onError.bind(this));
            liquidEntityModelGet.requestId = "";

            //Context Model manager is self executing function and because of that on load this liquid call is getting triggered before preload happens.
            //DUe to that progress bar count is getting messed up and it's never getting completed on applicaiont load.
            //Since this get process will be done in back end side it should not increase request or response count of progress bar.
            liquidEntityModelGet.excludeInProgress = true;
            liquidEntityModelGet.operation = "searchandget";
            var contextData = {};
            var itemContext = {
                "type": "entityType",
            };
            // itemContext.domain = "thing";
            contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
            contextData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
            contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
            var req = DataRequestHelper.createEntityGetRequest(contextData);
            delete req.params.options.maxRecords;
            req.params.fields.attributes = ["externalName"];
            liquidEntityModelGet.requestData = req;
            liquidEntityModelGet.generateRequest();
        }
        _onResponse(ev) {
            if (ev && ev.detail && ev.detail.response && ev.detail.response.content) {
                var entityTypes = ev.detail.response.content.entityModels;
                this.entityTypeByIds = {}
                entityTypes.forEach(element => {
                    if (element && !_.isEmpty(element)) {
                        this.entityTypeByIds[element.id] = element;
                    }
                });
            }
            if (this.promiseResolve) {
                this.promiseResolve();
            }
        }
        _onError(ev) {
            console.log(ev)
        }
        _triggerRequest() {
            return new Promise((resolve, reject) => {
                this.promiseResolve = resolve;
                this._generateRequest();
            })
        }
        getTypeExternalNameById(entityTypeId) {
            var _entityTypeId = entityTypeId + "_entityType";
            if (this.entityTypeByIds && !_.isEmpty(this.entityTypeByIds)) {
                var obj = this.entityTypeByIds[_entityTypeId];
                if (obj && !_.isEmpty(obj) && obj.properties && obj.properties.externalName) {
                    return obj.properties.externalName;
                }
            }
            return entityTypeId;
        }

        getTypeByName(entityTypeName) {
            var entityTypeId = entityTypeName + "_entityType";
            if (this.entityTypeByIds && !_.isEmpty(this.entityTypeByIds)) {
                var obj = this.entityTypeByIds[entityTypeId];
                if (obj && !_.isEmpty(obj)) {
                    return obj;
                }
            }
            return {};
        }

        getTypesByDomain(domain) {
            var thingEntityTypes = [];
            if (!_.isEmpty(domain) && !_.isEmpty(this.entityTypeByIds)) {
                for (let entityTypeId in this.entityTypeByIds) {
                    if (this.entityTypeByIds[entityTypeId].domain == domain) {
                        thingEntityTypes.push(this.entityTypeByIds[entityTypeId].name);
                    }
                }
            }
            return thingEntityTypes;
        }

        async getTypeExternalNameByIdAsync(entityTypeId) {
            if (this.entityTypeByIds) {
                return this.getTypeExternalNameById(entityTypeId);
            } else {
                var callLiquid = await this._triggerRequest();
                return this.getTypeExternalNameById(entityTypeId);
            }
        }

        async getTypesByDomainAsync(domain) {
            if (this.entityTypeByIds) {
                return this.getTypesByDomain(domain);
            } else {
                var callLiquid = await this._triggerRequest();
                return this.getTypesByDomain(domain);
            }
        }

        async preload() {
            return await this._triggerRequest();
        }
    }

</script>