<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">

<script>
    'use strict';
    let ContextModelManager = (function() {
        let _contextModels;
        let _promiseResolve;

        async function _init() {
            _getContextModelBasedOnDomains();
        }

        function _preInit() {
            return new Promise((resolve, reject) => {
                _promiseResolve = resolve;
                _init();
            });
        }

        function _getContextModelBasedOnDomains() {
            let liquidEntityCustomElement = customElements.get("liquid-rest");

            if (typeof liquidEntityCustomElement !== 'function') return;

            let liquidEntityModelGet = new liquidEntityCustomElement();

            liquidEntityModelGet.url = "/data/pass-through/entitymodelservice/getcontext";
            liquidEntityModelGet.method = "POST";

            liquidEntityModelGet.addEventListener("liquid-response", _onContextModelGetReponse);
            liquidEntityModelGet.addEventListener("liquid-error", _onContextModelGetFailed);

            let contextData = {};
            let itemContext = {
                "type": "entityContextModel",
                "ids": ""
            };
            // itemContext.domain = "thing";
            contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
            contextData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
            contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
            let req = DataRequestHelper.createEntityGetRequest(contextData);
            delete req.params.options.maxRecords;
            req.params.fields.attributes = ["externalName"];
            liquidEntityModelGet.requestData = req;
            liquidEntityModelGet.generateRequest();
        }

        function _onContextModelGetReponse(ev) {
            if (ev && ev.detail && ev.detail.response && ev.detail.response.response && ev.detail.response.response.entityModels) {
                let entityModels = ev.detail.response.response.entityModels;
                if (!_.isEmpty(entityModels)) {
                    _contextModels = {};
                    entityModels.forEach(element => {
                        if (element && !_.isEmpty(element)) {
                            _contextModels[element.name] = element;
                        }
                    });
                }

                if (_promiseResolve) {
                    _promiseResolve();
                }
            } else {
                const logDetail = {
                    "request": ev.detail.request.requestData,
                    "requestId": ev.detail.request.requestData.requestId,
                    "reason": ev.detail.response.reason
                };
                RUFUtilities.Logger.error('Context Model Fetch Error', logDetail, "context-model-manager");
                let info = document.getElementById('info');
                info.hidden = false;
                info.lastElementChild.innerHTML = "Context Model Fetch Error " + ev.detail.response.reason;
                document.getElementById('loader').hidden = true;
            }
        }

        function _onContextModelGetFailed(ev) {
            RUFUtilities.Logger.error('Context Model Fetch Error', ev.detail, "context-model-manager");
        }

        function getContextModelBasedOnCurrentDataContext(entityContextModel, firstDataContext) {
            let contextModel;

            if (entityContextModel) {
                let contextHierarchy = [];

                let contextHierarchyInfo = DataHelper.isValidObjectPath(entityContextModel, "properties.coalesceInfo") && entityModel.properties.coalesceInfo;

                if (!_.isEmpty(contextHierarchyInfo)) {
                    contextHierarchyInfo.sort(function(a,b) {
                        if(a.sequence && b.sequence) {
                            return a.sequence - b.sequence;
                        }
                    });
                    contextHierarchyInfo.forEach(function(ctx) {
                        if(ctx.contextKey && contextHierarchy.indexOf(ctx.contextKey) < 0) {
                            contextHierarchy.push(ctx.contextKey);
                        }
                    }, this);

                    let contextModels = entityContextModel.data && entityContextModel.data.contexts ? entityContextModel.data.contexts : undefined;

                    if (!_.isEmpty(contextModels)) {
                        for (let i = 0; i < contextModels.length; i++) {
                            let ctxModelItem = contextModels[i];
                            if (ctxModelItem && ctxModelItem.context) {
                                let dataContext = ctxModelItem.context;
                                if (DataHelper.compareObjects(dataContext, firstDataContext)) {
                                    contextModel = ctxModelItem;
                                    break;
                                }
                            }
                        }
                    }
                }
            }

            return contextModel;
        }

        let contextModelManagerInstance;

        class ContextModelManager {
            constructor() {
                if (!contextModelManagerInstance) {
                    _preInit();
                    contextModelManagerInstance = this;
                }

                return contextModelManagerInstance;
            }

            async getByDomain(domain) {
                if (!_contextModels) {
                    if (await _preInit()) {
                        return _contextModels[domain];
                    }
                }

                return _contextModels ? _contextModels[domain] : undefined;
            }

            async getContextModelsBasedOnDomain(domain) {
                let contextModels = [];
                let domainContextModel = await this.getByDomain(domain);

                if (domainContextModel && domainContextModel.data) {
                    contextModels = domainContextModel.data.contexts;
                }

                return contextModels;
            }

            async getEnhancerAttributeNamesBasedOnDomainAndContext(domain, dataContext) {
                let enhancerAttributeNames = [];
                let enhancerAttributes = [];
                let domainContextModel = await this.getByDomain(domain);

                if(domainContextModel && domainContextModel.properties) {
                    if(!_.isEmpty(dataContext)) {
                        Object.keys(dataContext).forEach(function(ctxKey) {
                            let coalesceInfo = domainContextModel.properties.coalesceInfo ? domainContextModel.properties.coalesceInfo.find(obj => obj.contextKey === ctxKey) : undefined;
                            if(coalesceInfo && !_.isEmpty(coalesceInfo.enhancerAttributes)) {
                                enhancerAttributes = enhancerAttributes.concat(coalesceInfo.enhancerAttributes);
                            }
                        }, this);
                    } else if(!_.isEmpty(domainContextModel.properties.enhancerAttributes)) {
                        enhancerAttributes = domainContextModel.properties.enhancerAttributes;
                    }
                }

                if(!_.isEmpty(enhancerAttributes)) {
                    enhancerAttributes.forEach(function(attrObj) {
                        if(enhancerAttributeNames.indexOf(attrObj.enhancerAttributeName) < 0) {
                            enhancerAttributeNames.push(attrObj.enhancerAttributeName);
                        }
                    }, this);
                }
                return enhancerAttributeNames;
            }
        }

        return contextModelManagerInstance = new ContextModelManager();
    }());
</script>