<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">


<script>
    'use strict';
    let ContextModelManager = (function () {

        let _contextModels;
        let _entityTypes;
        let _promiseResolve;
        let _contextHierarchyInfo;
        let _dependectContextValue = {};

        async function _init() {
            _entityTypes = await EntityTypeManager.getInstance().getTypesByDomainAsync("thing");
            if (!_.isEmpty(_entityTypes)) {
                _getContextModelBasedOnEntityTypes();
            }
        }

        function _preInit() {
            return new Promise((resolve, reject) => {
                _promiseResolve = resolve;
                _init();
            });
        }

        function _preInitEntity(entityType, ctxEntityType, ctxEntityName, relationshipTypes) {
            return new Promise((resolve, reject) => {
                _promiseResolve = resolve;
                _initiateEntityGetRequest(entityType, ctxEntityType, ctxEntityName, relationshipTypes);
            });
        }

        function _getContextModelBasedOnEntityTypes() {
            let liquidEntityCustomElement = customElements.get("liquid-rest");

            if (typeof liquidEntityCustomElement !== 'function') return;

            let liquidEntityModelGet = new liquidEntityCustomElement();

            liquidEntityModelGet.url = "/data/pass-through/entitymodelservice/getcontext";
            liquidEntityModelGet.method = "POST";

            liquidEntityModelGet.addEventListener("liquid-response", _onContextModelGetReponse);
            liquidEntityModelGet.addEventListener("liquid-error", _onContextModelGetFailed);

            let contextData = {};
            let itemContext = {
                "type": "entityContextModel",
                "ids": ""
            };
            // itemContext.domain = "thing";
            contextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
            contextData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
            contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
            let req = DataRequestHelper.createEntityGetRequest(contextData);
            delete req.params.options.maxRecords;
            req.params.fields.attributes = ["externalName"];
            liquidEntityModelGet.requestData = req;
            liquidEntityModelGet.generateRequest();
        }

        function _onContextModelGetReponse(ev) {
            if (ev && ev.detail && ev.detail.response && ev.detail.response.response && ev.detail.response.response.entityModels) {
                let entityModels = ev.detail.response.response.entityModels;
                if (!_.isEmpty(entityModels)) {
                    _contextModels = {};
                    entityModels.forEach(element => {
                        if (element && !_.isEmpty(element)) {
                            _contextModels[element.name] = element;
                        }
                    });
                }

                if (_promiseResolve) {
                    _promiseResolve();
                }
            } else {
                const logDetail = {
                    "request": ev.detail.request.requestData,
                    "requestId": ev.detail.request.requestData.requestId,
                    "reason": ev.detail.response.reason
                };
                RUFUtilities.Logger.error('Context Model Fetch Error', logDetail, "context-model-manager");
                let info = document.getElementById('info');
                info.hidden = false;
                info.lastElementChild.innerHTML = "Context Model Fetch Error " + ev.detail.response.reason;
                document.getElementById('loader').hidden = true;
            }
        }

        function _onContextModelGetFailed(ev) {
            console.log(ev)
        }

        function _initiateEntityGetRequest(entityType, ctxEntityType, ctxEntityName, relationshipTypes) {
            let entityGetRequest = {
                "params": {
                    "query": {
                        "name": ctxEntityName,
                        "filters": {
                            "typesCriterion": [
                                ctxEntityType
                            ]
                        }
                    },
                    "fields": {
                        "relationships": relationshipTypes,
                        "relationshipAttributes": ["isDefault"]
                    }
                }
            }

            let liquidCustomElement = customElements.get("liquid-entity-data-get");
            let liquidElement = new liquidCustomElement();

            liquidElement.requestData = entityGetRequest;
            liquidElement.operation = "searchandget";
            liquidElement.excludeInProgress = true;

            let _onEntityGetResponse = function (e) {
                let res = e.detail.response;
                if (!_dependectContextValue[entityType]) {
                    _dependectContextValue[entityType] = {};
                }

                if (!_dependectContextValue[entityType][ctxEntityType]) {
                    _dependectContextValue[entityType][ctxEntityType] = [];
                }

                if (!_dependectContextValue[entityType][ctxEntityType][ctxEntityName]) {
                    _dependectContextValue[entityType][ctxEntityType][ctxEntityName] = {};
                }

                let formattedCtxEntity = _dependectContextValue[entityType][ctxEntityType][ctxEntityName];

                if (res && res.content) {
                    let entities = res.content.entities;
                    if (!_.isEmpty(entities)) {
                        for (let entity of entities) {
                            for (let rel of relationshipTypes) {
                                formattedCtxEntity[rel] = entity.data && entity.data.relationships && entity.data.relationships[rel] ? entity.data.relationships[rel] : [];
                            }
                        }
                    }
                }

                if (_promiseResolve) {
                    _promiseResolve();
                }
            }

            liquidElement.addEventListener("response", _onEntityGetResponse.bind(this));
            liquidElement.generateRequest();
        }

        function getContextModelBasedOnCurrentDataContext(entityContextModel, firstDataContext, exactMatch) {
            let contextModel;

            if (entityContextModel) {
                let partialContextModels = [];
                let contextHierarchy = [];

                let globalCoalescePath = DataHelper.isValidObjectPath(entityContextModel, "properties.globalCoalescePath") && entityContextModel.properties.globalCoalescePath;
                if (!_.isEmpty(globalCoalescePath)) {
                    contextHierarchy = globalCoalescePath.split(">>");
                    let contextModels = entityContextModel.data && entityContextModel.data.contexts ? entityContextModel.data.contexts : undefined;

                    if (!_.isEmpty(contextModels)) {
                        for (let i = 0; i < contextModels.length; i++) {
                            let ctxModelItem = contextModels[i];
                            if (ctxModelItem && ctxModelItem.context) {
                                let dataContext = ctxModelItem.context;
                                if (DataHelper.compareObjects(dataContext, firstDataContext)) {
                                    contextModel = ctxModelItem;
                                    break;
                                } else {
                                    let numberOfExactMatch = 0;
                                    let isPartialMatch = false;
                                    let ctxKeys = Object.keys(dataContext);
                                    let selectedCtxKeys = Object.keys(firstDataContext);

                                    if (ctxKeys.length != selectedCtxKeys.length) {
                                        continue;
                                    }

                                    if (!DataHelper.areEqualArrays(ctxKeys, selectedCtxKeys)) {
                                        continue;
                                    }

                                    for (let ctxHKey of contextHierarchy) {
                                        if (dataContext[ctxHKey]) {
                                            if (firstDataContext[ctxHKey] == dataContext[ctxHKey]) {
                                                numberOfExactMatch++
                                            } else if (dataContext[ctxHKey].toLowerCase() == "_all") {
                                                isPartialMatch = true;
                                            } else {
                                                isPartialMatch = false;
                                                break;
                                            }
                                        }
                                    }

                                    if (isPartialMatch) {
                                        partialContextModels.push({
                                            "numberOfExactMatch": numberOfExactMatch,
                                            "ctxModelItem": ctxModelItem
                                        });
                                    }
                                }
                            }
                        }

                        if (partialContextModels && _.isEmpty(contextModel)) {
                            if (partialContextModels.length == 1) {
                                contextModel = partialContextModels[0].ctxModelItem;
                            } else {
                                let highestNumberOfMatch = 0;
                                partialContextModels.forEach(function (ctxModel) {
                                    if (ctxModel.numberOfExactMatch > highestNumberOfMatch) {
                                        highestNumberOfMatch = ctxModel.numberOfExactMatch;
                                        contextModel = ctxModel.ctxModelItem;
                                    }
                                }, this);
                            }
                        }
                    }
                }
            }

            return contextModel;
        };

        let contextModelManagerInstance;

        class ContextModelManager {
            constructor() {
                if (!contextModelManagerInstance) {
                    _preInit();
                    contextModelManagerInstance = this;
                }

                return contextModelManagerInstance;
            }

            async getByEntityType(entityType) {
                if (!_contextModels) {
                    if (await _preInit()) {
                        return _contextModels[entityType];
                    }
                }

                return _contextModels ? _contextModels[entityType] : undefined;
            }

            async getContextModelsBasedOnEntityType(entityType) {
                let contextModels = [];
                let entityTypeContextModel = await this.getByEntityType(entityType);

                if (entityTypeContextModel && entityTypeContextModel.data) {
                    contextModels = entityTypeContextModel.data.contexts;
                }

                return contextModels;
            }

            async getContextModelByEntityTypeAndDataContext(entityType, dataContext) {
                let contextModel;
                let entityTypeContextModel = await this.getByEntityType(entityType);

                if (!_.isEmpty(entityTypeContextModel) && !_.isEmpty(dataContext)) {
                    contextModel = getContextModelBasedOnCurrentDataContext(entityTypeContextModel, dataContext);
                }

                return contextModel;
            }

            async getDependentRelationshipDetails(entityType, ctxKey, context) {
                let dependent;
                let mappedValueContexts = await this.getMappedValueContextsBasedOnEntityTypeAndContextKey(entityType, ctxKey);
                if (mappedValueContexts) {
                    let relTypes = mappedValueContexts.map(v => v.valueContextRelationship);
                    let path = entityType + "." + ctxKey + "." + context;
                    if (relTypes) {
                        if (!DataHelper.isValidObjectPath(_dependectContextValue, path)) {
                            await _preInitEntity(entityType, ctxKey, context, relTypes);
                        }

                        for (let relType of relTypes) {
                            path = path + "." + relType;
                            if (!DataHelper.isValidObjectPath(_dependectContextValue, path)) {
                                await _preInitEntity(entityType, ctxKey, context, [relType]);
                            }
                        }
                        dependent = _dependectContextValue[entityType][ctxKey][context];
                    }
                }

                return await dependent;
            }

            async getMappedValueContextsBasedOnEntityTypeAndContextKey(entityType, contextKey) {
                let mappedValueContexts;

                if (!_.isEmpty(entityType) && !_.isEmpty(contextKey)) {
                    let entityTypeContextModel = await this.getByEntityType(entityType);

                    if (entityTypeContextModel) {
                        let contextHierarchyInfo = DataHelper.isValidObjectPath(entityTypeContextModel, "properties.globalCoalesceInfo") && entityTypeContextModel.properties.globalCoalesceInfo;
                        if (contextHierarchyInfo) {
                            let ctxInfo = contextHierarchyInfo.find(v => v.contextKey == contextKey);
                            mappedValueContexts = ctxInfo && ctxInfo.mappedValueContexts;
                        }
                    }
                }

                return mappedValueContexts;
            }
        }

        return contextModelManagerInstance = new ContextModelManager();
    }());

</script>