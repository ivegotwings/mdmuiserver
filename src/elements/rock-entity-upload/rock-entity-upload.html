<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">


<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">
<link rel="import" href="../liquid-config-get/liquid-config-get.html">
<link rel="import" href="../liquid-config-save/liquid-config-save.html">

<link rel="import" href="../pebble-file-upload/pebble-file-upload.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->
<dom-module id="rock-entity-upload">
    <template>
        <style include="bedrock-style-common">
            :host {
                display: block;
                height: 100%;
            }

            .placeHolder {
                width: 880px;
                margin: 0 auto;
                margin-top: 5px;
                box-shadow: 0 0 10px 0 var(--cloudy-blue-color, #c1cad4);
                position: relative;
            }

            
            #content-label {
                box-shadow: 0 1px 7px 0 var(--palette-cloudy-blue, #c1cad4);
                padding: 15px;
                margin: 10px;
            }

            #image-container {
                width: 30px;
                height: 35px;
                vertical-align: middle;
            }

            import-log {
                vertical-align: middle;
            }

            .title {
                font-size: var(--default-font-size, 14px);
                text-align: center;
                color: var(--palette-steel-grey, #75808b);
            }

            .checkbox-container {
                width: 880px;
                text-align: right;
                margin: 0 auto;
            }

            .checkbox-label-color {
                --pebble-checkbox-label-color: #75808b;
            }

            .confirmSave {
                font-size: 12px;
            }

            #categoryTreeContainer {
                height: calc(100% - 80px);
            }

            .preview-message-info {
                font-size: 12px;
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <liquid-rest id="entityMatchService" url="/pass-through-bulk/matchservice/search" method="POST" request-data={{_entityMatchRequest}}
            on-liquid-response="_onMatchSuccess" on-liquid-error="_onMatchFailure">
        </liquid-rest>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="[[attributeModelRequest]]" on-response="_onCompositeModelResponse"></liquid-entity-model-composite-get>
        <liquid-entity-data-save name="entitiesSaveDataService" operation="" request-data="{{_saveRequest}}" on-response="_onSaveResponse"></liquid-entity-data-save>

        <div id="content-entity-import" hidden class="base-grid-structure">
            <div class="base-grid-structure-child-1">
                <div align="right" class="checkbox-container">
                    <pebble-checkbox hidden$="[[!enableMappings]]" id="customizeMappingsChk" class="checkbox-label-color m-r-10" on-change="_onMappingsChange">Customize Mappings</pebble-checkbox>
                </div>
            </div>
            <div class="base-grid-structure-child-2">
                <div class="placeHolder p-10">
                    <p class="title">
                        <a href="#" class="btn-link" on-tap="_exportDialogOpen">Download</a> a system template or just upload an existing data file
                    </p>
                    <pebble-dialog id="exportDialog" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                        <pebble-spinner active="[[_downloadInProgress]]"></pebble-spinner>
                        <div id="exportSmartExcelContent" style="height:85vh;">
                            <div class="base-grid-structure">
                                <div class="base-grid-structure-child-1">
                                    Select one or more classifications to download the smart excel template. You can select the classification at any level and
                                    the data required for all child classifications will be shown in the template.
                                </div>
                                <div id="categoryTreeContainer" class="base-grid-structure-child-2">
                                    <div class="button-siblings">
                                        <rock-classification-tree id="contextTree" multi-select="true" taxonomy="[[taxonomy]]" context-data="[[contextData]]" selected-classifications="{{_selectedCategories}}"></rock-classification-tree>
                                    </div>
                                    <div id="exportActions" class="buttonContainer-static" align="center">
                                        <pebble-button id="cancel" class="close btn btn-secondary m-r-10" button-text="Cancel" raised on-tap="_onCancelDownloadSelection"></pebble-button>
                                        <pebble-button id="download" class="apply btn btn-success" button-text="Download" raised on-tap="_exportSelectedCategory"></pebble-button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </pebble-dialog>
                    <!-- screen for import -->
                    <pebble-file-upload id="fileUpload" allowed-file-types="[[allowedFileTypes]]"></pebble-file-upload>
                    <bedrock-pubsub event-name="pebble-file-upload-success" handler="_onFileUploadSuccess" target-id="fileUpload"></bedrock-pubsub>
                </div>
            </div>
            <div id="upload-actions" class="p-b-10" align="center">
                <template is="dom-repeat" id="event-template" items="[[componentEvents]]">
                    <template is="dom-if" if="[[_showEvent(item)]]">
                        <pebble-button id="[[item.id]]" class$="[[item.class]]" button-text="[[item.text]]" on-tap="_onTriggerEvent" data-args$="[[item.event]]"
                            elevation=1 raised></pebble-button>
                    </template>
                </template>
            </div>
        </div>
        <div id="content-label" hidden>
            <img alt="Product image." id="image-container" sizing="contain" src="/src/images/MicrosoftExcel50,100,500px/MicrosoftExcel_100.svg"
            />
            <span class="import-log">
                <strong>[[_fileName]]</strong> uploaded
                <strong>[[_entities.length]]</strong> items with
                <strong>[[attributeNames.length]]</strong> attributes.</span>
        </div>
        <div id="content-entities-grid" hidden class="full-height">
            <rock-grid id="entitiesGrid" page-size="10" context-data="[[contextData]]" attribute-models="[[_attributeModels]]" no-header></rock-grid>
            <span class="confirmSave">Please review the data above. Save process cannot be cancelled once started.</span>
        </div>
        <div id="content-actions" align="center" hidden class="buttonContainer-static">
            <pebble-button class="action-button btn btn-secondary m-r-5" id="skip" button-text="Cancel" raised on-tap="_onSkipTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>
        <bedrock-pubsub event-name="field-map-save" handler="_onFieldMappingsSave" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="field-map-back" handler="_onFieldMappingsBack" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="field-map-import" handler="_onFieldMappingsImport" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-back" handler="_onContextMappingsBack" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-skip" handler="_onContextMappingsSkipOrSave" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-save" handler="_onContextMappingsSkipOrSave" target-id=""></bedrock-pubsub>
        <liquid-entity-data-get id="taxonomyGetDataService" operation="getbyids" request-data="{{_taxonomyRequest}}" on-response="_onTaxonomyResponse"></liquid-entity-data-get>
        <liquid-rest id="taxonomyModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_taxonomyModelRequest}}"
            on-liquid-response="_onTaxonomyModelGetResponse"></liquid-rest>
        <liquid-entity-data-get id="initiateEntitySearch" operation="initiatesearch" request-data="{{entityGetrequest}}" last-response="{{initiateSearchResponse}}"
            on-error="_onGetSearchError" on-response="_onInitiateEntitySearchResponse" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-data-get id="getEntitySearchResultDetail" operation="getsearchresultdetail" request-data="{{entityGetrequest}}"
            request-id="[[initiateSearchResponse.content.requestId]]" last-response="{{getEntitySearchResultsResponse}}" on-error="_onGetSearchError"
            on-response="_onGetEntitySearchResultDetailResponse" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-model-get id="getEntityTypeModel" operation="getbyids" on-response="_onEntityTypeModelReceived" on-error="_onEntityTypeModelFailed"></liquid-entity-model-get>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: "rock-entity-upload",

                properties: {
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the names of the attributes that are retrieved from "Excel".
                     */
                    attributeNames: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates the contexts which are retrieved from "Excel".
                     */
                    contexts: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Specifies the request object for the attribute model request.
                     */
                    attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the response object for the attribute models.
                     */
                    attributeModelResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    taxonomy: {
                        type: String
                    },
                    _gridConfig: {
                        type: Object,
                        value: function () {
                            return {
                                "viewMode": "Tabular",
                                "readOnly": true,
                                "itemConfig": {
                                    "isMultiSelect": false,
                                    "maxNoOfRows": 200,
                                    "fields": {
                                    }
                                },
                                "viewConfig": {
                                    "tabular": {
                                        "settings": {},
                                        "fieldChanges": {}
                                    }
                                }
                            };
                        }
                    },
                    _gridData: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _copRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },

                    _entitiesData: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _entities: {
                        type: Array,
                        value: function () { return []; }
                    },
                    _saveRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _attributeModels: {
                        type: Object
                    },
                    _fileName: {
                        type: String
                    },
                    _currentBatchNumber: {
                        type: Number,
                        value: 0
                    },
                    _batchSize: {
                        type: Number,
                        value: 10
                    },
                    _loading: {
                        type: Boolean,
                        value: false
                    },
                    _downloadInProgress: {
                        type: Boolean,
                        value: false
                    },
                    _entityMatchRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _matchedEntities: {
                        type: Array,
                        value: function () { return []; }
                    },
                    _newEntities: {
                        type: Array,
                        value: function () { return []; }
                    },
                    _faultedEntities: {
                        type: Array,
                        value: function () { return []; }
                    },
                    _currentEntityIndex: {
                        type: Number
                    },
                    _currentAction: {
                        type: String,
                        value: "create"
                    },
                    _showPreview: {
                        type: Boolean,
                        value: false
                    },
                    _isDirty: {
                        type: Boolean,
                        value: false
                    },
                    _workAutomationId: {
                        type: String
                    },
                    customizeMappings: {
                        type: Boolean,
                        value: false
                    },
                    _selectedCategories: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    enableDataPreview: {
                        type: Boolean,
                        value: false
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    enableMappings: {
                        type: Boolean,
                        value: false
                    },
                    _currentCOPService: {
                        type: String,
                        value: "process"
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    skipNext: {
                        type: Boolean,
                        value: false
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    businessFunctionData: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    allowedFileTypes: {
                        type: Array,
                        value: function () { return []; }
                    },
                    _fileDetails: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    copContext: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    mappingConfig: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    mappingActions: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _taxonomyExtName: {
                        type: String,
                        value: ""
                    },
                    _taxonomyModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _taxonomyExtNameAttr: {
                        type: String,
                        value: ""
                    },
                    businessFunctionData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    componentEvents: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    selectedOptions: {
                        type: Object,
                        value: function () {
                            return { "role": "_DEFAULT", "ownershipData": "_DEFAULT", "saveType": "self" }
                        }
                    },
                    domain: {
                        type: String,
                        value: "generic"
                    }
                },
                observers: [
                    '_attributeNamesChanged(attributeNames, contexts)',
                    '_contextChanged(contextData)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                ready: function () {
                    if (!this.taxonomy || this.taxonomy == "undefined") {
                        this.taxonomy = this.appSetting("dataDefaults").taxonomy;
                    }
                },
                _contextChanged: function (contextData) {
                    if (!_.isEmpty(contextData)) {
                        this._showView("entity-import");
                        this._getTaxonomyManageModel();
                    }
                },

                _getTaxonomyManageModel: function () {
                    this._taxonomyModelRequest = DataRequestHelper.createGetManageModelRequest(["taxonomy"]);

                    var taxonomyModelGetElement = this.$$("#taxonomyModelGet");

                    if (taxonomyModelGetElement) {
                        taxonomyModelGetElement.generateRequest();
                    }
                },

                _onTaxonomyModelGetResponse: function (e) {
                    var response = e.detail && e.detail.response ? e.detail.response.response : "";

                    if (response && response.entityModels) {
                        var entityModel = response.entityModels[0];
                        var externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);

                        if (externalNameAndExternalNameAttr && externalNameAndExternalNameAttr.externalNameAttr) {
                            this._taxonomyExtNameAttr = externalNameAndExternalNameAttr.externalNameAttr;
                            this._getTaxonomy();
                        } else {
                            this.showErrorToast("Attribute not found with isExternlName in taxonomy entity manage model", 10000);
                            this._loading = false;
                        }
                    } else {
                        this.showErrorToast("Entity manage model not found for taxonomy.", 10000);
                        this._loading = false;
                    }
                },

                _getTaxonomy: function () {
                    var contextData = DataHelper.cloneObject(this.contextData);
                    var firstItemContext = ContextHelper.getFirstItemContext(contextData);
                    if (firstItemContext) {
                        firstItemContext.type = "taxonomy";
                        firstItemContext.attributeNames = [this._taxonomyExtNameAttr];
                        firstItemContext.id = this.taxonomy;
                        contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                        var req = DataRequestHelper.createEntityGetRequest(contextData);
                        delete req.params.options;
                        this._taxonomyRequest = req;

                        var taxonomyGetElement = this.$$("#taxonomyGetDataService");

                        if (taxonomyGetElement) {
                            taxonomyGetElement.generateRequest();
                        }
                    }
                },

                _onTaxonomyResponse: function (e) {
                    if (e && e.detail && e.detail.response) {
                        var res = e.detail.response;
                        if (res && res.content && res.content.entities && res.content.entities.length) {
                            var entity = res.content.entities[0];
                            if (entity && entity.data) {
                                var attributes = entity.data.attributes;

                                if (attributes && attributes[this._taxonomyExtNameAttr]) {
                                    this._taxonomyExtName = attributes[this._taxonomyExtNameAttr].values && attributes[this._taxonomyExtNameAttr].values.length ? attributes[this._taxonomyExtNameAttr].values[0].value : undefined;
                                }
                            }
                        }
                    }
                },

                _showView: function (viewName) {
                    if (viewName) {
                        var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.removeAttribute("hidden");
                        }
                    }
                },

                _hideView: function (viewName) {
                    if (viewName) {
                        var contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.setAttribute("hidden", "");
                        }
                    }
                },

                _onFileUploadSuccess: function (e, detail, sender) {
                    this._isDirty = true;
                    this._loading = true;
                    this.set("_fileName", detail.originalFileName);

                    var fileDetails = {
                        "file": detail.file,
                        "fileName": detail.fileName,
                        "originalFileName": detail.originalFileName
                    };

                    this.set("_fileDetails", fileDetails);

                    var url = "";
                    if (this.customizeMappings) {
                        this._currentCOPService = "getHeaderFields";
                        url = "/data/cop/getHeaderFields";
                    } else if (this._showPreview) {
                        this._currentCOPService = "transform";
                        url = "/data/cop/transform";
                    } else {
                        this._currentCOPService = "process";
                        url = "/data/cop/process";
                    }
                    this._generateCopRequest(url, this._fileDetails);

                    this.async(function () {
                        //Clear file upload
                        this.$$('pebble-file-upload').reset();
                    });
                },
                _generateCopRequest: function (url, fileDetails) {
                    var formData = new FormData();
                    formData.append("file", fileDetails.file);
                    formData.append("fileName", fileDetails.fileName);

                    var hotline = false;
                    if (DataHelper.isHotlineModeEnabled()) {
                        hotline = true;
                    }

                    var req = DataRequestHelper.createImportRequest(fileDetails, this.copContext, hotline);
                    if (this._currentCOPService == "process") {
                        this._workAutomationId = DataHelper.generateUUID();
                        req.dataObject.properties.workAutomationId = this._workAutomationId;
                    }

                    if (this._currentCOPService == "getHeaderFields") {
                        var copMappingContext = this.mappingConfig["cop-mapping-context"];
                        req.dataObject.dataObjectInfo.dataObjectType = copMappingContext.dataObjectType;
                        req.dataObject.properties.service = copMappingContext.service;

                        //Set properties for headerFields
                        req.dataObject.properties.fileId = "";
                        if (copMappingContext.excludeSubType) {
                            delete req.dataObject.properties.subtype;
                        }

                        if (copMappingContext.excludeOrder) {
                            delete req.dataObject.properties.order;
                        }
                    }

                    formData.append("requestData", JSON.stringify(req));

                    var xhr = new XMLHttpRequest();
                    xhr.open('POST', url, true);
                    xhr.responseType = 'json';
                    xhr.onload = function (e) {
                        //Process triggred in async manner, so track the details through workAutomationId
                        if (this._currentCOPService == "process") {
                            return;
                        }

                        if (e.currentTarget && e.currentTarget.response) {
                            var response = e.currentTarget.response;
                            e.detail = {
                                "response": response
                            }
                            if ((response.response && response.response.status == "success") ||
                                (response.dataObjectOperationResponse && response.dataObjectOperationResponse.status == "success")) {
                                this._onCOPSuccess(e);
                            } else {
                                this._onCOPFailure(e);
                            }

                        }
                    }.bind(this);
                    xhr.send(formData);
                    //After sending the form data show workAutomationId to user
                    if (this._currentCOPService == "process") {
                        this._onCOPProcessComplete();
                    }
                },

                _setContexts: async function () {
                    var itemContext = this.getFirstItemContext();
                    this.entityType = itemContext.type;
                    var contexts = await ContextModelManager.getContextModelsBasedOnEntityType(this.entityType);

                    if (contexts && contexts.length) {
                        var _ctxKeys = [];
                        var contextCoalesceInfo = [];

                        var _contexts = [];
                        contexts.forEach(function (context) {
                            _contexts.push(context.context);
                            if (context && context.properties &&
                                context.properties.coalesceInfo && context.properties.coalesceInfo.length) {
                                contextCoalesceInfo = contextCoalesceInfo.concat(context.properties.coalesceInfo)
                            }

                            var ctxKeys = Object.keys(context.context);
                            if (ctxKeys && ctxKeys.length) {
                                ctxKeys.forEach(function (ctxKey) {
                                    if (_ctxKeys.indexOf(ctxKey) < 0) {
                                        _ctxKeys.push(ctxKey);
                                    }
                                }, this);
                            }
                        }, this);

                        this._contexts = _contexts;

                        var _ctxIds = [];
                        if (_ctxKeys && _ctxKeys.length) {
                            _ctxKeys.forEach(function (item) {
                                if (item) {
                                    _ctxIds.push(item);
                                }
                            }, this);
                        }

                        this.contexts = _ctxIds;

                        //Fetch taxonomy type entities
                        var contextData = DataHelper.cloneObject(this.contextData);
                        var firstItemContext = ContextHelper.getFirstItemContext(contextData);
                        if (firstItemContext) {
                            firstItemContext.type = "taxonomy";
                            firstItemContext.attributeNames = ["_ALL"];
                            var req = DataRequestHelper.createEntityGetRequest(contextData);
                            delete req.params.options;
                            this.entityGetrequest = req;

                            //Trigger request
                            var taxonomyGetElement = this.$$("#initiateEntitySearch");
                            if (taxonomyGetElement) {
                                taxonomyGetElement.generateRequest();
                            }
                        }
                    } else {
                        this.showErrorToast("Contexts not available, please contact administrator.");
                        this._loading = false;

                    }
                },

                _onInitiateEntitySearchResponse: function (e, detail) {
                    if (detail && detail.response && detail.response.status == "success") {
                        var taxonomyGetElement = this.$$("#getEntitySearchResultDetail");
                        if (taxonomyGetElement) {
                            taxonomyGetElement.generateRequest();
                        }
                    } else {
                        this._raiseTaxonomyError(detail);
                    }
                },

                _onGetEntitySearchResultDetailResponse: function (e, detail) {
                    if (detail && detail.response && detail.response.status == "success") {
                        var response = detail.response;
                        if (response.content && response.content.entities && response.content.entities.length) {
                            this.taxonomies = detail.response.content.entities;

                            //Fetch externalNames
                            var entityTypeModelGetEl = this.$$("#getEntityTypeModel");
                            if (entityTypeModelGetEl) {
                                var eTypes = [];
                                eTypes.push(this.entityType); //entityType
                                if (this.contexts && this.contexts.length) {
                                    for (var i = 0; i < this.contexts.length; i++) {
                                        eTypes.push(this.contexts[i]); //context
                                    }
                                }
                                entityTypeModelGetEl.requestData = DataRequestHelper.createGetModelRequest(eTypes, "entityType");
                                entityTypeModelGetEl.generateRequest();
                            }
                        }
                    } else {
                        this._raiseTaxonomyError(detail);
                    }
                },

                _onGetSearchError: function (e, detail) {
                    this._raiseTaxonomyError(detail);
                },

                _raiseTaxonomyError: function (detail) {
                    this.logError("Taxonomy entity get error", detail);
                    this.showSuccessToast("Unable to get taxonomy details, please contact administrator.");
                    this._loading = false;
                },

                _onEntityTypeModelReceived: function (e, detail) {
                    if (detail && detail.response) {
                        var response = detail.response;
                        if (response.status == "success" && response.content && response.content.entityModels) {
                            var entityModels = response.content.entityModels || [];
                            var entityTypeExternalNames = {};
                            for (var i = 0; i < entityModels.length; i++) {
                                entityTypeExternalNames[entityModels[i].name] = entityModels[i].properties.externalName;

                                //Get domain for the entityType
                                if (entityModels[i].name == this.entityType) {
                                    this.domain = entityModels[i].domain;
                                }
                            }

                            this.entityTypeExternalName = entityTypeExternalNames[this.entityType];
                            delete entityTypeExternalNames[this.entityType];
                            this.contextExternalNames = entityTypeExternalNames; // Remaining context names
                        }
                    }
                    this._loadMappingComponent();
                },

                _onEntityTypeModelFailed: function (e, detail) {
                    this.logError("Entity type model get error", detail);
                    this._loadMappingComponent();
                },

                _loadMappingComponent: function () {
                    this._loading = false;
                    this._isDirty = false;
                    this._setSelectedOptions();

                    if (this.skipContextMapping) {
                        this._importAttributeComponent(); //Attribute Mappings
                    } else {
                        this._importContextComponent(); //Context Mappings
                    }
                },

                _onCOPSuccess: function (e) {
                    var response = e.detail.response;
                    var statusMessage = DataHelper.validateAndGetMessage(response);
                    if (statusMessage == "") {
                        var res = response.response ? response.response : response;
                        if (this._currentCOPService == "getHeaderFields") {
                            this.headerFields = [];
                            this.attributeFields = [];
                            this.fileFormat = "";
                            this.skipContextMapping = false;
                            var workAutomationId = "";
                            if (DataHelper.isValidObjectPath(res, "dataObjectOperationResponse.statusDetail.message.headers")) {
                                var response = res.dataObjectOperationResponse.statusDetail.message.headers;
                                this.headerFields = response.entities;
                                this.fileFormat = response.format || "Excel";
                                this.skipContextMapping = response.skipContextMapping;
                            }

                            if (DataHelper.isValidObjectPath(res, "dataObjectOperationResponse.statusDetail.message.workAutomationId")) {
                                workAutomationId = res.dataObjectOperationResponse.statusDetail.message.workAutomationId;
                            }

                            if (!this.headerFields || this.headerFields.length == 0) {
                                this.showErrorToast("Unable to continue with mappings customization, please contact administrator.");
                                this._loading = false;
                                this._isDirty = false;
                                return;
                            }
                            //Fetch contexts, taxonomies, external names and domain
                            this._setContexts();
                        } else if (this._currentCOPService == "transform" && res.entities && res.entities.length > 0) {
                            this._entities = res.entities;
                            var maxNoOfRows = this._gridConfig.itemConfig.maxNoOfRows;
                            if (maxNoOfRows && this._entities.length > maxNoOfRows) {
                                this.showErrorToast("Preview of more than " + maxNoOfRows + " entities is not supported. Please review the file imported or contact your administrator.", 3000);
                                this._loading = false;
                                this._isDirty = false;
                                return;
                            }
                            var attributeNames = EntityHelper.getAttributeNamesFromEntities(this._entities);
                            if (attributeNames && attributeNames.length > 0) {
                                var contexts = EntityHelper.getContextsFromEntities(this._entities);
                                if (contexts && contexts.length > 0) {
                                    this.set("contexts", contexts);
                                }
                                //setting contexts first and then attributeNames, because there is an observer on both
                                //setting attributeNames first would send unnecessary request for model
                                this.set("attributeNames", attributeNames);
                            } else {
                                this.showErrorToast("Unable to fetch attributes from excel. Please check excel file imported or contact your administrator.");
                                this._loading = false;
                                this._isDirty = false;
                            }
                            this._hideView("entity-import");
                            this._hideButtons();
                            this._showView("label");
                            this._showView("entities-grid");

                        } else if (this._currentCOPService == "process") {
                            this._onCOPProcessComplete();
                        }
                    } else {
                        this.logWarning("UnexpectedCOP", "response", JSON.stringify(e.detail.response));
                        this.showErrorToast(statusMessage + ". Please check the service or contact your administrator.");
                        this._isDirty = false;
                        this._loading = false;
                    }
                },
                _onCOPFailure: function (e) {
                    this.logWarning("COPTransformationFail", "response", JSON.stringify(e.detail));
                    this.showErrorToast("Unable to transform excel to json. Please check the service or contact your administrator.");
                    this._loading = false;
                    this._isDirty = false;
                },
                _onCOPProcessComplete: function () {
                    var _entityType = "";
                    if (!_.isEmpty(this.contextData)) {
                        var _itemContext = ContextHelper.getFirstItemContext(this.contextData);
                        if (_itemContext) {
                            _entityType = _itemContext.type;
                        }
                    }
                    var data = {
                        "messages": [
                            {
                                "message": "Entities will be created/updated using the uploaded file."
                            },
                            {
                                "message": "You can view the status of the task " + this._workAutomationId + " in the Task Details"
                            }
                        ],
                        "actions": [
                            {
                                "name": "closeFunction",
                                "text": "Take Me back to Where I started",
                                "action": { "name": "refresh-data" }
                            },
                            {
                                "name": "gotoTaskDetails",
                                "text": "Show me the task details",
                                "dataRoute": "task-detail",
                                "queryParams": {
                                    "id": this._workAutomationId
                                }
                            },
                            {
                                "name": "nextAction",
                                "text": "Upload more entities",
                                "dataRoute": "upload-excel",
                                "queryParams": {
                                    "type": _entityType
                                }
                            }
                        ]
                    };
                    this.businessFunctionData = data;
                    ComponentHelper.getParentElement(this).businessFunctionData = data;
                    var eventName = "onSave";
                    var eventDetail = {
                        name: eventName,
                        data: { "skipNext": this.skipNext }
                    };
                    this._loading = false;
                    this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                },
                _attributeNamesChanged: function (attributeNames, contexts) {
                    if (!_.isEmpty(attributeNames) && contexts != undefined) {
                        this.contextData[ContextHelper.CONTEXT_TYPE_DATA] = contexts;
                        var itemContext = this.getFirstItemContext();

                        itemContext.attributeNames = attributeNames;

                        var t = DataRequestHelper.createEntityModelCompositeGetRequest(this.contextData);

                        this.set("attributeModelRequest", t);

                        var liquidModelGet = this.shadowRoot.querySelector("[name=compositeAttributeModelGet]");
                        if (liquidModelGet) {
                            liquidModelGet.generateRequest();
                        }
                    }
                },
                _onCompositeModelResponse: function (e) {
                    if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                        if (!this._attributeModels) {
                            var attributeModels = DataTransformHelper.transformAttributeModels(e.detail.response.content.entityModels[0], this.contextData);
                            if (!_.isEmpty(attributeModels)) {
                                this.set("_attributeModels", attributeModels);
                                this._populateEntityGrid();
                            } else {
                                this.showErrorToast("Unable to fetch attribute models. Please check the service or contact your administrator.");
                                this._loading = false;
                            }
                        }
                    } else {
                        this.showErrorToast("Unable to fetch attribute models. Please check the service or contact your administrator.");
                        this._loading = false;
                    }
                },
                _populateEntityGrid: function () {
                    var entitiesGrid = this.shadowRoot.querySelector('#entitiesGrid');
                    if (entitiesGrid) {
                        entitiesGrid.config = {};
                        entitiesGrid.data = [];
                        entitiesGrid.attributeModels = {};
                        this._prepareEntityGridConfig();
                        entitiesGrid.config = this._gridConfig;

                        entitiesGrid.data = this._prepareEntityGridData();
                        entitiesGrid.attributeModels = this._attributeModels;
                        this._loading = false;
                        this._showView("actions");
                    }
                },
                _prepareEntityGridConfig: function () {
                    if (this._attributeModels) {
                        var keys = Object.keys(this._attributeModels);
                        if (keys && keys.length > 0) {
                            for (var i = 0; i < keys.length; i++) {
                                var model = this._attributeModels[keys[i]];
                                this._gridConfig.itemConfig.fields[model.name] = {
                                    "header": model.externalName,
                                    "name": model.name,
                                    "sortable": true,
                                    "visible": true,
                                    "isNested": model.dataType === "nested" ? true : false
                                };
                            }
                        }
                        if (!_.isEmpty(this.contexts)) {
                            this._gridConfig.itemConfig.fields["classification"] = {
                                "header": "classification",
                                "name": "classification",
                                "visible": true
                            };
                            this._gridConfig.itemConfig.fields["taxonomy"] = {
                                "header": "taxonomy",
                                "name": "taxonomy",
                                "visible": true
                            };
                        }
                    }
                },
                _prepareEntityGridData: function () {
                    var gridData = [];
                    for (var i = 0; i < this._entities.length; i++) {
                        var entity = this._entities[i];
                        var entityId = DataHelper.getRandomString();
                        var attributes = EntityHelper.getAllAttributes(entity);
                        var keys = Object.keys(attributes);
                        if (keys && keys.length > 0) {
                            var rowData = {
                                "rowId": entityId
                            };
                            for (var j = 0; j < keys.length; j++) {
                                var key = keys[j];
                                if (this._attributeModels[key]) {
                                    rowData[key] = AttributeHelper.getAtributeValueForGrid(attributes[key], this._attributeModels[key]);
                                }
                            }
                            var entityContexts = EntityHelper.getContextsFromEntities([entity]);
                            if (!_.isEmpty(entityContexts)) {
                                var ctx = entityContexts[0];
                                rowData["classification"] = ctx.classification;
                                rowData["taxonomy"] = ctx.taxonomy;
                            }
                            gridData.push(rowData);
                        }
                    }

                    return gridData;
                },
                _onSaveTap: function (e) {
                    this._disableActions();
                    this._loading = true;
                    //get all entities from grid and process save
                    var gridData = this.shadowRoot.querySelector("#entitiesGrid").data;
                    var contextData = DataHelper.cloneObject(this.contextData);
                    this._entities = DataTransformHelper.prepareEntitiesForCreate(gridData, contextData, this._attributeModels);
                    this._currentBatchNumber = 0;
                    this._generateMatchServiceRequest();
                },
                _generateMatchServiceRequest: function () {
                    var batchEntities = this._getNextBatch(this._entities, this._currentBatchNumber, this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        this.set('_entityMatchRequest', {
                            "entities": batchEntities
                        });
                        const entityMatchService = this.shadowRoot.querySelector("#entityMatchService");
                        if (entityMatchService) {
                            entityMatchService.generateRequest();
                        }
                    } else {
                        this._currentBatchNumber = 0;
                        this._currentAction = "create";
                        this._createEntities();
                    }
                },
                _onMatchSuccess: function (e, detail) {
                    if (detail.response) {
                        var responseList = detail.response;
                        if (responseList.length > 0) {
                            for (var i = 0; i < responseList.length; i++) {
                                var entity = this._entities.find(entity => entity.id == responseList[i].id);
                                var response = DataHelper.isValidObjectPath(responseList[i], "operationResponse.response") ? responseList[i].operationResponse.response : {};
                                if (response && response.status && response.status.toLowerCase() == "success") {
                                    if (response.entities) {
                                        if (response.entities.length == 1) {
                                            var matchedEntity = response.entities[0];
                                            entity.id = matchedEntity.id;
                                            this._matchedEntities.push(entity);
                                        } else if (response.entities.length > 1) {
                                            this._faultedEntities.push(entity);
                                        }
                                    } else {
                                        this._newEntities.push(entity);
                                    }
                                } else {
                                    this._faultedEntities.push(entity);
                                }
                            }
                            this._currentBatchNumber++;
                            this._generateMatchServiceRequest();
                        } else {
                            this.logWarning("EntityMatchServiceFail", "response", JSON.stringify(detail));
                            this.showErrorToast("There is a problem in match service. Please contact administrator.");
                            this._isDirty = false;
                            return;
                        }
                    }
                },
                _onMatchFailure: function (e, detail) {
                    this.logWarning("EntityMatchServiceFail", "response", JSON.stringify(detail));
                    this.showErrorToast("There is a problem in match service. Please contact administrator.");
                    this._isDirty = false;
                },
                _createEntities: function () {
                    var batchEntities = this._getNextBatch(this._newEntities, this._currentBatchNumber, this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        var clientState = {};
                        clientState.notificationInfo = {};
                        clientState.notificationInfo.showNotificationToUser = false;

                        this._saveRequest = {
                            "clientState": clientState,
                            "entities": batchEntities
                        };

                        if (DataHelper.isHotlineModeEnabled()) {
                            this._saveRequest.hotline = true;
                        }

                        var liquidSave = this.shadowRoot.querySelector("[name=entitiesSaveDataService]");
                        if (liquidSave) {
                            liquidSave.operation = this._currentAction;
                            liquidSave.generateRequest();
                        }
                    } else {
                        this._currentBatchNumber = 0;
                        this._currentAction = "update";
                        this._updateEntities();
                    }
                },
                _updateEntities: function () {
                    var batchEntities = this._getNextBatch(this._matchedEntities, this._currentBatchNumber, this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        var clientState = {};
                        clientState.notificationInfo = {};
                        clientState.notificationInfo.showNotificationToUser = false;

                        this._saveRequest = {
                            "clientState": clientState,
                            "entities": batchEntities
                        };

                        if (DataHelper.isHotlineModeEnabled()) {
                            this._saveRequest.hotline = true;
                        }

                        var liquidSave = this.shadowRoot.querySelector("[name=entitiesSaveDataService]");
                        if (liquidSave) {
                            liquidSave.operation = this._currentAction;
                            liquidSave.generateRequest();
                        }
                    } else {
                        var msg = "Created " + this._newEntities.length + " entities and updated " + this._matchedEntities.length + " entities.";
                        if (this._faultedEntities.length > 0) {
                            msg = msg + " Found " + this._faultedEntities.length + " entities faulted.";
                        }
                        this.showSuccessToast(msg, 3000);

                        var data = {
                            "messages": [
                                {
                                    "message": msg
                                }
                            ],
                            "actions": [
                                {
                                    "name": "closeFunction",
                                    "text": "Take Me back to Where I started"
                                },
                                {
                                    "name": "nextAction",
                                    "text": "Take me to User Dashboard",
                                    "dataRoute": "dashboard"
                                }
                            ]
                        };
                        this.businessFunctionData = data;
                        ComponentHelper.getParentElement(this).businessFunctionData = data;
                        var eventName = "onSave";
                        var eventDetail = {
                            name: eventName,
                            data: { "skipNext": this.skipNext }
                        };
                        this.fireBedrockEvent(eventName, eventDetail, { ignoreId: true });
                    }
                },
                _onSaveResponse: function (e) {
                    this._currentBatchNumber++;
                    if (this._currentAction == "create") {
                        this._createEntities();
                    } else if (this._currentAction == "update") {
                        this._updateEntities();
                    }
                },
                _onSkipTap: function (e) {
                    //raise event with name given for onbackAction in configuration
                    var data;
                    var eventName = "onCancel";
                    var eventDetail = {
                        name: eventName,
                        data: data
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                },
                _hideButtons: function () {
                    var parentEl = ComponentHelper.getParentElement(this);
                    if (parentEl && parentEl.hideCreateButtons) {
                        parentEl.hideCreateButtons();
                    }
                },
                _getNextBatch: function (entities, currentBatchNumber, batchSize) {
                    var start = currentBatchNumber * batchSize;
                    var end = ((currentBatchNumber + 1) * batchSize) - 1;
                    if (start > entities.length) {
                        return;
                    }
                    if (end > entities.length) {
                        end = entities.length - 1;
                    }
                    return entities.slice(start, end + 1);
                },
                _disableActions: function () {
                    var saveButton = this.shadowRoot.querySelector("#next");
                    var cancelButton = this.shadowRoot.querySelector("#skip")
                    saveButton.setAttribute("disabled", true);
                    cancelButton.setAttribute("disabled", true);
                },
                _onPreviewChange: function (e) {
                    var chkbox = e.currentTarget;
                    if (chkbox.checked) {
                        this._showPreview = true;

                    } else {
                        this._showPreview = false;
                    }
                },
                _onMappingsChange: function (e) {
                    var chkbox = e.currentTarget;
                    if (chkbox.checked) {
                        this.customizeMappings = true;
                    } else {
                        this.customizeMappings = false;
                    }
                },
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                getIsDirty: function () {
                    return this._isDirty;
                },
                _exportDialogOpen: function () {
                    var exportDialog = this.shadowRoot.querySelector("#exportDialog");

                    if (exportDialog) {
                        exportDialog.dialogTitle = "Download Smart Excel Template";
                        this._selectedCategories = [];
                        exportDialog.open();
                    }

                    const contextTree = exportDialog.querySelector('#contextTree');

                    if (contextTree) {
                        contextTree.generateRequest();
                    }
                },
                _onCancelDownloadSelection: function () {
                    var exportDialog = this.shadowRoot.querySelector("#exportDialog");

                    if (exportDialog) {
                        exportDialog.close();
                    }
                },
                _exportSelectedCategory: function (e) {
                    this._downloadInProgress = true;
                    if (this._selectedCategories && this._selectedCategories.length) {
                        var contexts = [];
                        var firstItemContext = this.getFirstItemContext();
                        var fileName = "CategoryTemplate";
                        var categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                        this._selectedCategories.forEach(function (category) {
                            var formattedClassification = category.valuePath.replace(/#@#/g, categoryPathSeperator);
                            contexts.push({
                                "taxonomy": this._taxonomyExtName,
                                "classification": formattedClassification
                            });
                        }, this);

                        if (this._selectedCategories.length == 1) {
                            fileName = this._selectedCategories[0].value.replace(/\W/g, '_');
                        }

                        if (firstItemContext && firstItemContext.type && contexts.length) {
                            var req = {
                                "params": {
                                    "query": {
                                        "contexts": contexts,
                                        "filters": {
                                            "typesCriterion": [
                                                "entityManageModel"
                                            ]
                                        },
                                        "id": firstItemContext.type + "_entityManageModel"
                                    },
                                    "fields": {
                                        "attributes": ["_ALL"],
                                        "relationships": ["_ALL"]
                                    }
                                },
                                "fileName": fileName
                            };

                            var _this = this;
                            RUFUtilities.fileDownload("/data/cop/downloadModelExcel", {
                                httpMethod: 'POST',
                                data: { data: JSON.stringify(req) },
                                successCallback: function (url) {
                                    this._downloadInProgress = false;
                                }.bind(_this),
                                failCallback: function (responseHtml, url, error) {
                                    this._onCOPDownloadFailure(error);
                                }.bind(_this)
                            });

                        }
                    }
                    else {
                        this.showErrorToast("Please select a category to download category model template");
                        this._downloadInProgress = false;
                    }
                },
                _onCOPDownloadFailure: function (e) {
                    this.showErrorToast("Failed to download category model template. Please contact administrator.");
                    this._downloadInProgress = false;
                },
                _importContextComponent: function () {
                    var copCtx = DataHelper.cloneObject(this.copContext);
                    var mappingData = {
                        "headerFields": this.headerFields || [],
                        "contexts": this.contexts,
                        "taxonomies": this.taxonomies,
                        "taxonomy": this.taxonomy,
                        "domain": this.domain,
                        "entityTypeExternalName": this.entityTypeExternalName,
                        "contextExternalNames": this.contextExternalNames,
                        "fileFormat": this.fileFormat  || "Excel",
                        "selectedOptions": this.selectedOptions
                    }

                    this._loading = false;
                    var eventName = "onNext";
                    var eventDetail = {
                        name: eventName,
                        data: {}
                    }
                    //Prepare mapping data, and pass the same as businessFunctionData
                    if(!this.businessFunctionData) {
                        this.businessFunctionData = {};
                    }
                    this.businessFunctionData["context-mapping-data"] = mappingData;
                    ComponentHelper.getParentElement(this).businessFunctionData = this.businessFunctionData;
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                },
                _importAttributeComponent: function () {
                    var copCtx = DataHelper.cloneObject(this.copContext);
                    var mappingData = {
                        "headerFields": this.headerFields || [],
                        "taxonomies": this.taxonomies,
                        "taxonomy": this.taxonomy,
                        "contexts": this.contexts,
                        "domain": this.domain,
                        "fileFormat": this.fileFormat || "Excel",
                        "selectedOptions": this.selectedOptions,
                        "isAplusSheet": true
                    }

                    //Prepare mapping data, and pass the same as businessFunctionData
                    if(!this.businessFunctionData) {
                        this.businessFunctionData = {};
                    }
                    this.businessFunctionData["attribute-mapping-data"] = mappingData;
                    ComponentHelper.getParentElement(this).businessFunctionData = this.businessFunctionData;

                    var eventName = "onNext";
                    var eventDetail = {
                        name: eventName,
                        data: { "skipNext": true }
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                    this._loading = false;
                },
                _onBackTap: function(e) {
                    var eventName = "onBack";
                    var eventDetail = {
                        name: eventName,
                        data: {}
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                },
                _onSkipTap: function() {
                    //Fetch contexts, taxonomies, external names and domain
                    this._loading = true;
                    this._setContexts();
                },
                _showEvent: function(event) {
                    //nextEvent is for upload success, so no button needed
                    if(!_.isEmpty(event) && event.id != "nextEvent") {
                        return true;
                    }

                    return false;
                },
                _onTriggerEvent: function(e, detail) {
                    var event = e.target.getAttribute("id");
                    if(event == "backEvent") {
                        this._onBackTap(e);
                    } else if (event == "skipEvent") {
                        this._onSkipTap(e);
                    }
                },
                _setSelectedOptions: function () {
                    if (this.businessFunctionData && this.businessFunctionData.selectedOptions) {
                        this.selectedOptions.role = this.businessFunctionData.selectedOptions.role.id || "_DEFAULT";
                        this.selectedOptions.ownershipData = this.businessFunctionData.selectedOptions.ownershipData || "_DEFAULT";
                        this.selectedOptions.saveType = this.businessFunctionData.selectedOptions.saveType || "self";
                    }
                }
            });
        })();
    </script>
</dom-module>