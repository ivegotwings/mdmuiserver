<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">

<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/entity-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/attribute-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">


<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">
<link rel="import" href="../liquid-config-get/liquid-config-get.html">
<link rel="import" href="../liquid-config-save/liquid-config-save.html">

<link rel="import" href="../pebble-file-upload/pebble-file-upload.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-checkbox/pebble-checkbox.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->
<dom-module id="rock-entity-upload">
    <template>
        <style include="bedrock-style-common">
            :host {
                display: block;
                height: 100%;
            }

            .placeHolder {
                margin-top: 5px;
                box-shadow: 0 0 10px 0 var(--cloudy-blue-color, #c1cad4);
                position: relative;
                height:70%;
                padding-top:20px;
                padding-bottom: 20px;
                width: calc(100% - 10px);
            }

            #content-label {
                box-shadow: 0 1px 7px 0 var(--palette-cloudy-blue, #c1cad4);
                padding: 15px;
                margin: 10px;
            }

            #image-container {
                width: 30px;
                height: 35px;
                vertical-align: middle;
            }
            .exportSmartExcelContent{
                height:85vh;
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <liquid-rest id="entityMatchService" url="/pass-through-bulk/matchservice/search" method="POST" request-data={{_entityMatchRequest}}
            on-liquid-response="_onMatchSuccess" on-liquid-error="_onMatchFailure">
        </liquid-rest>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="[[attributeModelRequest]]" on-entity-model-composite-get-response="_onCompositeModelResponse"></liquid-entity-model-composite-get>
        <liquid-entity-data-save name="entitiesSaveDataService" operation="" request-data="{{_saveRequest}}" on-response="_onSaveResponse"></liquid-entity-data-save>

        <div id="content-entity-import" hidden class="base-grid-structure w-70 align-center">
            <div class="base-grid-structure-child-1">
                <div align="right" class="checkbox-container">
                    <pebble-checkbox hidden$="[[!enableMappings]]" id="customizeMappingsChk" class="text-steel-grey m-r-10" on-change="_onMappingsChange">Customize Mappings</pebble-checkbox>
                </div>
            </div>
            <div class="base-grid-structure-child-2 button-siblings">
                <div class="placeHolder p-10">
                    <div class="base-grid-structure">
                        <div class="base-grid-structure-child-1">
                            <p class="font-14 text-center text-steel-grey">
                                <a href="#" class="btn-link" on-tap="_exportDialogOpen">Download</a> a system template or just upload an existing data file
                            </p>
                        </div>
                        <div class="base-grid-structure-child-2">
                            <pebble-file-upload id="fileUpload" allowed-file-types="[[allowedFileTypes]]"></pebble-file-upload>
                        </div>
                        <pebble-dialog id="exportDialog" modal show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key>
                            <pebble-spinner active="[[_downloadInProgress]]"></pebble-spinner>
                            <div id="exportSmartExcelContent" class="exportSmartExcelContent">
                                <div class="base-grid-structure">
                                    <div class="base-grid-structure-child-1">
                                        Select one or more classifications to download the smart excel template. You can select the classification at any level and
                                        the data required for all child classifications will be shown in the template.
                                    </div>
                                    <div id="categoryTreeContainer" class="base-grid-structure-child-2">
                                        <div class="button-siblings">
                                            <rock-classification-tree id="contextTree" multi-select="[[multiSelect]]" taxonomy="[[taxonomy]]" context-data="[[contextData]]"
                                                selected-classifications="{{_selectedCategories}}" leaf-node-only="[[leafNodeOnly]]"></rock-classification-tree>
                                        </div>
                                        <div id="exportActions" class="buttonContainer-static" align="center">
                                            <pebble-button id="cancel" class="close btn btn-secondary m-r-10" button-text="Cancel" raised on-tap="_onCancelDownloadSelection"></pebble-button>
                                            <pebble-button id="download" class="apply btn btn-success" button-text="Download" raised on-tap="_exportSelectedCategory"></pebble-button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </pebble-dialog>
                        <!-- screen for import -->

                        <bedrock-pubsub event-name="pebble-file-upload-success" handler="_onFileUploadSuccess" target-id="fileUpload"></bedrock-pubsub>
                    </div>
                </div>
            </div>
            <div id="upload-actions" class="buttonContainer-static" align="center">
                <template is="dom-repeat" id="event-template" items="[[componentEvents]]">
                    <template is="dom-if" if="[[_showEvent(item)]]">
                        <pebble-button id="[[item.id]]" class$="[[item.class]]" button-text="[[item.text]]" on-tap="_onTriggerEvent" data-args$="[[item.event]]"
                            elevation=1 raised></pebble-button>
                    </template>
                </template>
            </div>
        </div>
        <div id="content-label" hidden>
            <img alt="Product image." id="image-container" sizing="contain" src="/src/images/MicrosoftExcel50,100,500px/MicrosoftExcel_100.svg"
            />
            <span class="import-log">
                <strong>[[_fileName]]</strong> uploaded
                <strong>[[_entities.length]]</strong> items with
                <strong>[[attributeNames.length]]</strong> attributes.</span>
        </div>
        <div id="content-entities-grid" hidden class="full-height">
            <rock-grid id="entitiesGrid" page-size="10" context-data="[[contextData]]" attribute-models="[[_attributeModels]]" no-header></rock-grid>
            <span class="font-12">Review the data above. Save process cannot be cancelled once started.</span>
        </div>
        <div id="content-actions" align="center" hidden class="buttonContainer-static">
            <pebble-button class="action-button btn btn-secondary m-r-5" id="skip" button-text="Cancel" raised on-tap="_onSkipTap"></pebble-button>
            <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap"></pebble-button>
        </div>
        <bedrock-pubsub event-name="field-map-save" handler="_onFieldMappingsSave" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="field-map-back" handler="_onFieldMappingsBack" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="field-map-import" handler="_onFieldMappingsImport" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-back" handler="_onContextMappingsBack" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-skip" handler="_onContextMappingsSkipOrSave" target-id=""></bedrock-pubsub>
        <bedrock-pubsub event-name="context-mapping-save" handler="_onContextMappingsSkipOrSave" target-id=""></bedrock-pubsub>
        <liquid-entity-data-get id="taxonomyGetDataService" operation="getbyids" request-data="{{_taxonomyRequest}}" on-response="_onTaxonomyResponse" on-error="_onTaxonomyGetError"></liquid-entity-data-get>
        <liquid-rest id="taxonomyModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_taxonomyModelRequest}}"
            on-liquid-response="_onTaxonomyModelGetResponse" on-liquid-error="_onTaxonomyModelGetError"></liquid-rest>
        <liquid-entity-data-get id="initiateEntitySearch" operation="initiatesearch" request-data="{{entityGetrequest}}" last-response="{{initiateSearchResponse}}"
            on-error="_onGetSearchError" on-response="_onInitiateEntitySearchResponse" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-data-get id="getEntitySearchResultDetail" operation="getsearchresultdetail" request-data="{{entityGetrequest}}"
            request-id="[[initiateSearchResponse.content.requestId]]" last-response="{{getEntitySearchResultsResponse}}" on-error="_onGetSearchError"
            on-response="_onGetEntitySearchResultDetailResponse" exclude-in-progress></liquid-entity-data-get>
        <liquid-entity-model-get id="getEntityTypeModel" operation="getbyids" on-response="_onEntityTypeModelReceived" on-error="_onEntityTypeModelFailed"></liquid-entity-model-get>
    </template>
    <script>
                class RockEntityUpload
                    extends Polymer.mixinBehaviors([
                        RUFBehaviors.UIBehavior,
                        RUFBehaviors.ComponentContextBehavior
                    ], Polymer.OptionalMutableData(Polymer.Element)) {
                    static get is() {
                        return 'rock-entity-upload';
                    }
                    static get observers() {
                        return [
                            '_attributeNamesChanged(attributeNames, contexts)',
                            '_contextChanged(contextData)'
                        ]
                    }
                    static get properties() {
                        return {
                            /**
                             * <b><i>Content development is under progress... </b></i> 
                             */
                            contextData: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            /**
                             * Indicates the names of the attributes that are retrieved from "Excel".
                             */
                            attributeNames: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            /**
                             * Indicates the contexts which are retrieved from "Excel".
                             */
                            contexts: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            /**
                             * Specifies the request object for the attribute model request.
                             */
                            attributeModelRequest: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            /**
                             * Specifies the response object for the attribute models.
                             */
                            attributeModelResponse: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            taxonomy: {
                                type: String
                            },
                            _gridConfig: {
                                type: Object,
                                value: function () {
                                    return {
                                        "viewMode": "Tabular",
                                        "readOnly": true,
                                        "itemConfig": {
                                            "isMultiSelect": false,
                                            "maxNoOfRows": 200,
                                            "fields": {}
                                        },
                                        "viewConfig": {
                                            "tabular": {
                                                "settings": {},
                                                "fieldChanges": {}
                                            }
                                        }
                                    };
                                }
                            },
                            _gridData: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _copRequest: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },

                            _entitiesData: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            _entities: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _saveRequest: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            _attributeModels: {
                                type: Object
                            },
                            _fileName: {
                                type: String
                            },
                            _currentBatchNumber: {
                                type: Number,
                                value: 0
                            },
                            _batchSize: {
                                type: Number,
                                value: 10
                            },
                            _loading: {
                                type: Boolean,
                                value: false
                            },
                            _downloadInProgress: {
                                type: Boolean,
                                value: false
                            },
                            _entityMatchRequest: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            _matchedEntities: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _newEntities: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _faultedEntities: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _currentEntityIndex: {
                                type: Number
                            },
                            _currentAction: {
                                type: String,
                                value: "create"
                            },
                            _showPreview: {
                                type: Boolean,
                                value: false
                            },
                            _isDirty: {
                                type: Boolean,
                                value: false
                            },
                            _workAutomationId: {
                                type: String
                            },
                            uploadMode: {
                                type: String,
                                value: "process",
                                observer: "_onUploadModeChange"
                            },
                            customizeMappings: {
                                type: Boolean,
                                value: false
                            },
                            _selectedCategories: {
                                type: Array,
                                value: function () {
                                    return [];
                                },
                                notify: true
                            },
                            /**
                             * <b><i>Content development is under progress... </b></i> 
                             */
                            enableMappings: {
                                type: Boolean,
                                value: false
                            },
                            _currentCOPService: {
                                type: String,
                                value: "process"
                            },
                            /**
                             * <b><i>Content development is under progress... </b></i> 
                             */
                            skipNext: {
                                type: Boolean,
                                value: false
                            },
                            /**
                             * <b><i>Content development is under progress... </b></i> 
                             */
                            businessFunctionData: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            allowedFileTypes: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            _fileDetails: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            copContext: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            mappingConfig: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            mappingActions: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            _taxonomyExtName: {
                                type: String,
                                value: ""
                            },
                            _taxonomyModelRequest: {
                                type: Object,
                                value: function () {
                                    return {};
                                }
                            },
                            _taxonomyExtNameAttr: {
                                type: String,
                                value: ""
                            },
                            componentEvents: {
                                type: Array,
                                value: function () {
                                    return [];
                                }
                            },
                            selectedOptions: {
                                type: Object,
                                value: function () {
                                    return {
                                        "role": "_DEFAULT",
                                        "ownershipData": "_DEFAULT",
                                        "saveType": "self"
                                    }
                                }
                            },
                            domain: {
                                type: String,
                                value: "generic"
                            },
                            multiSelect: {
                                type: Boolean,
                                value: false
                            },
                            leafNodeOnly: {
                                type: Boolean,
                                value: false
                            }
                        }
                    }



                /**
                 * <b><i>Content development is under progress... </b></i> 
                 */
                ready () {
                    super.ready();
                    if (!this.taxonomy || this.taxonomy == "undefined") {
                        this.taxonomy = this.appSetting("dataDefaults").taxonomy;
                    }
                }
                _contextChanged (contextData) {
                    if (!_.isEmpty(contextData)) {
                        this._showView("entity-import");
                        this._getTaxonomyManageModel();
                    }
                }

                _getTaxonomyManageModel () {
                    this._taxonomyModelRequest = DataRequestHelper.createGetManageModelRequest([
                        "taxonomy"
                    ]);

                    let taxonomyModelGetElement = this.$$("#taxonomyModelGet");

                    if (taxonomyModelGetElement) {
                        taxonomyModelGetElement.generateRequest();
                    }
                }

                _onTaxonomyModelGetResponse (e) {
                    let response = e.detail && e.detail.response ? e.detail.response.response : "";

                    if (response && response.entityModels) {
                        let entityModel = response.entityModels[0];
                        let externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(
                            entityModel);

                        if (externalNameAndExternalNameAttr && externalNameAndExternalNameAttr.externalNameAttr) {
                            this._taxonomyExtNameAttr = externalNameAndExternalNameAttr.externalNameAttr;
                            this._getTaxonomy();
                        } else {
                            this.logError(
                                "Attribute not found with isExternlName in taxonomy entity manage model",
                                e.detail);
                            this._loading = false;
                        }
                    } else {
                        this.logError("rock-entity-upload - Entity manage model not found for taxonomy", e.detail);
                        this._loading = false;
                    }
                }

                _onTaxonomyModelGetError (e) {
                    this.logError("rock-entity-upload - Entity manage model get for taxonomy exception", e.detail);
                    this._loading = false;
                }

                _getTaxonomy () {
                    let contextData = DataHelper.cloneObject(this.contextData);
                    let firstItemContext = ContextHelper.getFirstItemContext(contextData);
                    if (firstItemContext) {
                        firstItemContext.type = "taxonomy";
                        firstItemContext.attributeNames = [this._taxonomyExtNameAttr];
                        firstItemContext.id = this.taxonomy;
                        contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                        let req = DataRequestHelper.createEntityGetRequest(contextData);
                        delete req.params.options;
                        this._taxonomyRequest = req;

                        let taxonomyGetElement = this.$$("#taxonomyGetDataService");

                        if (taxonomyGetElement) {
                            taxonomyGetElement.generateRequest();
                        }
                    }
                }

                _onTaxonomyResponse (e) {
                    if (DataHelper.isValidObjectPath(e, "detail.response.content.entities.0")) {
                        let entity =  e.detail.response.content.entities[0];
                        if (entity && entity.data) {
                            let attributes = entity.data.attributes;

                            if (attributes && attributes[this._taxonomyExtNameAttr]) {
                                this._taxonomyExtName = attributes[this._taxonomyExtNameAttr].values &&
                                    attributes[this._taxonomyExtNameAttr].values.length ?
                                    attributes[this._taxonomyExtNameAttr].values[0].value :
                                    undefined;
                            }
                        }
                    } else {
                        this.logError("rock-entity-upload - Taxonomy get failed", e.detail);
                        this._loading = false;
                    }
                }

                _onTaxonomyGetError (e) {
                    this.logError("rock-entity-upload - Entity get for taxonomy exception", e.detail);
                    this._loading = false;
                }

                _showView (viewName) {
                    if (viewName) {
                        let contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.removeAttribute("hidden");
                        }
                    }
                }

                _hideView (viewName) {
                    if (viewName) {
                        let contentView = this.shadowRoot.querySelector("#content-" + viewName);
                        if (contentView) {
                            contentView.setAttribute("hidden", "");
                        }
                    }
                }

                _onFileUploadSuccess (e, detail, sender) {
                    this._isDirty = true;
                    this._loading = true;
                    this.set("_fileName", detail.originalFileName);

                    let fileDetails = {
                        "file": detail.file,
                        "fileName": detail.fileName,
                        "originalFileName": detail.originalFileName
                    };

                    this.set("_fileDetails", fileDetails);

                    let url = "";
                    if (this.customizeMappings) {
                        this._currentCOPService = "getHeaderFields";
                        url = "/data/cop/getHeaderFields";
                    } else if (this._showPreview) {
                        this._currentCOPService = "transform";
                        url = "/data/cop/transform";
                    } else {
                        this._currentCOPService = "process";
                        url = "/data/cop/process";
                    }
                    this._generateCopRequest(url, this._fileDetails);

                    this.async(function () {
                        //Clear file upload
                        this.$$('pebble-file-upload').reset();
                    });
                }
                _generateCopRequest (url, fileDetails) {
                    let formData = new FormData();
                    formData.append("file", fileDetails.file);
                    formData.append("fileName", fileDetails.fileName);

                    let hotline = false;
                    if (DataHelper.isHotlineModeEnabled()) {
                        hotline = true;
                    }

                    let req = DataRequestHelper.createImportRequest(fileDetails, this.copContext,
                        hotline);
                    if (this._currentCOPService == "process") {
                        this._workAutomationId = DataHelper.generateUUID();
                        req.dataObject.properties.workAutomationId = this._workAutomationId;
                    }

                    if (this._currentCOPService == "getHeaderFields") {
                        let copMappingContext = this.mappingConfig["cop-mapping-context"];
                        req.dataObject.dataObjectInfo.dataObjectType = copMappingContext.dataObjectType;
                        req.dataObject.properties.service = copMappingContext.service;

                        //Set properties for headerFields
                        req.dataObject.properties.fileId = "";
                        if (copMappingContext.excludeSubType) {
                            delete req.dataObject.properties.subtype;
                        }

                        if (copMappingContext.excludeOrder) {
                            delete req.dataObject.properties.order;
                        }
                    }

                    formData.append("requestData", JSON.stringify(req));

                    let xhr = new XMLHttpRequest();
                    xhr.open('POST', url, true);
                    xhr.responseType = 'json';
                    xhr.onload = function (e) {
                        //Process triggred in async manner, so track the details through workAutomationId
                        if (this._currentCOPService == "process") {
                            return;
                        }

                        if (e.currentTarget && e.currentTarget.response) {
                            let response = e.currentTarget.response;
                            e.detail = {
                                "response": response
                            }
                            if ((response.response && response.response.status == "success") ||
                                (response.dataObjectOperationResponse && response.dataObjectOperationResponse
                                    .status == "success")) {
                                this._onCOPSuccess(e);
                            } else {
                                this._onCOPFailure(e);
                            }

                        }
                    }.bind(this);
                    xhr.send(formData);
                    //After sending the form data show workAutomationId to user
                    if (this._currentCOPService == "process") {
                        this._onCOPProcessComplete();
                    }
                }

                async _setContexts () {
                    let itemContext = this.getFirstItemContext();
                    this.entityType = itemContext.type;
                    let contexts = await ContextModelManager.getContextModelsBasedOnEntityType(this.entityType);

                    if (contexts && contexts.length) {
                        let _ctxKeys = [];
                        let contextCoalesceInfo = [];

                        let _contexts = [];
                        contexts.forEach(function (context) {
                            _contexts.push(context.context);
                            if (context && context.properties &&
                                context.properties.coalesceInfo && context.properties.coalesceInfo
                                    .length) {
                                contextCoalesceInfo = contextCoalesceInfo.concat(context.properties
                                    .coalesceInfo)
                            }

                            let ctxKeys = Object.keys(context.context);
                            if (ctxKeys && ctxKeys.length) {
                                ctxKeys.forEach(function (ctxKey) {
                                    if (_ctxKeys.indexOf(ctxKey) < 0) {
                                        _ctxKeys.push(ctxKey);
                                    }
                                }, this);
                            }
                        }, this);

                        this._contexts = _contexts;

                        let _ctxIds = [];
                        if (_ctxKeys && _ctxKeys.length) {
                            _ctxKeys.forEach(function (item) {
                                if (item) {
                                    _ctxIds.push(item);
                                }
                            }, this);
                        }

                        this.contexts = _ctxIds;

                        //Fetch taxonomy type entities
                        let contextData = DataHelper.cloneObject(this.contextData);
                        let firstItemContext = ContextHelper.getFirstItemContext(contextData);
                        if (firstItemContext) {
                            firstItemContext.type = "taxonomy";
                            firstItemContext.attributeNames = ["_ALL"];
                            let req = DataRequestHelper.createEntityGetRequest(contextData);
                            delete req.params.options;
                            this.entityGetrequest = req;

                            //Trigger request
                            let taxonomyGetElement = this.$$("#initiateEntitySearch");
                            if (taxonomyGetElement) {
                                taxonomyGetElement.generateRequest();
                            }
                        }
                    } else {
                        this.logError("rock-entity-upload - Contexts not available in " + this.entityType + "_entityContextModel");
                        this._loading = false;
                    }
                }

                _onInitiateEntitySearchResponse (e, detail) {
                    if (detail && detail.response && detail.response.status == "success") {
                        let taxonomyGetElement = this.$$("#getEntitySearchResultDetail");
                        if (taxonomyGetElement) {
                            taxonomyGetElement.generateRequest();
                        }
                    } else {
                        this._raiseTaxonomyError(detail);
                    }
                }

                _onGetEntitySearchResultDetailResponse (e, detail) {
                    if (detail && detail.response && detail.response.status == "success") {
                        let response = detail.response;
                        if (response.content && response.content.entities && response.content.entities.length) {
                            this.taxonomies = detail.response.content.entities;

                            //Fetch externalNames
                            let entityTypeModelGetEl = this.$$("#getEntityTypeModel");
                            if (entityTypeModelGetEl) {
                                let eTypeIds = [];
                                eTypeIds.push(this.entityType + "_entityType"); //entityType
                                if (this.contexts && this.contexts.length) {
                                    for (let i = 0; i < this.contexts.length; i++) {
                                        eTypeIds.push(this.contexts[i] + "_entityType"); //context
                                    }
                                }
                                entityTypeModelGetEl.requestData = DataRequestHelper.createGetModelRequest("entityType", eTypeIds);
                                entityTypeModelGetEl.generateRequest();
                            }
                        }
                    } else {
                        this._raiseTaxonomyError(detail);
                    }
                }

                _onGetSearchError (e, detail) {
                    this._raiseTaxonomyError(detail);
                }

                _raiseTaxonomyError (detail) {
                    this.logError("rock-entity-upload - Taxonomy entity get error", detail);
                    this.showSuccessToast(
                        "Unable to get taxonomy details, contact administrator.");
                    this._loading = false;
                }

                _onEntityTypeModelReceived (e, detail) {
                    if (DataHelper.isValidObjectPath(detail, "response.content.entityModels")) {
                        let entityModels = detail.response.content.entityModels || [];
                        let entityTypeExternalNames = {};
                        for (let i = 0; i < entityModels.length; i++) {
                            entityTypeExternalNames[entityModels[i].name] = entityModels[i].properties
                                .externalName;

                            //Get domain for the entityType
                            if (entityModels[i].name == this.entityType) {
                                this.domain = entityModels[i].domain;
                            }
                        }

                        this.entityTypeExternalName = entityTypeExternalNames[this.entityType];
                        delete entityTypeExternalNames[this.entityType];
                        this.contextExternalNames = entityTypeExternalNames; // Remaining context names
                    } else {
                        this.logError("rock-entity-upload - Entity type model not found for " + this.entityType, detail);
                    }
                    this._loadMappingComponent();
                }

                _onEntityTypeModelFailed (e, detail) {
                    this.logError("rock-entity-upload - Entity type model get exception", e.detail);
                    this._loadMappingComponent();
                }

                _loadMappingComponent () {
                    this._loading = false;
                    this._isDirty = false;
                    this._setSelectedOptions();

                    if (this.skipContextMapping) {
                        this._importAttributeComponent(); //Attribute Mappings
                    } else {
                        this._importContextComponent(); //Context Mappings
                    }
                }

                _onCOPSuccess (e) {
                    let response = e.detail.response;
                    let statusMessage = DataHelper.validateAndGetMessage(response);
                    if (statusMessage == "") {
                        let res = response.response ? response.response : response;
                        if (this._currentCOPService == "getHeaderFields") {
                            this.headerFields = [];
                            this.attributeFields = [];
                            this.fileFormat = "";
                            this.skipContextMapping = false;
                            let workAutomationId = "";
                            if (DataHelper.isValidObjectPath(res, "dataObjectOperationResponse.statusDetail.message.headers")) {
                                let resHeaders = res.dataObjectOperationResponse.statusDetail.message.headers;
                                this.headerFields = resHeaders.entities;
                                this.fileFormat = resHeaders.format || "Excel";
                                this.skipContextMapping = resHeaders.skipContextMapping;
                            }

                            if (DataHelper.isValidObjectPath(res,
                                "dataObjectOperationResponse.statusDetail.message.workAutomationId"
                            )) {
                                workAutomationId = res.dataObjectOperationResponse.statusDetail.message
                                    .workAutomationId;
                            }

                            if (!this.headerFields || this.headerFields.length == 0) {
                                this.logError(
                                    "Unable to continue with mappings customization.", e.detail
                                );
                                this._loading = false;
                                this._isDirty = false;
                                return;
                            }
                            //Fetch contexts, taxonomies, external names and domain
                            this._setContexts();
                        } else if (this._currentCOPService == "transform" && res.entities && res.entities
                            .length > 0) {
                            this._entities = res.entities;
                            let maxNoOfRows = this._gridConfig.itemConfig.maxNoOfRows;
                            if (maxNoOfRows && this._entities.length > maxNoOfRows) {
                                this.showWarningToast("Preview of more than " + maxNoOfRows +
                                    " entities is not supported. Review the file imported or contact your administrator.",
                                    e.detail);
                                this._loading = false;
                                this._isDirty = false;
                                return;
                            }
                            let attributeNames = EntityHelper.getAttributeNamesFromEntities(this._entities);
                            if (attributeNames && attributeNames.length > 0) {
                                let contexts = EntityHelper.getContextsFromEntities(this._entities);
                                if (contexts && contexts.length > 0) {
                                    this.set("contexts", contexts);
                                }
                                //setting contexts first and then attributeNames, because there is an observer on both
                                //setting attributeNames first would send unnecessary request for model
                                this.set("attributeNames", attributeNames);
                            } else {
                                this.logError(
                                    "Unable to fetch attributes from excel. Check excel file imported.", e.detail
                                );
                                this._loading = false;
                                this._isDirty = false;
                            }
                            this._hideView("entity-import");
                            this._hideButtons();
                            this._showView("label");
                            this._showView("entities-grid");

                        } else if (this._currentCOPService == "process") {
                            this._onCOPProcessComplete();
                        }
                    } else {
                        this.logError("rock-entity-upload - COP response error", e.detail);
                        this.logError(statusMessage +
                            ". Check the service.", e.detail);
                        this._isDirty = false;
                        this._loading = false;
                    }
                }
                _onCOPFailure (e) {
                    this.logError(
                        "Unable to transform excel to json. Check the service.", e.detail
                    );
                    this._loading = false;
                    this._isDirty = false;
                }
                _onCOPProcessComplete () {
                    let _entityType = "";
                    if (!_.isEmpty(this.contextData)) {
                        let _itemContext = ContextHelper.getFirstItemContext(this.contextData);
                        if (_itemContext) {
                            _entityType = _itemContext.type;
                        }
                    }
                    let data = {
                        "messages": [{
                            "message": "Entities will be created/updated using the uploaded file."
                        },
                        {
                            "message": "You can view the status of the task " + this._workAutomationId +
                                " in the Task Details"
                        }
                        ],
                        "actions": [{
                            "name": "closeFunction",
                            "text": "Take Me back to Where I started",
                            "action": {
                                "name": "refresh-data"
                            }
                        },
                        {
                            "name": "gotoTaskDetails",
                            "text": "Show me the task details",
                            "dataRoute": "task-detail",
                            "queryParams": {
                                "id": this._workAutomationId
                            }
                        },
                        {
                            "name": "nextAction",
                            "text": "Upload more entities",
                            "dataRoute": "upload-excel",
                            "queryParams": {
                                "type": _entityType
                            }
                        }
                        ]
                    };
                    this.businessFunctionData = data;
                    ComponentHelper.getParentElement(this).businessFunctionData = data;
                    let eventName = "onSave";
                    let eventDetail = {
                        name: eventName,
                        data: {
                            "skipNext": this.skipNext
                        }
                    };
                    this._loading = false;
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                }
                _attributeNamesChanged (attributeNames, contexts) {
                    if (!_.isEmpty(attributeNames) && contexts != undefined) {
                        this.contextData[ContextHelper.CONTEXT_TYPE_DATA] = contexts;
                        let itemContext = this.getFirstItemContext();

                        itemContext.attributeNames = attributeNames;

                        let t = DataRequestHelper.createEntityModelCompositeGetRequest(this.contextData);

                        this.set("attributeModelRequest", t);

                        let liquidModelGet = this.shadowRoot.querySelector(
                            "[name=compositeAttributeModelGet]");
                        if (liquidModelGet) {
                            liquidModelGet.generateRequest();
                        }
                    }
                }
                _onCompositeModelResponse (e) {
                    if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                        if (!this._attributeModels) {
                            let attributeModels = DataTransformHelper.transformAttributeModels(e.detail
                                .response.content.entityModels[0], this.contextData);
                            if (!_.isEmpty(attributeModels)) {
                                this.set("_attributeModels", attributeModels);
                                this._populateEntityGrid();
                            } else {
                                this.logError(
                                    "Unable to fetch attribute models. Check the service.", e.detail
                                );
                                this._loading = false;
                            }
                        }
                    } else {
                        this.logError(
                            "Unable to fetch attribute models. Check the service.", e.detail
                        );
                        this._loading = false;
                    }
                }
                _populateEntityGrid () {
                    let entitiesGrid = this.shadowRoot.querySelector('#entitiesGrid');
                    if (entitiesGrid) {
                        entitiesGrid.config = {};
                        entitiesGrid.data = [];
                        entitiesGrid.attributeModels = {};
                        this._prepareEntityGridConfig();
                        entitiesGrid.config = this._gridConfig;

                        entitiesGrid.data = this._prepareEntityGridData();
                        entitiesGrid.attributeModels = this._attributeModels;
                        this._loading = false;
                        this._showView("actions");
                    }
                }
                _prepareEntityGridConfig () {
                    if (this._attributeModels) {
                        let keys = Object.keys(this._attributeModels);
                        if (keys && keys.length > 0) {
                            for (let i = 0; i < keys.length; i++) {
                                let model = this._attributeModels[keys[i]];
                                this._gridConfig.itemConfig.fields[model.name] = {
                                    "header": model.externalName,
                                    "name": model.name,
                                    "sortable": true,
                                    "visible": true,
                                    "isNested": model.dataType === "nested" ? true : false
                                };
                            }
                        }
                        if (!_.isEmpty(this.contexts)) {
                            this._gridConfig.itemConfig.fields["classification"] = {
                                "header": "classification",
                                "name": "classification",
                                "visible": true
                            };
                            this._gridConfig.itemConfig.fields["taxonomy"] = {
                                "header": "taxonomy",
                                "name": "taxonomy",
                                "visible": true
                            };
                        }
                    }
                }
                _prepareEntityGridData () {
                    let gridData = [];
                    for (let i = 0; i < this._entities.length; i++) {
                        let entity = this._entities[i];
                        let entityId = DataHelper.getRandomString();
                        let attributes = EntityHelper.getAllAttributes(entity);
                        let keys = Object.keys(attributes);
                        if (keys && keys.length > 0) {
                            let rowData = {
                                "rowId": entityId
                            };
                            for (let j = 0; j < keys.length; j++) {
                                let key = keys[j];
                                if (this._attributeModels[key]) {
                                    rowData[key] = AttributeHelper.getAtributeValueForGrid(attributes[
                                        key], this._attributeModels[key]);
                                }
                            }
                            let entityContexts = EntityHelper.getContextsFromEntities([entity]);
                            if (!_.isEmpty(entityContexts)) {
                                let ctx = entityContexts[0];
                                rowData["classification"] = ctx.classification;
                                rowData["taxonomy"] = ctx.taxonomy;
                            }
                            gridData.push(rowData);
                        }
                    }

                    return gridData;
                }
                _onSaveTap (e) {
                    this._disableActions();
                    this._loading = true;
                    //get all entities from grid and process save
                    let gridData = this.shadowRoot.querySelector("#entitiesGrid").data;
                    let contextData = DataHelper.cloneObject(this.contextData);
                    this._entities = DataTransformHelper.prepareEntitiesForCreate(gridData, contextData,
                        this._attributeModels);
                    this._currentBatchNumber = 0;
                    this._generateMatchServiceRequest();
                }
                _generateMatchServiceRequest () {
                    let batchEntities = this._getNextBatch(this._entities, this._currentBatchNumber,
                        this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        this.set('_entityMatchRequest', {
                            "entities": batchEntities
                        });
                        const entityMatchService = this.shadowRoot.querySelector("#entityMatchService");
                        if (entityMatchService) {
                            entityMatchService.generateRequest();
                        }
                    } else {
                        this._currentBatchNumber = 0;
                        this._currentAction = "create";
                        this._createEntities();
                    }
                }
                _onMatchSuccess (e, detail) {
                    if (detail.response) {
                        let responseList = detail.response;
                        if (responseList.length > 0) {
                            for (let i = 0; i < responseList.length; i++) {
                                let entity = this._entities.find(entity => entity.id == responseList[i].id);
                                let response = DataHelper.isValidObjectPath(responseList[i], "operationResponse.response") ? responseList[i].operationResponse.response : {};
                                if (response && response.status && response.status.toLowerCase() == "success") {
                                    if (response.entities) {
                                        if (response.entities.length == 1) {
                                            let matchedEntity = response.entities[0];
                                            entity.id = matchedEntity.id;
                                            this._matchedEntities.push(entity);
                                        } else if (response.entities.length > 1) {
                                            this._faultedEntities.push(entity);
                                        }
                                    } else {
                                        this._newEntities.push(entity);
                                    }
                                } else {
                                    this._faultedEntities.push(entity);
                                }
                            }
                            this._currentBatchNumber++;
                            this._generateMatchServiceRequest();
                        } else {
                            this.logError(
                                "EntityMatchServiceFail:- There is a problem in match service.", e.detail);
                            this._isDirty = false;
                            return;
                        }
                    }
                }
                _onMatchFailure (e, detail) {
                    this.logError(
                        "EntityMatchServiceFail:- There is a problem in match service." ,e.detail);
                    this._isDirty = false;
                }
                _createEntities () {
                    let batchEntities = this._getNextBatch(this._newEntities, this._currentBatchNumber,
                        this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        let clientState = {};
                        clientState.notificationInfo = {};
                        clientState.notificationInfo.showNotificationToUser = false;

                        this._saveRequest = {
                            "clientState": clientState,
                            "entities": batchEntities
                        };

                        if (DataHelper.isHotlineModeEnabled()) {
                            this._saveRequest.hotline = true;
                        }

                        let liquidSave = this.shadowRoot.querySelector("[name=entitiesSaveDataService]");
                        if (liquidSave) {
                            liquidSave.operation = this._currentAction;
                            liquidSave.generateRequest();
                        }
                    } else {
                        this._currentBatchNumber = 0;
                        this._currentAction = "update";
                        this._updateEntities();
                    }
                }
                _updateEntities () {
                    let batchEntities = this._getNextBatch(this._matchedEntities, this._currentBatchNumber,
                        this._batchSize);
                    if (batchEntities && batchEntities.length > 0) {
                        let clientState = {};
                        clientState.notificationInfo = {};
                        clientState.notificationInfo.showNotificationToUser = false;

                        this._saveRequest = {
                            "clientState": clientState,
                            "entities": batchEntities
                        };

                        if (DataHelper.isHotlineModeEnabled()) {
                            this._saveRequest.hotline = true;
                        }

                        let liquidSave = this.shadowRoot.querySelector("[name=entitiesSaveDataService]");
                        if (liquidSave) {
                            liquidSave.operation = this._currentAction;
                            liquidSave.generateRequest();
                        }
                    } else {
                        let msg = "Created " + this._newEntities.length + " entities and updated " +
                            this._matchedEntities.length + " entities.";
                        if (this._faultedEntities.length > 0) {
                            msg = msg + " Found " + this._faultedEntities.length + " entities faulted.";
                        }
                        this.showSuccessToast(msg, 3000);

                        let data = {
                            "messages": [{
                                "message": msg
                            }],
                            "actions": [{
                                "name": "closeFunction",
                                "text": "Take Me back to Where I started"
                            },
                            {
                                "name": "nextAction",
                                "text": "Take me to User Dashboard",
                                "dataRoute": "dashboard"
                            }
                            ]
                        };
                        this.businessFunctionData = data;
                        ComponentHelper.getParentElement(this).businessFunctionData = data;
                        let eventName = "onSave";
                        let eventDetail = {
                            name: eventName,
                            data: {
                                "skipNext": this.skipNext
                            }
                        };
                        this.fireBedrockEvent(eventName, eventDetail, {
                            ignoreId: true
                        });
                    }
                }
                _onSaveResponse (e) {
                    this._currentBatchNumber++;
                    if (this._currentAction == "create") {
                        this._createEntities();
                    } else if (this._currentAction == "update") {
                        this._updateEntities();
                    }
                }

                _onSkipTap () {
                    //Fetch contexts, taxonomies, external names and domain
                    this._loading = true;
                    this._setContexts();
                }

                _hideButtons () {
                    let parentEl = ComponentHelper.getParentElement(this);
                    if (parentEl && parentEl.hideCreateButtons) {
                        parentEl.hideCreateButtons();
                    }
                }
                _getNextBatch (entities, currentBatchNumber, batchSize) {
                    let start = currentBatchNumber * batchSize;
                    let end = ((currentBatchNumber + 1) * batchSize) - 1;
                    if (start > entities.length) {
                        return;
                    }
                    if (end > entities.length) {
                        end = entities.length - 1;
                    }
                    return entities.slice(start, end + 1);
                }
                _disableActions () {
                    let saveButton = this.shadowRoot.querySelector("#next");
                    let cancelButton = this.shadowRoot.querySelector("#skip")
                    saveButton.setAttribute("disabled", true);
                    cancelButton.setAttribute("disabled", true);
                }
                _onPreviewChange (e) {
                    let chkbox = e.currentTarget;
                    if (chkbox.checked) {
                        this._showPreview = true;

                    } else {
                        this._showPreview = false;
                    }
                }
                _onMappingsChange (e) {
                    let chkbox = e.currentTarget;
                    if (chkbox.checked) {
                        this.customizeMappings = true;
                    } else {
                        this.customizeMappings = false;
                    }
                }
                /**
                 * <b><i>Content development is under progress... </b></i> 
                 */
                getIsDirty () {
                    return this._isDirty;
                }
                _exportDialogOpen () {
                    let exportDialog = this.shadowRoot.querySelector("#exportDialog");

                    if (exportDialog) {
                        exportDialog.dialogTitle = "Download Smart Excel Template";
                        this._selectedCategories = [];
                        exportDialog.open();

                        const contextTree = exportDialog.querySelector('#contextTree');

                        if (contextTree) {
                            contextTree.generateRequest();
                        }
                    }
                }
                _onCancelDownloadSelection () {
                    let exportDialog = this.shadowRoot.querySelector("#exportDialog");

                    if (exportDialog) {
                        exportDialog.close();
                    }
                }
                _exportSelectedCategory (e) {
                    this._downloadInProgress = true;
                    if (this._selectedCategories && this._selectedCategories.length) {
                        let contexts = [];
                        let firstItemContext = this.getFirstItemContext();
                        let fileName = "CategoryTemplate";
                        let categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                        this._selectedCategories.forEach(function (category) {
                            let formattedClassification = category.valuePath.replace(/#@#/g,
                                categoryPathSeperator);
                            contexts.push({
                                "taxonomy": this._taxonomyExtName,
                                "classification": formattedClassification
                            });
                        }, this);

                        if (this._selectedCategories.length == 1) {
                            fileName = this._selectedCategories[0].value.replace(/\W/g, '_');
                        }

                        if (firstItemContext && firstItemContext.type && contexts.length) {
                            let req = {
                                "params": {
                                    "query": {
                                        "contexts": contexts,
                                        "filters": {
                                            "typesCriterion": [
                                                "entityManageModel"
                                            ]
                                        },
                                        "id": firstItemContext.type + "_entityManageModel"
                                    },
                                    "fields": {
                                        "attributes": ["_ALL"],
                                        "relationships": ["_ALL"]
                                    }
                                },
                                "fileName": fileName
                            };

                            let _this = this;
                            RUFUtilities.fileDownload("/data/cop/downloadModelExcel", {
                                httpMethod: 'POST',
                                data: {
                                    data: JSON.stringify(req)
                                },
                                fileName: fileName,
                                successCallback: function (url) {
                                    this._downloadInProgress = false;
                                }.bind(_this),
                                failCallback: function (responseHtml, url, error) {
                                    this._onCOPDownloadFailure(error);
                                }.bind(_this)
                            });

                        }
                    } else {
                        this.logError(
                            "Select a category to download category model template", e.detail);
                        this._downloadInProgress = false;
                    }
                }
                _onCOPDownloadFailure (e) {
                    this.logError("Failed to download category model template", e.detail);
                    this._downloadInProgress = false;
                }
                _importContextComponent () {
                    let copCtx = DataHelper.cloneObject(this.copContext);
                    let mappingData = {
                        "headerFields": this.headerFields || [],
                        "contexts": this.contexts,
                        "taxonomies": this.taxonomies,
                        "taxonomy": this.taxonomy,
                        "domain": this.domain,
                        "entityTypeExternalName": this.entityTypeExternalName,
                        "contextExternalNames": this.contextExternalNames,
                        "fileFormat": this.fileFormat || "Excel",
                        "selectedOptions": this.selectedOptions
                    }

                    this._loading = false;
                    let eventName = "onNext";
                    let eventDetail = {
                        name: eventName,
                        data: {}
                    }
                    //Prepare mapping data, and pass the same as businessFunctionData
                    if (!this.businessFunctionData) {
                        this.businessFunctionData = {};
                    }
                    this.businessFunctionData["context-mapping-data"] = mappingData;
                    ComponentHelper.getParentElement(this).businessFunctionData = this.businessFunctionData;
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                }
                _importAttributeComponent () {
                    let copCtx = DataHelper.cloneObject(this.copContext);
                    let mappingData = {
                        "headerFields": this.headerFields || [],
                        "taxonomies": this.taxonomies,
                        "taxonomy": this.taxonomy,
                        "contexts": this.contexts,
                        "domain": this.domain,
                        "fileFormat": this.fileFormat || "Excel",
                        "selectedOptions": this.selectedOptions,
                        "isAplusSheet": true
                    }

                    //Prepare mapping data, and pass the same as businessFunctionData
                    if (!this.businessFunctionData) {
                        this.businessFunctionData = {};
                    }
                    this.businessFunctionData["attribute-mapping-data"] = mappingData;
                    ComponentHelper.getParentElement(this).businessFunctionData = this.businessFunctionData;

                    let eventName = "onNext";
                    let eventDetail = {
                        name: eventName,
                        data: {
                            "skipNext": true
                        }
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                    this._loading = false;
                }
                _onBackTap (e) {
                    let eventName = "onBack";
                    let eventDetail = {
                        name: eventName,
                        data: {}
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                }
                
                _showEvent (event) {
                    //nextEvent is for upload success, so no button needed
                    if (!_.isEmpty(event) && event.id != "nextEvent") {
                        return true;
                    }

                    return false;
                }
                _onTriggerEvent (e, detail) {
                    let event = e.target.getAttribute("id");
                    if (event == "backEvent") {
                        this._onBackTap(e);
                    } else if (event == "skipEvent") {
                        this._onSkipTap(e);
                    }
                }
                _setSelectedOptions () {
                    if (this.businessFunctionData && this.businessFunctionData.selectedOptions) {
                        this.selectedOptions.role = this.businessFunctionData.selectedOptions.role.id || "_DEFAULT";
                        this.selectedOptions.ownershipData = this.businessFunctionData.selectedOptions.ownershipData.title || "_DEFAULT";
                        this.selectedOptions.saveType = this.businessFunctionData.selectedOptions.saveType || "self";
                    }
                }
                _onUploadModeChange () {
                    if (this.uploadMode && this.uploadMode.toLowerCase() == "mappings") {
                        this.customizeMappings = true;
                    } else {
                        this.customizeMappings = false;
                    }
                }
            }
            customElements.define(RockEntityUpload.is, RockEntityUpload);

    </script>
</dom-module>