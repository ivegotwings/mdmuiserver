<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">

<script>
    /***
    * `RUFBehaviors.SplitScreenBehavior` provides common behavior for rock-relationship-split-screen and rock-attribute-split-screen
    *
    *  ### Example
    *
    *     <dom-module id="x-app">
    *        <template>
    *        </template>
    *        <script>
    *           Polymer({
    *             is: "x-app",
    *
    *             behaviors: [
    *               RUFBehaviors.SplitScreenBehavior
    *             ],
    *
    *             properties: {
    *              
    *             }
    *           });
    *        &lt;/script>
    *     </dom-module>
    */

    window.RUFBehaviors = window.RUFBehaviors || {};
    /** @polymerBehavior RUFBehaviors.SplitScreenBehavior */
    RUFBehaviors.SplitScreenBehaviorIml = {
        properties: {
            contextData: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            /**
                * <b><i>Content development is under progress... </b></i>
                */
            configContext: {
                type: Object,
                value: function () {
                    return {};
                }
            },
            /**
                * Indicates whether the attribute is rendered in the edit mode or view mode.
                * The two possible values are <b>view</b> and <b>edit</b>.
                */
            mode: {
                type: String,
            },
            /**
                * <b><i>Content development is under progress... </b></i>
                */
            noOfScreens: {
                type: Number,
                value: 0
            },

            /**
            * Indicates the number of columns in which the attributes are rendered. Possible values are
            * one, two, and three.
            */
            noOfColumns: {
                type: Number,
                value: 3,
                computed: '_computeColumns(noOfScreens)'
            },

            doSyncValidation: {
                type: Boolean,
                value: false
            },

            _contexts: {
                type: Array,
                value: function () {
                    return [];
                }
            },

            dataIndex: {
                type: String,
                value: "entityData"
            },

            dataSubIndex: {
                type: String,
                value: "data"
            },

            loadGovernData: {
                type: Boolean,
                value: true
            }
        },

        observers: [
            '_computeScreens(contextData, configContext)'
        ],

        /**
        * Can be used to get the elements if they are dirty.
        */
        _getIsDirty: function (el) {
            if (el && el.getIsDirty) {
                return el.getIsDirty();
            }
        },

        _getControlIsDirty: function (el) {
            if (el && el.getControlIsDirty) {
                return el.getControlIsDirty();
            }
        },

        _getStyle: function () {
            return this.noOfScreens == 1 ? 'display: none' : '';
        },

        _isHidden: function (item) {
            let index = this.locales.indexOf(item);

            return index === (this.noOfScreens - 1);
        },

        _computeColumns: function () {
            return this.noOfScreens > 1 ? 1 : this.noOfColumns;
        },

        _onActionsTap: function () {
            alert("actions tapped");
        },

        _getContextData(context) {
            let ctxData = {};

            let itemContext = DataHelper.cloneObject(this.getFirstItemContext());

            if (!itemContext) return ctxData;

            let dataContexts = DataHelper.cloneObject(this.getDataContexts());
            let valContexts = DataHelper.cloneObject(this.getValueContexts());
            let domainContexts = DataHelper.cloneObject(this.getDomainContexts());
            let userContexts = DataHelper.cloneObject(this.getUserContexts());

            itemContext.attributeNames = this.configContext.attributeNames;
            ctxData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];
            ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
            ctxData[ContextHelper.CONTEXT_TYPE_DATA] = [];
            ctxData[ContextHelper.CONTEXT_TYPE_DOMAIN] = [];

            ctxData[ContextHelper.CONTEXT_TYPE_USER] = userContexts;
            ctxData[ContextHelper.CONTEXT_TYPE_DOMAIN] = domainContexts;

            if (!context || (context.type !== 'value' && context.type !== 'data')) {
                ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;
                ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;

                return ctxData;
            }

            if (context.type == "value") {
                ctxData[ContextHelper.CONTEXT_TYPE_DATA] = dataContexts;

                if (valContexts && valContexts.length) {
                    valContexts.forEach(function (valCtx) {
                        if (valCtx[context.name] == context.value) {
                            ctxData[ContextHelper.CONTEXT_TYPE_VALUE].push(valCtx);
                        }
                    });
                }
            } else if (context.type == "data") {
                ctxData[ContextHelper.CONTEXT_TYPE_VALUE] = valContexts;

                if (dataContexts && dataContexts.length) {
                    dataContexts.forEach(function (dataCtx) {
                        if (dataCtx[context.name] == context.value) {
                            ctxData[ContextHelper.CONTEXT_TYPE_DATA].push(dataCtx);
                        }
                    });
                }
            }

            return ctxData;
        },

        _prepareFlatContext: function (contexts, formattedContext, contextType) {
            if (!contexts || !contexts.length || !formattedContext) return;

            contexts.forEach(dataCtx => Object.keys(dataCtx).forEach(item => {
                const contextValue = dataCtx[item];

                let formattedContextItem = formattedContext[item];

                if (!formattedContextItem) {
                    formattedContextItem = formattedContext[item] = [];
                }

                const _isContextExist = this._isContextExist(formattedContextItem, contextValue);

                if (!contextValue || _isContextExist) return;

                formattedContextItem.push({
                    "type": contextType,
                    "name": item,
                    "value": contextValue
                });
            }));
        },

        _computeScreens: function (contextData, configContext) {
            if (_.isEmpty(contextData) || !configContext) return;

            let valContexts = this.getValueContexts();
            let dataContexts = this.getDataContexts();

            let allContexts = {};
            this._prepareFlatContext(valContexts, allContexts, "value");
            this._prepareFlatContext(dataContexts, allContexts, "data");

            let localeManager = ComponentHelper.getLocaleManager();

            const _contexts = Object.keys(allContexts).reduce((res, key, i) => {
                const ctx = allContexts[key];

                if (ctx.length > 1) {
                    for (let i = 0; i < ctx.length; i++) {
                        const ctxElement = ctx[i];
                        ctxElement["header"] = ctxElement.value;
                        if (ctxElement.name && (ctxElement.name == "locale")) {
                            let _localeObj = localeManager.getByName(ctxElement.value);
                            if (!_.isEmpty(_localeObj) && _localeObj.externalName) {
                                ctxElement["header"] = _localeObj.externalName;
                            }
                        }
                    }

                    res.push(...ctx);
                }

                return res;
            }, []);

            this._contexts = _contexts.length ? _contexts : allContexts[Object.keys(allContexts)[0]];
            if (!this._contexts) return;
            this.noOfScreens = this._contexts.length;
        },

        _isContextExist: function (contexts, context) {
            if (!contexts || !context) return false;

            return !!contexts.filter(ctx => ctx.value == context).length;
        },

        _getListClassName() {
            return `${this.listClassName} ${this.listClassName}-${this.noOfScreens}`;
        },

        refresh: function () {
            this._computeScreens(this.contextData, this.configContext);
        },

        _getTitle: function (context) {
            let titleItem = [];
            let contextData = this._getContextData(context);
            let dataContexts = ContextHelper.getFirstDataContext(contextData);
            let valueContexts = ContextHelper.getFirstValueContext(contextData);

            if (dataContexts) {
                for (let dcKey in dataContexts) {
                    if(context.name === dcKey) {
                        titleItem.unshift(dataContexts[dcKey]);
                    } else {
                        titleItem.push(dataContexts[dcKey]);
                    }
                }
            }

            if (valueContexts) {
                for (let vcKey in valueContexts) {

                    //TDOD:: Need to find out a way to check whether it's hidden in dimension selctor or not. 
                    if (vcKey.toLowerCase() != "source") {
                        let item = "";
                        if (vcKey.toLowerCase() == "locale") {
                            let locale = valueContexts[vcKey];
                            let externalName = locale;
                            let localeManager = ComponentHelper.getLocaleManager();

                            if (localeManager && !_.isEmpty(localeManager.localesJson)) {
                                let localeObject = localeManager.localesJson.find(v => v.name == valueContexts[vcKey]);

                                if (localeObject) {
                                    externalName = localeObject.externalName;
                                }
                            }

                            item = externalName;
                        } else {
                            item = valueContexts[vcKey];
                        }

                        if(context.name === vcKey) {
                            titleItem.unshift(item);
                        } else {
                            titleItem.push(item);
                        }
                    }
                }
            }

            return titleItem.join(" :: ");
        }
    };

    /** @polymerBehavior */
    RUFBehaviors.SplitScreenBehavior = [RUFBehaviors.ComponentContextBehavior, RUFBehaviors.UIBehavior, RUFBehaviors.SplitScreenBehaviorIml];
</script>