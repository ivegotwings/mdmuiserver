<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">

<link rel="import" href="../liquid-entity-get/liquid-entity-get.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">

<link rel="import" href="../rock-attribute-list/rock-attribute-list.html">

<!--
`rock-attribute-manage` Represents component to manage attribute values.
It renders rock-attribute-list the specified context parameters. It is responsible for getting and saving attributes data.

@demo demo/index.html 
-->
<dom-module id="rock-attribute-manage">
    <template>
        <style include="pebble-styles-shared">
            .button {
                --pebble-button: {
                    height: 30px;
                    width: 100px;
                    background: var(--white);
                    border: 1px solid var(--cloudy-blue-color);
                    font-size: 15px;
                }
            }
            
            .focus {
                --pebble-button: {
                    height: 30px;
                    width: 100px;
                    font-size: 15px;
                    background: var(--button-bg-color);
                    color: var(--white);
                }
            }
            
            #buttonContainer {
                height: 50px;
                position: fixed;
                bottom: 55px;
                display: none;
                text-align: center;
                padding: 12px 0 0 0;
            }
        </style>
        <rock-attribute-list attribute-values="[[_attributeValues]]" attribute-models="[[_attributeModelResponse.returnValue.attributeModels]]"
            no-of-columns="[[noOfColumns]]" mode="{{mode}}"></rock-attribute-list>
            <liquid-entity-data-get auto name="attributeGetDataService" operation="getbyids" request-data="{{_attributeRequest}}" last-response="{{_attributeResponse}}"></liquid-entity-data-get>
            <!--<liquid-entity-get name="attributeGetService" request="{{_attributeRequest}}" response="{{_attributeResponse}}"></liquid-entity-get>-->
            <liquid-entity-data-save name="attributeSaveDataService" operation="update" request-data="{{_saveRequest}}" last-response="{{_saveResponse}}"
                on-response="_onSaveResponse"></liquid-entity-data-save>
                <liquid-entity-get name="attributeModelGetService" request="{{_attributeModelRequest}}" response="{{_attributeModelResponse}}"></liquid-entity-get>
                <div id="buttonContainer" align="center">
                    <pebble-button id="cancel" class="button" button-text="Cancel" on-tap="_revertAll" elevation=1 raised></pebble-button>
                    <pebble-button id="save" class="focus" button-text="Save" on-tap="_save" elevation=1 raised></pebble-button>
                </div>
    </template>
    <script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute-manage',
                created: function () {
                    if (this.verbose)
                        console.log('attribute manage created');
                },
                attached: function () {
                    if (this.verbose)
                        console.log('attribute manage attached');
                },
                ready: function () {
                    if (this.verbose)
                        console.log('attribute manage ready');
                },
                properties: {
                    /**
                     * Indicates whether the attribute should be rendered in edit mode or view mode. 
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                     * Indicates the no of columns in which the attributes should be rendered. Possible values are 1, 2 and 3.
                     */
                    noOfColumns: {
                        type: Number,
                        value: 1
                    },
                    /**
                     * Indicates the context parameters for which the attribute data has to be managed.
                     * JSON sample to be added here.
                     */
                    context: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indictaes Id of the entity for which the attributes have to be managed.
                     */
                    entityId: {
                        type: String
                    },
                    /**
                     * Indictaes the locale dimension for which the attributes have to be managed.
                     */
                    locale: {
                        type: String
                    },
                    /**
                     * Indictaes the list for which the attributes have to be managed.
                     */
                    list: {
                        type: String
                    },
                    /**
                     * Indictaes the classification for which the attributes have to be managed.
                     */
                    classification: {
                        type: String,
                        value: "nivea/niveaBodyCare/niveaBody/nbodyEssential/nbody/ess/nourishingMilkDry"
                    },
                    /**
                     * Indictaes the source dimension for which the attributes have to be managed.
                     */
                    source: {
                        type: String
                    },
                    /**
                    * Indicates the request object that is passed to the data element to retrive attribute data.
                      Sample: { 
                                action: "getAttributes" 
                              }
                    */
                    _attributeRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the response object that is received from the data element for the attribute get request.
                     */
                    _attributeResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                    * Indicates the request object that is passed to the data element to retrive attribute model data.
                      Sample: { 
                                action: "getAttributeModels" 
                              }
                    */
                    _attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {
                                action: "getAttributeModels"
                            };
                        }
                    },
                    /**
                     * Indicates the response object that is received from the data element for the attribute get request.
                     */
                    _attributeModelResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _saveRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _saveResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _attributeValues: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates whether to write logs or not.
                     */
                    verbose: {
                        type: Boolean,
                        value: false
                    }
                },
                observers: [
                    '_attributeResponseChanged(_attributeResponse)',
                    '_attributeModelResponseChanged(_attributeModelResponse, entityId)',
                    '_contextChanged(context)',
                    '_modeChanged(mode)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior
                ],
                _modeChanged: function (mode) {
                    if (mode == 'edit') {
                        var width = Polymer.dom(this).parentNode.clientWidth;
                        this.$.buttonContainer.style.width = width + "px";
                        this.$.buttonContainer.style.display = "inline-block";
                    } else {
                        this.$.buttonContainer.style.display = "none";
                    }
                },
                _contextChanged: function (context) {
                    if (this.verbose) {
                        console.log("_contextChanged context: " + JSON.stringify(context, null, 2));
                    }

                    if (context && context.attributeGroups) {
                        var t = {
                            action: "getAttributeModels",
                            "attributeGroups": context.attributeGroups
                        };
                        this.set("_attributeModelRequest", t);
                    }
                },
                _attributeModelResponseChanged: function (_attributeModelResponse, entityId) {
                    if (this.verbose) {
                        console.log("_attributeModelResponseChanged _attributeModelResponse: " + JSON.stringify(
                            _attributeModelResponse, null, 2), +
                            " entityId: " + entityId);
                    }

                    if (_attributeModelResponse && _attributeModelResponse.returnValue &&
                        _attributeModelResponse.returnValue.attributeModels) {
                        var attributeNames = [];
                        for (var attributeGroupName in _attributeModelResponse.returnValue.attributeModels) {
                            for (var attributeName in _attributeModelResponse.returnValue.attributeModels[
                                attributeGroupName]) {
                                attributeNames.push(attributeName);
                            }
                        }
                        var req = {
                            "params": {
                                "query": {
                                    "ctx": [{
                                        "list": this.list,
                                        "classification": this.classification
                                    }],
                                    "valCtx": [{
                                        "source": this.source,
                                        "locale": this.locale
                                    }],
                                    "id": this.entityId,
                                    "filters": {
                                        "attributesCriterion": [],
                                        "relationshipsCriterion": [],
                                        "typesCriterion": ["nart"]
                                    }
                                },
                                "fields": {
                                    "ctxTypes": [
                                        "properties"
                                    ],
                                    "attributes": attributeNames,
                                    "relationships": [
                                    ]
                                },
                                "options": {
                                    "totalRecords": 10,
                                    "includeRequest": false
                                }
                            }
                        };
                        this.set("_attributeRequest", req);
                    }
                },
                _attributeResponseChanged: function (_attributeResponse) {
                    if (this.verbose) {
                        console.log("_attributeResponseChanged _attributeResponse: " + JSON.stringify(
                            _attributeResponse, null, 2));
                    }

                    var values = [];
                    var dataContext = {
                        "locale": this.locale,
                        "time": "now",
                        "source": this.source,
                        "list": this.list,
                        "classification": this.classification
                    };
                    if (DataHelper.validateGetEntitiesResponse(_attributeResponse)
                        && DataHelper.validateGetAttributeModelsResponse(this._attributeModelResponse)) {

                        var entity = DataHelper.findEntityById(_attributeResponse.content.entities, this.entityId);
                        if (entity) {
                            values = DataHelper.getAttributesInManageFormat(entity, this._attributeModelResponse.returnValue.attributeModels, dataContext);

                            //ToDo: read following through configuration to set rock title bar
                            //ToDo: this should happen from app-entity-manage
                            if (values[0].attributes[0] && values[0].attributes[1]) {
                                this._setTitleBar(values[0].attributes[0].value, values[0].attributes[1].value);
                            }
                        }
                    }
                    this._attributeValues = values;
                },
                _save: function () {
                    var mainApp = document.querySelector('#app');

                    mainApp.$$("#pebbleAppToast").fitInto = mainApp.$$("#toastArea");
                    //check if any changes
                    //if none, then return operationResult with warning message else proceed
                    var attributeList = Polymer.dom(this).node.root.querySelector('rock-attribute-list');
                    var changedAttributeElements = attributeList.getChangedAttributeElements();
                    if (changedAttributeElements == undefined || changedAttributeElements.length == 0) {
                        mainApp.toastText = "No changes to save";
                        var toastElement = mainApp.$$("#pebbleAppToast");
                        toastElement.toastType = "information";
                        toastElement.heading = "Information";
                        toastElement.autoClose = true;
                        toastElement.show();
                        return {
                            "message": "No changes to save"
                        }; //TODO: Prepare OR
                    }

                    //TODO: Temporary, need to send all the attributes for save as API is not supporting delta comparion within entity content and replacing complete entity object...
                    //changedAttributeElements = attributeList.root.querySelectorAll('rock-attribute');

                    //validate - if error then return operationResult, else proceed
                    //prepare attribute JSON from changed attributes
                    var attributesJSON = [];
                    for (var i = 0; i < changedAttributeElements.length; i++) {
                        var attributeElement = changedAttributeElements[i];
                        var attributeJSON = attributeElement.attributeObject;
                        attributesJSON.push(attributeJSON);
                    }
                    if (this.verbose) {
                        console.log('_save attributesJSON: ', JSON.stringify(attributesJSON, null, 2));
                    }
                    var entityData = {};
                    if (this._attributeResponse && this._attributeResponse.content && this._attributeResponse
                        .content.entities && this._attributeResponse.content.entities.length > 0) {

                        var originalEntity = this._attributeResponse.content.entities[0];
                        for (var entityDataField in originalEntity) {
                            if (entityDataField == "data") {
                                var contextualData = {};
                                contextualData.ctxInfo = [];
                                var ctxItem = {};
                                ctxItem.ctxGroup = { "list": this.list, "classification": this.classification };
                                ctxItem.attributes = DataHelper.transformAttributeFromUIFormat(attributesJSON);
                                contextualData.ctxInfo.push(ctxItem);
                                entityData[entityDataField] = contextualData;
                            } else {
                                entityData[entityDataField] = this._cloneObject(originalEntity[entityDataField]);
                            }
                        }
                    }

                    if (!_.isEmpty(entityData)) {
                        //set requestObject for save liquid
                        this._saveRequest = {
                            "entities": [entityData]
                        };
                        var liquidSave = this.$$("[name=attributeSaveDataService]");
                        if (liquidSave) {
                            liquidSave.generateRequest();
                        }
                    }

                    //this return isnt useful for now
                    return entityData;
                },
                _onSaveResponse: function (e) {
                    var mainApp = document.querySelector('#app');
                    var liquidGet = this.$$("[name=attributeGetDataService]");
                    if (liquidGet) {
                        this.mode = "view";
                        var attributeList = Polymer.dom(this).node.root.querySelector(
                            'rock-attribute-list');
                        attributeList.resetChanged();
                        liquidGet.generateRequest();
                    }
                    mainApp.toastText = "Attribute Data saved successfully!!";
                    var toastElement = mainApp.$$("#pebbleAppToast");
                    toastElement.toastType = "success";
                    toastElement.heading = "Success";
                    toastElement.autoClose = true;

                    toastElement.show();
                    //Raise event on attributes save
                    this.fireBedrockEvent("on-attribute-save", null, { ignoreId: true });
                },
                _revertAll: function () {
                    var attributeList = Polymer.dom(this).node.root.querySelector('rock-attribute-list');
                    attributeList.revertAll();
                    this.mode = "view";
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                _setTitleBar: function (title, subtitle) {
                    var mainApp = document.querySelector('main-app');
                    if (mainApp) {
                        var contentViewMgr = mainApp.$$("rock-content-view-manager");
                        if (contentViewMgr) {
                            var activeContentView = contentViewMgr.$.contentViewManager.querySelector(
                                "rock-content-view:not([hidden])");
                            if (activeContentView) {
                                var contentComponent = activeContentView.$$("app-entity-manage");
                                if (contentComponent) {
                                    var rockTitleBar = contentComponent.$$("rock-titlebar");
                                    if (rockTitleBar) {
                                        rockTitleBar.subTitle = subtitle !== '' ? subtitle : "No Title";
                                        rockTitleBar.title = title !== '' ? title : "No Title";
                                    }
                                }
                            }
                        }
                    }
                },
                /**
                 * Can be used to get if the element is dirty
                 */
                getIsDirty: function () {
                    var attributeList = this.$$("rock-attribute-list");
                    if (attributeList && attributeList.getIsDirty) {
                        return attributeList.getIsDirty();
                    }
                }
            });
        })();
    </script>
</dom-module>