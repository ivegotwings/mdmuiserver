<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/component-helper.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-helpers/message-helper.html">
<link rel="import" href="../bedrock-helpers/data-merge-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">

<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-govern-data-get/liquid-entity-govern-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../rock-attribute-list/rock-attribute-list.html">

<!--
`rock-attribute-manage` Represents the component to manage the attribute values.
It renders the `rock-attribute-list` with the specified context parameters. 
It is responsible to "get" and "save" the attributes.

@demo demo/index.html 
-->
<dom-module id="rock-attribute-manage">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            :host {
                display: block;
                height: 100%;
                @apply --rock-attribute-manage;
            }

            .defaultButton {
                width: 100%;
            }

            .dataFunctionButton {
                width: 100%;
                bottom: 0;
                text-align: center;
                z-index: 9999;
            }

            #errorsDialog {
                --popup-header-color: var(--palette-pinkish-red, #ee204c);
            }

            #rock-attribute-list-container {
                height: 100%;
                overflow-y: auto;
                overflow-x: hidden;
            }

            /* IE edge specific fix for button-siblings */

            _:-ms-lang(x),
            _:-webkit-full-screen,
            .button-siblings {
                height: calc(100% - 50px) !important;
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <pebble-dialog id="errorsDialog" modal small vertical-offset=1 50 horizontal-align="auto" vertical-align="auto" no-cancel-on-outside-click
            no-cancel-on-esc-key dialog-title="Errors on page">
            <p>Found below errors in entity details: </p>
            <ul>
                <template is="dom-repeat" items="[[_syncValidationErrors]]">
                    <li>[[item.attributeExternalName]] with error: [[item.message]]</li>
                </template>
            </ul>
            <p>Do you want to fix the errors or continue?</p>
            <div class="buttons">
                <pebble-button id="skip" class="close btn btn-secondary m-r-5" button-text="Skip & Continue" on-tap="_skipServerErrors"></pebble-button>
                <pebble-button id="ok" class="apply btn btn-success" button-text="Fix" on-tap="_fixServerErrors"></pebble-button>
            </div>
        </pebble-dialog>
        <pebble-dialog id="cancelDialog" dialog-title="Confirmation" modal alert-box show-cancel show-ok no-cancel-on-outside-click
            no-cancel-on-esc-key>
            <p>Are you sure you want to discard the unsaved changes.</p>
        </pebble-dialog>
        <bedrock-pubsub event-name="on-buttonok-clicked" handler="_revertAll" target-id="cancelDialog"></bedrock-pubsub>
        <liquid-entity-data-get name="attributeGetDataService" operation="getbyids" apply-locale-coalesce="[[applyLocaleCoalesce]]"
            last-response="{{_attributeResponse}}" on-response="_onEntityDataGetReceived" on-error="_onEntityDataGetFailed" data-index="[[dataIndex]]"
            data-sub-index="[[dataSubIndex]]"></liquid-entity-data-get>


        <liquid-entity-govern-data-get id="entityGovernDataGet" operation="getbyids" request-data={{_entityGovernDataGetRequest}}
            on-response="_onEntityGovernDataGetReceived" on-error="_onEntityGetFailed" no-cache></liquid-entity-govern-data-get>
        <liquid-entity-data-save name="attributeSaveDataService" operation="[[_entityDataOperation]]" data-index="[[dataIndex]]"
            data-sub-index="[[dataSubIndex]]" request-data="{{_saveRequest}}" last-response="{{_saveResponse}}" on-response="_onSaveResponse"
            on-error="_onSaveError"></liquid-entity-data-save>

        <liquid-entity-model-composite-get on-error="_onEntityModelCompositeGetFailed" name="compositeAttributeModelGet" request-data="{{_attributeModelRequest}}"
            on-entity-model-composite-get-response="_onCompositeModelGetResponse"></liquid-entity-model-composite-get>

        <liquid-rest id="entityGovernService" url="/data/pass-through/entitygovernservice/validate" method="POST" request-data={{_entityGovernRequest}}
            on-liquid-response="_onGovernResponse" on-liquid-error="_onGovernFailed">
        </liquid-rest>
        <liquid-rest id="modelGovernService" url="/data/pass-through/modelgovernservice/validate" method="POST" request-data={{_modelGovernRequest}}
            on-liquid-response="_onGovernResponse" on-liquid-error="_onGovernFailed">
        </liquid-rest>
        <liquid-rest id="entityMatchService" url="/data/pass-through/matchservice/search" method="POST" request-data={{_entityMatchRequest}}
            on-liquid-response="_onMatchSuccess" on-liquid-error="_onMatchFailure">
        </liquid-rest>
        <div class="base-grid-structure button-siblings">
            <div class="base-grid-structure-child-1">
                <template is="dom-if" if="[[_showNoAttributeMessage]]">
                    <div align="center">[[_attributesMessage]]</div>
                </template>
            </div>
            <div class="base-grid-structure-child-2">
                <template is="dom-if" if="{{hasComponentErrored(isComponentErrored)}}">
                    <div id="error-container"></div>
                </template>

                <template is="dom-if" if="{{!hasComponentErrored(isComponentErrored)}}">
                    <div id="rock-attribute-list-container"></div>
                </template>
            </div>
        </div>
        <div id="buttonContainer" align="center" class="buttonContainer-static">
            <pebble-button id="cancel" class="btn btn-secondary m-r-5" button-text="Cancel" on-tap="_openCancelDialog" elevation=1 raised></pebble-button>
            <pebble-button id="save" disabled="[[readonly]]" class="focus btn btn-success" button-text="Save" on-tap="_save" elevation=1
                raised></pebble-button>
        </div>

        <liquid-entity-data-get name="relatedEntityGet" operation="getbyids" on-response="_relatedEntityGetResponse" exclude-in-progress></liquid-entity-data-get>

        <bedrock-pubsub event-name="global-edit" handler="_onGlobalEdit"></bedrock-pubsub>
        <bedrock-pubsub event-name="source-info-open" handler="_onSourceInfoOpen"></bedrock-pubsub>
    </template>
    <script>
        class RockAttributeManage extends Polymer.mixinBehaviors([RUFBehaviors.UIBehavior, RUFBehaviors.ComponentContextBehavior],
            Polymer.OptionalMutableData(Polymer.Element)) {
            static get is() {
                return "rock-attribute-manage";
            }
            static get properties() {
                return {
                    /**
                     * Indicates whether the attribute is rendered in the "edit" mode or "view mode. 
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                     * If set as true , it indicates the component is in read only mode
                     */
                    readonly: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i>
                     */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    configContext: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the number of columns in which the attributes are rendered. Possible values are one, two,
                      and three.
                     */
                    noOfColumns: {
                        type: Number,
                        value: 1
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    allowSaveOnError: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    doSyncValidation: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    successMessage: {
                        type: String,
                        value: ''
                    },
                    /**
                     * Indicates the response object that is received from the data element for the attribute `get request`.
                     */
                    _attributeResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the response object that is received from the data element for the attribute get request.
                     */
                    _attributeModelResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _saveRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _saveResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _attributeValues: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _attributeModels: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    showGroupName: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    groupName: {
                        type: String,
                        value: "My Attributes"
                    },
                    /**
                     * Specifies whether or not to write the logs.
                     */
                    verbose: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Indicates the attribute value objects which renders the attributes.
                     * JSON sample to be added here.
                     */
                    _attributeMessages: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    messageCodeMapping: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _syncValidationErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    functionalMode: {
                        type: "String",
                        value: "default"
                    },
                    _showNoAttributeMessage: {
                        type: Boolean,
                        value: false
                    },
                    _entityDataOperation: {
                        type: String,
                        value: 'update'
                    },
                    _entityMatchRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    applyLocaleCoalesce: {
                        type: Boolean,
                        value: false
                    },

                    applyContextCoalesce: {
                        type: Boolean,
                        value: false
                    },

                    _relatedEntityGetResponse: {
                        type: Object
                    },
                    dataIndex: {
                        type: String,
                        value: "entityData"
                    },
                    dataSubIndex: {
                        type: String,
                        value: "data"
                    },
                    loadGovernData: {
                        type: Boolean,
                        value: true
                    },
                    _modelGovernRequest: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },
                    needAttributesGrouping: {
                        type: Boolean,
                        value: false
                    },
                    _dependentAttributeModels: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _dependentAttributeValues: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _isDependentModelsResponse: {
                        type: Boolean,
                        value: false
                    },
                    _attributesMessage: {
                        type: String,
                        value: "No attributes Found"
                    },
                    _loading: {
                        type: Boolean,
                        value: false
                    },
                    hideRevertAndHistory: {
                        type: Boolean,
                        value: false
                    }
                }
            }
            connectedCallback() {
                super.connectedCallback();
                this.logInfo("AttributeManageAttached");
                this._cancelDialog = this.shadowRoot.querySelector("#cancelDialog");
            }
            disconnectedCallback() {
                super.disconnectedCallback();
                if (this.loadContentFrameId) cancelAnimationFrame(this.loadContentFrameId);
            }
            static get observers() {
                return [
                    '_attributeResponseChanged(_attributeResponse)',
                    '_contextChanged(contextData)',
                    '_modeChanged(mode)'
                ]
            }
            refresh() {
                //this._configContextChanged(this.getFirstValueContext());
                this._contextChanged(this.contextData.ValContexts);
            }
            _getButtonsClass(functionalMode) {
                if (functionalMode == "dataFunction") {
                    return "dataFunctionButton";
                } else {
                    return "defaultButton"
                }
            }
            _onListModeChanged(e) {
                this._modeChanged(e.detail.mode);
            }
            get attributeList() {
                return this.shadowRoot.querySelector('rock-attribute-list');
            }
            _modeChanged(mode, updateList) {
                if (!mode) return;
                this.mode = mode;
                this.$.buttonContainer.style.display = mode === 'edit' ? "block" : 'none';

                if (updateList && this.attributeList) {
                    this.attributeList.mode = mode;
                }
            }
            _contextChanged(valueContexts) {
                if (valueContexts != undefined) {
                    this.logInfo("AttributeManageContextChange", "contextData", this.contextData);

                    if (_.isEmpty(valueContexts) || _.isEmpty(this.contextData)) {
                        return;
                    }

                    if (_.isEmpty(this.configContext)) {
                        this._attributesMessage =
                            "No default attributes are configured, select a group from the menu."
                        this._showNoAttributeMessage = true;
                        return;
                    }

                    this.groupName = this.configContext.groupName ? this.configContext.groupName :
                        this.groupName;
                    let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(
                        this.contextData);

                    if (compositeModelGetRequest) {
                        this._isDependentModelsResponse = false;
                        this._compositeAttributeModelGet = this._compositeAttributeModelGet ||
                            this.shadowRoot.querySelector("[name=compositeAttributeModelGet]");

                        if (this._compositeAttributeModelGet) {
                            this._loading = true;
                            this._compositeAttributeModelGet.useModelCoalesce = !!this.applyContextCoalesce;
                            this._compositeAttributeModelGet.requestData =
                                compositeModelGetRequest;
                            this._compositeAttributeModelGet.generateRequest();
                        }
                    }
                }
            }
            _getContextDataWithDefaultLocale() {
                const defaultLocale = DataHelper.getDefaultLocale();
                let clonedContextData = DataHelper.cloneObject(this.contextData);

                if (clonedContextData && !clonedContextData[ContextHelper.CONTEXT_TYPE_VALUE]) {
                    let defaultContext = clonedContextData[ContextHelper.CONTEXT_TYPE_VALUE].find(
                        context => context.locale === defaultLocale);
                    if (!defaultContext) {
                        let firstValueContext = ContextHelper.getFirstValueContext(
                            clonedContextData);
                        let defaultLocaleValueContext = DataHelper.cloneObject(
                            firstValueContext);
                        defaultLocaleValueContext.locale = defaultLocale;
                        clonedContextData[ContextHelper.CONTEXT_TYPE_VALUE].push(
                            defaultLocaleValueContext);
                    }
                }

                return clonedContextData;
            }
            async _onCompositeModelGetResponse(e) {
                let _attributeModelResponse = this._attributeModelResponse || {};
                let itemContext = this.getFirstItemContext();
                let entityId = itemContext.id;

                this.logInfo("AttributeManageCompositeModelResponse", "response", _attributeModelResponse, "id", entityId);

                if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {

                    let writePermission = true;
                    if (DataHelper.isValidObjectPath(itemContext, "permissionContext.writePermission")) {
                        writePermission = itemContext.permissionContext.writePermission;
                    }

                    if (!this._isDependentModelsResponse) {
                        this._attributeModels = await DataTransformHelper.transformAttributeModelsAsync(
                            e.detail.response.content.entityModels[0], this.contextData,
                            writePermission);
                        let dependentAttributeNames = this._getDependentAttributeNames();

                        if (dependentAttributeNames.length > 0) {
                            let clonedContextData = DataHelper.cloneObject(this.contextData);
                            let itemContext = ContextHelper.getFirstItemContext(clonedContextData);
                            itemContext.attributeNames = dependentAttributeNames;
                            let compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(clonedContextData);

                            if (compositeModelGetRequest) {
                                this._isDependentModelsResponse = true;
                                this._compositeAttributeModelGet = this._compositeAttributeModelGet ||
                                    this.shadowRoot.querySelector("[name=compositeAttributeModelGet]");

                                if (this._compositeAttributeModelGet) {
                                    this._compositeAttributeModelGet.useModelCoalesce = !!this.applyContextCoalesce;
                                    this._compositeAttributeModelGet.requestData = compositeModelGetRequest;
                                    this._compositeAttributeModelGet.generateRequest();
                                    return;
                                }
                            }
                        }
                    } else {
                        let transformedModels = await DataTransformHelper.transformAttributeModelsAsync(
                            e.detail.response.content.entityModels[0], this.contextData,
                            writePermission);
                        this._dependentAttributeModels = this._dependentAttributeModels || {};
                        for (let modelName in transformedModels) {
                            this._dependentAttributeModels[modelName] = transformedModels[
                                modelName];
                        }
                    }

                    entityId = itemContext.id;

                    let attributeNames = Object.keys(this._attributeModels);

                    if (!_.isEmpty(this._dependentAttributeModels)) {
                        let dependentAttributeNames = Object.keys(this._dependentAttributeModels);
                        attributeNames = attributeNames.concat(dependentAttributeNames);
                    }

                    if (attributeNames.length > 0) {

                        if (entityId && entityId != "-1") {
                            //add attribute names in item context
                            itemContext.attributeNames = attributeNames;

                            let contextData = this._getContextDataWithDefaultLocale();
                            let req = DataRequestHelper.createEntityGetRequest(contextData,
                                true);

                            let entityGovernDataGetReq = DataHelper.cloneObject(req);

                            delete entityGovernDataGetReq.params.query.valueContexts;

                            let governAttributeNames = Object.keys(this._attributeModels);
                            entityGovernDataGetReq.params.fields.attributes =
                                governAttributeNames;

                            let liquidDataGet = this.shadowRoot.querySelector("[name=attributeGetDataService]");
                            liquidDataGet.useDataCoalesce = !!this.applyContextCoalesce;
                            liquidDataGet.requestData = req;

                            this.set("_entityGovernDataGetRequest", entityGovernDataGetReq);
                            let liquidGovernGet = this.$.entityGovernDataGet;
                            if (liquidGovernGet && this.loadGovernData && (this.dataIndex != "entityModel")) {
                                liquidGovernGet.generateRequest();
                            } else {
                                liquidDataGet.generateRequest();
                            }
                            this._showNoAttributeMessage = false;
                        } else {
                            let values = await DataTransformHelper.transformAttributes({}, this._attributeModels, this.contextData, "array", true);
                            this.set("_attributeValues", values);
                            this.mode = 'edit';
                            this._loadAttributeList();
                        }
                    } else {
                        if (this.functionalMode == "dataFunction" || this.functionalMode ==
                            "quickManage") {
                            this._showNoAttributeMessage = true;
                        }
                        this._loading = false;
                    }
                } else {
                    this._onEntityModelCompositeGetFailed();
                    this._loading = false;

                }
            }

            _getDependentAttributeNames(attributeModels) {
                let dependentAttributeNames = [];
                this._dependentAttributeModels = this._dependentAttributeModels || {};
                if (_.isEmpty(attributeModels)) {
                    attributeModels = this._attributeModels;
                }
                for (let attributeName in attributeModels) {
                    let model = attributeModels[attributeName];
                    if (model.dataType.toLowerCase() === "nested" && !_.isEmpty(model.group)) {
                        let childAttrModels = model.group[0];
                        let childDependentAttributeNames = this._getDependentAttributeNames(
                            childAttrModels);
                        if (!_.isEmpty(childDependentAttributeNames)) {
                            dependentAttributeNames = dependentAttributeNames.concat(
                                childDependentAttributeNames);
                        }
                    } else if (DataHelper.isValidObjectPath(model,
                            "properties.dependencyInfo.0.dependentOn")) {
                        let attrName = model.properties.dependencyInfo[0].dependentOn;
                        if (this._attributeModels[attrName]) {
                            this._dependentAttributeModels[attrName] = this._attributeModels[
                                attrName];
                        } else if (dependentAttributeNames.indexOf(attrName) === -1) {
                            dependentAttributeNames.push(attrName);
                        }
                    }
                }

                return dependentAttributeNames;
            }

            _onEntityGovernDataGetReceived(e) {
                //TODO: Needs to check with Vishal.
                this._attributeMessages = {};
                let res = e.detail.response;
                let itemContext = this.getFirstItemContext();
                let entityId;
                if (itemContext) {
                    entityId = itemContext.id;
                }
                let entity = DataHelper.findEntityById(res.content.entities, entityId);

                let attrMessages = this._getAttributeMessages(entity);
                this.set('_attributeMessages', attrMessages);


                let liquidDataGet = this.shadowRoot.querySelector(
                    "[name=attributeGetDataService]");
                if (liquidDataGet) {
                    liquidDataGet.generateRequest();
                } else {
                    this._loading = false;
                }
            }
            _onEntityGetFailed(e) {
                this.logError("AttributeManageGetFail", e);
                this._loading = false;
            }
            async _attributeResponseChanged(_attributeResponse) {
                if (_.isEmpty(_attributeResponse)) return;

                this.logInfo("AttributeManageResponseChange", "response", _attributeResponse);

                let attributes = [];
                let dependentAttributes = [];

                if (DataHelper.validateGetEntitiesResponse(_attributeResponse) && this._attributeModels) {
                    let entity = _attributeResponse.content.entities[0];

                    if (entity) {
                        attributes = await DataTransformHelper.transformAttributes(entity, this
                            ._attributeModels, this.contextData, "array", true);
                        if (!_.isEmpty(this._dependentAttributeModels)) {
                            dependentAttributes = await DataTransformHelper.transformAttributes(
                                entity, this._dependentAttributeModels, this.contextData,
                                "array", true);
                        }
                    }
                }
                this._attributeValues = attributes;
                this._dependentAttributeValues = dependentAttributes;

                if (this._attributeValues.length) {
                    this._loadAttributeList();
                } else {
                    this._loading = false;
                }
            }
            _loadAttributeList() {
                Polymer.Async.timeOut.after(100).run(() => {
                    const listContainer = this.shadowRoot.querySelector(
                        "#rock-attribute-list-container");
                    for (let modelName in this._attributeModels) {
                        this._dependentAttributeModels[modelName] = this._attributeModels[
                            modelName];
                    }
                    const meta = {
                        "name": "rock-attribute-list",
                        "path": "/../../src/elements/rock-attribute-list/rock-attribute-list.html",
                        "properties": {
                            "readonly": this.readonly,
                            "show-group-name": true,
                            "group-name": this.groupName,
                            "mode": this.mode,
                            "attribute-values": this._attributeValues,
                            "attribute-models": this._attributeModels,
                            "attribute-messages": this._attributeMessages,
                            "dependent-attribute-models": this._dependentAttributeModels,
                            "dependent-attribute-values": this._dependentAttributeValues,
                            "attributes-chunk-length": this.attributesChunkLength || 10,
                            "no-of-columns": this.noOfColumns,
                            "context-data": this.contextData,
                            "apply-locale-coalesce": this.applyLocaleCoalesce,
                            "need-attributes-grouping": this.needAttributesGrouping,
                            "hide-revert-and-history": this.hideRevertAndHistory
                        }
                    };
                    this.loadContentFrameId = requestAnimationFrame(() => {
                        ComponentHelper.loadContent(listContainer, meta, this, (
                            content) => {
                            content.addEventListener('list-mode-changed',
                                this._onListModeChanged.bind(this));
                        });
                    });
                });
                this._loading = false;
            }
            createNewEntity(attributesJSON) {
                let newEntity = {};
                let firstItemContext = this.getFirstItemContext();

                let entityType = firstItemContext.type && firstItemContext.type;
                let entityId = "e" + ElementHelper.getRandomString();
                let entityName;
                if (this.dataIndex == "entityModel") {
                    entityName = DataHelper.getNameForNewEntityFromAttributes(attributesJSON, this._attributeModels, "isEntityIdentifier");
                    if (this._isEmptyValue(entityName)) {
                        entityId = entityId + "_" + entityType;
                    } else {
                        entityId = entityName + "_" + entityType;
                    }
                } else {
                    entityName = DataHelper.getNameForNewEntityFromAttributes(attributesJSON, this._attributeModels, "isExternalName");
                }

                firstItemContext.id = entityId;
                let modelDomain;
                if (DataHelper.getParamValue('state')) {
                    modelDomain = JSON.parse(DataHelper.getParamValue('state')).modelDomain;
                }

                newEntity = DataTransformHelper.prepareEntityForCreate(entityId, entityType,
                    attributesJSON, this.contextData, DataHelper.getUserName(), {}, this._attributeModels,
                    modelDomain);
                if(entityName) {
                    newEntity.name = entityName;
                }

                this._entityDataOperation = "create";
                this._saveRequest = {
                    "entities": [newEntity]
                };

                this.set('_entityMatchRequest', {
                    "entity": newEntity
                });

                const entityMatchService = this.shadowRoot.querySelector("#entityMatchService");
                if (entityMatchService) {
                    entityMatchService.generateRequest();
                }
                return newEntity;
            }
            showNoChangesToast() {
                RUFUtilities.pebbleAppToast.fitInto = RUFUtilities.appCommon.$.toastArea;;
                RUFUtilities.appCommon.toastText = "No changes to save";
                let toastElement = RUFUtilities.pebbleAppToast;
                toastElement.toastType = "information";
                toastElement.heading = "Information";
                toastElement.autoClose = true;
                toastElement.show();
            }
            async updateEntity(attributesJSON) {
                let newEntity = {};
                let originalEntity = this._attributeResponse.content.entities[0];
                newEntity = await DataTransformHelper.prepareEntityForAttributesSave(
                    originalEntity, attributesJSON, this.contextData, this._attributeModels
                );
                this._entityDataOperation = "update";

                if (!_.isEmpty(newEntity)) {
                    let clonedNewEntity = DataHelper.cloneObject(newEntity);
                    let firstDataContext = ContextHelper.getFirstDataContext(this.contextData);
                    if (!_.isEmpty(firstDataContext)) {
                        clonedNewEntity.data.webProcessingOptions = {
                            "prepareCoalescedResponse": true,
                            "currentSelectedContext": firstDataContext
                        }
                    }

                    //set requestObject for save liquid
                    this._saveRequest = {
                        "entities": [clonedNewEntity]
                    };

                    //Add hotline flag if hotline is enabled
                    if (DataHelper.isHotlineModeEnabled()) {
                        this._saveRequest["hotline"] = true;
                    }

                    if (this.functionalMode == "quickManage") {
                        let clientState = {};
                        clientState.notificationInfo = {};
                        clientState.notificationInfo.showNotificationToUser = false;
                        this._saveRequest["clientState"] = clientState;
                    }
                    if (this.doSyncValidation) {
                        if (this.dataIndex == "entityModel") {
                            let liquidModelGovernGet = this.$.modelGovernService;
                            if (liquidModelGovernGet) {
                                let clonedOriginalEntity = DataHelper.cloneObject(
                                    originalEntity);
                                let mergedEntity = DataMergeHelper.mergeDataObjects(
                                    clonedOriginalEntity, newEntity);
                                let modelReq = DataRequestHelper.createSyncValidationRequest(
                                    mergedEntity.id, mergedEntity.type, mergedEntity.data,
                                    "entityModel");
                                this.set("_modelGovernRequest", modelReq);
                                liquidModelGovernGet.generateRequest();
                            }
                        } else {
                            let liquidGovernGet = this.$.entityGovernService;
                            if (liquidGovernGet && this.loadGovernData) {
                                let req = DataRequestHelper.createSyncValidationRequest(
                                    newEntity.id, newEntity.type, newEntity.data);
                                this.set("_entityGovernRequest", req);
                                liquidGovernGet.generateRequest();
                            }
                        }
                    } else {
                        this._saveEntity();
                    }
                }
                return newEntity;
            }
            responseHasEntities() {
                return this._attributeResponse && this._attributeResponse.content && this._attributeResponse
                    .content.entities && this._attributeResponse.content.entities.length > 0;
            }
            isNewEntity() {
                let firstItemContext = this.getFirstItemContext();
                return firstItemContext && firstItemContext.id == '-1';
            }
            extractAttributes(changedAttributeElements) {
                let attributesJSON = [];
                for (let i = 0; i < changedAttributeElements.length; i++) {
                    let attributeElement = changedAttributeElements[i];
                    let attributeJSON = undefined;
                    if (attributeElement.attributeObject.action == "delete" || this._isEmptyValue(
                            attributeElement.attributeObject.value)) {
                        attributeJSON = DataHelper.cloneObject(attributeElement.originalAttributeObject);
                        attributeJSON.action = "delete";
                    } else {
                        attributeJSON = attributeElement.attributeObject;
                        if (attributeElement.attributeModelObject && attributeElement.attributeModelObject
                            .referenceEntityTypes) {
                            let attributeRefEntityTypes = attributeElement.attributeModelObject
                                .referenceEntityTypes;
                            if (attributeRefEntityTypes instanceof Array &&
                                attributeRefEntityTypes.length > 0) {
                                attributeJSON.referenceEntityType = attributeRefEntityTypes[0];
                            }
                        }
                    }
                    attributesJSON.push(attributeJSON);
                }
                return attributesJSON;
            }
            _isEmptyValue(value) {
                if (typeof (value) === "string") {
                    return value === "" || value.trim().length === 0;
                } else {
                    return _.isEmpty(value);
                }
            }
            async _save(e) {
                if (e.currentTarget.disabled == true) {
                    return;
                }
                //TODO: Needs to check with Vishal.
                //check if any changes
                //if none, then return operationResult with warning message else proceed

                //If have errors return
                if (!this.allowSaveOnError && this.attributeList && this.attributeList.hasModelErrors()) {
                    this.showWarningToast("Cannot save the entity, resolve the errors.");
                    return;
                }

                let changedAttributeElements = this.attributeList && this.attributeList.getChangedAttributeElements();
                if (!changedAttributeElements || changedAttributeElements.length == 0) {
                    this.showNoChangesToast();
                    return {
                        "message": "No changes to save"
                    }; //TODO: Prepare OR
                }

                //TODO: Temporary, need to send all the attributes for save as API is not supporting delta comparion within entity content and replacing complete entity object...
                //changedAttributeElements = attributeList.root.querySelectorAll('rock-attribute');
                //validate - if error then return operationResult, else proceed
                //prepare attribute JSON from changed attributes
                let attributesJSON = this.extractAttributes(changedAttributeElements);

                this.logInfo("AttributeManageSave", "attributes", attributesJSON);
                let newEntity = {};
                if (this.responseHasEntities()) {
                    newEntity = await this.updateEntity(attributesJSON);
                } else if (this.isNewEntity()) {
                    newEntity = this.createNewEntity(attributesJSON);
                }
            }
            _saveEntity() {
                let liquidSave = this.shadowRoot.querySelector(
                    "[name=attributeSaveDataService]");
                if (liquidSave) {
                    liquidSave.generateRequest();
                } else {
                    this.logError(
                        "Save failed: Not able to access attributeSaveDataService liquid");
                }
            }
            _onSaveResponse(e) {
                if (e.detail.response.status == "success") {
                    let liquidGet = this.shadowRoot.querySelector(
                        "[name=attributeGetDataService]");
                    let liquidSave = this.shadowRoot.querySelector(
                        "[name=attributeSaveDataService]");

                    if (liquidGet) {
                        this.mode = "view";
                        this.attributeList && this.attributeList.resetChanged();

                        if (!_.isEmpty(liquidGet.requestData)) {
                            liquidGet.generateRequest();
                        }
                    }

                    if (!(liquidSave && liquidSave.operation == 'create')) {
                        let liquidGovernGet = this.$.attributeGetMessageService;
                        if (liquidGovernGet && this.loadGovernData) {
                            liquidGovernGet.generateRequest();
                        }
                    }

                    let message = this.successMessage ? this.successMessage :
                        "Attribute save request is submitted successfully!!";
                    this.showSuccessToast(message, 10000);

                    //Raise event on attributes save
                    this.fireBedrockEvent("on-attribute-save", null, {
                        ignoreId: true
                    });
                    if (this.functionalMode == "dataFunction") {
                        let eventName = "onSave";
                        let eventDetail = {
                            name: eventName,
                            "action": {
                                "name": "business-condition-save-request"
                            }
                        };
                        this.fireBedrockEvent(eventName, eventDetail, {
                            ignoreId: true
                        });
                    }

                } else {
                    this.showWarningToast("Attribute save failed");
                    this.logError("Attribute save failed. Response status is error", e.detail);
                }
            }
            _onSaveError(e) {
                this.logError("entity update failed", e.detail);
                this.showWarningToast("Attribute save failed");
            }
            _openCancelDialog() {
                if (this.getIsDirty()) {
                    this._cancelDialog.open();
                } else {
                    this._revertAll();
                }
            }
            _revertAll() {
                if (this.functionalMode == "dataFunction") {
                    let eventName = "onSkip";
                    let eventDetail = {
                        name: eventName
                    };
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                } else {
                    this.attributeList && this.attributeList.revertAll();
                    this._modeChanged('view');
                    this._resetErrors();
                }
            }
            _resetErrors() {
                if (this.attributeList) {
                    this.attributeList.updateDependentAttributesAndResetErrors();
                }
            }
            _setTitleBar(values) {
                let mainApp = RUFUtilities.mainApp;
                if (mainApp && mainApp.contentViewManager) {
                    let activeContentView = mainApp.contentViewManager.activeContentView;
                    if (activeContentView) {
                        let contentComponent = activeContentView.shadowRoot.querySelector(
                            "app-entity-manage");
                        if (contentComponent) {
                            contentComponent.setTitleBar(values);
                        }
                    }
                }
            }
            _onGovernResponse(e) {
                if (e && e.detail && e.detail.response && e.detail.response.response && e.detail
                    .response.response.status == "success") {
                    let res = e.detail.response.response;
                    let itemContext = this.getFirstItemContext();
                    let entityId;
                    if (itemContext) {
                        entityId = itemContext.id;
                    }
                    let entity;
                    if (this.dataIndex == "entityModel") {
                        entity = DataHelper.findEntityById(res.entityModels, entityId);
                    } else {
                        entity = DataHelper.findEntityById(res.entities, entityId);
                    }
                    let attrMessages = this._getAttributeMessages(entity);

                    if (!_.isEmpty(attrMessages)) {
                        let errorMessages = MessageHelper.getErrorsFromAttrMessages(
                            attrMessages, this._attributeModels);
                        this.set("_syncValidationErrors", errorMessages);
                        this.$.errorsDialog.open();
                        return;
                    } else {
                        this._saveEntity();
                    }
                } else {
                    this.logError(
                        "AttributeManageValidationFail:- There is a problem in validation service.",
                        e.detail);
                }
            }
            _onGovernFailed(e) {
                this.logError(
                    "AttributeManageGovernFail:- There is a problem in validation service.",
                    e.detail);
            }
            _onEntityModelCompositeGetFailed(e) {
                this.logError(
                    "EntityModelCompositeGetFail:- There is a problem with entity data service (EntityModelCompositeGet).",
                    "", true);
            }
            _onEntityDataGetFailed(e) {
                this.logError(
                    "EntityDataGetFailed:- There is a problem in entity data service. Received empty response.",
                    e.detail, true);
            }
            _onEntityDataGetReceived(e) {
                let {
                    response
                } = e.detail;
                if (response.content && !response.content.entities.length) {
                    this._onEntityDataGetFailed(e);
                }
            }
            _closeErrorsDialog() {
                this.$.errorsDialog._close();
            }
            _skipServerErrors() {
                this._closeErrorsDialog();
                this._saveEntity();
            }
            _fixServerErrors() {
                this._closeErrorsDialog();
                let newAttributeMessages = {};
                if (this._syncValidationErrors) {
                    for (let i = 0; i < this._syncValidationErrors.length; i++) {
                        let attributeMessages = this._syncValidationErrors[i];
                        let attributeName = attributeMessages.attributeName;
                        let message = attributeMessages.message;
                        if (attributeName && message) {
                            let newMessages = [];
                            newAttributeMessages[attributeName] = newMessages;
                            if (newMessages.indexOf(message) < 0) {
                                newMessages.unshift(message);
                            }
                        }
                    }
                }
                this.set('_attributeMessages', newAttributeMessages);
                this._resetErrors();
            }
            /**
             * Can be used to get the elements if they are dirty.
             */
            getIsDirty() {
                if (this.attributeList) {
                    return this.attributeList.getIsDirty();
                }
            }
            /**
             * Can be used to get the controls if they are dirty.
             */
            getControlIsDirty() {
                if (this.attributeList) {
                    return this.attributeList.getControlIsDirty();
                }
            }
            _hasErrors(detail) {
                return !detail || !detail.response ||
                    (detail.response.dataObjectOperationResponse && detail.response.dataObjectOperationResponse
                        .status && detail.response.dataObjectOperationResponse.status.toLowerCase() ==
                        "error") ||
                    (detail.response.response.dataObjectOperationResponse && detail.response.response
                        .dataObjectOperationResponse.status &&
                        detail.response.response.dataObjectOperationResponse.status.toLowerCase() ==
                        "error");
            }
            _onMatchSuccess(e, detail) {
                if (detail.response) {
                    let response = detail.response.response;

                    if (this._hasErrors(detail)) {
                        this.logError("Failed to request match service with error:", detail);
                        return;
                    }

                    if (response.status && response.status.toLowerCase() == "success") {
                        if (response.entities) {
                            if (response.entities.length >= 1) {
                                this.showWarningToast(
                                    "We found one or multiple entites matching in our system. Check entity details or contact your administrator.",
                                    e.detail);
                                let itemContext = this.getFirstItemContext();
                                if (itemContext) {
                                    itemContext.id = -1;
                                }
                                return;
                            }
                        } else {
                            let governReq = DataHelper.cloneObject(this._entityMatchRequest);

                            this.set("_entityGovernRequest", governReq);
                            let liquidSave = this.shadowRoot.querySelector(
                                "[name=attributeSaveDataService]");
                            if (liquidSave) {
                                liquidSave.operation = "create";
                            }
                            let liquidGovernGet = this.$.entityGovernService;
                            if (liquidGovernGet && this.loadGovernData) {
                                liquidGovernGet.generateRequest();
                            }
                        }
                    }
                }
            }
            _onMatchFailure(e, detail) {
                this.logError("There is a problem in match service.", detail);
            }

            _getAttributeMessages(entity) {
                let attrMessages = {};
                let firstDataContext = ContextHelper.getFirstDataContext(this.contextData);

                let mergedAttributes = {};

                if (entity && entity.data && entity.data.attributes) {
                    mergedAttributes = DataMergeHelper.mergeAttributes(mergedAttributes, entity
                        .data.attributes, true);
                }

                if (firstDataContext) {
                    let ctxAttributes = SharedUtils.DataObjectFalcorUtil.getAttributesByCtx(
                        entity, firstDataContext);
                    if (!_.isEmpty(ctxAttributes)) {
                        mergedAttributes = DataMergeHelper.mergeAttributes(mergedAttributes,
                            ctxAttributes, true);
                    }
                }

                attrMessages = MessageHelper.getAttributeMessages(mergedAttributes, this._attributeModels,
                    this.messageCodeMapping, this.localize());

                return attrMessages;
            }
            _onGlobalEdit(e) {
                if (this.areAttributesEditable) {
                    this._modeChanged('edit', true);
                }
            }

            _onSourceInfoOpen(e) {
                let data = e.detail.data;
                let callback = e.detail.callback;
                let relatedEntityGetElement = this.$$("[name=relatedEntityGet]");

                this._relatedEntityGetResponse = function (e) {
                    if (e.detail && e.detail.response && e.detail.response.content) {
                        let entities = e.detail.response.content.entities;

                        if (!_.isEmpty(entities)) {
                            callback(entities[0]);
                        }
                    }
                }

                if (!_.isEmpty(data) && relatedEntityGetElement) {
                    let req = {
                        "params": {
                            "query": {
                                "id": data.id,
                                "filters": {
                                    "typesCriterion": [
                                        data.type
                                    ]
                                }
                            }
                        }
                    }
                    relatedEntityGetElement.requestData = req;
                    relatedEntityGetElement.generateRequest();
                }
            }

            get areAttributesEditable() {
                let hasWritePermissionValues = [];

                for (let attr in this._attributeModels) {
                    if (this._attributeModels.hasOwnProperty(attr)) {
                        hasWritePermissionValues.push(this._attributeModels[attr].hasWritePermission);
                    }
                }

                return !hasWritePermissionValues.every(val => val === false);
            }
        }
        customElements.define(RockAttributeManage.is, RockAttributeManage);
    </script>
</dom-module>