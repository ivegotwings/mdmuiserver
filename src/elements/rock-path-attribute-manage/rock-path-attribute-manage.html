<link rel="import" href="../../../bower_components/polymer/polymer-element.html">
<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">

<link rel="import" href="../../../bower_components/polymer/lib/utils/async.html">

<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-entity-model-get/liquid-entity-model-get.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">

<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<link rel="import" href="../rock-component-config-behavior/rock-component-config-behavior.html">
<!--
<b><i>Content development is under progress... </b></i>

@demo demo/index.html
-->
<dom-module id="rock-path-attribute-manage">
    <template>
        <style include="bedrock-style-common">
            :host {
                display: block;
                height: 100%;
            }

            .buttonContainer-top-right {
                text-align: right;
                padding-top: 10px;
                margin-bottom: 0px;
                margin-top: 0px;
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <div id="buttonContainer" align="center" class="buttonContainer-top-right">
            <pebble-button id="save" class="action-button-focus btn btn-success" button-text="Save" on-tap="_onSave" elevation=1 raised></pebble-button>
        </div>
        <div class="button-siblings">
            <div class="base-grid-structure w-70 align-center" align="center">
                <div class="tree-heading base-grid-structure-child-1">
                    <!-- <p class="status-error status-text" hidden$="[[isClassificationsAvailable]]">Classification not available.</p> -->
                </div>
                <div class="base-grid-structure-child-2">
                    <rock-classification-tree id="contextTree" multi-select="[[multiSelect]]" root-node="[[pathRootNode]]" path-entity-type="[[pathEntityType]]" path-relationship-name="[[pathRelationshipName]]" context-data="[[contextData]]" selected-classifications="{{_selectedCategories}}" leaf-node-only="[[leafNodeOnly]]"></rock-classification-tree>
                </div>
            </div>
        </div>
        <liquid-entity-model-get id="getEntityTypeModel" operation="getbyids" on-response="_onEntityTypeModelReceived" on-error="_onEntityTypeModelFailed"></liquid-entity-model-get>
        <liquid-entity-model-get id="liquidAttributeModelGet" operation="getbyids" on-error="_onAttributeModelGetError" on-response="_onAttributeModelGetResponse" exclude-in-progress></liquid-entity-model-get>
        <liquid-entity-data-get id="getEntity" operation="getbyids" data-index="entityData" on-response="_onEntityGetResponse" on-error="_onEntityGetFailed" no-cache="true"></liquid-entity-data-get>
        <liquid-entity-data-save id="attributeSaveDataService" operation="update" data-index="entityData" last-response="{{_saveResponse}}" on-response="_onSaveResponse" on-error="_onSaveError"></liquid-entity-data-save>
    </template>
    <script>
        class RockPathAttributeManage
            extends Polymer.mixinBehaviors([
                RUFBehaviors.UIBehavior,
                RUFBehaviors.ComponentContextBehavior,
                RUFBehaviors.ComponentConfigBehavior
            ], Polymer.OptionalMutableData(Polymer.Element)) {
            static get is() {
                return 'rock-path-attribute-manage';
            }
            static get observers() {
                return [
                    '_contextChanged(contextData)',
                    '_onSelectedItemsChange(_selectedCategories.*)'
                ]
            }
            static get properties() {
                return {
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _loading: {
                        type: Boolean,
                        value: false
                    },

                    _selectedCategories: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },

                    multiSelect: {
                        type: Boolean,
                        value: false
                    },

                    leafNodeOnly: {
                        type: Boolean,
                        value: false
                    },

                    pathRootNode: {
                        type: String,
                        value: ""
                    },

                    pathEntityType: {
                        type: String,
                        value: ""
                    },

                    pathRelationshipName: {
                        type: String,
                        value: ""
                    },

                    classificationAttributeModel: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    attributeModels: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    classificationAttribute: {
                        type: String,
                        value: ""
                    },

                    _initialClassifications: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _currentEntity: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _pathSeperator: {
                        type: String,
                        value: ""
                    },

                    _valuePathSeperator: {
                        type: String,
                        value: "#@#"
                    }

                }
            }

            /**
             * <b><i>Content development is under progress... </b></i> 
             */
            ready() {
                super.ready();
                this._pathSeperator = this.appSetting('dataDefaults').categoryPathSeparator || ">>";
            }

            _contextChanged(contextData) {
                if (!_.isEmpty(contextData)) {
                    this._loading = true;
                    if (this.isPartOfBusinessFunction) {
                        let context = DataHelper.cloneObject(this.contextData);
                        //App specific
                        let appName = "";
                        appName = ComponentHelper.getCurrentActiveAppName(this);
                        if (appName) {
                            context[ContextHelper.CONTEXT_TYPE_APP] = [{
                                "app": appName
                            }];
                        }
                        this.requestConfig('rock-path-attribute-manage', context);
                    } else {
                        this._triggerGetClassificationsProcess();
                    }
                }
            }

            onConfigLoaded(componentConfig) {
                if (!this.classificationAttribute) {
                    this.logError("Classification attribute missing from config");
                    this._loading = false;
                    return;
                }
                this._triggerGetClassificationsProcess();
            }

            async _triggerGetClassificationsProcess() {
                //entityType, then fetch domain
                let itemContext = this.getFirstItemContext();
                let entityTypeManager = EntityTypeManager.getInstance();
                if (entityTypeManager && itemContext) {
                    this.domain = await entityTypeManager.getDomainByType(itemContext.type);
                }
                let enhancerAttributes = await ContextModelManager.getEnhancerAttributeNamesBasedOnDomainAndContext(this.domain);
                this._liquidAttributeModelGetElement = this.$$('#liquidAttributeModelGet');
                if (this._liquidAttributeModelGetElement) {
                    this._liquidAttributeModelGetElement.requestData = DataRequestHelper.createGetAttributeModelRequest(enhancerAttributes);
                    this._liquidAttributeModelGetElement.generateRequest();
                }
            }

            _onAttributeModelGetResponse(e) {
                let response = e.detail.response;
                if (response && response.content && response.content.entityModels) {
                    let attributeModels = response.content.entityModels;
                    let pathModels = [];
                    let pathRootNodes = [];
                    attributeModels.forEach(function (model) {
                        if (DataHelper.isValidObjectPath(model, "properties.displayType") &&
                            (model.properties.displayType || "").toLowerCase() == "path" &&
                            DataHelper.isValidObjectPath(model.properties, "pathEntityInfo.0.rootNode") &&
                            model.properties.pathEntityInfo[0].rootNode) {
                            pathModels.push(model);
                            pathRootNodes.push(model.properties.pathEntityInfo[0].rootNode);
                        }
                    }, this);
                    this.attributeModels = pathModels;

                    if (_.isEmpty(pathRootNodes)) {
                        this.logError("Classification root nodes not available for the process");
                        this._loading = false;
                        return;
                    }

                    //Prepare entity get request with pathRootNodes
                    let request = this._getClassificationsEntityGetRequest(pathRootNodes);
                    this._triggerEntityGetRequest(request);
                }
            }

            _onAttributeModelGetError(e) {
                this.logError("Attribute model get error", e.detail);
                this._loading = false;
            }

            _getClassificationsEntityGetRequest(pathRootNodes) {
                let request = DataRequestHelper.createEntityGetRequest(this.contextData);
                //Update attributes type and ids
                delete request.params.query.id;
                request.params.fields.attributes = ["externalName"];
                request.params.query.filters.typesCriterion = ["classification"];
                request.params.query.ids = pathRootNodes;

                return request;
            }

            async _onEntityGetResponse(e, detail) {
                let entities = [];
                if (DataHelper.isValidObjectPath(detail, "response.content.entities")) {
                    entities = detail.response.content.entities;
                }

                if (_.isEmpty(entities)) {
                    this.logError("Entities missing for the process");
                    this._loading = false;
                    return;
                }

                if (detail && detail.request && detail.request.requestData) {
                    let request = detail.request.requestData;
                    if (DataHelper.isValidObjectPath(request, "params.query.filters.typesCriterion")) {
                        //Classification get
                        if (request.params.query.filters.typesCriterion.indexOf("classification") != -1) {
                            this._setClassificationAttributeModel(entities);
                            if (_.isEmpty(this.classificationAttributeModel) &&
                                DataHelper.isValidObjectPath(this.classificationAttributeModel, "properties.pathEntityInfo.0")) {
                                this.logError("Classification attribute model missing for the process");
                                this._loading = false;
                                return;
                            }
                            //If component opened in rock BF, then set title
                            let activeBusinessFunctionDialog = RUFUtilities.activeBusinessFunctionDialog;
                            if (activeBusinessFunctionDialog) {
                                activeBusinessFunctionDialog.setTitle("Select classifications for - " + this.classificationAttributeModel.properties.externalName);
                            }
                            //generate request for entity
                            let entityRequest = DataRequestHelper.createEntityGetRequest(this.contextData);
                            entityRequest.params.fields.attributes = [this.classificationAttribute];
                            this._triggerEntityGetRequest(entityRequest);
                        } else {
                            //Current Entity get for already saved classifications
                            this._currentEntity = entities[0];
                            if (DataHelper.isValidObjectPath(entities, "0.data.attributes")) {
                                let attributes = entities[0].data.attributes;
                                let classifications = [];
                                if (attributes[this.classificationAttribute]) {
                                    attributes[this.classificationAttribute].values.forEach(item => {
                                        let paths = item.value.split(this._pathSeperator) || [];
                                        paths.shift(); //Remove root node
                                        classifications.push(paths);
                                    }, this)
                                }
                                this._selectedCategories = this._initialClassifications = classifications;
                            }

                            this._showClassificationTree();
                        }
                    }
                }
            }

            _onEntityGetFailed(e) {
                this.logError("Entities data get failed", e.detail);
                this._loading = false;
            }

            _triggerEntityGetRequest(request) {
                let liquidDataElement = this.shadowRoot.querySelector('#getEntity');
                if (liquidDataElement) {
                    liquidDataElement.requestData = request;
                    liquidDataElement.generateRequest();
                }
            }

            _setClassificationAttributeModel(entities) {
                for (let model of this.attributeModels) {
                    let classificationEntity = entities.filter(entity => {
                        return entity.id == model.properties.pathEntityInfo[0].rootNode;
                    }, this);

                    if (_.isEmpty(classificationEntity) ||
                        !DataHelper.isValidObjectPath(classificationEntity[0], "data.attributes.externalName.values.0.value")) {
                        return;
                    }
                    model.properties.pathEntityInfo[0].rootNodeExternalName = classificationEntity[0].data.attributes.externalName.values[0].value;

                    if (this.classificationAttribute == model.name.toLowerCase()) {
                        this.classificationAttributeModel = model;
                        break;
                    }
                }
            }

            _showClassificationTree() {
                let pathEntityInfo = this.classificationAttributeModel.properties.pathEntityInfo[0];
                this.pathEntityType = pathEntityInfo.pathEntityType;
                this.pathRelationshipName = pathEntityInfo.pathRelationshipName;
                this.pathRootNode = pathEntityInfo.rootNode;

                let contextTree = this.shadowRoot.querySelector('#contextTree');
                if (contextTree) {
                    contextTree.generateRequest();
                }
                this._loading = false;
            }

            _onSelectedItemsChange() {
                this.isComponentDirty = this._isSelectedItemsChanged(this._selectedCategories);
            }

            _isSelectedItemsChanged(selectedItems) {
                selectedItems = selectedItems || [];
                if (selectedItems.length != this._initialClassifications.length) {
                    return true;
                }
                selectedItems = selectedItems.map(item => item.valuePath);
                let initialItems = this._initialClassifications.map(item => item.join(this._valuePathSeperator));
                return !DataHelper.areEqualArrays(selectedItems, initialItems);
            }

            async _onSave(e) {
                if (!this.isComponentDirty) {
                    this.showInformationToast("No changes to save.");
                    return;
                }

                //Add root node for classifications
                let attributesJSON = this._prepareAttributesForSave();
                let saveEntityRequest = await DataTransformHelper.prepareEntityForAttributesSave(this._currentEntity, attributesJSON, this.contextData, this.attributeModels);
                this._setDeleteActionForAttributeValues(saveEntityRequest);
                let liquidDataElement = this.shadowRoot.querySelector('#attributeSaveDataService');
                if (liquidDataElement) {
                    liquidDataElement.requestData = {
                        "entities": [saveEntityRequest]
                    };
                    liquidDataElement.generateRequest();
                }
            }

            _onSaveResponse(e) {
                if (DataHelper.isValidObjectPath(e, "detail.response.status") &&
                    e.detail.response.status == "success") {
                    let itemCtx = ContextHelper.getFirstItemContext(this.contextData) || {};
                    this.dataFunctionComplete({ "id": itemCtx.id, "type": itemCtx.type });
                    this._updateInitialClassifications();
                    this.showSuccessToast("Classifications save request submitted successfully.");
                }
            }

            _onSaveError(e) {
                this.logError("entity update failed", e.detail);
                this.showWarningToast("Attribute save failed");
            }

            _prepareAttributesForSave() {
                let values = [];
                let attributes = [];
                let classificationAttributeModels = this.attributeModels.filter(item => { return item.name == this.classificationAttribute });
                let rootClassificationExternalName = classificationAttributeModels[0].properties.externalName;

                //Add selected categories
                this._selectedCategories.forEach(category => {
                    let valuePath = category.valuePath.replace(eval(`/${this._valuePathSeperator}/g`), this._pathSeperator);
                    values.push(rootClassificationExternalName + this._pathSeperator + valuePath);
                }, this);

                //Add initial categories - further add delete action based on selected categories
                this._initialClassifications.forEach(category => {
                    let valuePath = category.join(this._pathSeperator);
                    let fullPath = rootClassificationExternalName + this._pathSeperator + valuePath;
                    if (values.indexOf(fullPath) == -1) {
                        values.push(fullPath);
                    }
                }, this);

                //Prepare values
                let valueCtxs = ContextHelper.getValueContexts(this.contextData);
                if (!_.isEmpty(valueCtxs)) {
                    valueCtxs.forEach(valueCtx => {
                        attributes.push({
                            "value": values,
                            "source": valueCtx.source,
                            "locale": valueCtx.locale,
                            "selfContext": 1,
                            "name": this.classificationAttribute
                        })
                    }, this)
                }

                return attributes;
            }

            //Set delete action to attribute values based on selected categories
            _setDeleteActionForAttributeValues(saveEntityRequest) {
                if (DataHelper.isValidObjectPath(saveEntityRequest, "data.attributes") &&
                    saveEntityRequest.data.attributes[this.classificationAttribute] &&
                    saveEntityRequest.data.attributes[this.classificationAttribute].values) {
                    let attributeValues = saveEntityRequest.data.attributes[this.classificationAttribute].values;
                    attributeValues.forEach(attributeValue => {
                        let path = attributeValue.value.split(this._pathSeperator);
                        path.shift(); //remove root node
                        path = path.join(this._valuePathSeperator);
                        let filterResults = this._selectedCategories.filter(category => {
                            return category.valuePath == path;
                        })
                        if (_.isEmpty(filterResults)) {
                            attributeValue.action = "delete";
                        }
                    }, this);
                }
            }

            _updateInitialClassifications() {
                let initialClassifications = [];
                this._selectedCategories.forEach(category => {
                    initialClassifications.push(category.valuePath.split(this._valuePathSeperator));
                }, this);
                this._initialClassifications = initialClassifications;
            }
        }
        customElements.define(RockPathAttributeManage.is, RockPathAttributeManage);

    </script>
</dom-module>