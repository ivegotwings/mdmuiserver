<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-a11y-announcer/iron-a11y-announcer.html">
<link rel="import" href="../../../bower_components/iron-overlay-behavior/iron-overlay-behavior.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout-classes.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">

<!--

`pebble-toast` Represents an element that provides precise notifications at the bottom of the screen. They 
are primarily used for system messaging. Once displayed on the screen, they may not be swiped off-screen.  
Multiple pebble-toasts can be visible on the screen.

### Example

        <paper-button id="btnError" raised>Show Error</paper-button>
				<pebble-toast id="toastError" toast-type="error" align-toast="top">
					This is an error message!
				</pebble-toast>
				<script>
					window.addEventListener('WebComponentsReady', function(e) {
							document.querySelector("#btnError").addEventListener('click', function(e) {
								document.querySelector("#toastError").show();
							});
					});
				</script>

### Styling
The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--pebble-toast` | Mixin applied to toast | {}

### Accessibility

See the docs for `Polymer.IronOverlayBehavior` for accessibility features implemented by this element.

@group Pebble Elements
@element pebble-toast
@demo demo/index.html
-->

<dom-module id="pebble-toast">
    <template>
        <style is="custom-style" include="iron-flex iron-flex-alignment pebble-styles-shared">
			:host {
				display: block;
				position: fixed;
				background-color: var(--toast-background, #ffffff);
				color: var(--toast-font-color, #4b4e51);
				height: 40px;
				width: 440px;
				box-sizing: border-box;
                box-shadow: 1px 2px 6px 1px rgba(0, 0, 0, 0.2);
				border-radius: 3px;
				margin: 25px;
                line-height: 20px;
				font-size: var(--font-size-sm, 12px);
				cursor: default;
				-webkit-transition: -webkit-transform 0.3s, opacity 0.3s;
				transition: transform 0.3s, opacity 0.3s;
				opacity: 0;
				-webkit-transform: translateX(100px);
                -ms-transform: translateX(100px);
				transform: translateX(100px);
				@apply(--pebble-font-common-base);
				@apply(--pebble-toast);   
                overflow: hidden;             
			}
			
			:host(.capsule) {
				border-radius: 24px;
			}
			
			:host(.fit-bottom) {
				width: 100%;
				min-width: 0;
				border-radius: 0;
				margin: 0;
			}
			
			:host(.paper-toast-open) {
				opacity: 1;
				-webkit-transform: translateX(0px);
				transform: translateX(0px);
			}

            :host([toast-type="success"]) .toast-type-icon{
                background: var(--toast-success, #09c021);
            }

            :host([toast-type="error"]) .toast-type-icon{
                background: var(--toast-error, #ee204c);
            }

            :host([toast-type="warning"]) .toast-type-icon{
                background: var(--toast-warning, #f78e1e);
            }

            :host([toast-type="information"]) .toast-type-icon{
                background: var(--toast-information, #139ee7);
            }
			
			.container {
				@apply(--layout-horizontal);
				@apply(--layout-justified);
				align-items: center;
                -webkit-align-items: center; /* Safari 7.0+ */
				height: 40px;
				width: 440px;
			}
			
			.layout-vertical {
				@apply(--layout-horizontal);
			}
			
			.toast-heading {
				font-weight: var(--font-bold, bold);
			}
            
            .toast-content{
                padding: 0 10px;
                height: 20px;
                margin-top: 10px;
            }
			
			.toast-close {
                cursor: pointer;
                margin-right: 10px;
                display: inline-block;
                vertical-align: middle;
			}
			
			.toast-type-icon {
                width: 40px;
                height: 40px;
                display: inline-block;
                background: var(--toast-success, #09c021);
			}

            .toast-type-icon::shadow .pebble-icon{
                color: var(--palette-white, #ffffff);
                width: 20px !important;
                height: 20px !important;
                margin-top: 11px;
                display: block;
                margin-left: 11px;
            }
		</style>

<div class="container">
    <template is="dom-if" if="[[heading]]">
        <div class="layout-vertical">
            <span class="toast-type-icon"><pebble-icon icon="[[toastIcon]]"></pebble-icon></span>
            <div class="toast-content">
                <!--<div class="toast-heading">{{heading}}</div>-->
                <div id="label">{{text}}</div>
                <slot></slot>
            </div>
        </div>
    </template>
    <template is="dom-if" if="[[!heading]]">
        <span class="toast-type-icon"><pebble-icon icon="[[toastIcon]]"></pebble-icon></span>
        <div class="toast-content">            
            <div id="label">{{text}}</div>
            <slot></slot>
        </div>
    </template>
    <div class="toast-close">
        <template is="dom-if" if="[[!autoClose]]">
            <pebble-icon class="pebble-md-icons" icon="pebble-md-icons:Clear" on-tap="hide"></pebble-icon>
        </template>
    </div>
</div>
</template>

<script>
    (function () {
        // Keeps track of the toast currently opened.
        var currentToast = null;

        var currentTopOpenedToasts = [];
        var currentBottomOpenedToasts = [];
        var currentCenterOpenedToasts = [];

        var _top = "top";
        var _bottom = "bottom";
        var _center = "center";
        var _right = "right";

        Polymer({
            is: 'pebble-toast',

            behaviors: [
                Polymer.IronOverlayBehavior
            ],

            properties: {
                /**
                 * Specifies the element to fit `this` into.
                 * This is overridden from `Polymer.IronFitBehavior`.
                 */
                fitInto: {
                    type: Object,
                    value: window,
                    observer: '_onFitIntoChanged'
                },

                /**
                 * Indicates an alignment of the toast. The `default value` for this is <b>center</b>.
                 * Other allowed values are: <b>top</b> and <b>bottom</b>. 
                 */
                alignToast: {
                    type: String,
                    value: "center",
                    observer: "_alignToastChanged"
                },


                /**
                 * Indicates the duration in milliseconds to show the toast.
                 * It is linked with auto-close property. It affects only `auto-close` when it is set to <b>true</b>.
                 */
                toastDuration: {
                    type: Number,
                    value: 5000
                },

                /**
                 * Indicates the text to display in the toast.
                 */
                text: {
                    type: String,
                    value: null
                },

                /**
                 * Specifies whether or not toast is closed when you click outside of it.
                 * Set it to <b>false</b> to enable closing of the toast by clicking outside it.
                 * It is overridden from `IronOverlayBehavior`.
                 */
                noCancelOnOutsideClick: {
                    type: Boolean,
                    value: true
                },

                /**
                 * Specifies whether or not auto-focus is disabled for the toast or child nodes.
                 * Set it to <b>true</b> to to disable auto-focusing the toast or child nodes with 
                 * the `autofocus attribute` when the overlay is opened. 
                 * It is overridden from `IronOverlayBehavior`.
                 */
                noAutoFocus: {
                    type: Boolean,
                    value: true
                },

                /**
                 * Indicates an icon that gets displayed as per the toast type.
                 * You can override the icon.
                 */
                toastIcon: {
                    type: String,
                    value: null
                },

                /**
                 * Indicates the background color of the toast as per its type.
                 * You can override the toast background color.
                 */
                toastColor: {
                    type: String,
                    value: null,
                    observer: '_onToastColorChange'
                },

                /**
                 * Indicates the text and border color of the toast as per its type.
                 * You can override the toast text and color of the border.
                 */
                toastTextColor: {
                    type: String,
                    value: null,
                    observer: '_onToastColorChange'
                },

                /**
                 * Indicates the type of the toast. Color is defined as per this toast icon.
                 * Defined toast types are success, warning, information, error, and task.
                 */
                toastType: {
                    type: String,
                    value: null,
                    observer: '_toastChanged'
                },

                /**
                 * Specifies whether or not the toast is closed without the user action.
                 */
                autoClose: {
                    type: Boolean,
                    value: false,
                    observer: '_autoCloseChanged'
                },

                /**
                 * Indicates the heading of a toast.
                 */
                heading: {
                    type: String,
                    value: null
                }

            },

            listeners: {
                'transitionend': '__onTransitionEnd',
                'iron-overlay-opened': '_toastOpened',
                'iron-overlay-closed': '_toastClosed',
            },

            //Fired when autoClose is changed.
            _autoCloseChanged: function () {
                if (this.autoClose) {
                    this.duration = this.toastDuration <= 0 ? 1000 : this.toastDuration;
                }
                else {
                    this.duration = 0;
                }
            },

            //Fired when alignToast is changed.
            _alignToastChanged: function () {
                if (this.alignToast == _bottom) {
                    this.verticalAlign = _bottom;
                    this.horizontalAlign = _right;
                }
                else {
                    this.verticalAlign = _top;
                    this.horizontalAlign = _right;
                }
            },

            _onToastColorChange: function(){
                this.customStyle['--pebble-toast-background-color'] = this.toastColor;
                this.customStyle['--pebble-toast-color'] = this.toastTextColor;
                this.updateStyles();
            },

            //Fired when toast type is changed. 
            _toastChanged: function () {
                if (!this.toastType) {
                    return;
                }

                if (this.toastType == 'error') {
                    if (this.toastIcon == '' || this.toastIcon == undefined) {
                        this.toastIcon = "pebble-icons:Warning";
                    }

                    if (this.toastColor == '' || this.toastColor == undefined) {
                        this.toastColor = "#fae6e1";
                        this.toastTextColor = "#ee204c";
                    }
                }
                else if (this.toastType == 'warning') {
                    if (this.toastIcon == '' || this.toastIcon == undefined) {
                        this.toastIcon = "pebble-icons:Warning";
                    }

                    if (this.toastColor == '' || this.toastColor == undefined) {
                        this.toastColor = "#fbf4d4";
                        this.toastTextColor = "#f78e1e";
                    }
                }
                else if (this.toastType == 'success') {
                    if (this.toastIcon == '' || this.toastIcon == undefined) {
                        this.toastIcon = "pebble-icons:SuccessToast";
                        this.toastColor = "rgba(93, 202, 115, 0.25)";
                        this.toastTextColor = "rgba(93, 202, 115, 1)";
                    }
                }
                else if (this.toastType == 'information') {
                    if (this.toastIcon == '' || this.toastIcon == undefined) {
                        this.toastIcon = "pebble-icons:InfoOutline";
                        this.toastColor = "rgba(22, 180, 252, 0.25)";
                        this.toastTextColor = "rgba(22, 180, 252, 1)";
                    }
                }
                else if (this.toastType == 'task') {
                    if (this.toastIcon == '' || this.toastIcon == undefined) {
                        this.toastIcon = "pebble-icons:Done";
                    }

                    if (this.toastColor == '' || this.toastColor == undefined) {
                        this.toastColor = "rgba(187, 134, 239, 0.25)";
                        this.toastTextColor = "rgba(187, 134, 239, 1)";
                    }
                }


                this.customStyle['--pebble-toast-background-color'] = this.toastColor;
                this.customStyle['--pebble-toast-color'] = this.toastTextColor;
                this.updateStyles();
            },

            /**
             * Can be used to refit if the overlay is opened and is not animating.
             * @protected
             */
            _onIronResize: function () {
                var currentOpenedToasts = [];
                currentOpenedToasts = currentCenterOpenedToasts.concat(currentTopOpenedToasts).concat(currentBottomOpenedToasts);

                if (currentOpenedToasts.length > 0) {
                    for (var idx = 0; idx < currentOpenedToasts.length; idx++) {
                        currentOpenedToasts[idx].style.transition = '';
                        currentOpenedToasts[idx].refit();
                    }
                    this._arrangeToasts(_center);
                    this._arrangeToasts(_top);
                    this._arrangeToasts(_bottom);
                }
            },

            // Can be used to stack the toast as per alignment when overlay is opened.
            _toastOpened: function () {
                if (this.alignToast == _top) {
                    currentTopOpenedToasts.push(this);
                }
                else if (this.alignToast == _bottom) {
                    currentBottomOpenedToasts.push(this);
                }
                else {
                    this.alignToast = _center;
                    currentCenterOpenedToasts.push(this);
                }

                //Arrangment will be done as per alignment
                this._arrangeToasts(this.alignToast, true);
            },

            // Can be used to remove the overlay from the stack as per alignment when overlay is closed. 
            _toastClosed: function () {
                if (this.alignToast == _bottom) {
                    this._removeToastFromProcess(currentBottomOpenedToasts, this);
                    this._refitAndArrangeToasts(currentBottomOpenedToasts, this.alignToast); //Refit toasts before alignment            
                }
                else if (this.alignToast == _top) {
                    this._removeToastFromProcess(currentTopOpenedToasts, this);
                    this._refitAndArrangeToasts(currentTopOpenedToasts, this.alignToast); //Refit toasts before alignment
                }
                else {
                    this._removeToastFromProcess(currentCenterOpenedToasts, this);
                    this._refitAndArrangeToasts(currentCenterOpenedToasts, this.alignToast); //Refit toasts before alignment
                }
            },

            //Can be used to refit the toasts before arrangments.This prevents the gap that gets displayed when a toast is closed.
            _refitAndArrangeToasts: function (currentOpenedToasts, alignment) {
                if (currentOpenedToasts.length > 0) {
                    for (var idx = 0; idx < currentOpenedToasts.length; idx++) {
                        currentOpenedToasts[idx].refit();
                    }

                    //Arrangment will be done as per alignment
                    this._arrangeToasts(alignment);
                }
            },

            //Can be used to remove the toast from process.
            _removeToastFromProcess: function (currentOpenedToasts, closedToast) {
                for (var idx = 0; idx < currentOpenedToasts.length; idx++) {
                    if (currentOpenedToasts[idx].attributes["id"] != undefined && closedToast.attributes["id"] != undefined) {
                        if (currentOpenedToasts[idx].attributes["id"].value == closedToast.attributes["id"].value) {
                            currentOpenedToasts.splice(idx, 1);
                            break;
                        }
                    }
                }
            },

            // Can be used to arrange the toasts.
            //alignment - toast group will be picked based on alignment
            //isOpen - will true when toast opens
            _arrangeToasts: function (alignment, isOpen) {

                if (alignment == _center) {
                    this._arrangeToastsPerAlignment(currentCenterOpenedToasts, alignment, isOpen);
                }
                else if (alignment == _top) {
                    this._arrangeToastsPerAlignment(currentTopOpenedToasts, alignment, isOpen);
                }
                else if (alignment == _bottom) {
                    this._arrangeToastsPerAlignment(currentBottomOpenedToasts, alignment, isOpen);
                }
                else {
                    this._arrangeToastsPerAlignment(currentCenterOpenedToasts, _center, isOpen);
                    this._arrangeToastsPerAlignment(currentTopOpenedToasts, _top, isOpen);
                    this._arrangeToastsPerAlignment(currentBottomOpenedToasts, _bottom, isOpen);
                }
            },

            // Can be used to calculate the actual position for center, top, and bottom positions.
            _arrangeToastsPerAlignment: function (currentOpenedToasts, alignment, isOpen) {

                if (currentOpenedToasts.length > 0) //Alignment is needed when toasts available
                {
                    var margin = 10;

                    for (var idx = (currentOpenedToasts.length - 1); idx >= 0; idx--) {
                        var presentToast = window.getComputedStyle(currentOpenedToasts[idx], null);

                        if (currentOpenedToasts.length != (idx + 1)) {
                            var previousToast = window.getComputedStyle(currentOpenedToasts[idx + 1], null);
                        }

                        if (alignment == _bottom) {
                            var topPosition = 0;

                            for (var j = idx; j < (currentOpenedToasts.length - 1); j++) {
                                topPosition += currentOpenedToasts[j].getBoundingClientRect().height + margin;
                            }

                            latestToastTop = currentOpenedToasts[currentOpenedToasts.length - 1].getBoundingClientRect().top;
                            currentOpenedToasts[idx].style.top = latestToastTop - margin - topPosition + 'px';
                        }
                        else if (alignment == _top) {
                            var topPosition = 0;
                            for (j = idx + 1; j <= (currentOpenedToasts.length - 1); j++) {
                                topPosition += currentOpenedToasts[j].getBoundingClientRect().height + margin;
                            }

                            currentOpenedToasts[idx].style.top = topPosition + 'px';
                        }
                        else {
                            if (!previousToast) //Current toast is latest
                            {
                                this._applyStyleForCenter(currentOpenedToasts[idx]);
                            }
                            else {
                                if (!isOpen) {
                                    this._applyStyleForCenter(currentOpenedToasts[idx]);
                                }

                                var topPosition = 0;
                                for (j = idx + 1; j <= (currentOpenedToasts.length - 1); j++) {
                                    topPosition += currentOpenedToasts[j].getBoundingClientRect().height + margin;
                                }

                                currentOpenedToasts[idx].style.top = topPosition + 'px';
                            }
                        }

                        // Apply style when toast opens
                        if (isOpen) {
                            this._addTransitionStyle(currentOpenedToasts[idx]);
                        }
                        else {
                            this._removeTransitionStyle(currentOpenedToasts[idx]);
                        }
                    }
                }
            },

            // Can be used to add style for smooth transition.
            _addTransitionStyle: function (toast) {
                toast.style.transition = 'all 0.5s ease-in-out';
            },

            /**
             * Can be used for smooth transitioning that are not needed for toast close or refit.
             */
            _removeTransitionStyle: function (toast) {
                toast.style.transition = '';
            },

            /** 
             * Can be used to display toast at center of the window.
             */
            _applyStyleForCenter: function (toast) {
                toast.style.left = toast.style.left.replace('px', '') / 2 + 'px';
            },

            /**
             * Read-only. Can be uased to auto-close if duration is a positive finite number.
             * @property _canAutoClose
             */
            get _canAutoClose() {
                return this.duration > 0 && this.duration !== Infinity;
            },

            created: function () {
                this._autoClose = null;
                Polymer.IronA11yAnnouncer.requestAvailability();
            },

            /**
             * Can be used to show the toast. Without the arguments, this is same as `open()` from `IronOverlayBehavior`.
             * @param {(Object|string)=} properties Properties to be set before opening the toast.         
             */
            show: function (properties) {
                if (typeof properties == 'string') {
                    properties = { text: properties };
                }
                for (var property in properties) {
                    if (property.indexOf('_') === 0) {
                        Polymer.Base._warn('The property "' + property + '" is private and was not set.');
                    } else if (property in this) {
                        this[property] = properties[property];
                    } else {
                        Polymer.Base._warn('The property "' + property + '" is not valid.');
                    }
                }
                this.open();
            },

            /**
             * Can be used to hide the toast. This is same as `close()` from `IronOverlayBehavior`.
             */
            hide: function () {
                this.close();
            },

            /**
             * Can be used to indicate a finished animation. This is called on transitions of the toast. 
             * @private
             */
            __onTransitionEnd: function (e) {
                // there are different transitions that are happening when opening and
                // closing the toast. The last one so far is for `opacity`.
                // This marks the end of the transition, so we check for this to determine if this
                // is the correct event.
                if (e && e.target === this && e.propertyName === 'opacity') {
                    if (this.opened) {
                        this._finishRenderOpened();
                    } else {
                        this._finishRenderClosed();
                    }
                }
            },

            /**
             * Used when the value of `opened` changes. This is overridden from `IronOverlayBehavior`.
             *
             */
            _openedChanged: function () {
                if (this._autoClose !== null) {
                    this.cancelAsync(this._autoClose);
                    this._autoClose = null;
                }
                if (this.opened) {

                    // if (currentToast && currentToast !== this) {
                    //   currentToast.close();
                    // }

                    currentToast = this;
                    this.fire('iron-announce', {
                        text: this.text
                    });
                    if (this._canAutoClose) {
                        this._autoClose = this.async(this.close, this.duration);
                    }
                } else if (currentToast === this) {
                    currentToast = null;
                }
                Polymer.IronOverlayBehaviorImpl._openedChanged.apply(this, arguments);
            },

            /**
             * This is overridden from `IronOverlayBehavior`.
             */
            _renderOpened: function () {
                this.classList.add('paper-toast-open');
            },

            /**
             * This is overridden from `IronOverlayBehavior`.
             */
            _renderClosed: function () {
                this.classList.remove('paper-toast-open');
            },

            /**
             * @private
             */
            _onFitIntoChanged: function (fitInto) {
                this.positionTarget = fitInto;
            }

            /**
             * Fired when `paper-toast` is opened.
             *
             * @event 'iron-announce'
             * @param {{text: string}} detail Contains text that will be announced.
             */
        });
    })();
</script>
</dom-module>