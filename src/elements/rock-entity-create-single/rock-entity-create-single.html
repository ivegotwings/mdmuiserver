<link rel="import" href="../../../bower_components/polymer/polymer-element.html">

<link rel="import" href="../../../bower_components/polymer/lib/mixins/mutable-data.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/element-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-helpers/message-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">

<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-entity-govern-data-get/liquid-entity-govern-data-get.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">

<link rel="import" href="../rock-attribute-list/rock-attribute-list.html">
<link rel="import" href="../rock-compare-entities/rock-compare-entities.html">
<!--
`rock-entity-create-single` Represents a component that renders a panel with the initial set of 
attributes during the single entity creation. 

@demo demo/index.html
-->


<dom-module id="rock-entity-create-single">
    <template>
        <style include="bedrock-style-common">
            :host {
                display: block;
                height: 100%;
            }
            #errorsDialog {
                --popup-header-color: var(--palette-pinkish-red, #ee204c);
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <liquid-rest id="entityMatchService" url="/data/pass-through/matchservice/search" method="POST" request-data={{_entityMatchRequest}} on-liquid-response="_onMatchSuccess" on-liquid-error="_onMatchFailure">
        </liquid-rest>
        <liquid-rest id="entityGovernService" url="/data/pass-through/entitygovernservice/validate" method="POST" request-data={{_entityGovernRequest}} on-liquid-response="_onEntityGovernResponse" on-liquid-error="_onEntityGovernFailed">
        </liquid-rest>
        <liquid-rest id="modelGovernService" url="/data/pass-through/modelgovernservice/validate" method="POST" request-data={{_modelGovernRequest}} on-liquid-response="_onEntityGovernResponse" on-liquid-error="_onEntityGovernFailed">
        </liquid-rest>
        <pebble-dialog id="updateConfirmDialog" modal small vertical-offset=1 50 horizontal-align="auto" vertical-align="auto" no-cancel-on-outside-click no-cancel-on-esc-key dialog-title="Found Match">
            <p>Found the below matching entity in system: </p>
            <ul>
                <li>Entity Id: [[_matchedEntity.id]]</li>
                <li>Entity Type: [[_matchedEntity.type]]</li>
            </ul>
            <p>Do you want to update the entity?</p>
            <div class="buttons">
                <pebble-button id="ok" class="close btn btn-secondary m-r-5" button-text="Update" on-tap="_updateEntity"></pebble-button>
                <pebble-button id="skip" class="apply btn btn-success" button-text="Cancel" on-tap="_cancelProcess"></pebble-button>
            </div>
        </pebble-dialog>
        <pebble-dialog id="errorsDialog" modal small vertical-offset=1 50 horizontal-align="auto" vertical-align="auto" no-cancel-on-outside-click no-cancel-on-esc-key dialog-title="Errors on page">
            <p>Found below errors in entity details: </p>
            <ul>
                <template is="dom-repeat" items="[[_syncValidationErrors]]">
                    <li>[[item.attributeExternalName]] with error: [[item.message]]</li>
                </template>
            </ul>
            <p>Do you want to fix the errors or continue?</p>
            <div class="buttons">
                <pebble-button id="skip" class="close btn btn-secondary m-r-5" button-text="Skip & Continue" on-tap="_skipServerErrors"></pebble-button>
                <pebble-button id="ok" class="apply btn btn-success" button-text="Fix" on-tap="_fixServerErrors"></pebble-button>
            </div>
        </pebble-dialog>
        <div id="content-entity-create" class="full-height">
            <div class="button-siblings">
                <rock-attribute-list attribute-values="[[_attributeValues]]" attribute-models="[[_attributeModels]]" context-data="[[contextData]]" no-of-columns="3" mode="[[mode]]" attribute-messages="[[_attributeMessages]]" dependent-attribute-values="[[_attributeValues]]" dependent-attribute-models="[[_attributeModels]]" hide-revert-and-history></rock-attribute-list>
            </div>
            <div id="content-actions" class="buttonContainer-static" align="center">
                <template is="dom-if" if="[[!isPartOfBusinessFunction]]">
                    <pebble-button class="action-button btn btn-secondary m-r-5" id="skip" button-text="Cancel" raised on-tap="_onSkipTap"></pebble-button>
                </template>
                <pebble-button class="action-button-focus dropdownText btn btn-success m-r-5" id="next" button-text="Save" raised on-tap="_onSaveTap" disabled$="[[disableSave]]"></pebble-button>
            </div>
        </div>
        <div id="content-entity-match" hidden class="full-height">
            <rock-compare-entities id="matchEntities" enable-relationships-match-merge="[[enableRelationshipsMatchMerge]]" compare-entities-context="[[compareEntitiesContext]]" attribute-names="[[attributeNames]]" show-action-buttons enable-column-select is-part-of-business-function$="[[isPartOfBusinessFunction]]"></rock-compare-entities>
        </div>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="{{attributeModelRequest}}" on-entity-model-composite-get-response="_onCompositeModelGetResponse">
            <liquid-entity-data-save name="entitySaveService" operation="create" data-index="[[dataIndex]]" data-sub-index="[[dataSubIndex]]" request-data="{{_saveRequest}}" last-response="{{_saveResponse}}" on-response="_onSaveResponse" on-error="_onSaveError"></liquid-entity-data-save>
            <bedrock-pubsub event-name="error-length-changed" handler="_errorLengthChanged"></bedrock-pubsub>
            <bedrock-pubsub event-name="compare-entities-back" handler="_onCompareEntitiesBack" target-id="matchEntities"></bedrock-pubsub>
            <bedrock-pubsub event-name="compare-entities-create" handler="_onCompareEntitiesCreate" target-id="matchEntities"></bedrock-pubsub>
            <bedrock-pubsub event-name="compare-entities-merge" handler="_onCompareEntitiesMerge" target-id="matchEntities"></bedrock-pubsub>
            <bedrock-pubsub event-name="entity-model-created" handler="_onEntityModelCreated"></bedrock-pubsub>
    </template>
    <script>
        class RockEntityCreateSingle
            extends Polymer.mixinBehaviors([
                RUFBehaviors.UIBehavior,
                RUFBehaviors.ComponentContextBehavior
            ], Polymer.OptionalMutableData(Polymer.Element)) {
            static get is() {
                return 'rock-entity-create-single';
            }
            static get observers() {
                return [
                    '_contextChanged(attributeNames, contextData)'
                ]
            }

            static get properties() {
                return {
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the names of the attributes that are rendered while creating a single entity.
                     */
                    attributeNames: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates the mode in which the attributes are rendered.
                     */
                    mode: {
                        type: String,
                        value: "edit",
                        notify: true
                    },
                    /**
                     * Specifies the request object for the attribute model request.
                     */
                    attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the response object for the attribute models.
                     */
                    attributeModelResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _attributeValues: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    enableRelationshipsMatchMerge: {
                        type: Boolean,
                        value: false
                    },
                    _attributeMessages: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _saveRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _loading: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Specifies the length of the error message.
                     */
                    errorLength: {
                        type: Number,
                        notify: true,
                        value: 0
                    },
                    _entityMatchRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    _matchedEntity: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    compareEntitiesContext: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _syncValidationErrors: {
                        type: Array,
                        value: function () { return []; }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    messageCodeMapping: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    skipNext: {
                        type: Boolean,
                        value: false
                    },
                    matchConfig: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    enableMatchStep: {
                        type: Boolean,
                        value: false
                    },
                    matchType: {
                        type: String,
                        value: "deterministic"
                    },
                    defaultEntity: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    dataIndex: {
                        type: String,
                        value: "entityData"
                    },
                    dataSubIndex: {
                        type: String,
                        value: "data"
                    },
                    entityDomain: {
                        type: String,
                        value: ""
                    },
                    _onEntityModelCreated: {
                        type: Function,
                        value: function () {
                            return "";
                        }
                    },
                    isPartOfBusinessFunction: {
                        type: Boolean,
                        value: false
                    },
                    disableSave: {
                        type: Boolean,
                        value: false
                    }
                }
            }

            _contextChanged(attributeNames, contextData) {
                if (attributeNames && attributeNames.length > 0 && !_.isEmpty(contextData)) {
                    let firstItemContext = this.getFirstItemContext();

                    if (typeof (firstItemContext) != "undefined") {
                        firstItemContext.attributeNames = attributeNames;
                    }

                    let t = DataRequestHelper.createEntityModelCompositeGetRequest(this.contextData);

                    this.set("attributeModelRequest", t);

                    let liquidModelGet = this.shadowRoot.querySelector("[name=compositeAttributeModelGet]");
                    if (liquidModelGet) {
                        liquidModelGet.generateRequest();
                    }
                }
            }
            async _onCompositeModelGetResponse(e) {
                let values = [];
                if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                    this._attributeModels = DataTransformHelper.transformAttributeModels(e.detail.response.content.entityModels[0], this.contextData);
                    values = await DataTransformHelper.transformAttributes({}, this._attributeModels, this.contextData, "array", true);
                }
                this._attributeValues = values;
            }
            _onSaveTap(e) {
                //raise event with name given for onNextAction in configuration
                let attributeList = this.shadowRoot.querySelector('rock-attribute-list');
                let attributeModels = attributeList ? attributeList.attributeModels : {};
                let changedAttributeElements = attributeList.getChangedAttributeElements();

                if (!_.isEmpty(this.matchConfig)) {
                    this.enableMatchStep = this.matchConfig["enable-match-step"];
                    this.matchType = this.matchConfig["match-type"] || "deterministic";
                }

                if (attributeList.hasModelErrors()) {
                    this.showWarningToast("Cannot save. Resolve the errors.");
                    return;
                }
                if (changedAttributeElements == undefined || changedAttributeElements.length == 0) {
                    this.showWarningToast("No changes to save.");
                    return;
                }

                let attributesJSON = [];
                for (let i = 0; i < changedAttributeElements.length; i++) {
                    let attributeElement = changedAttributeElements[i];
                    let attributeJSON = attributeElement.attributeObject;
                    attributesJSON.push(attributeJSON);
                }

                let itemCtx = this.getFirstItemContext();
                let entityType = itemCtx.type;
                let entityId = "e" + ElementHelper.getRandomString();
                let entityName;
                /**
                 * For any model the id should be <<model.name>>_<<model.type>>. Hence name for the
                 * model is the value of attribute which has "isEntityIdentifier" flag.
                 * For any entity, name should be the value of the attribute which has "isExternalName" flag.
                 * */
                if (this.dataIndex == "entityModel") {
                    entityName = DataHelper.getNameForNewEntityFromAttributes(attributesJSON, this._attributeModels, "isEntityIdentifier");
                    if (this._isEmptyValue(entityName)) {
                        entityId = entityId + "_" + entityType;
                    } else {
                        entityId = entityName + "_" + entityType;
                    }
                } else {
                    entityName = DataHelper.getNameForNewEntityFromAttributes(attributesJSON, this._attributeModels, "isExternalName");
                }

                let domain;
                if (this.entityDomain && this.entityDomain != "" && this.entityDomain != "undefined") {
                    domain = this.entityDomain;
                }
                itemCtx.id = entityId;
                let newEntity = DataTransformHelper.prepareEntityForCreate(entityId, entityType, attributesJSON, this.contextData, DataHelper.getUserName(), this.defaultEntity, attributeModels, domain);
                if (entityName) {
                    newEntity.name = entityName;
                }

                ComponentHelper.getParentElement(this).onSaveContextChange = true;
                ComponentHelper.getParentElement(this).contextData = this.contextData;

                this._saveRequest = {
                    "entities": [newEntity]
                };

                if (this.dataIndex == "entityModel") {
                    let clientState = {};
                    clientState.notificationInfo = {};
                    clientState.notificationInfo.showNotificationToUser = true;
                    this._saveRequest["clientState"] = clientState;
                }

                //Add hotline flag if hotline is enabled
                if (DataHelper.isHotlineModeEnabled()) {
                    this._saveRequest["hotline"] = true;
                }

                //Set match request
                this.set('_entityMatchRequest', {
                    "entity": newEntity
                });

                let entityMatchService = this.shadowRoot.querySelector("#entityMatchService");

                if (this.enableMatchStep && this.matchType === "MLBased") {
                    entityMatchService.url = "/data/pass-through/matchservice/match";
                }
                if (entityMatchService) {
                    entityMatchService.generateRequest();
                }
            }

            _isEmptyValue(value) {
                if (typeof (value) === "string") {
                    return value === "" || value.trim().length === 0;
                } else {
                    return _.isEmpty(value);
                }
            }

            _onMatchSuccess(e, detail) {
                if (detail.response) {
                    let response = detail.response.response;
                    if ((response.dataObjectOperationResponse && response.dataObjectOperationResponse.status &&
                        response.dataObjectOperationResponse.status.toLowerCase() == "error") ||
                        (response.status && response.status.toLowerCase() == "error")) {
                        this.logError("MatchServiceRequestFail", e.detail);
                        return;
                    }

                    if (this.matchType === "MLBased") {
                        response.status = "success";
                    }

                    if (response.status && response.status.toLowerCase() == "success") {
                        if (!_.isEmpty(response.entities)) {
                            if (!this.enableMatchStep) {
                                if (response.entities.length == 1) {
                                    this._matchedEntity = response.entities[0];
                                    this.shadowRoot.querySelector('#updateConfirmDialog').open();
                                } else if (response.entities.length > 1) {
                                    this.showWarningToast("We found multiple entities matching in our system. Check entity details or contact your administrator.");
                                }
                                return;
                            }

                            if (this.matchType === "MLBased") {
                                let entity = response.entities[0];
                                let matchResult = EntityHelper.getAttribute(entity, "matchresult");

                                if (matchResult && !_.isEmpty(matchResult.group)) {
                                    let entities = [];
                                    for (let idx = 0; idx < matchResult.group.length; idx++) {
                                        let group = matchResult.group[idx];
                                        let mEntity = {
                                            "id": AttributeHelper.getFirstAttributeValue(group.identifier),
                                            "score": AttributeHelper.getFirstAttributeValue(group.score)
                                        }

                                        entities.push(mEntity);
                                    }

                                    response.entities = entities;
                                } else {
                                    this._triggerGovernRequest();
                                    return;
                                }
                            }

                            let matchedEntityIds = response.entities.map(entity => entity.id);
                            let entityType = ContextHelper.getFirstItemContext(this.contextData).type;

                            this.compareEntitiesContext = {
                                "newEntity": DataHelper.cloneObject(this._entityMatchRequest.entity),
                                "entityIds": matchedEntityIds,
                                "entityTypes": [entityType],
                                "contextData": DataHelper.cloneObject(this.contextData),
                                "matchConfig": this.matchConfig,
                                "entities-data": response.entities
                            }

                            this._hideView("entity-create");
                            this._showView("entity-match");
                        } else {
                            this._triggerGovernRequest();
                        }
                    }
                }
            }

            _triggerGovernRequest(operation) {
                let governReq = DataHelper.cloneObject(this._entityMatchRequest);

                let liquidSave = this.shadowRoot.querySelector("[name=entitySaveService]");
                if (liquidSave) {
                    liquidSave.operation = operation || "create";
                }
                if (this.dataIndex == "entityModel") {
                    // let liquidModelGovernGet = this.$.modelGovernService;
                    // if(liquidModelGovernGet){
                    //     let reqObj = {};
                    //     reqObj["entityModel"] = governReq["entity"];
                    //     this.set("_modelGovernRequest", reqObj);
                    //     liquidModelGovernGet.generateRequest();
                    // }
                    liquidSave.generateRequest();
                } else {
                    let liquidGovernGet = this.$.entityGovernService;
                    if (liquidGovernGet) {
                        this.set("_entityGovernRequest", governReq);
                        liquidGovernGet.generateRequest();
                    }
                }
            }

            _onMatchFailure(e, detail) {
                this.logError("MatchServiceRequestFail", "response", JSON.stringify(detail));
            }

            _updateEntity() {
                if (!this.enableMatchStep) {
                    let updateConfirmDialog = this.$.updateConfirmDialog;
                    if (updateConfirmDialog) {
                        updateConfirmDialog.close();
                    }
                }
                let clientState = {};
                clientState.notificationInfo = {};
                clientState.notificationInfo.showNotificationToUser = false;
                this._saveRequest["clientState"] = clientState;
                this._saveRequest.entities[0].id = this._matchedEntity.id;
                let itemCtx = this.getFirstItemContext();
                itemCtx.id = this._matchedEntity.id;

                this._triggerGovernRequest("update");
            }
            _cancelProcess() {
                let updateConfirmDialog = this.$.updateConfirmDialog;
                if (updateConfirmDialog) {
                    updateConfirmDialog.close();
                }
            }

            _onSaveResponse(e) {
                let operation = e.detail.request.operation;
                this._loading = true;
                let msg = "";

                if (operation == "create") {
                    msg = "Entity created successfully.";
                }
                if (operation == "update") {
                    msg = "Entity updated successfully.";
                }

                if (this.dataIndex != "entityModel") {
                    this._setBusinessFunctionData(operation, msg, true);
                } else {
                    let timeout = setTimeout(function () {
                        msg = "Entity create request has been sent successfully but creation is taking longer than expected. Please come after some time and do mapping manually."
                        this._setBusinessFunctionData(operation, msg, false);
                    }.bind(this), 5000);

                    this._onEntityModelCreated = function (e) {
                        clearTimeout(timeout);
                        this._setBusinessFunctionData('create', "Entity created successfully.", true);
                    }.bind(this)
                }
            }

            _setBusinessFunctionData(operation, msg, isEntityCreated) {
                let eventName = "onSave";
                let eventDetail = {
                    name: eventName,
                    data: { "skipNext": operation == "update" ? true : this.skipNext }
                }
                let itemCtx = this.getFirstItemContext();
                let data = {
                    "messages": [
                        {
                            "message": msg
                        }
                    ],
                    "actions": [
                        {
                            "name": "closeFunction",
                            "text": "Take Me back to Where I started"
                        },
                        {
                            "name": "showEntity",
                            "text": "Show me the entity",
                            "dataRoute": "entity-manage",
                            "queryParams": { "id": itemCtx.id, "type": itemCtx.type }
                        },
                        {
                            "name": "createEntity",
                            "text": "Create one more",
                            "dataRoute": "entity-create",
                            "queryParams": { "type": itemCtx.type }
                        }
                    ]
                };

                let entityCreateElement = ComponentHelper.getParentElement(this); //rock-entity-create
                //Set BF component behavior props
                entityCreateElement.isComponentDirty = false;
                entityCreateElement.componentResult = {
                    "status": "completed",
                    "id": itemCtx.id,
                    "type": "entity"
                }
                entityCreateElement.finishStepData = {
                    "message": msg,
                    "id": itemCtx.id,
                    "type": itemCtx.type
                };
                entityCreateElement.raiseStepComplete();

                let businessFunctionData = entityCreateElement.businessFunctionData;
                if (_.isEmpty(businessFunctionData)) {
                    businessFunctionData = data;
                } else {
                    _.isEmpty(businessFunctionData.actions) && (businessFunctionData.actions = data.actions);
                    _.isEmpty(businessFunctionData.messages) && (businessFunctionData.messages = data.messages);
                }

                if (isEntityCreated) {
                    ComponentHelper.fireBedrockEvent("entity-created", { "id": itemCtx.id, "type": itemCtx.type }, { ignoreId: true });
                }

                entityCreateElement.businessFunctionData = businessFunctionData;
                setTimeout(() => {
                    this._loading = false;
                    if (operation != "update") {
                        if(!this.isPartOfBusinessFunction) {
                            this.showSuccessToast(msg);
                        }
                    }

                    if (this.isPartOfBusinessFunction) {
                        this.showSuccessToast(msg);
                        this.disableSave = true;
                    }

                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                }, 100);
            }
            _onSaveError(e) {
                // To Remove
                this.logError("Failed to update entity", e.detail);
            }
            _onSkipTap(e) {
                //raise event with name given for onbackAction in configuration
                let data;
                let eventName = "onCancel";
                let eventDetail = {
                    name: eventName,
                    data: data
                }
                this.fireBedrockEvent(eventName, eventDetail, {
                    ignoreId: true
                });
            }
            _errorLengthChanged(e) {
                this.errorLength = e.detail.data;
            }
            _onEntityGovernResponse(e) {
                let response = e.detail.response;
                if (response.response && response.response.status && response.response.status.toLowerCase() == "success") {
                    let res = response.response;
                    let itemContext = this.getFirstItemContext();
                    let entityId;
                    if (itemContext) {
                        entityId = itemContext.id;
                    }

                    let entity;
                    if (this.dataIndex == "entityModel") {
                        entity = DataHelper.findEntityById(res.entityModels, entityId);
                    } else {
                        entity = DataHelper.findEntityById(res.entities, entityId);
                    }
                    let attrMessages = {};
                    if (entity && entity.data && entity.data.attributes) {
                        let attributes = entity.data.attributes;
                        attrMessages = MessageHelper.getAttributeMessages(attributes, this._attributeModels, this.messageCodeMapping, this.localize());
                    }
                    if (!_.isEmpty(attrMessages)) {
                        let errorMessages = MessageHelper.getErrorsFromAttrMessages(attrMessages, this._attributeModels);
                        this.set("_syncValidationErrors", errorMessages);
                        this.shadowRoot.querySelector('#errorsDialog').open();
                        return;
                    } else {
                        let liquidSave = this.shadowRoot.querySelector("[name=entitySaveService]");
                        if (liquidSave) {
                            liquidSave.generateRequest();
                        }
                    }
                } else {
                    this.logError("There is a problem in validation service.", e.detail);
                }
            }
            _onEntityGovernFailed(e) {
                this.logError("There is a problem in validation service.", e.detail);
            }
            _skipServerErrors() {
                let errorDialog = this.$.errorsDialog;
                if (errorDialog) {
                    errorDialog.close();
                }
                let liquidSave = this.shadowRoot.querySelector("[name=entitySaveService]");
                if (liquidSave) {
                    liquidSave.generateRequest();
                }
            }
            _fixServerErrors() {
                let errorDialog = this.$.errorsDialog;
                if (errorDialog) {
                    errorDialog.close();
                }
                let newAttributeMessages = {};

                if (this._syncValidationErrors) {
                    for (let i = 0; i < this._syncValidationErrors.length; i++) {
                        let attributeMessages = this._syncValidationErrors[i];
                        let attributeName = attributeMessages.attributeName;
                        let message = attributeMessages.message;
                        if (attributeName && message) {
                            newAttributeMessages[attributeName] = [message];
                        }
                    }
                }
                this.set('_attributeMessages', newAttributeMessages);
            }
            //   * <b><i>Content development is under progress... </b></i> 
            //   */
            getIsDirty() {
                let attributeList = this.shadowRoot.querySelector('rock-attribute-list');
                let changedAttributeElements = attributeList.getChangedAttributeElements();
                return changedAttributeElements && changedAttributeElements.length > 0;
            }

            _showView(viewName) {
                if (viewName) {
                    let contentView = this.shadowRoot.querySelector("#content-" + viewName);
                    if (contentView) {
                        contentView.removeAttribute("hidden");
                    }
                }
            }

            _hideView(viewName) {
                if (viewName) {
                    let contentView = this.shadowRoot.querySelector("#content-" + viewName);
                    if (contentView) {
                        contentView.setAttribute("hidden", "");
                    }
                }
            }

            _onCompareEntitiesBack(e, detail) {
                this._hideView("entity-match");
                this._showView("entity-create");
            }

            _onCompareEntitiesCreate(e, detail) {
                this._triggerGovernRequest();
            }

            _onCompareEntitiesMerge(e, detail) {
                this._matchedEntity = detail.matchedEntity;
                this._updateEntity();
            }
        }
        /**
         * <b><i>Content development is under progress... </b></i> 
         */
        customElements.define(RockEntityCreateSingle.is, RockEntityCreateSingle)
    </script>
</dom-module>