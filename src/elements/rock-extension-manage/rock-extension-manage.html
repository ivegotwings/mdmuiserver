<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-ajax/iron-ajax.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">


<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-accordion/pebble-accordion.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-attribute-list/rock-attribute-list.html">
<link rel="import" href="../rock-classification-tree/rock-classification-tree.html">
<!--<link rel="import" href="classification-get-data.html">-->
<!--
`rock-extension-manage` Represents a component that renders all the extensions of an entity.
It manages the current extensions and creates the new extensions.

@element rock-extension-manage
@group rock-elements
@demo demo/index.html
-->
<dom-module id="rock-extension-manage">
    <template>
        <style include="bedrock-style-common">            

            .tree-heading {
                font-weight: var(--font-bold, bold);
                font-size: var(--default-font-size, 14px);
            }

            
        </style>
        <div class="button-siblings">
            <div class="base-grid-structure" align="center">
                <div class="tree-heading base-grid-structure-child-1">Classification selection</div>
                <div class="base-grid-structure-child-2">
                    <rock-classification-tree id="contextTree" multi-select="[[multiSelect]]" selected-classifications="{{_selectedItems}}" taxonomy="[[taxonomy]]"
                        context-data="[[contextData]]" leaf-node-only="[[leafNodeOnly]]">
                    </rock-classification-tree>
                </div>
            </div>
        </div>
        <div id="buttonContainer" align="center" class="buttonContainer-static">
            <template is="dom-repeat" id="event-template" items="[[componentEvents]]">
                <pebble-button id="[[item.id]]" class$="[[item.class]]" button-text="[[item.text]]" on-tap="_onTriggerEvent" data-args$="[[item.event]]" elevation=1 raised></pebble-button>
            </template>
        </div>
        <liquid-entity-data-get id="taxonomyGetDataService" operation="getbyids" request-data="{{_taxonomyRequest}}" on-response="_onTaxonomyResponse"></liquid-entity-data-get>
        <liquid-entity-data-save id="attributeSaveDataService" operation="update" data-index$="[[dataIndex]]" data-sub-index$="[[dataSubIndex]]"
            request-data="{{_saveRequest}}" on-response="_onSaveResponse"></liquid-entity-data-save>
        <liquid-rest id="contextLiquid" url="[[_getContextURL]]" method="POST" request-data="{{requestData}}" on-liquid-response="_onResponseReceived"
            exclude-in-progress>
        </liquid-rest>
        <liquid-rest id="taxonomyModelGet" url="/data/pass-through/entitymodelservice/get" method="POST" request-data="{{_taxonomyModelRequest}}"
            on-liquid-response="_onTaxonomyModelGetResponse"></liquid-rest>
        <liquid-rest id="asyncReclassification" url="/data/pass-through/bulkentityservice/createtask" method="POST"
            on-liquid-response="_onAsyncReclassificationSuccess" on-liquid-error="_onAsyncReclassificationFailure"></liquid-rest>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: "rock-extension-manage",
                properties: {
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _selectedItems: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    taxonomy: {
                        type: String,
                        value: ""
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    businessFunctionData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    multiSelect: {
                        type: Boolean,
                        value: false
                    },
                    dataIndex: {
                        type: String,
                        value: "entityData"
                    },
                    dataSubIndex: {
                        type: String,
                        value: "data"
                    },
                    _entityCurrentClassifications: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    _entitiesCurrentClassifications: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _liquidSaveElement: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                    * Specifies whether or not only leaf-node selection is enabled.
                    */
                    leafNodeOnly: {
                        type: Boolean,
                        value: false
                    },

                    _taxonomyExtName: {
                        type: String,
                        value: ""
                    },

                    _taxonomyExtNameAttr: {
                        type: String,
                        value: ""
                    },

                    _taxonomyRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _taxonomyModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _getContextURL: {
                        type: String,
                        value: "/data/pass-through/entityservice/getcontext"
                    },

                    isBulkProcess: {
                        type: Boolean,
                        value: false
                    },

                    syncThreshold: {
                        type: Number,
                        value: 20
                    },

                    selectedEntities: {
                        type: Array,
                        value: function() {
                            return [];
                        }
                    },

                    selectionMode: {
                        type: String,
                        value: "count"
                    },

                    selectionQuery: {
                        type: Object,
                        value: function() {
                            return {};
                        }
                    },

                    _asyncReclassificationRequest: {
                        type: Object,
                        value: function() {
                            return {
                                "params": {
                                    "reclassification": true,
                                    "operationType": "inboundService",
                                    "data": {
                                        "contexts": []
                                    }
                                }
                            }
                        }
                    },

                    _bulkReclassificationErrorMessage: {
                        type: String,
                        value: "Failed to perform the Bulk reclassification. Please contact administrator."
                    },

                    componentEvents: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    }
                },

                observers: [
                    '_onContextOrTaxonomyChange(contextData, taxonomy)'
                ],

                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                ready: function () {
                    this._liquidSaveElement = this.shadowRoot.querySelector("#attributeSaveDataService");
                },

                attached: function () {
                    if (!this.taxonomy || this.taxonomy == "undefined") {
                        this.taxonomy = this.appSetting("dataDefaults").taxonomy;
                    }
                },

                _onContextOrTaxonomyChange: function () {
                    if (this.taxonomy && !_.isEmpty(this.contextData)) {
                        this._getTaxonomyManageModel();
                    }
                },

                _getTaxonomyManageModel: function () {
                    this._taxonomyModelRequest = DataRequestHelper.createGetManageModelRequest(["taxonomy"]);

                    var taxonomyModelGetElement = this.$$("#taxonomyModelGet");

                    if (taxonomyModelGetElement) {
                        taxonomyModelGetElement.generateRequest();
                    }
                },

                _onTaxonomyModelGetResponse: function (e) {
                    var modelErrorMsg = "Entity manage model not found for taxonomy.";
                    if(!e.detail || !e.detail.response || !e.detail.response.response) {
                        this.showErrorToast(modelErrorMsg, 10000);
                        return;
                    }

                    var response = e.detail.response.response;
                    if (response && response.entityModels) {
                        var entityModel = response.entityModels[0];
                        var externalNameAndExternalNameAttr = AttributeHelper.getExternalNameAndExternalNameAttr(entityModel);

                        if (externalNameAndExternalNameAttr && externalNameAndExternalNameAttr.externalNameAttr) {
                            this._taxonomyExtNameAttr = externalNameAndExternalNameAttr.externalNameAttr;
                            this._getTaxonomy();
                        } else {
                            this.showErrorToast("Attribute not found with isExternlName in taxonomy entity manage model", 10000);
                        }
                    } else {
                        this.showErrorToast(modelErrorMsg, 10000);
                    }
                },

                _getTaxonomy: function () {
                    var contextData = DataHelper.cloneObject(this.contextData);
                    var firstItemContext = ContextHelper.getFirstItemContext(contextData);
                    if (firstItemContext) {
                        firstItemContext.type = "taxonomy";
                        firstItemContext.attributeNames = [this._taxonomyExtNameAttr];
                        firstItemContext.id = this.taxonomy;
                        contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                        var req = DataRequestHelper.createEntityGetRequest(contextData);
                        delete req.params.options;
                        this._taxonomyRequest = req;

                        var taxonomyGetElement = this.$$("#taxonomyGetDataService");

                        if (taxonomyGetElement) {
                            taxonomyGetElement.generateRequest();
                        }
                    }
                },

                _onTaxonomyResponse: function (e) {
                    if (e && e.detail && e.detail.response) {
                        var res = e.detail.response;
                        if (res && res.content && res.content.entities && res.content.entities.length) {
                            var entity = res.content.entities[0];
                            if (entity && entity.data) {
                                var attributes = entity.data.attributes;

                                if (attributes && attributes[this._taxonomyExtNameAttr]) {
                                    this._taxonomyExtName = attributes[this._taxonomyExtNameAttr].values && attributes[this._taxonomyExtNameAttr].values.length ? attributes[this._taxonomyExtNameAttr].values[0].value : undefined;
                                }
                            }
                        }
                    }

                    if(this.isBulkProcess) {
                        this._triggerClassificationTree();
                    } else {
                        this._prepareGetContextRequest();
                    }
                },

                //Prepare request get the contexts for the selected entities
                _prepareGetContextRequest: function () {
                    var contextData = DataHelper.cloneObject(this.contextData);
                    contextData[ContextHelper.CONTEXT_TYPE_VALUE] = [];
                    contextData[ContextHelper.CONTEXT_TYPE_DATA] = [];
                    var triggerRequest = false;
                    if(this.isBulkProcess) {
                        var entities = [];
                        var types = [];
                        if(this.selectedEntities && this.selectedEntities.length) {
                            triggerRequest = true;
                        }
                        for(var entityIdx = 0; entityIdx < this.selectedEntities.length; entityIdx++) {
                            entities.push(this.selectedEntities[entityIdx].id);
                            if(types.indexOf(this.selectedEntities[entityIdx].type) == -1) {
                                types.push(this.selectedEntities[entityIdx].type)
                            }
                        }
                    } else {
                        var firstItemContext = ContextHelper.getFirstItemContext(contextData);
                        if (firstItemContext && firstItemContext.type && firstItemContext.id) {
                            firstItemContext.attributes = [];
                            triggerRequest = true;
                        }
                    }

                    if (triggerRequest) {
                        var req = DataRequestHelper.createEntityGetRequest(contextData);
                        req.params.fields.attributes = [];
                        delete req.params.options;
                        if(this.isBulkProcess) {
                            req.params.query.ids = entities;
                            req.params.query.filters.typesCriterion = types;
                        }
                        this.set('requestData', req);

                        if (!_.isEmpty(this.dataIndex) && this.dataIndex.toLowerCase() == "entitymodel") {
                            this._getContextURL = "/data/pass-through/entitymodelservice/getcontext"
                        }

                        this.shadowRoot.querySelector("#contextLiquid").generateRequest();
                    }
                },

                _onResponseReceived: function (e) {
                    if (e.detail && e.detail.response) {
                        var res = e.detail.response.response;
                        if (res && res.entities && res.entities.length) {
                            //Collect bulk entities currect cassifications
                            if(this.isBulkProcess) {
                                this._entitiesCurrentClassifications = {};
                                for(var entityIdx = 0; entityIdx < res.entities.length; entityIdx++) {
                                    var entity = res.entities[entityIdx];
                                    if (entity && entity.data) {
                                        var contexts = entity.data.contexts;
                                        var entityCurrentClassifications = [];
                                        for (var ctxIdx = 0; ctxIdx < contexts.length; ctxIdx++) {
                                            var context = contexts[ctxIdx].context;
                                            if (context) {
                                                var item = context["classification"];
                                                if (item) {
                                                    if (context["taxonomy"] == this._taxonomyExtName) {
                                                        entityCurrentClassifications.push(item);
                                                    }
                                                }
                                            }
                                        }
                                        this._entitiesCurrentClassifications[entity.id] = entityCurrentClassifications;
                                    }
                                }
                            } else { //Collect classification for single entity and make it selectable in tree
                                var items = [];
                                var entity = res.entities[0];
                                if (entity && entity.data) {
                                    var contexts = entity.data.contexts;
                                    var firstDataContext = this.getFirstDataContext(this.contextData);
                                    var primaryContext = this._getPrimaryContext(firstDataContext);

                                    for (var i = 0; i < contexts.length; i++) {
                                        var context = contexts[i].context;
                                        if (context) {
                                            if (!_.isEmpty(primaryContext)) {
                                                if (!_.isEqual(primaryContext, this._getPrimaryContext(context))) {
                                                    continue;
                                                }
                                            } else {
                                                //No primaryContext, then select the context which is having classification and taxonomy only
                                                var contextKeys = Object.keys(context) || [];
                                                if (contextKeys.length != 2 ||
                                                    contextKeys.indexOf("classification") == -1 ||
                                                    contextKeys.indexOf("taxonomy") == -1) {
                                                    continue;
                                                }
                                            }
                                            var item = context["classification"];
                                            if (item) {
                                                if (context["taxonomy"] == this._taxonomyExtName) {
                                                    this._entityCurrentClassifications.push(item);
                                                    var arr = item.split(">>");
                                                    items.push(arr);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (this.isBulkProcess) {
                        this._prepareBulkReclassificationSaveRequest();
                    } else {
                        // Input - selected items as path arrays
                        this._selectedItems = items || [];

                        if (!this.multiSelect && this._selectedItems.length > 1) {
                            this.showErrorToast("UI is configured for single context but there are " + this._selectedItems.length + " selected contexts for the entity");
                        }

                        this._triggerClassificationTree();
                    }
                },

                _triggerClassificationTree: function() {
                    const contextTree = this.shadowRoot.querySelector("#contextTree");
                    if (contextTree) {
                        contextTree.generateRequest();
                    }
                },

                _save: function () {
                    if (this._selectedItems && this._selectedItems.length > 0) {
                        var selectedClassifications = [];
                        for (var i = 0; i < this._selectedItems.length; i++) {
                            if (this._selectedItems[i].valuePath) {
                                selectedClassifications.push(this._selectedItems[i].valuePath.replace(/#@#/g, ">>"));
                            }
                        }
                        if (!this.isBulkProcess && DataHelper.areEqualArrays(selectedClassifications, this._entityCurrentClassifications)) {
                            this.showInformationToast("No changes to save");
                            return;
                        }
                    }
                    else {
                        this.showErrorToast("No context data selected to save.");
                        return;
                    }

                    this._triggerReclassification();
                },

                _triggerReclassification: function() {
                    if(this.isBulkProcess) {
                        if ((!this.selectionMode || this.selectionMode == "count") &&
                            (!this.selectedEntities || this.selectedEntities.length == 0)) {
                            this.showErrorToast("Entities not available for the process");
                            return;
                        }

                        if(this.selectionMode == "query" || (this.selectionMode == "count" && this.selectedEntities.length > this.syncThreshold)) {
                            if (!this.selectionQuery || _.isEmpty(this.selectionQuery)) {
                                this.showErrorToast("Selection query not available for the process");
                                return;
                            }

                            this._triggerAsyncReclassification(); //Trigger async process for 20+ entities OR query selection
                        } else {
                            //this._prepareGetContextRequest(); //Trigger bulk process based on selected entities context
                            //Triggering bulk process based on selected classification
                            this._prepareBulkReclassificationSaveRequest();
                        }
                    } else {
                        var data = {};
                        var entities = [];
                        data.contexts = this._prepareContexts(this._selectedItems);
                        var firstItemContext = this.getFirstItemContext();
                        var entity = {
                            "id": firstItemContext.id,
                            "type": firstItemContext.type,
                            "data": data
                        };
                        entities.push(entity);
                        this._triggerSaveRequest(entities);
                    }
                },

                _getSelectedClassifications: function() {
                    var originalClassifications = [];
                    for (var ctxIdx = 0; ctxIdx < this.contextData.Contexts.length; ctxIdx++) {
                        originalClassifications.push(this.contextData.Contexts[ctxIdx].classification);
                    }

                    return originalClassifications;
                },

                _prepareBulkReclassificationSaveRequest: function () {
                    var entities = [];
                    var originalClassifications = [];
                    for (var entityIdx = 0; entityIdx < this.selectedEntities.length; entityIdx++) {
                        var data = {};
                        data.contexts = this._prepareContexts(this._selectedItems, originalClassifications);
                        var entity = {
                            "id": this.selectedEntities[entityIdx].id,
                            "type": this.selectedEntities[entityIdx].type,
                            "data": data,
                            "isReclassification": true
                        };
                        entities.push(entity);
                    }

                    this._triggerSaveRequest(entities);
                },

                _prepareContexts: function (selectedItems, entityClassifications) {
                    var contexts = [];
                    var deletedcontexts = [];
                    var entityCurrentClassifications = this.isBulkProcess ? entityClassifications : this._entityCurrentClassifications;
                    var categoryPathSeperator = this.appSetting('dataDefaults').categoryPathSeparator;
                    var firstDataContext = this.getFirstDataContext(this.contextData);
                    var primaryContext = this._getPrimaryContext(firstDataContext);

                    // Update - For selected items
                    for (var i in selectedItems) {
                        var context = DataHelper.cloneObject(primaryContext);
                        var valuePath = selectedItems[i].valuePath;
                        if (valuePath) {
                            valuePath = valuePath.replace(/#@#/g, categoryPathSeperator);
                        }
                        context.classification = valuePath;
                        if (this._taxonomyExtName) {
                            context["taxonomy"] = this._taxonomyExtName;
                        }

                        contexts.push({
                            "context": context
                        });
                    }

                    // Delete - For existing items 
                    for (var i in entityCurrentClassifications) {
                        var context = DataHelper.cloneObject(primaryContext);
                        var isSelected = false;

                        for (var j in selectedItems) {
                            var valuePath = selectedItems[j].valuePath;
                            if (valuePath) {
                                valuePath = valuePath.replace(/#@#/g, categoryPathSeperator);
                            }

                            if (valuePath == entityCurrentClassifications[i]) {
                                isSelected = true;
                                break;
                            }
                        }

                        // Not in current selected list, then action to delete
                        if (!isSelected) {
                            context["classification"] = entityCurrentClassifications[i];
                            if(this.isBulkProcess) {
                                context["taxonomy"] = this.contextData.Contexts[0].taxonomy;
                            } else {
                                if (this._taxonomyExtName) {
                                    context["taxonomy"] = this._taxonomyExtName;
                                }
                            }

                            deletedcontexts.push(context);
                        }
                    }

                    //Fill deleted contexts in selected contexts as originalContexts
                    if (contexts && contexts.length &&
                        deletedcontexts && deletedcontexts.length) {
                        for (var i = 0; i < contexts.length; i++) {
                            contexts[i].properties = {
                                "originalcontext": deletedcontexts
                            }
                        }
                    }

                    return contexts;
                },

                _triggerSaveRequest: function(entities) {
                    //TODO:: This will be temporary fix needs to come up with good solution.
                    var clientState = {};
                        clientState.notificationInfo = {};                        
                        clientState.notificationInfo.actionType = "addContext";                        
                    if (this._isNotificationDisabled()) {
                        clientState.notificationInfo.showNotificationToUser = false;
                        this.set("_saveRequest", { "clientState": clientState, "entities": entities });
                    } else {
                        clientState.notificationInfo.showNotificationToUser = true;                 
                        this.set("_saveRequest", { "clientState": clientState, "entities": entities });
                    }
                    this._liquidSaveElement.generateRequest();
                },

                _skipOrCancelSelection: function (e) {
                    this._selectedItems = [];
                    var eventName = e.target.getAttribute("data-args") || "onCancel";
                    var eventDetail = {
                        name: eventName
                    }
                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });
                },

                _onSaveResponse: function (e, detail) {
                    if(this.isBulkProcess) {
                        //Todo: Handle bulk messages here
                        var request = detail.request;
                        var response = detail.response;
                        this._responseMessages = [];

                        if(request && request.requestData && request.requestData.entities) {
                            var entities = request.requestData.entities;
                            var newClassifiactions = "";
                            //New classifications
                            if(entities[0] && entities[0].data && 
                               entities[0].data.contexts && entities[0].data.contexts.length) {
                                var contexts = entities[0].data.contexts;
                                var classifications = [];
                                for(var ctxIdx = 0; ctxIdx < contexts.length; ctxIdx++) {
                                    if(contexts[ctxIdx] && contexts[ctxIdx].context &&
                                    contexts[ctxIdx].context.classification) {
                                        classifications.push(contexts[ctxIdx].context.classification);
                                    }
                                }

                                newClassifiactions = classifications.join(", ");
                            }

                            for(var entityIdx = 0; entityIdx < entities.length; entityIdx++) {
                                var message = {
                                    "Entity Id": entities[entityIdx].id
                                };

                                message["New Classification(s)"] = newClassifiactions;
                                message["Status"] = response.status == "success" ? "Request submitted successfully" : "Request failed";

                                this._responseMessages.push(message);
                            }
                         }
                    }
                    this._triggerFinishStep();
                },

                _triggerFinishStep: function (isJob) {
                    //Single entity reclassification
                    if(!this.isBulkProcess) {
                        this.showSuccessToast("Context data saved successfully.");
                        var eventName = "onSave";
                        var eventDetail = {
                            name: eventName,
                            "action": {
                                "name": "refresh-dimension-selector"
                            }
                        };
                        if (eventName && this.functionalMode == "dataFunction") {
                            eventName.action = "business-condition-save-request";
                        };
                        this.fireBedrockEvent(eventName, eventDetail, {
                            ignoreId: true
                        });
                        return;
                    }

                    //Bulk reclassification final step starts from here
                    var noGrid = false;
                    var message = "";
                    var actions = [{
                        "name": "goBack",
                        "text": "Take me back to where I started",
                        "isNotApp": true
                    }];

                    if (isJob) {
                        noGrid = true;
                        message = "Reclassification process has started, you can review the progress of the task " + this._taskId + " in task details.";
                        actions.push({
                            "name": "gotoJobDetails",
                            "text": "Show me the task details",
                            "isNotApp": true,
                            "dataRoute": "task-detail",
                            "queryParams": {
                                "id": this._taskId
                            }
                        });
                    } else {
                        message = "Reclassification process has started, please refresh data grid after some time.";
                    }

                    var data = {
                        "messages": this._responseMessages,
                        "message": message,
                        "noGrid": noGrid,
                        "actions": actions,
                        "contextData": this.contextData,
                        "processedEntities": this.selectedEntities,
                        "messageKey": "Entity Id"
                    };

                    this.businessFunctionData = data;
                    var eventName = "onSave";
                    var eventDetail = {
                        name: eventName
                    }

                    this.fireBedrockEvent(eventName, eventDetail, {
                        ignoreId: true
                    });

                    //Reset contextData, selectedEntities
                    this.contextData = {};
                    this.selectedEntities = [];
                },

                _isNotificationDisabled: function () {
                    var app = ComponentHelper.getCurrentActiveApp();
                    if (app.is == "app-business-function") {
                        return true;
                    }
                    return false;
                },

                _getPrimaryContext: function (dataContext) {
                    var primaryContext = {};
                    if (!_.isEmpty(dataContext)) {
                        Object.keys(dataContext).forEach(function (item) {
                            //TODO:: For now "taxonomy" and "classification" dimensions are considered as additional for extension manage. Need to correct it with proper design.
                            if (item.toLowerCase() != "taxonomy" && item.toLowerCase() != "classification") {
                                primaryContext[item] = dataContext[item];
                            }
                        }, this);
                    }
                    return primaryContext;
                },

                _triggerAsyncReclassification: function () {
                    var asyncLiqReclassification = this.shadowRoot.querySelector("#asyncReclassification");
                    var reclassificationRequest = DataHelper.cloneObject(this._asyncReclassificationRequest);

                    if(!asyncLiqReclassification) {
                        this.showErrorToast(this._bulkReclassificationErrorMessage);
                        this.logError("BulkReclassificationError", "component", "Liquid component not available to trigger create task");
                        return;
                    }

                    //Add hotline flag if hotline is enabled
                    if(DataHelper.isHotlineModeEnabled()) {
                        reclassificationRequest.hotline = true;
                    }

                    if (this.selectionQuery.params && this.selectionQuery.params.isCombinedQuerySearch) {
                        asyncLiqReclassification.url = "/data/pass-through-combined-query/bulkentityservice/createtask";
                        reclassificationRequest.params.taskType = "process-multi-query";
                        reclassificationRequest.entities = [this.selectionQuery.entity];
                    } else {
                        reclassificationRequest.params.taskType = "process-query";
                        reclassificationRequest.params.query = this.selectionQuery.params ? this.selectionQuery.params.query : this.selectionQuery;
                    }

                    var originalClassifications = [];
                    reclassificationRequest.params.data.contexts = this._prepareContexts(this._selectedItems, originalClassifications);

                    //Add clientAttributes
                    var valueContext = ContextHelper.getFirstValueContext(this.contextData);
                    var userContext = ContextHelper.getFirstUserContext(this.contextData);
                    var clientMessage = "Bulk reclassification";

                    reclassificationRequest.clientAttributes = {
                        "taskName": {
                            "values": [{
                                "source": valueContext.source,
                                "locale": valueContext.locale,
                                "value": clientMessage
                            }]
                        }
                    };

                    asyncLiqReclassification.requestData = reclassificationRequest;
                    asyncLiqReclassification.generateRequest();
                },

                _onAsyncReclassificationSuccess: function(e, detail) {
                    var response = e.detail.response && e.detail.response.response ? e.detail.response.response : e.detail.response;
                    var request = e.detail.response ? e.detail.response.request : undefined;

                    if ((!response || _.isEmpty(response)) ||
                        (DataHelper.isValidObjectPath(response, "dataObjectOperationResponse.status") && response.dataObjectOperationResponse.status.toLowerCase() == "error") ||
                        (response.status && response.status.toLowerCase() == "error")) {
                            this.showErrorToast(this._bulkReclassificationErrorMessage);
                            this.logError("BulkReclassificationError", "response", JSON.stringify(response));
                        return;
                    } else {
                        if (response.status && response.status.toLowerCase() == "success") {
                            if (request && request.taskId) {
                                this._taskId = request.taskId;
                            }
                        }

                        this._triggerFinishStep(true);
                    }
                },

                _onAsyncReclassificationFailure: function(e, detail) {
                    this.showErrorToast(this._bulkReclassificationErrorMessage);
                    this.logError("BulkReclassificationError", "response", JSON.stringify(e.detail.response.reason.message));
                },

                _onTriggerEvent: function(e, detail) {
                    var event = e.target.getAttribute("id");
                    if(event == "skipEvent" || event == "cancelEvent" || event == "backEvent") {
                        this._skipOrCancelSelection(e);
                    } else if (event == "nextEvent") {
                        this._save(e);
                    }
                }
            });
        })();
    </script>
</dom-module>