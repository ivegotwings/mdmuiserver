<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-ajax/iron-ajax.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">

<link rel="import" href="../liquid-entity-get/liquid-entity-get.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-data-save/liquid-entity-data-save.html">
<link rel="import" href="../liquid-rest/liquid-rest.html">

<link rel="import" href="../pebble-accordion/pebble-accordion.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-vertical-divider/pebble-vertical-divider.html">
<link rel="import" href="../pebble-tree/pebble-tree.html">
<link rel="import" href="../pebble-button/pebble-button.html">

<link rel="import" href="../rock-attribute-list/rock-attribute-list.html">
<!--
`rock-extension-manage` represents a component that renders all the extensions of the entity.
Can manage current extensions, create new extensions etc.

@element rock-extension-manage
@group rock-elements
@demo demo/index.html
-->
<dom-module id="rock-extension-manage">
    <template>
        <style include="pebble-styles-shared">
            /* Accordian styles */
            pebble-accordion::shadow .header{
                background-color:var(--palette-pale-grey-four);
                border: 0;
                margin:1px;
            }
            pebble-accordion::shadow .header-items-space{
                float:left !important;
            }
            .tree-heading {
                font-weight: bold;
                font-size: var(--default-font-size, 14px);
            }
            #extensions-container {
                position: relative;
                margin: 0;
                width: 100%;
                display: inline-flex;
                display: -webkit-inline-flex;
            }            
            .left {
                width:30%;
                overflow-x: scroll;
            }
            .right {
                width:70%;
            }
            .card {
                margin: 10px;
                background-color:var(--palette-white, #fff);
                box-shadow: 0 1px 7px 0 var(--palette-cloudy-blue, #c1cad4);
            }
            .card > pebble-accordion::shadow .header-items-space{
                float:right !important;
            }
            .card > pebble-accordion::shadow .header{
                background-color:var(--palette-white, #fff);
                border: 0;
                margin:1px;
            }
            .card > pebble-accordion::shadow .header-text a {
                font-size: var(--default-font-size, 14px);
            }
            .card > pebble-accordion::shadow .header-text iron-icon {
                height: 25px;
                width: 25px;
                float:right !important;
                color:var(--palette-medium-steel-grey, #7d8690);
            }
            .attribute {
                display: inline-block;
                width: 49%;
            }
            #buttonContainer {
                height: 50px;
                width: 50%;
                position: fixed;
                bottom: 55px;
                text-align: center;
                display: none;
                padding: 12px 0 0 0;
                z-index: 1;
            }
            pebble-accordion::shadow iron-icon{
                float:left !important;
            }
            pebble-accordion::shadow .header .header-text{
                padding-top: 3px;
            }
        </style>
        <!--<liquid-entity-data-get id="getEntityData" verbose operation="getbyids"
        request-data={{_entityRequest}} on-response="_onEntitiesReceived" on-error="_onEntityGetFailed"></liquid-entity-data-get>-->
        <liquid-rest id="getEntityData" url="/pass-through/entityservice/get" method="POST" 
        request-data={{_entityRequest}} on-liquid-response="_onEntitiesReceived" on-liquid-error="_onEntityGetFailed"></liquid-rest>
        <pebble-accordion header-text="Extension Context" default-icon="expand-less" open-icon="expand-more">
            <div id="extensions-container">
                <div id="tree-container" class="left m-15">
                    <span class="tree-heading">Container & Catagory Context</span>
                    <iron-ajax auto url="demo/entity-containers-data.json" handle-as="json" last-response="{{_containerData}}"></iron-ajax>
                    <iron-ajax auto url="demo/entity-categories-data.json" handle-as="json" last-response="{{_categoriesData}}"></iron-ajax>
                    <pebble-tree id="contextTree" data="{{_treeData}}" enable-search multi-select></pebble-tree>
                    <bedrock-pubsub event-name="tree-node-selected" handler="_treeNodeSelected" target-id=""></bedrock-pubsub>
                </div>
                <pebble-vertical-divider class="divider"></pebble-vertical-divider>
                <div id="values-container" class="right">
                    <bedrock-pubsub on-bedrock-event-list-mode-changed="_listModeChanged"></bedrock-pubsub>
                    <div id="expansion-panel"></div>
                    <div id="buttonContainer" align="center">
                        <pebble-button id="cancel" class="action-button btn btn-secondary" button-text="Cancel" on-tap="_revertAll" elevation=1 raised></pebble-button>
                        <pebble-button id="save" class="action-button-focus dropdownText btn btn-success m-r-5" button-text="Save" on-tap="_save" elevation=1 raised></pebble-button>
                    </div>
                </div>
            </div>
        </pebble-accordion>
        <liquid-entity-get name="attributeModelGetService" request="{{_attributeModelRequest}}" response="{{_attributeModelResponse}}"></liquid-entity-get>
        <liquid-entity-data-get id="attributeGetDataService" name="attributeGetDataService" operation="getbyids" request-data="{{_attributeRequest}}" last-response="{{_attributeResponse}}" on-response="_onAttributeResponse"></liquid-entity-data-get>
        <liquid-entity-data-save name="attributeSaveDataService" operation="update" request-data="{{_saveRequest}}" on-response="_onSaveResponse"></liquid-entity-data-save>
    </template>
    <script>
        (function () {
            'use strict';

            Polymer({
                is: "rock-extension-manage",
                properties: {
                    /**
                     * Indicates the context parameters for which the attribute data is managed.
                     * JSON sample to be added here.
                     */
                    context: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the locale dimension for which the extensions are managed.
                     */
                    locale: {
                        type: String,
                        value: ""
                    },
                    /**
                     * Indicates the source dimension for which the extensions are managed.
                     */
                    source: {
                        type: String,
                        value: ""
                    },
                    /**
                     * Indictaes Id of the entity for which the extansions have to be managed.
                     */
                    entityId: {
                        type: String
                    },
                     _selectedItems: {
                        type: Array,
                        value: function() {return [];},
                    },
                    /**
                   * Indicates the names of the attributes to be rendered in extensions.
                   */
                   attributeNames: {
                       type: Array,
                       value: function() { 
                           return []; 
                        }
                   },
                    /**
                    * Specifies the request object for attribute model request.
                    */
                   _attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {
                                action: "getAttributeModels"
                            };
                        }
                    },
                    /**
                    * Specifies the response object for attribute models.
                    */
                    _attributeModelResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _containerData: {
                        type: Array,
                        value: function() { return []; }
                    },
                    _categoriesData: {
                        type: Array,
                        value: function() { return []; }
                    },
                    _treeData: {
                        type: Array,
                        value: function() { return []; }
                    },
                     /**
                    * Indicates the request object that is passed to the data element to retrive attribute data.
                      Sample: { 
                                action: "getAttributes" 
                              }
                    */
                    _attributeRequest: {
                        type: Object,
                        value: function () { return {}; }
                    },
                    /**
                     * Indicates the response object that is received from the data element for the attribute get request.
                     */
                    _attributeResponse: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    _entityRequest: {
                        type: Object,
                        value: function() { return {}; }
                    },
                    _isDirty: {
                        type: Boolean,
                        value: false
                    },
                },
                observers: [
                    '_contextChanged(context)',
                    '_attributeNamesChanged(attributeNames)',
                    '_entityDataChanged(_containerData, _categoriesData)',
                    '_attributeModelResponseChanged(_attributeModelResponse)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior
                ],
                _contextChanged: function(context) {
                    if(context) {
                        if(context.entityId) {
                            this.entityId = context.entityId;
                        }
                        if(context.locale) {
                            this.locale = context.locale;
                        }
                        if(context.source) {
                            this.source = context.source;
                        }
                    }
                },
                _attributeNamesChanged: function(attributeNames) {
                    var t = {
                        action: "getAttributeModels",
                        "attributeNames": this.attributeNames
                    };
                    this.set("_attributeModelRequest", t);
                },
                _entityDataChanged: function(_containerData, _categoriesData) {
                    if(_containerData && _containerData.length > 0) {
                        var treeData = [];
                        for(var i=0; i < _containerData.length; i++) {
                            var nodeJson = {
                                "text": _containerData[i].text,
                                "value": _containerData[i].value,
                                "border": _containerData[i].border,
                                "expanded": _containerData[i].expanded
                            };
                            treeData.push(nodeJson);
                        }
                        if(_categoriesData && _categoriesData.length > 0) {
                            for(var i=0; i<treeData.length; i++) {
                                var containerName = treeData[i].text;
                                var categories = this._getCategoriesForContainer(_categoriesData, containerName);
                                if(categories && categories.length > 0) {
                                    treeData[i]["children"] = categories;
                                }
                            }
                            this._generateRequestForEntity();
                        }
                        this.set("_treeData", treeData);
                    }
                },
                _getCategoriesForContainer: function(categories, containerName) {
                    if(categories && categories.length > 0) {
                        var categoriesJson = [];
                        for(var i=0; i< categories.length; i++) {
                            var container = categories[i].text;
                            if(container == containerName) {
                                categoriesJson = categories[i].children;
                                return categoriesJson;
                            }
                        }
                    }
                },
                _generateRequestForEntity: function() {
                    var req = {
                            "params": {
                                "query": {
                                    "id": this.entityId,
                                    "filters": {
                                        "attributesCriterion": [],
                                        "typesCriterion": [
                                            "nart"
                                        ]
                                    }
                                },
                                "fields": {
                                    "ctxTypes": [
                                        "properties"
                                    ],
                                    "attributes": [
                                    ]
                                }
                            }
                        };
                        this.set("_entityRequest", req);
                        this.$$("#getEntityData").generateRequest();
                },
                _onEntitiesReceived: function(e) {
                    var response = e.detail.response;
                    if(response) {
                        var entitiy = response["response"].entities[0];
                    }
                    if(entitiy && entitiy.data) {
                        this.isTreeReady = true;
                        this._selectNodes(entitiy.data);
                    }
                },
                _selectNodes: function(entityData) {
                    var treeElement = this.$$("#contextTree");
                    var contexts = [];
                    for(var i=0; i< entityData.contexts.length; i++) {
                        var currContext = entityData.contexts[i].context;
                        var list = currContext.list;
                        var classification = currContext.classification;
                        var node;
                        if(list && classification) {
                            var valuePath = list + "." + classification.replace(/\//g, ".");
                            var node = treeElement.getElementNodeByPath(valuePath);
                        }
                        if(node) {
                            node.selectItem();
                            node.selectAllParentNodes();
                            node.expand();
                            var context = this._getContextData(node);
                            var categoryPath = context.categoryPath;
                            var categoryPathValue = context.categoryPathValue;
                            var newContext = {
                                "list": list,
                                "classification": classification
                            };
                            contexts.push(newContext);
                            this._createCardDiv(categoryPathValue);
                            this._createAccordion(categoryPathValue, categoryPath);
                        }
                    }
                    if(contexts && contexts.length > 0) {
                        this._attributeRequest.params.query.contexts = contexts;
                        this._attributeRequest.params.query.id = this.entityId;
                        this.$$("#attributeGetDataService").generateRequest();
                    }
                },
                _onEntityGetFailed: function(e) {
                    var message = e.detail.response;
                },
                _treeNodeSelected: function(e, detail, sender) {
                    if(detail && detail.data) {
                        var node = detail.data;
                        this._isDirty = true;
                        this.isTreeReady = false;
                        node.selectAllParentNodes();
                        this._transformItemIntoContext(node);
                        this.$.buttonContainer.style.display = "inline-block";
                    }
                },
                _transformItemIntoContext: function(node) {
                    var context = this._getContextData(node);
                    var list = context.list;
                    var classification = context.classification;
                    var categoryPath = context.categoryPath;
                    var categoryPathValue = context.categoryPathValue;
                    this._attributeRequest.params.query.contexts = [];
                    var currContext = {
                            "list": list,
                            "classification": classification
                        }
                    this._attributeRequest.params.query.contexts.push(currContext);
                    this._createCardDiv(categoryPathValue);
                    this._createAccordion(categoryPathValue, categoryPath);
                    this.$$("#attributeGetDataService").generateRequest();
                },
                _getContextData: function(selectedNode) {
                    var treeElement = this.$$("#contextTree");
                    var nodePath = selectedNode.valuePath;
                    var paths = nodePath.split(".");
                    var path = "";
                    var list = "";
                    var classification = "";
                    var categoryPath = "";
                    for(var j=0; j<paths.length; j++) {
                        path = path + paths[j];
                        var node = treeElement.getElementNodeByPath(path);
                        if(j == 0){
                            categoryPath = node.nodeData.text + " - ";
                            list = node.nodeData.value;
                        }
                        else if(j== paths.length -1) {
                            categoryPath = categoryPath + node.nodeData.text;
                            classification = classification + node.nodeData.value;
                        }
                        else {
                            categoryPath = categoryPath + node.nodeData.text + " >> ";
                            classification = classification + node.nodeData.value + "/";
                        }
                        path = path + ".";
                    }
                    var categoryPathValue = list + "-" + classification.replace(/\//g, "-");
                    var contextJson = {
                        "list": list,
                        "categoryPath": categoryPath,
                        "categoryPathValue": categoryPathValue,
                        "classification": classification
                    };
                    return contextJson;
                },
                _attributeModelResponseChanged: function(_attributeModelResponse) {
                     if (_attributeModelResponse && _attributeModelResponse.returnValue &&
                            _attributeModelResponse.returnValue.attributeModels) {
                        var attributeNames = [];
                        for (var attributeGroupName in _attributeModelResponse.returnValue.attributeModels) {
                            for (var attributeName in _attributeModelResponse.returnValue.attributeModels[
                                    attributeGroupName]) {
                                attributeNames.push(attributeName);
                            }
                        }
                        var req = {
                            "params": {
                                "query": {
                                    "contexts": [],
                                    "valueContexts": [{
                                        "source": this.source,
                                        "locale": this.locale
                                    }],
                                    "id": this.entityId,
                                    "filters": {
                                        "attributesCriterion": [],
                                        "relationshipsCriterion": [],
                                        "typesCriterion": ["nart"]
                                    }
                                },
                                "fields": {
                                    "ctxTypes": [
                                        "properties"
                                    ],
                                    "attributes": attributeNames,
                                    "relationships": [
                                    ]
                                },
                                "options": {
                                    "totalRecords": 1,
                                    "includeRequest": false
                                }
                            }
                        }
                        this.set("_attributeRequest", req);
                    }
                },
                 _onAttributeResponse: function (e) {
                    var _attributeResponse = e.detail.response;
                    var _attributeRequest = e.detail.request;
                    var values = [];
                    var mode = "";
                    var dataContext = {
                            "locale": this.locale,
                            "time": "now",
                            "source": this.source,
                            "list": "",
                            "classification": ""                        
                    };
                    if(this.isTreeReady) {
                        if (DataHelper.validateGetEntitiesResponse(_attributeResponse) 
                            && DataHelper.validateGetAttributeModelsResponse(this._attributeModelResponse)) {
                            
                            var entity = DataHelper.findEntityById(_attributeResponse.content.entities,     this.entityId);
                            if(entity && entity.data && entity.data.contexts && entity.data.contexts.length>0) {
                                for(var i=0; i< entity.data.contexts.length; i++) {
                                    var currContext = entity.data.contexts[i].context;
                                    dataContext.list = currContext.list;
                                    dataContext.classification = currContext.classification;
                                    var categoryPathValue = currContext.list + "-" + currContext.classification.replace(/\//g, "-");
                                    values = DataHelper.getAttributesInManageFormat(entity, this._attributeModelResponse.returnValue.attributeModels, dataContext);
                                    mode = "view";
                                    this._createAttributeList(categoryPathValue, values, mode); 
                                }
                            }
                            else {
                                var list = _attributeRequest.requestData.params.query.contexts[0].list;
                                var classification = _attributeRequest.requestData.params.query.contexts[0].classification;
                                dataContext.list = list;
                                dataContext.classification = classification;
                                var categoryPathValue = list + "-" + classification.replace(/\//g, "-");
                                values = DataHelper.transformAttributesToManageFormat({}, this._attributeModelResponse.returnValue.attributeModels, dataContext);
                                mode = "view";
                                this._createAttributeList(categoryPathValue, values, mode);
                            }
                        }
                    }
                    else {
                        var list = _attributeRequest.requestData.params.query.contexts[0].list;
                        var classification = _attributeRequest.requestData.params.query.contexts[0].classification;
                        dataContext.list = list;
                        dataContext.classification = classification;
                        var categoryPathValue = list + "-" + classification.replace(/\//g, "-");
                        values = DataHelper.transformAttributesToManageFormat({}, this._attributeModelResponse.returnValue.attributeModels, dataContext);
                        mode = "edit";
                        this._createAttributeList(categoryPathValue, values, mode);
                    }
                },
                _createCardDiv: function(categoryPathValue) {
                    var divEl = document.createElement('div');
                    divEl.setAttribute('id', 'card-'+ categoryPathValue);
                    divEl.setAttribute('class', "card");
                    var expansionPanel = this.$$("#expansion-panel");
                    if(expansionPanel) {
                        var cardEl = expansionPanel.querySelector("#"+ divEl.id);
                        if(!cardEl) {
                            expansionPanel.appendChild(divEl);
                        }
                    }
                },
                _createAccordion: function(categoryPathValue, categoryPath) {
                    var accordionEl = document.createElement('pebble-accordion');
                    accordionEl.setAttribute('id', 'accordion-' + categoryPathValue);
                    accordionEl.setAttribute('header-text', categoryPath);
                    accordionEl.setAttribute('default-icon', 'expand-less');
                    accordionEl.setAttribute('open-icon', 'expand-more');
                    var cardDiv = this.$$("#card-"+ categoryPathValue);
                    if(cardDiv){
                        var el = cardDiv.querySelector("#"+ accordionEl.id);
                        if(!el) {
                            cardDiv.appendChild(accordionEl);
                        }
                    }
                },
                _createAttributeList: function(categoryPathValue, attributes, mode) {
                    var attributeListEl = document.createElement('rock-attribute-list');
                    attributeListEl.setAttribute('id', 'list-'+ categoryPathValue);
                    attributeListEl.setAttribute('mode', mode);
                    attributeListEl.setAttribute('no-of-columns', 2);
                    attributeListEl.attributeValues = attributes;
                    attributeListEl.attributeModels = this._attributeModelResponse.returnValue.attributeModels;
                    var accordion = this.$$("#accordion-"+ categoryPathValue);
                    if(accordion){
                        var el = accordion.querySelector("#" + attributeListEl.id);
                        if(!el) {
                            accordion.appendChild(attributeListEl);
                        }
                    }
                },
                _save: function(e) {
                    var treeElement = this.$$("#contextTree");
                    var selectedNodes = treeElement.selectedNodes;
                    var selectedContexts = this._getChangedContexts(selectedNodes);
                    var changedContexts = this._getChangedContextItems(selectedContexts);
                    var entityData = this._getEntityData(changedContexts);
                    if (!_.isEmpty(entityData)) {
                        //set requestObject for save liquid
                        this._saveRequest = {
                            "entities": [entityData]
                        };
                        var liquidSave = this.$$("[name=attributeSaveDataService]");
                        if (liquidSave) {
                            liquidSave.generateRequest();
                        }
                    }
                },
                _onSaveResponse: function (e) {
                    var saveResponse = e.detail.response;
                    if(saveResponse.status == "success") {
                        this._refresh();
                    }
                },
                _revertAll: function(e) {
                    this._refresh();
                },
                _getChangedContexts: function(selectedNodes) {
                    if(selectedNodes && selectedNodes.length > 0) {
                        var changedContexts = [];
                        for(var i=0; i<selectedNodes.length; i++) {
                            var node = selectedNodes[i];
                            var context = this._getContextData(node);
                            var contextJson = {
                                "contextPath": context.categoryPathValue,
                                "list": context.list,
                                "classification": context.classification
                            };
                            changedContexts.push(contextJson);
                        }
                        return changedContexts;
                    }
                },
                _getChangedContextItems: function(contexts) {
                    if(contexts && contexts.length > 0) {
                        var finalContexts = [];
                        for(var i=0; i<contexts.length; i++) {
                            var context = contexts[i].contextPath;
                            var attributeList = this.$$("#list-"+ context);
                            if(attributeList){
                                var changedAttributeElements;
                                if(this.isTreeReady) {
                                    changedAttributeElements = attributeList.getChangedAttributeElements();
                                }
                                else {
                                    if(attributeList.mode == "edit") {
                                        changedAttributeElements = Polymer.dom(attributeList).node.root.querySelectorAll('rock-attribute');
                                    }
                                }
                                if (changedAttributeElements && changedAttributeElements.length > 0) {
                                    var attributesJSON = [];
                                    for (var j = 0; j < changedAttributeElements.length; j++) {
                                        var attributeElement = changedAttributeElements[j];
                                        var attributeJSON = attributeElement.attributeObject;
                                        attributesJSON.push(attributeJSON);
                                    }
                                    var ctxItem = {};
                                    ctxItem.context = { "list": contexts[i].list, "classification": contexts[i].classification };
                                    ctxItem.attributes = DataHelper.transformAttributeFromUIFormat(attributesJSON);
                                    finalContexts.push(ctxItem);
                                }
                            }
                        }
                        return finalContexts;
                    }
                },
                _getEntityData: function(contexts) {
                    if(contexts) {
                        var entityData = {};
                        if (this._attributeResponse && this._attributeResponse.content && this._attributeResponse
                        .content.entities && this._attributeResponse.content.entities.length > 0) {

                            var originalEntity = this._attributeResponse.content.entities[0];
                            for (var entityDataField in originalEntity) {
                                entityData[entityDataField] = DataHelper.cloneObject(originalEntity[entityDataField]);
                            }
                            var contextualData = {};
                            contextualData.contexts = contexts;
                            entityData["data"] = contextualData;
                        }
                        return entityData;
                    }
                },
                _refresh: function() {
                    var treeElement = this.$$("#contextTree");
                    treeElement.clearSelectedItems();
                    var expansionPanel = this.$$("#expansion-panel");
                    while (expansionPanel.hasChildNodes()) {
                      expansionPanel.removeChild(expansionPanel.lastChild);
                    }
                    this.$.buttonContainer.style.display = "none";
                    treeElement.refreshTree();
                    this.$$("#getEntityData").generateRequest();
                },
                _listModeChanged: function(e, detail, sender) {
                    if(detail.mode=="edit") {
                        this._isDirty = true;
                        this.$.buttonContainer.style.display = "inline-block";
                    }
                },
                /**
                 * Can be used to get the elemet if it is dirty.
                 */
                getIsDirty: function () {
                    return this._isDirty;
                },
            });
        })();
    </script>
</dom-module>