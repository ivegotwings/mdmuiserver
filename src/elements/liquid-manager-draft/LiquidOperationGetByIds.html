<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">

<link rel="import" href="./LiquidRequest.html">
<link rel="import" href="./LiquidResponse.html">

<link rel="import" href="./LiquidOperationBase.html">
<link rel="import" href="./FalcorManager.html">

<script>
    class LiquidOperationGetByIds extends LiquidOperationBase {
        constructor () {
            super();
        }

        static async execute (liquidRequest, liquidResponse) {
            super.execute(liquidRequest, liquidResponse);
            let options = liquidRequest.options;
            let response = {
                "status": "success",
                "content": {}
            };

            let responsePkg = await this._callGetByIds(liquidRequest, liquidResponse);

            if (responsePkg) {
                response.content = await this.format(responsePkg, options);
            }

            liquidResponse.response = response;
            return true;
        }

        static async format (responsePkg, options) {
            await super.format(responsePkg, options);

            let pathKeys = SharedUtils.DataObjectFalcorUtil.getPathKeys();
            let dataIndexInfo = pathKeys.dataIndexInfo[options.dataIndex];
                
            let returnObjectsCollectionName = dataIndexInfo.collectionName;

            let formattedDataObjects = [];

            if (responsePkg !== undefined && responsePkg.json && responsePkg.json[pathKeys.root]) {
                let dataObjects = this._getDataObjects(responsePkg, options);

                for (let dataObjectId in dataObjects) {
                    let dataObject = dataObjects[dataObjectId];
                    let formattedDataObject = this._formatDataObject(dataObject);
                    formattedDataObjects.push(formattedDataObject);
                }
            }

            let getByIdsResponse = {
            };
            getByIdsResponse[returnObjectsCollectionName] = formattedDataObjects;

            return getByIdsResponse;
        }

        static async _callGetByIds (liquidRequest, liquidResponse) {
            let reqData = liquidRequest.requestData;
            let options = liquidRequest.options;
            let dataIndex = options.dataIndex;
            let utils = SharedUtils.DataObjectFalcorUtil;

            let dataObjectFields = ["id", "name", "version", "type", "properties", "domain"];
            let paths = [];

            let basePath = this._getDataObjectBasePath(reqData);
            let ctxKeys = this._getCtxKeys(reqData);
            let loadAllFlags = this._checkLoadAllFlags(reqData);

            if (loadAllFlags.needObjectKeyResolution) {
                let objectKeysResponsePkg = await this._callObjectKeysGet(basePath, loadAllFlags, ctxKeys);
                if(!_.isEmpty(objectKeysResponsePkg)) {
                    this._appendObjectKeysToRequest(liquidRequest, basePath, ctxKeys, objectKeysResponsePkg, loadAllFlags);
                }
            }
 
            let relTypes = reqData.params.fields.relationships === undefined ? [] : reqData.params.fields.relationships;
            let valCtxKeys = utils.createCtxKeys(reqData.params.query.valueContexts);

            paths.push(utils.mergePathSets(basePath, [dataObjectFields]));

            let attributesPath = this._getAttributesPath(reqData, basePath, ctxKeys, valCtxKeys);
            if (attributesPath) {
                paths.push(attributesPath);
            }

            if (relTypes.length > 0) {
                let relPaths = await this._getRelationshipPaths(liquidRequest, basePath, ctxKeys, valCtxKeys, relTypes);
                paths.push.apply(paths, relPaths);
            }

            let jsonDataPath = this._getJsonDataPath(reqData, basePath, ctxKeys);
            if (jsonDataPath) {
                paths.push(jsonDataPath);
            }

            let responsePkg = await FalcorManager.get(paths);

            return responsePkg;
        }

        static _getDataObjectBasePath (reqData) {
            let dataObjectIds = [];

            if (reqData === undefined || reqData.params === undefined) {
                return;
            }

            if (reqData.params && reqData.params.query && (reqData.params.query.id || reqData.params.query.ids)) {
                if (reqData.params.query.id) {
                    dataObjectIds.push(reqData.params.query.id);
                } else if (reqData.params.query.ids) {
                    dataObjectIds.push.apply(dataObjectIds, reqData.params.query.ids);
                }
            } else if (reqData.params && reqData.params.query && (reqData.params.query.name || reqData.params.query.names)) {
                if (reqData.params.query.filters && reqData.params.query.filters.typesCriterion) {
                    let types = reqData.params.query.filters.typesCriterion;
                    if (reqData.params.query.name) {
                        for (let typeIndex = 0; typeIndex < types.length; typeIndex++) {
                            let type = types[typeIndex];
                            let smartId = reqData.params.query.name + "_" + type;
                            dataObjectIds.push(smartId);
                        }
                    } else if (reqData.params.query.names) {
                        for (let typeIndex = 0; typeIndex < types.length; typeIndex++) {
                            for (let nameIndex = 0; nameIndex < reqData.params.query.names.length; nameIndex++) {
                                let type = types[typeIndex];
                                let smartId = reqData.params.query.names[nameIndex] + "_" + type;
                                dataObjectIds.push(smartId);
                            }
                        }
                    }
                }
            }
            
            let dataObjectTypes = this._getDataObjectTypes(reqData);
            let basePath = [this._pathKeys.root, this.dataIndex, dataObjectTypes, this._pathKeys.byIds, dataObjectIds];

            return basePath;
        }
        
        static _getDataObjectTypes (reqData) {
            let dataObjectTypes = [];
            if (reqData && reqData.params && reqData.params.query &&
                reqData.params.query.filters && reqData.params.query.filters.typesCriterion &&
                reqData.params.query.filters.typesCriterion.length > 0) {
                dataObjectTypes = reqData.params.query.filters.typesCriterion;
            }

            if (dataObjectTypes.length == 0) {
                dataObjectTypes = [SharedUtils.DataObjectFalcorUtil.CONST_ALL];
            }

            return dataObjectTypes;
        }

        static _getCtxKeys (reqData) {
            let contexts = [];

            let utils = SharedUtils.DataObjectFalcorUtil;

            if (reqData.params && reqData.params.query && reqData.params.query.contexts && reqData.params.query.contexts.length > 0) {
                contexts = reqData.params.query.contexts;
            }

            contexts.push(utils.getSelfCtx());

            return utils.createCtxKeys(contexts);
        }

        static _checkLoadAllFlags (reqData) {
            let result = {};

            let needObjectKeyResolution = false;

            if (reqData && reqData.params && reqData.params.fields && reqData.params.fields) {
                let fields = reqData.params.fields;

                if (fields.attributes && fields.attributes.indexOf("_ALL") > -1) {
                    result.loadAttributeNames = needObjectKeyResolution = true;
                }

                if (fields.relationships && fields.relationships.indexOf("_ALL") > -1) {
                    result.loadRelationshipsTypes = needObjectKeyResolution = true;
                }

                if (fields.relationshipAttributes && fields.relationshipAttributes.indexOf("_ALL") > -1) {
                    result.loadRelationshipAttributes = needObjectKeyResolution = true;
                }

                if (fields.contexts && fields.contexts.indexOf("_ALL") > -1) {
                    result.loadContexts = needObjectKeyResolution = true;
                }
            }

            result.needObjectKeyResolution = needObjectKeyResolution;

            return result;
        }
        
        static _appendObjectKeysToRequest(liquidRequest, basePath, ctxKeys, objectKeysResponsePkg, loadAllFlags) {
            let allAttrNames = [];
            let allRelTypes = [];
            let allContexts = [];

            let reqData = liquidRequest.requestData;

            let utils = SharedUtils.DataObjectFalcorUtil;

            if (objectKeysResponsePkg) {

                let dataObjects = this._getDataObjects(objectKeysResponsePkg, liquidRequest.options);

                for (let dataObjectIdIdx in dataObjects) {
                    let resDataObject = dataObjects[dataObjectIdIdx];

                    for (let ctxKeyIdx in ctxKeys) {
                        let ctxKey = ctxKeys[ctxKeyIdx];

                        if (loadAllFlags.loadAttributeNames) {
                            let attrNames = utils.getNestedObject(resDataObject, ["data", "contexts", ctxKey, "mappings", "attributeMap"]);
                            if (!_.isEmpty(attrNames)) {
                                allAttrNames.push.apply(allAttrNames, attrNames);
                            }
                        }

                        if (loadAllFlags.loadRelationshipsTypes) {
                            let relTypes = utils.getNestedObject(resDataObject, ["data", "contexts", ctxKey, "mappings", "relationshipMap"]);
                            if (!_.isEmpty(relTypes)) {
                                allRelTypes.push.apply(allRelTypes, relTypes);
                            }
                        }
                    }

                    if (loadAllFlags.loadContexts) {
                        let contexts = utils.getNestedObject(resDataObject, ["data", "contextMap"]);
                        if (!_.isEmpty(contexts)) {
                            allContexts.push.apply(allContexts, contexts);
                        }
                    }
                }

                if (loadAllFlags.loadAttributeNames) {
                    reqData.params.fields.attributes = allAttrNames;
                }

                if (loadAllFlags.loadRelationshipsTypes) {
                    reqData.params.fields.relationships = allRelTypes;
                }

                if (loadAllFlags.loadContexts) {
                    reqData.params.query.contexts.push.apply(reqData.params.query.contexts, allContexts);
                }
            }

            return true;
        }
    
        static async _callObjectKeysGet (basePath, loadAllFlags, ctxKeys) {
            let utils = SharedUtils.DataObjectFalcorUtil;
            let paths = [];
            let objectKeysResponsePkg = {};

            if (!loadAllFlags.needObjectKeyResolution) {
                return;
            }

            if (loadAllFlags.loadAttributeNames) {
                let attributeMapPath = utils.mergePathSets(basePath, ["data", "contexts", ctxKeys, "mappings", "attributeMap"]);
                paths.push(attributeMapPath);
            }

            if (loadAllFlags.loadRelationshipsTypes) {
                let relationshipMapPath = utils.mergePathSets(basePath, ["data", "contexts", ctxKeys, "mappings", "relationshipMap"]);
                paths.push(relationshipMapPath);
            }

            if (loadAllFlags.loadContexts) {
                let contextMapPath = utils.mergePathSets(basePath, ["data", "mappings", "contextMap"]);
                paths.push(contextMapPath);
            }

            if (paths.length > 0) {
                objectKeysResponsePkg = await FalcorManager.get(paths);
            }

            return objectKeysResponsePkg;
        }

        static async _getRelationshipPaths (liquidRequest, basePath, ctxKeys, valCtxKeys, relTypes) {
            let reqData = liquidRequest.requestData;
            let options = liquidRequest.options;
            let dataIndex = options.dataIndex;
            let utils = SharedUtils.DataObjectFalcorUtil;

            let relPaths = [];

            let relIdListPath = utils.mergePathSets(basePath, ["data", "contexts", ctxKeys, "relationships", relTypes, "relIds"]);

            let relIdsResponsePkg = await FalcorManager.get(relIdListPath);

            if (!_.isEmpty(relIdsResponsePkg)) {
                let relDetailGetPaths = this._getRelationshipDetailPaths(liquidRequest, basePath, ctxKeys, valCtxKeys, relTypes, relIdsResponsePkg);

                if (relDetailGetPaths.length > 0) {
                    relPaths.push.apply(relPaths, relDetailGetPaths);
                }
            }

            return relPaths;
        }

        static _getDataObjects (rawResponsePkg, options) {
            let utils = SharedUtils.DataObjectFalcorUtil;

            let pathKeys = utils.getPathKeys();
            let dataObjects = {};
            
            if (utils.isValidObjectPath(rawResponsePkg, "json." + pathKeys.root + "." + options.dataIndex)) {
                let dataByIndex = rawResponsePkg.json[pathKeys.root][options.dataIndex];
                if (dataByIndex) {
                    for (let dataObjectType in dataByIndex) {
                        let dataObjectTypeJson = dataByIndex[dataObjectType][pathKeys.byIds];
                        for (let dataObjectId in dataObjectTypeJson) {
                            dataObjects[dataObjectId] = dataObjectTypeJson[dataObjectId];
                        }
                    }
                }
            }
            
            return dataObjects;
        }
    
        static _getAttributesPath (reqData, basePath, ctxKeys, valCtxKeys) {

            let utils = SharedUtils.DataObjectFalcorUtil;

            let attributesPath = undefined;
            let attrs = [];

            if (reqData.params.fields.attributes !== undefined && reqData.params.fields.attributes.length > 0) {
                attrs.push.apply(attrs, reqData.params.fields.attributes);
            }

            let attrDetailPath = this._getAttributeDetailPath(valCtxKeys);

            // TODO:: how to solve this hack..
            if (this.dataIndex == "entityModel") {
                attrs.push(utils.CONST_CTX_PROPERTIES); /// get contexts level properties as attribute named 'properties'.. this is cheating..
            }

            if (attrs.length > 0) {
                attributesPath = utils.mergePathSets(basePath, ["data", "contexts", ctxKeys, "attributes", attrs], attrDetailPath);
            }

            return attributesPath;
        }
        
        static _getAttributeDetailPath (valCtxKeys) {
            return ["valContexts", valCtxKeys, ["values", "group", "properties"]];
        }
        
        static _getRelationshipDetailPaths (liquidRequest, basePath, ctxKeys, valCtxKeys, relTypes, relIdsResponsePkg) {
            let reqData = liquidRequest.requestData;
            let options = liquidRequest.options;
            let dataIndex = options.dataIndex;
            let utils = SharedUtils.DataObjectFalcorUtil;

            let relDetailGetPaths = [];

            let relFieldsPath = [["id", "direction", "operation", "source", "properties", "relTo", "relToObject", "os", "osid", "ostype", "osctxpath"]];
            let attrDetailPath = this._getAttributeDetailPath(valCtxKeys);

            let relAttrNames = reqData.params.fields.relationshipAttributes === undefined ? [] : reqData.params.fields.relationshipAttributes;
            DataHelper.arrayRemove(relAttrNames, "_ALL"); //TODO: Fix this once we have logic to resolve ALL...
            
            let relatedDataObjectAttrs = reqData.params.fields.relatedEntityAttributes === undefined ? [] : reqData.params.fields.relatedEntityAttributes;
            DataHelper.arrayRemove(relatedDataObjectAttrs, "_ALL"); //TODO: Fix this once we have logic to resolve ALL...

            let relAttrsPath = [];
            if (relAttrNames.length > 0) {
                relAttrsPath = utils.mergePathSets(["attributes", relAttrNames], attrDetailPath);
            }

            let relToObjectPath_Fields = utils.mergePathSets(["relToObject"]);
            let relToObjectPath_Attrs = [];
            if (relatedDataObjectAttrs.length > 0) {
                relToObjectPath_Attrs = utils.mergePathSets(["relToObject", "data", "contexts", ctxKeys, "attributes", relatedDataObjectAttrs], attrDetailPath);
            }

            if (!_.isEmpty(relIdsResponsePkg)) {
                let resDataObjects = this._getDataObjects(relIdsResponsePkg, options);

                for (let dataObjectIdIdx in resDataObjects) {
                    let resDataObject = resDataObjects[dataObjectIdIdx];

                    for (let relTypeIdx in relTypes) {
                        let relType = relTypes[relTypeIdx];
                        let totalRelIds = [];
                        for (let ctxKeyIdx in ctxKeys) {
                            let ctxKey = ctxKeys[ctxKeyIdx];
                            let relIds = utils.getNestedObject(resDataObject, ["data", "contexts", ctxKey, "relationships", relType, "relIds"]);
                            if (!relIds) {
                                continue;
                            }
                            
                            //If user is asking for coalesced data, then only we need to merge context and self context objects
                            //Otherwise selected context data objects should come
                            // Context-v3: Need to verify bug 320078 post this change
                            totalRelIds = totalRelIds.concat(relIds);
                            let from = reqData.params.options && reqData.params.options.from !== undefined ? reqData.params.options.from : 0;
                            let to = reqData.params.options && reqData.params.options.to !== undefined ? reqData.params.options.to : relIds.length - 1;

                            if (from == -1) {
                                from = 0;
                            } else if (from >= relIds.length) {
                                from = -1;
                            }

                            if (to >= relIds.length) {
                                to = relIds.length - 1;
                            }

                            if (from != -1) {
                                let filteredRelIds = relIds.slice(from, to + 1);
                                let relBasePath = utils.mergePathSets(basePath, ["data", "contexts", ctxKey, "relationships", relType, "rels", filteredRelIds]);

                                //must have paths for eachrel..rel fields and relTo with only fields..
                                relDetailGetPaths.push(utils.mergePathSets(relBasePath, relFieldsPath));
                                //relDetailGetPaths.push(utils.mergePathSets(relBasePath, relToObjectPath_Fields));

                                //rel attrs..only if requested...
                                if (relAttrsPath.length > 0) {
                                    relDetailGetPaths.push(utils.mergePathSets(relBasePath, relAttrsPath));
                                }

                                //related entity attrs..only if requested...
                                if (relToObjectPath_Attrs.length > 0) {
                                    relDetailGetPaths.push(utils.mergePathSets(relBasePath, relToObjectPath_Attrs));
                                }
                            } else {
                                //Commented below line because of,
                                //rock-grid internally uses iron-data-table and iron-data-table has functionality of vitualization where it's loading 2 page very first time.
                                //2 pages are necessary to satisfy all possible scenarion of virtualization (To get scroll bar in grid).
                                //So here if page size and record size is same for second page "from" will become "-1" and due to this throw it will not return any thing to iron-data-tale.
                                //if there is no record iron-data-table requires atlest blank response to stop second page loading.
                                //throw "requested range is not available for relationships";
                            }
                        }

                        //Keep relIds total count in order to return with the final response...
                        let relCountObject = liquidRequest.stateBag.relIdsCountOfRelGetRequest && liquidRequest.stateBag.relIdsCountOfRelGetRequest[dataObjectIdIdx] ?  liquidRequest.stateBag.relIdsCountOfRelGetRequest[dataObjectIdIdx] : undefined;

                        if (!relCountObject) {
                            relCountObject = liquidRequest.stateBag.relIdsCountOfRelGetRequest[dataObjectIdIdx] = {};
                        }

                        relCountObject[relType] = [...new Set(totalRelIds)].length;
                    }
                }
            }

            return relDetailGetPaths;
        }
        
        static _getJsonDataPath (reqData, basePath, ctxKeys) {
            if (reqData.params.fields.jsonData) {
                return SharedUtils.DataObjectFalcorUtil.mergePathSets(basePath, ["data", "contexts", ctxKeys], ["jsonData"]);
            } else {
                return undefined;
            }
        }
        
        static _formatDataObject (dataObject) {
            let utils = SharedUtils.DataObjectFalcorUtil;

            let transDataObject = {};

            if (isEmpty(dataObject)) {
                return transDataObject;
            }

            for (let dataObjectField in dataObject) {
                if (dataObjectField != 'data') {
                    transDataObject[dataObjectField] = dataObject[dataObjectField];
                }
            }

            if (dataObject.data && dataObject.data.contexts) {
                let transContexts = [];
                let selfCtxItem = {};
                let ctxKeys = Object.keys(dataObject.data.contexts);

                if (ctxKeys && ctxKeys.length) {
                    for (let i = 0; i < ctxKeys.length; i++) {
                        let ctxKey = ctxKeys[i];
                        let transContextsItem = {};

                        let transContext = utils.createCtxItem(ctxKey);

                        transContextsItem.context = transContext;

                        let enContextData = dataObject.data.contexts[ctxKey];

                        if (enContextData.attributes) {
                            transContextsItem.attributes = this._formatAttributes(enContextData.attributes);
                        }

                        if (enContextData.relationships) {
                            transContextsItem.relationships = this._formatRelationships(enContextData.relationships);
                        }

                        if (enContextData.jsonData) {
                            transContextsItem.jsonData = enContextData.jsonData;
                        }

                        //read dataobject' metadata fields from the attributes.metadataFields, if available
                        if (transContextsItem.attributes && transContextsItem.attributes[utils.CONST_DATAOBJECT_METADATA_FIELDS]) {

                            if (transContext.selfContext) {
                                let metadataFields = this._formatProperties(transContextsItem.attributes[utils.CONST_DATAOBJECT_METADATA_FIELDS]);
                                for (let dataObjectField in metadataFields) {
                                    transDataObject[dataObjectField] = metadataFields[dataObjectField];
                                }
                            }

                            delete transContextsItem.attributes[utils.CONST_DATAOBJECT_METADATA_FIELDS];
                        }

                        //read context's properties from the attributes.properties, if available
                        if (transContextsItem.attributes && transContextsItem.attributes[utils.CONST_CTX_PROPERTIES]) {
                            transContextsItem.properties = this._formatProperties(transContextsItem.attributes[utils.CONST_CTX_PROPERTIES]);
                            delete transContextsItem.attributes[utils.CONST_CTX_PROPERTIES];
                        }

                        if (transContext.selfContext) {
                            selfCtxItem = transContextsItem;
                        } else {
                            transContexts.push(transContextsItem);
                        }
                    }
                }

                let transData = {};
                transData.contexts = transContexts;

                if (!isEmpty(selfCtxItem)) {
                    transData.attributes = selfCtxItem.attributes;
                    transData.relationships = selfCtxItem.relationships;
                    transData.properties = selfCtxItem.properties;
                    transData.jsonData = selfCtxItem.jsonData;
                }

                transDataObject.data = transData;
            }

            return transDataObject;
        };

        static _formatAttributes (attributes) {
            let utils = SharedUtils.DataObjectFalcorUtil;
            let transAttributes = {};

            if (isEmpty(attributes)) {
                return transAttributes;
            }

            for (let attrKey in attributes) {
                let attr = attributes[attrKey];
                let attrValContexts = attr.valContexts;

                if (!attrValContexts) {
                    continue;
                }

                let valCtxKeys = Object.keys(attrValContexts);
                if (valCtxKeys && valCtxKeys.length) {
                    for (let i = 0; i < valCtxKeys.length; i++) {
                        let valCtxKey = valCtxKeys[i];
                        let attrData = attrValContexts[valCtxKey];

                        let transAttr = utils.getOrCreate(transAttributes, attrKey, {});

                        if (attrData) {
                            if (attrData.values) {
                                let transAttrValues = utils.getOrCreate(transAttr, 'values', []);
                                transAttrValues.push.apply(transAttrValues, attrData.values);
                            }

                            if (attrData.group) {
                                let transAttrGroup = utils.getOrCreate(transAttr, 'group', []);
                                transAttrGroup.push.apply(transAttrGroup, attrData.group);
                            }

                            if (attrData.properties) {
                                let transAttrProperties = utils.getOrCreate(transAttr, 'properties', {});
                                transAttrProperties = utils.mergeObjects(transAttrProperties, attrData.properties);
                            }
                        }
                    }
                }
            }

            return transAttributes;
        }

        static _formatRelationships (relationships) {
            let transRelationships = {};

            if (isEmpty(relationships)) {
                return transRelationships;
            }

            for (let relTypeIdx in relationships) {
                let relTypeObj = relationships[relTypeIdx];
                let relsArray = [];

                for (let relObjKey in relTypeObj.rels) {
                    let rel = relTypeObj.rels[relObjKey];

                    if (!isEmpty(rel.attributes)) {
                        rel.attributes = this._formatAttributes(rel.attributes);
                    }

                    if (rel.relToObject) {
                        let relToObject = rel.relToObject;

                        if (relToObject.data) {
                            relToObject = this._formatDataObject(relToObject);
                        }

                        if (rel.relTo && relToObject.data) {
                            rel.relTo.data = relToObject.data;
                            rel.relTo.name = relToObject.name;
                            rel.relTo.version = relToObject.version;
                            rel.relTo.properties = relToObject.properties;
                        }

                        delete rel.relToObject;
                    }

                    relsArray.push(rel);
                }

                transRelationships[relTypeIdx] = relsArray;
            }

            return transRelationships;
        };

        static _formatProperties (properties) {
            let utils = SharedUtils.DataObjectFalcorUtil;

            let transProperties = {};

            if (isEmpty(properties)) {
                return transProperties;
            }

            if (!properties.properties) {
                return transProperties;
            }

            for (let propKey in properties.properties) {
                let property = properties.properties[propKey];
                transProperties[propKey] = utils.cloneObject(property);
            }

            return transProperties;
        }
    }
</script>