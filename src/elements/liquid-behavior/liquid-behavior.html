<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../bedrock-datachannel/bedrock-datachannel.html">
<script>
    /*
    * @demo demo/index.html
    * @polymerBehavior RUFBehaviors.LiquidBehavior
    */
    var RUFBehaviors = RUFBehaviors || {};

    RUFBehaviors.LiquidBehavior = {
        attached: function () { },
        ready: function () { },
        /**
         * Fired when a request is sent.
         *
         * @event request
         * @event liquid-request
         */

        /**
         * Fired when a response is received.
         *
         * @event response
         * @event liquid-response
         */

        /**
         * Fired when an error is received.
         *
         * @event error
         * @event liquid-error
         */
        properties: {
            /**
             * If true, automatically performs an Ajax request when either `url` or
             * `params` changes.
             */
            auto: {
                type: Boolean,
                value: false
            },
            /**
             * The most recent request made by this iron-ajax element.
             */
            lastRequest: {
                type: Object,
                value: function(){
                    return {};
                },
                notify: true,
                readOnly: true
            },
            /**
             * True while lastRequest is in flight.
             */
            loading: {
                type: Boolean,
                notify: true,
                readOnly: true
            },
            /**
             * lastRequest's response.
             *
             * Note that lastResponse and lastError are set when lastRequest finishes,
             * so if loading is true, then lastResponse and lastError will correspond
             * to the result of the previous request.
             *
             * The type of the response is determined by the value of `handleAs` at
             * the time that the request was generated.
             *
             * @type {Object}
             */
            lastResponse: {
                type: Object,
                value: function(){
                    return {};
                },
                notify: true,
                readOnly: true
            },
            /**
             * lastRequest's error, if any.
             *
             * @type {Object}
             */
            lastError: {
                type: Object,
                value: function(){
                    return {};
                },
                notify: true,
                readOnly: true
            },
            /**
             * An Array of all in-flight requests originating from this iron-ajax
             * element.
             */
            activeRequests: {
                type: Array,
                value: function () {
                    return [];
                },
                notify: true,
                readOnly: true,
            },
            /**
             * Length of time in milliseconds to debounce multiple automatically generated requests.
             */
            debounceDuration: {
                type: Number,
                value: 0,
                notify: true
            },
            /**
             * By default, liquid-element-*'s events bubble. Setting this attribute will cause its
             * request and response events as well as its iron-ajax-request, -response,  and -error
             * events to bubble to the window object. The vanilla error event never bubbles when
             * using shadow dom even if this.bubbles is true because a scoped flag is not passed with
             * it (first link) and because the shadow dom spec did not used to allow certain events,
             * including events named error, to leak outside of shadow trees (second link).
             * https://www.w3.org/TR/shadow-dom/#scoped-flag
             * https://www.w3.org/TR/2015/WD-shadow-dom-20151215/#events-that-are-not-leaked-into-ancestor-trees
             */
            bubbles: {
                type: Boolean,
                value: true
            },
            /**
             * If true, error messages will automatically be logged to the console.
             */
            verbose: {
                type: Boolean,
                value: false
            },
            /**
             * Set the timeout flag on the request.
             */
            timeout: {
                type: Number,
                value: 0
            },
            operation: {
                type: String,
                value: '',
                notify: true
            },
            requestId: {
                type: String,
                value: '',
                notify: true
            },
            requestData: {
                type: Object,
                value: function () {
                    return {};
                },
                notify: true
            },
            /**
             * Prefix to be stripped from a JSON response before parsing it.
             *
             * In order to prevent an attack using CSRF with Array responses
             * (http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx/)
             * many backends will mitigate this by prefixing all JSON response bodies
             * with a string that would be nonsensical to a JavaScript parser.
             *
             */
            _jsonPrefix: {
                type: String,
                value: ''
            },
            _dataChannelName: {
                type: String,
                value: 'Unknown',
                readonly: true
            }
        },
        observers: [
            '_requestOptionsChanged(requestData.*, operation, requestId, timeout, auto)'
        ],
        /**
         * Performs an request to the specified URL.
         *
         */
        generateRequest: function () {
            var request = this._createRequest();

            var self = this;

            if (request.requestData === null || request.operation === '') {

                if(this.verbose){
                    console.log('request operation is blank so NO request operation would be generated..terminating gracefully...');
                }

                return;
            }

            this.push('activeRequests', request);
            this._setLastRequest(request);
            this._setLoading(true);

            this.fire('request', {
                request: request
            }, { bubbles: this.bubbles });

            this.fire('liquid-request', {
                request: request
            }, { bubbles: this.bubbles });

            if (this._executeRequest) {
                var model = RUFBehaviors.DataChannel.getModel(this._dataChannelName);
                var modelResponse = this._executeRequest(model, request);
                if(!this._handleModelResponse(request, modelResponse)) //if mode response is not queued ...no need to create active request..
                    return;
            }
            else {
                throw "_executeRequest method is not defined";
                return;
            }

            return request;
        },
        _executeRequest: function (model, request) {
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _formatResponse: function(request, rawResponsePkg){
            return rawResponsePkg;
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _validateAutoTriggerChanges: function(requestData, operation, requestId){
            return true;
            //abstract method....do nothing...all elements implementing this behavior must implement this method
        },
        _createRequest: function () {
            return {
                "operation": this.operation,
                "requestId": this.requestId === undefined ? '' : this.requestId,
                "requestData": this.requestData
            }
        },
        _handleModelResponse: function(request, modelResponse){
            var self = this;

            if(modelResponse && modelResponse.then){
                modelResponse.then(function (resPkg) {
                    return self._handleResponse(request, resPkg);
                },
                function (errPkg) {
                    return self._handleError(request, errPkg);
                });

                return true;
            }
            else {
                if(modelResponse && modelResponse.status && modelResponse.status === "success"){
                    return self._handleResponse(request, modelResponse);
                }
                else if(modelResponse && modelResponse.status && modelResponse.status === "error"){
                    self._handleError(request, modelResponse);
                }

                return false;
            }

            return true;
        },
        _handleResponse: function (request, responsePkg) {
            if(this.verbose){
                console.log('_handleResponse called with :', request, responsePkg);
            }

            var formattedResponse = this._formatResponse(request, responsePkg);

            var response = this._createSuccessResponse(request, formattedResponse);

            if (request === this.lastRequest) {
                this._setLastResponse(response);
                this._setLastError(null);
                this._setLoading(false);
            }

            var eventDetail = { 'request': request, 'response': response };

            if(this.verbose){
                console.log('firing liquid-response event with event detail ', eventDetail);
            }

            this.fire('response', eventDetail, { bubbles: this.bubbles });
            this.fire('liquid-response', eventDetail, { bubbles: this.bubbles });

            this._discardRequest(request);
        },
        _handleError: function (request, errorPkg) {
            if (this.verbose) {
                Polymer.Base._error('Error occured for the request ', request, '. Error response package is ', errorPkg);
            }

            var errResponse = this._createErrorResponse(errorPkg);

            if (request === this.lastRequest) {
                this._setLastError(errResponse);
                this._setLastResponse(null);
                this._setLoading(false);
            }

            var eventDetail = { 'request': request, 'response': errResponse };

            if(this.verbose){
                console.log('firing liquid-error event with event detail ', eventDetail);
            }

            // Tests fail if this goes after the normal this.fire('error', ...)
            this.fire('liquid-error', eventDetail, { bubbles: this.bubbles });
            this.fire('error', eventDetail, { bubbles: this.bubbles });

            this._discardRequest(request);
        },
        _createSuccessResponse: function (request, data) {
            var clonedData;
            
            if(data === undefined){
                clonedData = {};
            }
            else {
             clonedData = JSON.parse(JSON.stringify(data));
            }

            return {
                'status': 'success',
                'content': clonedData
            };
        },
        _createErrorResponse: function (request, reason) {
            var result = {
                'status': 'error',
                'reason': reason
            };

            if (this.verbose) {
                console.log('Error response for the operation: ', request.operation, result);
            }

            return result;
        },
        _discardRequest: function (request) {
            var requestIndex = this.activeRequests.indexOf(request);

            if (requestIndex > -1) {
                this.splice('activeRequests', requestIndex, 1);
            }
        },
        _requestOptionsChanged: function (reqData, operation, requestId) {
            this.debounce('generate-falcor-request', function () {
                if (reqData == null || operation == '') {
                    return;
                }

                if (this.auto) {
                    if(this._validateAutoTriggerChanges(reqData, operation, requestId)){
                        this.generateRequest();
                    }
                }

            }, this.debounceDuration);
        }
    };

</script>