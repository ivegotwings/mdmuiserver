<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-validator/bedrock-validator.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">

<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textbox-collection/pebble-textbox-collection.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-richtexteditor/pebble-richtexteditor.html">
<link rel="import" href="../pebble-dropdown/pebble-dropdown.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-date-picker/pebble-date-picker.html">
<link rel="import" href="../pebble-datetime-picker/pebble-datetime-picker.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-info-icon/pebble-info-icon.html">
<link rel="import" href="../rock-entity-combo-box/rock-entity-combo-box.html">
<link rel="import" href="../rock-nested-attribute-grid/rock-nested-attribute-grid.html">

<link rel="import" href="pebble-error-list.html">
<!--
`rock-attribute`
Represents the attribute component in the framework. It understands the details of the attribute from 
the parameters it has recieved and renders appropriate UI elements to manage an attribute value.
@demo demo/index.html 
-->
<dom-module id="rock-attribute">
    <template>
            <style include="bedrock-style-common">
                :host(.fallback-value) {
                    --fallback-marker: {
                        color: var(--color-variant-1);
                    }
                }

                :host {
                    --fallback-marker: {}
                }

                :host(.coalesced-value) {
                    --fallback-marker: {
                        font-style: italic;
                    }
                }

                .attribute {
                    @apply --layout-horizontal;
                }

                .attribute.list {
                    @apply --layout-center-center;
                    padding: 15px 10px 25px 10px;
                }

                .attribute-main {
                    width: 100%;
                    position: relative;
                    cursor: pointer;
                    @apply --attribute-main;
                }

                .attribute-icons-wrapper {
                    text-align: right
                }

                .attribute-icons {
                    display: inline-block;
                    opacity: 0;
                    transition: all 0.3s;
                    -webkit-transition: all 0.3s;
                }

                .attribute-icons pebble-info-icon {
                    opacity: 1;
                }

                .attribute-main:hover .attribute-icons {
                    opacity: 1;
                }
                .attribute-view{
                    border-bottom: 1px solid #E0E0E0;
                    box-shadow: 0 2px 6px -6px #000;
                    -webkit-box-shadow: 0 2px 6px -6px #000;
                    -moz-box-shadow: 0 2px 6px -6px #000;
                    -ms-box-shadow: 0 2px 6px -6px #000;
                }

                .attribute-view,
                .attribute-edit {
                    clear: both;
                }

                .attribute-edit {
                    @apply --attribute-edit;
                    --pebble-dt-default-inputarea: {
                        width: 100%;
                    }
                }

                .attribute-view.grid {
                    margin-top: 0;
                }

                .attribute-view.grid .attribute-view-value {
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                }

                .attribute-view.grid {
                    --pebble-textarea-input: {
                        max-height: 25px;
                    }
                }

                .attribute-view-value {
                    font-size: var(--default-font-size,14px);
                    display: inline-block;
                    width: 100%;
                    vertical-align: middle;
                    max-height: 100px;
                    overflow-y: auto;
                    @apply --fallback-marker;
                }

                .attribute-icons pebble-button {
                    width: 32px;
                    color: var(--primary-icon-color, #75808b);
                }

                .attribute pebble-button {
                    color: var(--secondary-icon-color, #c1cad4);
                    padding: 0;
                    transition: all 0.3s;
                    -webkit-transition: all 0.3s;
                }

                .attribute pebble-button:hover {
                    color: var(--primary-icon-color, #75808b);
                }

                .attribute-icons pebble-button {
                    width: 32px;
                    color: var(--primary-icon-color);
                    --pebble-button: {
                        min-width: auto;
                        padding-top: 0;
                        padding-right: 0;
                        padding-bottom: 0;
                        padding-left: 0;
                        height: auto;
                    }
                }

                .datetimepicker-container {
                    width: 100%;
                    position: relative;
                }

                #dateTimeTriggerContainer {
                    position: absolute;
                    right: -11px;
                    bottom: -6px;
                }

                #dateTimeTriggerContainer {
                    --paper-button: {
                        min-width: auto;
                    }
                }

                #error-display {
                    position: absolute;
                    right: 0;
                    left: 0;
                    bottom: -24px;
                }

                .error {
                    color: var(--error-color, #ed204c);
                    font-size: var(--font-size-sm, 12px);
                    font-weight: var(--font-medium, 500);
                    letter-spacing: 0.011em;
                    line-height: 10px;
                    width: 85%;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    display: inline-block;
                }

                .error-circle {
                    height: 18px;
                    width: 18px;
                    line-height: 18px;
                    text-align: center;
                    border-radius: 50%;
                    background: var(--error-color, #ed204c);
                    color: var(--palette-white, #fff);
                    font-size: var(--font-size-xs, 10px);
                    float: right;
                    margin-top: 3px;
                }

                .text-collection-container {
                    margin-top: 25px;
                }

                pebble-textbox-collection {
                    --text-collection-label: {
                        font-size: 12px;
                        color: var(--label-text-color, #96B0C5);
                    };

                    --text-collection-manage-tag-container: {
                        height: 65px;
                    }
                }

                .close-item {
                    position: absolute;
                    top: 30px;
                    right: -15px;
                }

                .delete-item {
                    position: absolute;
                    top: 30px;
                    right: -30px;
                }

                .attribute-edit-changed {
                    background-color: var(--edit-attribute-bgcolor) !important;
                }

                pebble-popover#view-source-information-popover {
                    font-weight: normal;
                    text-transform: initial;
                    text-align: left;
                    margin-left: -12px;
                    margin-top: 7px;
                    --default-popup-b-p: 5px;
                    --default-popup-t-p: 5px;
                    --default-font-size: 12px;
                    width: 180px;
                }

                pebble-popover#view-source-information-popover::after,
                pebble-popover#view-source-information-popover::before {
                    bottom: 100%;
                    left: 20px;
                    border: solid transparent;
                    content: " ";
                    height: 0;
                    width: 0;
                    position: absolute;
                    pointer-events: none;
                }

                pebble-popover#view-source-information-popover::after {
                    border-color: rgba(255, 255, 255, 0);
                    border-bottom-color: #ffffff;
                    border-width: 6px;
                    margin-left: -6px;
                }

                pebble-popover#view-source-information-popover::before {
                    border-color: rgba(194, 225, 245, 0);
                    border-bottom-color: rgb(216, 221, 228);
                    border-width: 7px;
                    margin-left: -7px;
                }

                .source-information-header,
                .source-information-description,
                .source-information-path {
                    padding-left: 10px;
                    padding-right: 10px;
                }

                .source-information-header {
                    font-weight: bold;
                    border-bottom: thin solid rgb(216, 221, 228);
                    padding-bottom: 3px;
                }

                .source-information-path {
                    margin-top: 10px;
                    margin-bottom: 0px;
                }

                .source-information-path .path-item {
                    color: var(--link-text-color, #139ee7);
                    display: inline-block;
                }

                .source-information-path .path-item::after {
                    content: " >>";
                    color: var(--default-text-color, #444444);
                }

                .source-information-path .path-item:last-of-type::after {
                    content: "";
                }

                li {
                    text-align: inherit;
                }
            </style>
        <div class$="attribute [[functionalMode]]">
            <div class="attribute-main">
                <div class="attribute-icons-wrapper">
                    <div class="attribute-icons" hidden$="[[_isGridType]]">
                        <template is="dom-if" if="[[!_isEditMode(mode)]]">
                            <template is="dom-if" if="[[_isAttributeEditable(attributeModelObject)]]">
                                <pebble-button disabled$=[[readonly]] name="edit" class="pebble-md-icons m-l-5 tooltip-bottom" icon="pebble-md-icons:Edit"
                                    data-tooltip="Edit" on-tap="_onEditClick" tabindex="-1"></pebble-button>
                            </template>
                        </template>
                        <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                            <template is="dom-if" if="[[_hasValue(attributeObject.value)]]">
                                <pebble-button name="clear" class="pebble-md-icons m-l-5 tooltip-bottom close-item" icon="pebble-md-icons:Clear" data-tooltip="Clear value"
                                    on-tap="_onClearClick" tabindex="-1"></pebble-button>
                            </template>
                        </template>
                        <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                            <template is="dom-if" if="[[showDeleteIcon]]">
                                <pebble-button name="delete" class="pebble-md-icons m-l-5 tooltip-bottom delete-item" icon="pebble-md-icons:Delete" data-tooltip="Remove Attribute"
                                    on-tap="_onDeleteClick" tabindex="-1"></pebble-button>
                            </template>
                            <pebble-button name="revert" class="pebble-md-icons m-l-5 tooltip-bottom" icon="pebble-md-icons:ToolbarRefresh" data-tooltip="Revert"
                                on-tap="_onRevertClick" tabindex="-1"></pebble-button>
                        </template>


                        <template is="dom-if" if="[[_showSourceInfo()]]">
                            <pebble-button name="owner" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-lg-icons:Master" id="view-source-information"
                                data-tooltip="View source information" on-tap="_onSourceInformationClick" tabindex="-1"></pebble-button>

                            <pebble-popover id="view-source-information-popover" for="view-source-information">
                                <div class="attributes-description">
                                    <div class="source-information-header">Source Information</div>
                                    <div class="source-information-description">This value was sourced from the following path</div>
                                    <template is="dom-if" if="[[_hasFallbackValue()]]">
                                        <ul class="source-information-path">
                                            Locale:
                                            </br>
                                            <template is="dom-repeat" items="[[_fallbackList]]">
                                                <li class="path-item">[[item]]</li>
                                            </template>
                                        </ul>
                                    </template>
                                    <template is="dom-if" if="[[_hasContextCoalescedValue()]]">
                                        <ul class="source-information-path">
                                            Context:
                                            </br>
                                            <template is="dom-repeat" items="[[_contextCoalescePathList]]">
                                                <li class="path-item">[[item]]</li>
                                            </template>
                                        </ul>
                                    </template>
                                </div>
                            </pebble-popover>
                        </template>

                        <pebble-button name="owner" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:LowPriority" data-tooltip="View ownership info"
                            on-tap="_onOwnerClick" tabindex="-1"></pebble-button>

                        <pebble-button name="time" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:AccessTime" data-tooltip="Manage historical data"
                            on-tap="_onTimeClick" tabindex="-1"></pebble-button>

                        <pebble-button name="locale" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:Language" data-tooltip="Manage in multiple locales"
                            on-tap="_onLocaleClick" tabindex="-1"></pebble-button>
                        <div class="clearfix"></div>
                    </div>

                </div>
                <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                    <div class$="[[_getAttributeEditClass(changed)]]">
                        <!-- TEXTAREA -->
                        <template is="dom-if" if="[[_isTextArea(attributeModelObject)]]">
                            <pebble-textarea id="input" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                                label="{{_getLabel(attributeModelObject.externalName)}}" value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]"
                                invalid="{{invalid}}" tabindex="[[tabindex]]"></pebble-textarea>
                        </template>

                        <!-- DROPDOWN -->
                        <template is="dom-if" if="[[_isDropDown(attributeModelObject)]]">
                            <pebble-dropdown id="input" label="{{_getLabel(attributeModelObject.externalName)}}" items="{{attributeModelObject.allowedValues}}"
                                selected-value="{{attributeObject.value}}" invalid="{{invalid}}" no-label-float="[[noLabelFloat]]"
                                description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]">
                            </pebble-dropdown>
                        </template>
                        <!-- BOOLEAN -->
                        <template is="dom-if" if="[[_isBoolean(attributeModelObject)]]">
                            <pebble-boolean id="input" label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" invalid="{{invalid}}"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" true-text="[[_isNullOrEmpty(attributeModelObject.trueText, 'TRUE')]]"
                                false-text="[[_isNullOrEmpty(attributeModelObject.falseText,'FALSE')]]" tabindex="[[tabindex]]">
                            </pebble-boolean>
                        </template>
                        <!-- DATE -->
                        <template is="dom-if" if="[[_isDate(attributeModelObject)]]">
                            <pebble-datetime-picker id="datePicker" min-date="[[attributeModelObject.properties.rangeFrom]]" max-date="[[attributeModelObject.properties.rangeTo]]"
                                label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" picker-type="date"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- DATETIME -->
                        <template is="dom-if" if="[[_isDateTime(attributeModelObject)]]">
                            <pebble-datetime-picker id="dateTimePicker" min-date="[[attributeModelObject.properties.rangeFrom]]" max-date="[[attributeModelObject.properties.rangeTo]]"
                                label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" picker-type="datetime"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- TEXTBOX-COLLECTION -->
                        <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                            <div class="text-collection-container">
                                <pebble-textbox-collection label="{{_getLabel(attributeModelObject.externalName)}}" id="txtCollection" no-label-float="[[noLabelFloat]]"
                                    description-object="[[_getDescriptionObject()]]" values="{{attributeObject.value}}" tabindex="[[tabindex]]">
                                </pebble-textbox-collection>
                            </div>
                        </template>
                        <!-- If display type is not supported then textbox is used -->
                        <!-- TEXTBOX -->
                        <template is="dom-if" if="[[_isTextBox(attributeModelObject)]]">
                            <pebble-textbox id="input" label="{{_getLabel(attributeModelObject.externalName)}}" value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]"
                                invalid="{{invalid}}" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]"
                                tabindex="[[tabindex]]"></pebble-textbox>
                        </template>
                    </div>
                </template>

                <template is="dom-if" if="[[!_isComponentEditable(mode, attributeModelObject)]]">
                    <template is="dom-if" if="[[_useDefaultReadMode(attributeModelObject)]]">
                        <div class$="attribute-view [[functionalMode]]">
                            <span hidden="[[_isGridType]]">
                                <span class="attribute-view-label">{{attributeModelObject.externalName}} </span>
                                <pebble-info-icon hidden$="[[_isGridOrNested(attributeModelObject)]]" description-object="[[_getDescriptionObject()]]"></pebble-info-icon>
                                <br>
                            </span>
                            <span class="attribute-view-value" title="{{_formatValue(attributeModelObject, attributeObject)}}">{{_formatValue(attributeModelObject, attributeObject)}}</span>
                            <br>
                        </div>
                    </template>
                    <!-- TEXTBOX-COLLECTION -->
                    <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                        <div class="text-collection-container">
                            <pebble-textbox-collection label="{{_getLabel(attributeModelObject.externalName)}}" id="txtCollection" values="{{attributeObject.value}}"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]"
                                is-readonly>
                            </pebble-textbox-collection>
                        </div>
                    </template>

                </template>

                <template is="dom-if" if="[[_isLOV(attributeModelObject)]]">
                    <template is="dom-if" if="[[_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="multi-select-combo-box" id-field="[[_getMappedColumn('id', attributeModelObject)]]" value-field="[[_getMappedColumn('value', attributeModelObject)]]"
                            image-id-field="[[_getMappedColumn('imageId', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            sub-title-pattern="[[_getMappedColumn('subtitle', attributeModelObject)]]" multi-select label="[[_getLabel(attributeModelObject.externalName)]]"
                            is-readonly="[[!_isComponentEditable(mode, attributeModelObject)]]" request-data="[[_prepareRequestObjectForLov(attributeModelObject, dependentAttributeObjects)]]"
                            selected-ids="{{attributeObject.referenceDataId}}" selected-values="{{attributeObject.value}}" tabindex="[[tabindex]]"
                            no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" context-data="[[contextData]]"
                            on-tag-removed="_onTagItemRemoved">
                        </rock-entity-combo-box>
                    </template>
                    <template is="dom-if" if="[[!_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="combo-box" id-field="[[_getMappedColumn('id', attributeModelObject)]]" value-field="[[_getMappedColumn('value', attributeModelObject)]]"
                            image-id-field="[[_getMappedColumn('imageId', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            sub-title-pattern="[[_getMappedColumn('subtitle', attributeModelObject)]]" label="[[_getLabel(attributeModelObject.externalName)]]"
                            is-readonly="[[!_isComponentEditable(mode, attributeModelObject)]]" request-data="[[_prepareRequestObjectForLov(attributeModelObject, dependentAttributeObjects)]]"
                            selected-id="{{attributeObject.referenceDataId}}" selected-value="{{attributeObject.value}}" tabindex="[[tabindex]]"
                            context-data="[[contextData]]" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]"
                            on-tag-removed="_onTagItemRemoved">
                        </rock-entity-combo-box>
                    </template>
                </template>

                <!-- NESTED ATTRIBUTES -->
                <template is="dom-if" if="[[_isNested(attributeModelObject)]]">
                    <template is="dom-if" if="[[!_isGridType]]">
                        <rock-nested-attribute-grid label="{{_getLabel(attributeModelObject.externalName)}}" attribute-model-object="[[attributeModelObject]]"
                            original-attribute-object="[[_cloneObject(attributeObject)]]" attribute-object="{{attributeObject}}"
                            context-data="[[contextData]]" mode="[[mode]]" changed="{{changed}}"></rock-nested-attribute-grid>
                    </template>
                    <template is="dom-if" if="[[_isGridType]]">
                        <span id="nestedAttributeLink" on-tap="_nestedAttributeLinkTapped">Click here</span>
                        <pebble-dialog id="nestedAttributeModal" modal show-ok button-ok-text="ok" show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key
                            dialog-title="{{attributeModelObject.externalName}}">
                            <rock-nested-attribute-grid label="{{_getLabel(attributeModelObject.externalName)}}" attribute-model-object="[[attributeModelObject]]"
                                original-attribute-object="[[_cloneObject(attributeObject)]]" attribute-object="{{attributeObject}}"
                                context-data="[[contextData]]" mode="[[mode]]"></rock-nested-attribute-grid>
                        </pebble-dialog>
                    </template>
                </template>

                <!-- RICHTEXTEDITOR -->
                <template is="dom-if" if="[[_isRichTextEditor(attributeModelObject)]]">
                    <!-- Show the popover for read-only mode for the grid-->
                    <template is="dom-if" if="[[_isGridType]]">
                        <template is="dom-if" if="[[!_isEditMode(mode)]]">
                            <span id="rtelink" on-mouseenter="_rteLinkHovered">Show More</span>
                            <pebble-popover id="rtePopover" class="p-10" for="rtelink" no-overlap horizontal-align="right">
                                <pebble-richtexteditor id="input" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                                    label="{{_getLabel(attributeModelObject.externalName)}}" invalid="{{invalid}}" value="{{attributeObject.value}}"
                                    tabindex="[[tabindex]]" read-only="[[!_isComponentEditable(mode, attributeModelObject)]]"></pebble-richtexteditor>
                            </pebble-popover>
                        </template>
                        <template is="dom-if" if="[[_isEditMode(mode)]]">
                            <span id="rteEditLink" on-tap="_rteEditLinkTapped">Click to Edit</span>
                            <pebble-dialog id="rteSingleEdit" modal show-ok button-ok-text="ok" show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key
                                dialog-title="Rich Text Editor">
                                <rock-attribute id="singleEdit" mode="[[mode]]" functional-mode="list" attribute-model-object="{{attributeModelObject}}"
                                    attribute-object="{{attributeObject}}"></rock-attribute>
                            </pebble-dialog>
                        </template>
                    </template>
                    <template is="dom-if" if="[[!_isGridType]]">
                        <pebble-richtexteditor id="input" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                            label="{{_getLabel(attributeModelObject.externalName)}}" invalid="{{invalid}}" value="{{attributeObject.value}}"
                            tabindex="[[tabindex]]" read-only="[[!_isComponentEditable(mode, attributeModelObject)]]"></pebble-richtexteditor>
                    </template>
                </template>

                <bedrock-validator validation-errors="{{validationErrors}}" input="[[attributeObject.value]]" input-data-type="[[attributeModelObject.dataType]]"
                    pattern="[[attributeModelObject.pattern]]" min-length="[[attributeModelObject.minLength]]" max-length="[[attributeModelObject.maxLength]]"
                    precision="[[attributeModelObject.precision]]" required="[[attributeModelObject.required]]" invalid="{{invalid}}"
                    min="[[attributeModelObject.rangeFrom]]" max="[[attributeModelObject.rangeTo]]" min-inclusive="[[attributeModelObject.isRangeFromInclusive]]"
                    max-inclusive="[[attributeModelObject.isRangeToInclusive]]" date-format="[[attributeModelObject.dateFormat]]"
                    type="[[attributeModelObject.validationType]]" type-array="[[attributeModelObject.validationTypeArray]]"></bedrock-validator>

                <div id="error-display" hidden="[[_errorAbsent(errors)]]" on-tap="_errorTapped">
                    <span class="error">[[errorMessage]] </span>
                    <span id="error-circle" class="error-circle">[[errorLength]]</span>
                </div>
            </div>
            <!-- <div>
                    <template is="dom-if" if="[[_isEditMode(mode)]]">
                        <paper-icon-button name="clear" icon="pebble-icons:Clear" title="Clear" on-tap="_onClearClick" tabindex="-1"></paper-icon-button>
                    </template>
                </div> -->
        </div>
        <pebble-popover id="errorPopover" for="error-circle" no-overlap horizontal-align="right">
            <pebble-error-list id="attrErrorList" errors="[[errors]]"></pebble-error-list>
        </pebble-popover>        
        <bedrock-pubsub target-id="attrErrorList" event-name="fix-error" handler="_fixError"></bedrock-pubsub>


    </template>
    <script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute',
                ready: function () {
                    //console.log('attribute ready '+this._isInitialized);
                    this._isInitialized = true;
                },
                attached: function () {
                    //console.log('attribute attached');
                },
                properties: {
                    /**
                     * <b><i>Content development is under progress... </b></i>
                     */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * If set as true , it indicates the component is in read only mode
                     */
                    readonly: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Indicates whether the attribute is rendered in edit mode or view mode.
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                     * Indicates the JSON for the attribute value object. This object records all the user changes to the value.
                     * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                     */
                    attributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },
                    /**
                     * Indicates the JSON for the original attribute value object. This object does not record all the user changes to the value.
                     * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                     */
                    originalAttributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the JSON for the attribute model object.
                     * It renders appropriate UI element to edit the attribute, to configure the validation, and other behaviors.
                     * Sample: {
                                "name": "name",
                                "externalName": "Name",
                                "displayType": "textbox",
                                "minLength": 5,
                                "maxLength": 10
                              }
                     */
                    attributeModelObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    dependentAttributeObjects: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    dependentAttributeModelObjects: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates whether or not an attribute object value is changed.
                     */
                    changed: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    _isInitialized: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Specifies the errors in an attribute object received from the server.
                     */
                    serverErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Specifies the errors that are raised after validating the attribute object value.
                     */
                    validationErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        reflectToAttribute: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Indicates all server errors and validation errors of attribute object value.
                     */
                    errors: {
                        type: Array,
                        notify: true,
                        reflectToAttribute: true,
                        computed: '_getAllErrors(serverErrors,validationErrors)'
                    },
                    /**
                     * Specifies the length of the error message.
                     */
                    errorLength: {
                        type: Number,
                        notify: true,
                        value: 0
                    },
                    /**
                     * Specifies the error message to be shown.
                     */
                    errorMessage: {
                        type: String,
                        notify: true,
                        computed: '_getErrorMessage(errors)'
                    },
                    /**
                     * Indicates the functional mode of the attribute object.
                     */
                    functionalMode: {
                        type: String,
                        notify: true,
                        value: "list"
                    },
                    _isGridType: {
                        type: Boolean,
                        notify: true,
                        computed: '_isGrid(functionalMode)'
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i>
                     */
                    tabindex: {
                        type: Number
                    },
                    showDeleteIcon: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Indicates whether to disable the floating label or not.
                     * Set the value as <b>true</b> to disable the floating label.
                     */
                    noLabelFloat: {
                        type: Boolean,
                        value: true
                    },

                    _fallbackList: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _contextCoalescePathList: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    }
                },
                observers: [
                    '_attributeObjectChanged(attributeObject.*)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                FALLBACK_PATH_DELIMITER: ">>",
                addValidationErrors: function (errorMessage) {
                    var validationErrors = this.validationErrors;
                    if (validationErrors.indexOf(errorMessage) == -1) {
                        validationErrors.push(errorMessage);
                    }
                    this.validationErrors = [];
                    this.validationErrors = validationErrors;
                },
                removeValidationErrorsAt: function (index) {
                    var validationErrors = this.validationErrors;
                    validationErrors.splice(index, 1);
                    this.validationErrors = [];
                    this.validationErrors = validationErrors;
                },
                _formatValue: function (model, object) {
                    if (model &&
                        model.dataType &&
                        (model.dataType.toLowerCase() == "date" ||
                            model.dataType.toLowerCase() == "datetime")) {
                        return FormatHelper.convertFromISODateTime(object.value, model.dataType, model.dateFormat);
                    }

                    return object.value;
                },
                _isEditMode: function (mode) {
                    return mode === "edit";
                },
                _isAttributeEditable: function (attributeModelObject) {
                    return attributeModelObject.hasWritePermission && !attributeModelObject.readOnly;
                },
                _isComponentEditable: function (mode, attributeModelObject) {
                    return mode === "edit" && attributeModelObject.hasWritePermission && !attributeModelObject.readOnly;
                },
                _onChange: function (event) {
                    //todo: this is not working right now, have to find out how to propagate change event up the control hierarchy
                    if (this.shadowRoot) {
                        this.dispatchEvent(new CustomEvent(event.type, {
                            detail: {
                                sourceEvent: event
                            },
                            node: this,
                            cancelable: event.cancelable,
                            bubbles: event.bubbles,
                            composed: true
                        }));
                    }
                },
                _isTextBox: function (model) {
                    //If display type is not supported then also textbox is used
                    var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
                    return displayType === "textbox" && !model.isCollection ||
                        (!this._isTextArea(model) && !this._isDropDown(model) &&
                            !this._isBoolean(model) && !this._isDate(model) &&
                            !this._isDateTime(model) && !this._isTextboxCollection(model) &&
                            !this._isLOV(model) && !this._isRichTextEditor(model)) && !this._isNested(model);
                },
                _isTextArea: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textarea";
                },
                _isRichTextEditor: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "richtexteditor";
                },
                _isLOVSingleValued: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && !model.isCollection;
                },
                _isLOV: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist";
                },
                _isLOVCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && model.isCollection;
                },
                _isDropDown: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "dropdown";
                },
                _isBoolean: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "boolean";
                },
                _isDate: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "date";
                },
                _isDateTime: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "datetime";
                },
                _isTextboxCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textbox" && model.isCollection;
                },
                _useDefaultReadMode: function (model) {
                    var displayType = model.displayType ? model.displayType.toLowerCase() : "";
                    return !(model.isCollection || displayType === "referencelist" || displayType === "richtexteditor" || displayType === "nestedgrid");
                },
                _isCollection: function (model) {
                    return model.isCollection;
                },
                _isGridOrNested: function (model) {
                    return (this._isNested(model) || this._isGridType);
                },
                _isNested: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "nestedgrid";
                },
                _onEditClick: function (e) {
                    if (e.currentTarget.disabled == true) {
                        return;
                    }
                    this.mode = "edit";
                },
                getControlIsDirty: function () {
                    if (this.mode == "edit") {
                        return true;
                    }
                    return false;
                },
                _attributeObjectChanged: function (changeRecord) {
                    if (this.attributeObject.value && this.attributeObject.action) {
                        var isCollection = this.attributeModelObject && this.attributeModelObject.isCollection ? true : false;
                        if (!isCollection || (isCollection && this.attributeObject.value.length > 0)) {
                            delete this.attributeObject.action;
                        }
                    }
                    if (this._isInitialized && changeRecord.path != "attributeObject" && changeRecord.path != "attributeObject.errors") {
                        this.changed = true;
                        this.dispatchEvent(new CustomEvent("attribute-value-changed", { detail: this.attributeObject, bubbles: true, composed: true }));
                        //console.log("newValue after ready " + JSON.stringify(newValue));
                    }
                    this._fallbackList = this._getFallbackPath();
                    this._contextCoalescePathList = this.attributeObject.contextCoalescePaths;
                    this._updateMarkerClass();
                },
                _getAttributeEditClass: function (changed) {
                    if (changed) {
                        return 'attribute-edit attribute-edit-changed';
                    } else {
                        return 'attribute-edit';
                    }
                },
                _onRevertClick: function (e) {
                    this.attributeObject = this._cloneObject(this.originalAttributeObject); //can't assign directly, its by ref - thus using cloning
                    this.dispatchEvent(new CustomEvent("attribute-value-changed", { detail: { revertClicked: true }, bubbles: true, composed: true }));
                    this.changed = false;
                },
                _onClearClick: function (e) {
                    var setValue = this.attributeModelObject && this.attributeModelObject.isCollection ? [] : "";
                    this.set("attributeObject.value", setValue);
                    this.set("attributeObject.referenceDataId", setValue);
                    this.set("attributeObject.action", "delete");
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                _onTimeClick: function () {
                    var eventDetail = {
                        data: this.attributeModelObject,
                        name: "dimension-grid-open"
                    }

                    this.fireBedrockEvent("dimension-grid-open", eventDetail, {
                        ignoreId: true
                    });
                },
                _onSourceInformationClick: function (e) {
                    var sourceInformation = this.$$("#view-source-information-popover");
                    if (sourceInformation) {
                        sourceInformation.show();
                    }
                    e.stopPropagation();
                },
                _showPicker: function (e) {
                    var pickerId = e.target.getAttribute('picker-id');
                    if (pickerId) {
                        var picker = this.shadowRoot.querySelector("#" + pickerId);
                        if (picker) {
                            picker.show();
                        } else {
                            alert('picker with picker-id ' + pickerId + ' not found');
                        }
                    } else {
                        alert('picker-id attribute not found on target.');
                    }
                },
                _getAllErrors: function (serverErrors, validationErrors) {
                    return serverErrors.concat(validationErrors);
                },
                _getErrorMessage: function (errors) {
                    if (errors.length) {
                        return this.errors[0];
                    }
                },
                /**
                 * <b><i>Content development is under progress... </b></i>
                 */
                hasModelErrors: function () {
                    return this.validationErrors && this.validationErrors.length > 0;
                },
                _errorsChanged: function () {
                    if (this.serverErrors && this.validationErrors) {
                        this.errorLength = this.serverErrors.length + this.validationErrors.length;
                    }
                },
                _errorAbsent: function (errors) {
                    if (this._isGridType) {
                        return true;
                    }
                    return errors.length == 0;
                },
                _errorTapped: function () {
                    this.$.errorPopover.positionTarget = this.shadowRoot.querySelector('#error-circle');
                    this.$.errorPopover.open();
                },
                _fixError: function () {
                    this._onEditClick();
                    this.$.errorPopover.close();
                },
                _isGrid: function (functionalMode) {
                    return functionalMode == "grid";
                },
                _rteLinkHovered: function (e) {
                    this.shadowRoot.querySelector('#rtePopover').show();
                },
                _rteEditLinkTapped: function (e) {
                    this.shadowRoot.querySelector('#rteSingleEdit').open();
                },
                _nestedAttributeLinkTapped: function (e) {
                    this.shadowRoot.querySelector('#nestedAttributeModal').open();
                },
                //TODO: this did not work for entityTypes, need to check why
                _prepareRequestObjectForLov: function (attributeModel, dependentAttributeObjects) {
                    var refEntityTypes = [];

                    //find from manage model, looks like this:
                    // "referenceEntityInfo": [
                    //                     {
                    //                         "refRelationshipName": "hasReferenceTo",
                    //                         "refEntityType": "color"
                    //                     }
                    //                  ]
                    if (attributeModel.referenceEntityInfo) {
                        for (let i = 0; i < attributeModel.referenceEntityInfo.length; i++) {
                            var refEntityInfo = attributeModel.referenceEntityInfo[i];
                            if (refEntityInfo.refRelationshipName == 'hasReferenceTo' && refEntityInfo.refEntityType) {
                                refEntityTypes.push(refEntityInfo.refEntityType);
                            }
                        }
                    }

                    var relationshipsCriterion = [];
                    var dependencyInfo = attributeModel.dependencyInfo;
                    if (!DataHelper.isEmptyObject(dependencyInfo) && !DataHelper.isEmptyObject(this.dependentAttributeObjects) && !DataHelper.isEmptyObject(this.dependentAttributeModelObjects)) {
                        for (let i = 0; i < dependencyInfo.length; i++) {
                            var dependentAttrInfo = dependencyInfo[i];
                            var dependentAttributeModelObject = this.dependentAttributeModelObjects.find(attrModel => attrModel.name === dependentAttrInfo.dependentOn)
                            var dependentAttributeObject = this.dependentAttributeObjects.find(attr => attr.name === dependentAttrInfo.dependentOn)

                            if (dependentAttributeObject && dependentAttributeObject.value && dependentAttributeObject.value.length && dependentAttributeObject.action !== "delete") {
                                var relCriteria = this._prepareRelationshipCriterion(dependentAttrInfo.dependencyRelationship, dependentAttributeObject.referenceDataId, dependentAttributeModelObject.referenceEntityTypes[0]);
                                relationshipsCriterion.push(relCriteria);
                            }
                        }
                    }

                    var clonedContextData = DataHelper.cloneObject(this.contextData);

                    var itemContext = {
                        'type': refEntityTypes,
                        'relationshipsCriterion': relationshipsCriterion
                    };

                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    var requestData = DataRequestHelper.createEntityGetRequest(clonedContextData);
                    var referenceDataId = this.attributeObject.referenceDataId;
                    if (referenceDataId && referenceDataId.length > 0) {
                        requestData.params.additionalIds = attributeModel.isCollection ? referenceDataId : [referenceDataId];
                    }
                    return requestData;
                },
                _prepareRelationshipCriterion: function (relName, relToId, relToType) {
                    relToId = relToId || "";
                    var relCriteria = {};
                    relCriteria[relName] = {
                        "relTo": {}
                    };
                    if (typeof relToId == Array) {
                        relCriteria[relName].relTo.ids = relToId;
                    } else {
                        relCriteria[relName].relTo.id = relToId;
                    }
                    relCriteria[relName].relTo.type = relToType;
                    return relCriteria
                },

                _getMappedColumn: function (columName, attributeModelObject) {
                    if (columName && attributeModelObject) {
                        if (attributeModelObject.referenceEntityInfo) {
                            for (var i = 0; i < attributeModelObject.referenceEntityInfo.length; i++) {
                                var refEntityInfo = attributeModelObject.referenceEntityInfo[i];
                                if (refEntityInfo.refRelationshipName == 'hasReferenceTo') {

                                    var columNameToReturn;
                                    columName = columName.toLowerCase();

                                    if (columName == "id") {
                                        // Id is mandatory for Lov.
                                        // Hence if pattern for Id not available then set entity.id
                                        columNameToReturn = refEntityInfo.id;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "entity.id";
                                        }
                                    }

                                    if (columName == "title") {
                                        // Default fallback to Name, otherwise it will show empty values
                                        columNameToReturn = refEntityInfo.listTitle;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "{entity.name}";
                                        }
                                    }

                                    if (columName == "subtitle") {
                                        columNameToReturn = refEntityInfo.listSubTitle;
                                    }

                                    if (columName == "image") {
                                        columNameToReturn = refEntityInfo.image;
                                    }
                                    if (columName == "imageid") {
                                        columNameToReturn = refEntityInfo.thumbnail;
                                        if (!columNameToReturn || columNameToReturn.toLowerCase() === "none") {
                                            columNameToReturn = "";
                                        }
                                    }

                                    if (columName == "color") {
                                        columNameToReturn = refEntityInfo.color;
                                    }

                                    if (columName == "value") {
                                        //refEntityInfo.value = "referencedatavalue";
                                        columNameToReturn = refEntityInfo.listValueAttribute;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "entity.name";
                                        }
                                    }

                                    return columNameToReturn;
                                }
                            }
                        }
                    }
                },
                _hasValue: function (value) {
                    if (value) {
                        return true;
                    } else {
                        return false;
                    }
                },
                _getLabel: function (label) {
                    if (this._isGridType) {
                        return "";
                    } else {
                        return label;
                    }
                },
                _onDeleteClick: function (e) {
                    this.fireBedrockEvent("attribute-delete", { data: this.attributeModelObject }, { ignoreId: true });
                },
                _onTagItemRemoved: function (e) {
                    // Note:- In a scenario where attribute is of type Reference List and is Non Collection then,
                    //        removing a tag should perform the same action what the component is performing when
                    //        user clicks on clear Icon
                    var isCollection = this.attributeModelObject && this.attributeModelObject.isCollection ? true : false;
                    if (!isCollection || (isCollection && this.attributeObject && _.isEmpty(this.attributeObject.value))) {
                        this._onClearClick(e);
                    }
                },
                _updateMarkerClass: function () {
                    var root = this.root && this.root.host;
                    if (!root) return;
                    if (this._hasFallbackValue()) {
                        root.classList.add('fallback-value');
                    } else {
                        root.classList.remove('fallback-value');
                    }

                    if (this._hasContextCoalescedValue()) {
                        root.classList.add('coalesced-value');
                    } else {
                        root.classList.remove('coalesced-value');
                    }
                },
                _hasFallbackValue: function () {
                    return !!(this.attributeModelObject && this.attributeModelObject.isLocalizable &&
                        this.attributeObject.properties && this.attributeObject.properties.localeCoalescePath);
                },
                _hasContextCoalescedValue: function () {
                    return this.attributeObject.contextCoalescePaths && this.attributeObject.contextCoalescePaths.length;
                },
                _getFallbackPath: function () {
                    const { properties } = this.attributeObject;
                    const localeCoalescePath = properties && properties.localeCoalescePath;
                    if (localeCoalescePath) {
                        return localeCoalescePath.split(this.FALLBACK_PATH_DELIMITER);
                    }
                    return [];
                },
                _getDescriptionObject: function () {
                    if (!this.attributeModelObject.isNestedChild) {
                        return this.attributeModelObject.properties;
                    }
                },
                _showSourceInfo: function () {
                    return this._hasFallbackValue() || this._hasContextCoalescedValue();
                }
            });
        })();
    </script>
</dom-module>