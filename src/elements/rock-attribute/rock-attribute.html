<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/paper-icon-button/paper-icon-button.html">
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-dropdown/pebble-dropdown.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="pebble-error-list.html">
<!--
`rock-attribute`
Represents the attribute component in the framework. It takes parameters to know the details of the attribute and renders appropriate UI elements to manage an attribute value.
@demo demo/index.html 
-->
<dom-module id="rock-attribute">
	<template>
		<style include="pebble-styles-shared">
			.attribute {
				@apply(--layout-horizontal);
				@apply(--layout-center-center);
			}

			.attribute-main {
				padding-bottom: 10px;
				width: 80%;
			}

			.attribute-view {
				clear: both;
				border-bottom: 1px solid var(--color-steal-grey);
				margin-bottom: 2px;
			}

			.attribute-view-label {
				font-size: 12px;
				font-weight: normal;
				font-style: normal;
				font-stretch: normal;
				line-height: 1.42;
				text-transform: uppercase;
				color: var(--color-steal-grey);
			}

			.attribute-view-value {
				font-size: var(--default-font-size);
			}

			.attribute-icons {
				height: 32px;
			}

			.attribute-icons paper-icon-button {
				float: right;
				width: 32px;
				color: var(--color-steal-grey);
			}

			.attribute paper-icon-button {
				width: 32px;
				height: 32px;
				color: var(--color-steal-grey);
				top: 10px;
			}

			.attribute-edit {
				background-color: white;
			}

			.attribute-edit-changed {
				background-color: #EDF8FE !important;
			}
			.error  {
				color: var(--error-color, rgba(251, 96, 103, 1));
				font-size: 12px;
				font-weight: 400;
				letter-spacing: 0.011em;
				line-height: 20px;
				width: 85%;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
				display: inline-block;
			}
			.error-circle {
				height: 18px;
				width: 18px;
				line-height:18px;
				text-align: center;
				border-radius: 50%;
				background: var(--error-color);
				font-size: 9px;
				float: right;
			}
		</style>
		<div class="attribute" name$="[[attributeModelObject.name]]">
			<div class="attribute-main">
				<div class="attribute-icons">
					<template is="dom-if" if="[[!_isEditMode(mode)]]">
						<paper-icon-button name="edit" icon="pebble-icons:Create" title="Edit" on-tap="_onEditClick" tabindex="-1"></paper-icon-button>
					</template>
					<template is="dom-if" if="[[_isEditMode(mode)]]">
						<paper-icon-button name="revert" icon="pebble-icons:Refresh" title="Revert" on-tap="_onRevertClick" tabindex="-1"></paper-icon-button>
					</template>
					<paper-icon-button name="owner" icon="pebble-icons:LowPriority" title="View ownership info" on-tap="_onOwnerClick" tabindex="-1"></paper-icon-button>
					<paper-icon-button name="time" icon="pebble-icons:AccessTime" title="Manage historical data" on-tap="_onTimeClick" tabindex="-1"></paper-icon-button>
					<paper-icon-button name="locale" icon="pebble-icons:Language" title="Manage in multiple locales" on-tap="_onLocaleClick"
						tabindex="-1"></paper-icon-button>
				</div>
					<div class$="[[_getAttributeEditClass(changed)]]" hidden="[[!_isEditMode(mode)]]">
						//hidden is used here in place of dom-if because we want the client-side validation errors to show even on read mode which won't happen if we used dom-if
						<template is="dom-if" if="[[_isTextArea(attributeModelObject.displayType)]]">
                            <pebble-textarea validation-errors="{{validationErrors}}" label="{{attributeModelObject.longName}}" value="{{attributeObject.value}}" required="[[attributeModelObject.required]]"
                                             minlength="[[attributeModelObject.minLength]]" maxlength="[[attributeModelObject.maxLength]]" pattern="[[attributeModelObject.pattern]]" precision="[[attributeModelObject.precision]]"
                                             min="[[attributeModelObject.min]]" max="[[attributeModelObject.max]]"  validation-type="[[attributeModelObject.validationType]]" validation-type-array="[[attributeModelObject.validationTypeArray]]"
                            ></pebble-textarea>
						</template>
						<template is="dom-if" if="[[_isDropDown(attributeModelObject.displayType)]]">
                            <pebble-dropdown  validation-errors="{{validationErrors}}" label="{{attributeModelObject.longName}}" items="{{attributeModelObject.allowedValues}}" selected-value="{{attributeObject.value}}"
                                             pattern="[[attributeModelObject.pattern]]"  precision="[[attributeModelObject.precision]]" required="[[attributeModelObject.required]]"
                                             min="[[attributeModelObject.min]]" max="[[attributeModelObject.max]]"  validation-type="[[attributeModelObject.validationType]]" validation-type-array="[[attributeModelObject.validationTypeArray]]"></pebble-dropdown>						</template>
						<template is="dom-if" if="[[_isBoolean(attributeModelObject.displayType)]]">
							<pebble-boolean label="{{attributeModelObject.longName}}" value="{{attributeObject.value}}"></pebble-boolean>
						</template>
						<!-- If display type is not supported then textbox is used -->
						<template is="dom-if" if="[[_isTextBox(attributeModelObject.displayType)]]">
                            <pebble-textbox validation-errors="{{validationErrors}}"
                                    label="{{attributeModelObject.longName}}" value="{{attributeObject.value}}"
                                    required="[[attributeModelObject.required]]"
                                    minlength="[[attributeModelObject.minLength]]" maxlength="[[attributeModelObject.maxLength]]"
                                    pattern="[[attributeModelObject.pattern]]" precision="[[attributeModelObject.precision]]"
                                    min="[[attributeModelObject.min]]" max="[[attributeModelObject.max]]"  validation-type="[[attributeModelObject.validationType]]" validation-type-array="[[attributeModelObject.validationTypeArray]]"
                            ></pebble-textbox>
						</template>
					</div>
				<template is="dom-if" if="[[!_isEditMode(mode)]]">
					<div class="attribute-view">
						<span class="attribute-view-label">{{attributeModelObject.longName}}:</span><br>
						<span class="attribute-view-value"> {{attributeObject.value}}</span><br>
					</div>
				</template>
				<div id="error-display" hidden="[[_errorAbsent(errors)]]" on-tap="_errorTapped">
				<span class="error">[[errorMessage]] </span>
				<span id="error-circle"  class="error-circle" >[[errorLength]]</span>
				</div>
			</div>
			<div>
				<template is="dom-if" if="[[_isEditMode(mode)]]">
					<paper-icon-button name="clear" icon="pebble-icons:Clear" title="Clear" on-tap="_onClearClick" tabindex="-1"></paper-icon-button>
				</template>
			</div>
		</div>
		<pebble-popover id="errorPopover" for="error-circle" no-overlap horizontal-align="right" >
			<pebble-error-list errors="[[errors]]"></pebble-error-list>
			<!--<template is="dom-repeat" items="{{errors}}">-->
			<!--<div>-->
			<!--[[item]]-->
			<!--</div>-->
			<!--</template>-->
		</pebble-popover>
	</template>
	<script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute',
                ready: function () {
                    //console.log('attribute ready '+this._isInitialized);
                    this._isInitialized = true;
                },
                attached: function () {
                    //console.log('attribute attached');
                },
                properties: {
                    /**
                     * Indicates whether the attribute should be rendered in edit mode or view mode.
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                    * Indicates the JSON for the attribute value object. This object records all user changes to the value.
                    * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                    */
                    attributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },
                    originalAttributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                    * Indicates the JSON for the attribute model object.
                    * It renders appropriate UI element to edit the attribute, to configure validation, and other behaviors.
                    * Sample: {
                                "name": "name",
                                "longName": "Name",
                                "displayType": "textbox",
                                "minLength": 5,
                                "maxLength": 10
                              }
                    */
                    attributeModelObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    changed: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    _isInitialized: {
                        type: Boolean,
                        value: false
                    },
					serverErrors:{
                        type:Array,
						value: function () {
							return [];
                        },
						notify:true,
                        observer:'errorsChanged'
					},
					validationErrors:{
                        type:Array,
						value: function () {
							return [];
                        },
						notify:true,
                        reflectToAttribute:true,
						observer:'errorsChanged'
					},
					errors:{
                        type:Array,
						notify:true,
						reflectToAttribute:true,
						computed:'_getAllErrors(serverErrors,validationErrors)'
					},
					errorLength:{
                        type: Number,
						notify:true,
						value:0
					},
					errorMessage:{
                        type:String,
						notify:true,
						computed:'_getErrorMessage(errors)'
					}
                },
                observers: [
                    '_attributeObjectChanged(attributeObject.*)'
                ],
                _isEditMode: function (mode) {
                    return mode === "edit";
                },
                _onChange: function (event) {
                    //todo: this is not working right now, have to find out how to propagate change event up the control hierarchy
                    if (this.shadowRoot) {
                        this.fire(event.type, {
                            sourceEvent: event
                        }, {
                            node: this,
                            bubbles: event.bubbles,
                            cancelable: event.cancelable
                        });
                    }
                },
                _isTextBox: function (displayType) {
                    //If display type is not supported then also textbox is used
                    return displayType === "textbox" ||
                        (!this._isTextArea(displayType) && !this._isDropDown(displayType) && !this._isBoolean(
                            displayType));
                },
                _isTextArea: function (displayType) {
                    return displayType === "textarea";
                },
                _isDropDown: function (displayType) {
                    return displayType === "dropdown";
                },
                _isBoolean: function (displayType) {
                    return displayType === "boolean";
                },
                _onEditClick: function (e) {
                    this.mode = "edit";
                },
                _attributeObjectChanged: function (changeRecord) {
                    if (this._isInitialized && changeRecord.path != "attributeObject") {
                        this.changed = true;
                        //console.log("newValue after ready " + JSON.stringify(newValue));
                    }
                },
                _getAttributeEditClass: function (changed) {
                    if (changed) {
                        return 'attribute-edit attribute-edit-changed';
                    } else {
                        return 'attribute-edit';
                    }
                },
                _onRevertClick: function (e) {
                    this.attributeObject = this._cloneObject(this.originalAttributeObject); //can't assign directly, its by ref - thus using cloning
                    this.changed = false;
                },
                _onClearClick: function () {
                    this.set("attributeObject.value", ""); //TODO: Need to decide how do we clear value
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                _getAllErrors: function(serverErrors,validationErrors){
                    return serverErrors.concat(validationErrors);
				},
				_getErrorMessage: function (errors) {
                    if(errors.length) {
                        return this.errors[0];
                    }
				},
                errorsChanged:function () {
                    if(this.serverErrors && this.validationErrors) {
                        this.errorLength = this.serverErrors.length + this.validationErrors.length;
                    }
                },
                _errorAbsent: function (errors) {
					return errors.length==0;
                },
                _errorTapped: function () {
                    this.$.errorPopover.positionTarget =this.$$('#error-circle');
				  this.$.errorPopover.open();
                }
            });
        })();
    </script>
</dom-module>