<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../../../bower_components/shadycss/apply-shim.html">

<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-validator/bedrock-validator.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">

<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-dropdown/pebble-dropdown.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-date-picker/pebble-date-picker.html">
<link rel="import" href="../pebble-datetime-picker/pebble-datetime-picker.html">
<link rel="import" href="../pebble-styles-shared/pebble-styles-shared.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../rock-entity-combo-box/rock-entity-combo-box.html">

<link rel="import" href="pebble-error-list.html">
<!--
`rock-attribute`
Represents the attribute component in the framework. It understands the details of the attribute from 
the parameters it has recieved and renders appropriate UI elements to manage an attribute value.
@demo demo/index.html 
-->
<dom-module id="rock-attribute">
    <template>
        <style is="custom-style" include="pebble-styles-shared">
            .attribute {
                @apply --layout-horizontal;
            }

            .attribute.list {
                @apply --layout-center-center;
                padding: 15px 10px 25px 10px;
            }

            .attribute-main {
                width: 100%;
                position: relative;
                cursor: pointer;
            }

            .attribute-icons {
                opacity: 0;
                transition: all 0.3s;
                -webkit-transition: all 0.3s;
            }

            .attribute-main:hover .attribute-icons {
                opacity: 1;
            }

            .attribute-view,
            .attribute-edit {
                clear: both;
            }

            .attribute-edit {
                --pebble-dt-default-inputarea: {
                    width: 100%;
                }
            }

            .attribute-view.grid {
                margin-top: 0;
            }

            .attribute-view.grid .attribute-view-value {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .attribute-view.grid {
                --pebble-textarea-input: {
                    max-height: 25px;
                }
            }

            .attribute-view-label {
                font-size: var(--font-size-sm, 12px);
                font-weight: normal;
                font-style: normal;
                font-stretch: normal;
                line-height: 1.42;
                text-transform: uppercase;
                color: var(--label-text-color);
            }

            .attribute-view-value {
                font-size: var(--default-font-size);
                display: inline-block;
                width: 100%;
                vertical-align: middle;
                max-height: 100px;
                overflow-y: auto;
            }

            .attribute-icons pebble-button {
                float: right;
                width: 32px;
                color: var(--primary-icon-color);
            }

            .attribute pebble-button {
                width: 18px;
                height: 18px;
                color: var(--secondary-icon-color);
                padding: 0;
                transition: all 0.3s;
                -webkit-transition: all 0.3s;
            }

            .attribute pebble-button:hover {
                color: var(--primary-icon-color, #75808b);
            }

            .datetimepicker-container {
                width: 100%;
                position: relative;
            }

            #dateTimeTriggerContainer {
                position: absolute;
                right: -11px;
                bottom: -6px;
            }

            #dateTimeTriggerContainer {
                --paper-button: {
                    min-width: auto;
                }
            }

            #error-display {
                position: absolute;
                right: 0;
                left: 0;
                bottom: -24px;
            }

            .error {
                color: var(--error-color, #ed204c);
                font-size: var(--font-size-sm, 12px);
                font-weight: var(--font-medium, 500);
                letter-spacing: 0.011em;
                line-height: 10px;
                width: 85%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                display: inline-block;
            }

            .error-circle {
                height: 18px;
                width: 18px;
                line-height: 18px;
                text-align: center;
                border-radius: 50%;
                background: var(--error-color, #ed204c);
                color: var(--palette-white, #fff);
                font-size: var(--font-size-xs, 10px);
                float: right;
                margin-top: 3px;
            }

            .text-collection-container {
                margin-top: 25px;
            }

            pebble-textbox-collection {
                --text-collection-label: {
                    font-size: 12px;
                    color: #96B0C5;
                }

                --text-collection-manage-tag-container: {
                    height: 65px;
                }
            }

            .close-item {
                position: absolute;
                top: 30px;
                right: -30px;
            }
        </style>
        <div class$="attribute [[functionalMode]]">
            <div class="attribute-main">
                <div class="attribute-icons" hidden$="[[_isGridType]]">
                    <template is="dom-if" if="[[!_isEditMode(mode)]]">
                        <pebble-button name="edit" class="pebble-md-icons m-l-5 tooltip-bottom" icon="pebble-md-icons:Edit" data-tooltip="Edit" on-tap="_onEditClick"
                            tabindex="-1"></pebble-button>
                    </template>
                    <template is="dom-if" if="[[_isEditMode(mode)]]">
                        <template is="dom-if" if="[[_hasValue(attributeObject.value)]]">
                            <pebble-button name="clear" class="pebble-md-icons m-l-5 tooltip-bottom close-item" icon="pebble-md-icons:Clear" data-tooltip="Clear value"
                                on-tap="_onClearClick" tabindex="-1"></pebble-button>
                        </template>
                        <pebble-button name="revert" class="pebble-md-icons m-l-5 tooltip-bottom" icon="pebble-md-icons:ToolbarRefresh" data-tooltip="Revert"
                            on-tap="_onRevertClick" tabindex="-1"></pebble-button>
                    </template>
                    <pebble-button name="owner" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:LowPriority" data-tooltip="View ownership info"
                        on-tap="_onOwnerClick" tabindex="-1"></pebble-button>
                    <pebble-button name="time" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:AccessTime" data-tooltip="Manage historical data"
                        on-tap="_onTimeClick" tabindex="-1"></pebble-button>
                    <pebble-button name="locale" class="pebble-md-icons m-r-5 m-l-5 tooltip-bottom" icon="pebble-md-icons:Language" data-tooltip="Manage in multiple locales"
                        on-tap="_onLocaleClick" tabindex="-1"></pebble-button>
                    <div class="clearfix"></div>
                </div>
                <template is="dom-if" if="[[_isEditMode(mode)]]">
                    <div class$="[[_getAttributeEditClass(changed)]]">
                        <!-- LOV -->
                        <!-- TEXTAREA -->
                        <template is="dom-if" if="[[_isTextArea(attributeModelObject)]]">
                            <pebble-textarea id="input" validation-errors="{{validationErrors}}" label="{{_getLabel(attributeModelObject.externalName)}}"
                                value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]" invalid="{{invalid}}"
                                tabindex="[[tabindex]]"></pebble-textarea>
                        </template>
                        <!-- DROPDOWN -->
                        <template is="dom-if" if="[[_isDropDown(attributeModelObject)]]">
                            <pebble-dropdown id="input" label="{{_getLabel(attributeModelObject.externalName)}}" items="{{attributeModelObject.allowedValues}}"
                                selected-value="{{attributeObject.value}}" invalid="{{invalid}}" tabindex="[[tabindex]]">
                            </pebble-dropdown>
                        </template>
                        <!-- BOOLEAN -->
                        <template is="dom-if" if="[[_isBoolean(attributeModelObject)]]">
                            <pebble-boolean id="input" label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" invalid="{{invalid}}"
                                true-text="[[_isNullOrEmpty(attributeModelObject.trueText, 'TRUE')]]" false-text="[[_isNullOrEmpty(attributeModelObject.falseText,'FALSE')]]"
                                tabindex="[[tabindex]]">
                            </pebble-boolean>
                        </template>
                        <!-- DATE -->
                        <template is="dom-if" if="[[_isDate(attributeModelObject)]]">
                            <pebble-datetime-picker id="datePicker" label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}"
                                picker-type="date" tabindex="[[tabindex]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- DATETIME -->
                        <template is="dom-if" if="[[_isDateTime(attributeModelObject)]]">
                            <pebble-datetime-picker id="dateTimePicker" label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}"
                                picker-type="datetime" tabindex="[[tabindex]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- TEXTBOX-COLLECTION -->
                        <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                            <div class="text-collection-container">
                                <pebble-textbox-collection label="{{_getLabel(attributeModelObject.externalName)}}" id="txtCollection" values="{{attributeObject.value}}"
                                    tabindex="[[tabindex]]">
                                </pebble-textbox-collection>
                            </div>
                        </template>
                        <!-- If display type is not supported then textbox is used -->
                        <!-- TEXTBOX -->
                        <template is="dom-if" if="[[_isTextBox(attributeModelObject)]]">
                            <pebble-textbox id="input" label="{{_getLabel(attributeModelObject.externalName)}}" value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]"
                                invalid="{{invalid}}" tabindex="[[tabindex]]"></pebble-textbox>
                        </template>
                    </div>
                </template>
                <template is="dom-if" if="[[!_isEditMode(mode)]]">
                    <template is="dom-if" if="[[!_isCollectionOrLOV(attributeModelObject)]]">
                        <div class$="attribute-view [[functionalMode]]">
                            <span hidden="[[_isGridType]]">
                                <span class="attribute-view-label">{{attributeModelObject.externalName}}:</span><br>
                            </span>
                            <span class="attribute-view-value">{{_formatValue(attributeModelObject, attributeObject)}}</span><br>
                        </div>
                    </template>
                    <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                        <div class="text-collection-container">
                            <pebble-textbox-collection id="txtCollection" label="{{_getLabel(attributeModelObject.externalName)}}" values="{{attributeObject.value}}"
                                is-readonly></pebble-textbox-collection>
                        </div>
                    </template>
                </template>
                <template is="dom-if" if="[[_isLOV(attributeModelObject)]]">
                    <template is="dom-if" if="[[_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="multi-select-combo-box-readonly" id-field="[[_getMappedColumn('id', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            label="[[_getLabel(attributeModelObject.externalName)]]" multi-select is-readonly="[[!_isEditMode(mode)]]"
                            request-data='[[_prepareRequestObjectForLov(attributeModelObject)]]' selected-ids="{{attributeObject.value}}"
                            tabindex="[[tabindex]]" context-data="[[contextData]]">
                        </rock-entity-combo-box>
                    </template>
                    <template is="dom-if" if="[[!_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="combo-box-readonly" id-field="[[_getMappedColumn('id', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            label="[[_getLabel(attributeModelObject.externalName)]]" is-readonly="[[!_isEditMode(mode)]]" request-data='[[_prepareRequestObjectForLov(attributeModelObject)]]'
                            selected-id="{{attributeObject.value}}" tabindex="[[tabindex]]" context-data="[[contextData]]">
                        </rock-entity-combo-box>
                    </template>
                </template>
                <bedrock-validator validation-errors="{{validationErrors}}" input="[[attributeObject.value]]" input-data-type="[[attributeModelObject.dataType]]"
                    pattern="[[attributeModelObject.pattern]]" min-length="[[attributeModelObject.minLength]]" max-length="[[attributeModelObject.maxLength]]"
                    precision="[[attributeModelObject.precision]]" required="[[attributeModelObject.required]]" invalid="{{invalid}}"
                    min="[[attributeModelObject.rangeFrom]]" max="[[attributeModelObject.rangeTo]]" date-format="[[attributeModelObject.dateFormat]]"
                    min-inclusive="[[attributeModelObject.isRangeFromInclusive]]" max-inclusive="[[attributeModelObject.isRangeToInclusive]]"
                    type="[[attributeModelObject.validationType]]" type-array="[[attributeModelObject.validationTypeArray]]"></bedrock-validator>
                <div id="error-display" hidden="[[_errorAbsent(errors)]]" on-tap="_errorTapped">
                    <span class="error">[[errorMessage]] </span>
                    <span id="error-circle" class="error-circle">[[errorLength]]</span>
                </div>
            </div>
            <!-- <div>
                    <template is="dom-if" if="[[_isEditMode(mode)]]">
                        <paper-icon-button name="clear" icon="pebble-icons:Clear" title="Clear" on-tap="_onClearClick" tabindex="-1"></paper-icon-button>
                    </template>
                </div> -->
        </div>
        <pebble-popover id="errorPopover" class="p-10" for="error-circle" no-overlap horizontal-align="right">
            <pebble-error-list id="attrErrorList" errors="[[errors]]"></pebble-error-list>
        </pebble-popover>
        <bedrock-pubsub target-id="attrErrorList" event-name="fix-error" handler="_fixError"></bedrock-pubsub>

    </template>
    <script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute',
                ready: function () {
                    //console.log('attribute ready '+this._isInitialized);
                    this._isInitialized = true;
                },
                attached: function () {
                    //console.log('attribute attached');
                },
                properties: {
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates whether the attribute is rendered in edit mode or view mode.
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                    * Indicates the JSON for the attribute value object. This object records all the user changes to the value.
                    * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                    */
                    attributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },
                    /**
                    * Indicates the JSON for the original attribute value object. This object does not record all the user changes to the value.
                    * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                    */
                    originalAttributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                    * Indicates the JSON for the attribute model object.
                    * It renders appropriate UI element to edit the attribute, to configure the validation, and other behaviors.
                    * Sample: {
                                "name": "name",
                                "externalName": "Name",
                                "displayType": "textbox",
                                "minLength": 5,
                                "maxLength": 10
                              }
                    */
                    attributeModelObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates whether or not an attribute object value is changed.
                     */
                    changed: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    _isInitialized: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Specifies the errors in an attribute object received from the server.
                     */
                    serverErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Specifies the errors that are raised after validating the attribute object value.
                     */
                    validationErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        reflectToAttribute: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Indicates all server errors and validation errors of attribute object value.
                     */
                    errors: {
                        type: Array,
                        notify: true,
                        reflectToAttribute: true,
                        computed: '_getAllErrors(serverErrors,validationErrors)'
                    },
                    /**
                     * Specifies the length of the error message.
                     */
                    errorLength: {
                        type: Number,
                        notify: true,
                        value: 0
                    },
                    /**
                     * Specifies the error message to be shown.
                     */
                    errorMessage: {
                        type: String,
                        notify: true,
                        computed: '_getErrorMessage(errors)'
                    },
                    /**
                     * Indicates the functional mode of the attribute object.
                     */
                    functionalMode: {
                        type: String,
                        notify: true,
                        value: "list"
                    },
                    _isGridType: {
                        type: Boolean,
                        notify: true,
                        computed: '_isGrid(functionalMode)'
                    },
                    /**
                      * <b><i>Content development is under progress... </b></i> 
                      */
                    tabindex: {
                        type: Number
                    }
                },
                observers: [
                    '_attributeObjectChanged(attributeObject.*)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                _formatValue: function (model, object) {
                    if (model &&
                        model.dataType &&
                        (model.dataType.toLowerCase() == "date" ||
                            model.dataType.toLowerCase() == "datetime")) {
                        return FormatHelper.convertFromISODateTime(object.value, model.dataType, model.dateFormat);
                    }

                    return object.value;
                },
                _isEditMode: function (mode) {
                    return mode === "edit";
                },
                _onChange: function (event) {
                    //todo: this is not working right now, have to find out how to propagate change event up the control hierarchy
                    if (this.shadowRoot) {
                        this.fire(event.type, {
                            sourceEvent: event
                        }, {
                                node: this,
                                bubbles: event.bubbles,
                                cancelable: event.cancelable
                            });
                    }
                },
                _isTextBox: function (model) {
                    //If display type is not supported then also textbox is used
                    var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
                    return displayType === "textbox" && !model.isCollection ||
                        (!this._isTextArea(model) && !this._isDropDown(model) &&
                            !this._isBoolean(model) && !this._isDate(model) &&
                            !this._isDateTime(model) && !this._isTextboxCollection(model) &&
                            !this._isLOV(model));
                },
                _isTextArea: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textarea";
                },
                _isLOVSingleValued: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && !model.isCollection;
                },
                _isLOV: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist";
                },
                _isLOVCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && model.isCollection;
                },
                _isDropDown: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "dropdown";
                },
                _isBoolean: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "boolean";
                },
                _isDate: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "date";
                },
                _isDateTime: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "datetime";
                },
                _isTextboxCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textbox" && model.isCollection;
                },
                _isCollectionOrLOV: function (model) {
                    return model.isCollection || (model.displayType && model.displayType.toLowerCase() === "referencelist");
                },
                _isCollection: function (model) {
                    return model.isCollection;
                },
                _onEditClick: function (e) {
                    this.mode = "edit";
                },
                _attributeObjectChanged: function (changeRecord) {
                    if (changeRecord != undefined) {
                        if (this.attributeObject.value && this.attributeObject.action) {
                            delete this.attributeObject.action;
                        }
                        if (this._isInitialized && changeRecord.path != "attributeObject" && changeRecord.path !=
                            "attributeObject.errors") {
                            this.changed = true;
                            this.fire("attribute-value-changed", changeRecord.value);
                            //console.log("newValue after ready " + JSON.stringify(newValue));
                        }
                    }
                },
                _getAttributeEditClass: function (changed) {
                    if (changed) {
                        return 'attribute-edit attribute-edit-changed';
                    } else {
                        return 'attribute-edit';
                    }
                },
                _onRevertClick: function (e) {
                    this.attributeObject = this._cloneObject(this.originalAttributeObject); //can't assign directly, its by ref - thus using cloning
                    this.changed = false;
                },
                _onClearClick: function () {
                    this.set("attributeObject.value", "");
                    this.set("attributeObject.action", "delete");
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                _onTimeClick: function () {
                    var eventDetail = {
                        data: this.attributeModelObject,
                        name: "dimension-grid-open"
                    }

                    this.fireBedrockEvent("dimension-grid-open", eventDetail, {
                        ignoreId: true
                    });
                },
                _showPicker: function (e) {
                    var pickerId = e.target.getAttribute('picker-id');
                    if (pickerId) {
                        var picker = this.shadowRoot.querySelector("#" + pickerId);
                        if (picker) {
                            picker.show();
                        } else {
                            alert('picker with picker-id ' + pickerId + ' not found');
                        }
                    } else {
                        alert('picker-id attribute not found on target.');
                    }
                },
                _getAllErrors: function (serverErrors, validationErrors) {
                    return serverErrors.concat(validationErrors);
                },
                _getErrorMessage: function (errors) {
                    if (errors.length) {
                        return this.errors[0];
                    }
                },
                /**
                  * <b><i>Content development is under progress... </b></i> 
                  */
                hasModelErrors: function () {
                    return this.validationErrors && this.validationErrors.length > 0;
                },
                _errorsChanged: function () {
                    if (this.serverErrors && this.validationErrors) {
                        this.errorLength = this.serverErrors.length + this.validationErrors.length;
                    }
                },
                _errorAbsent: function (errors) {
                    if (this._isGridType) {
                        return true;
                    }
                    return errors.length == 0;
                },
                _errorTapped: function () {
                    this.$.errorPopover.positionTarget = this.shadowRoot.querySelector('#error-circle');
                    this.$.errorPopover.open();
                },
                _fixError: function () {
                    this._onEditClick();
                    this.$.errorPopover.close();
                },
                _isGrid: function (functionalMode) {
                    return functionalMode == "grid";
                },
                //TODO: this did not work for entityTypes, need to check why
                _prepareRequestObjectForLov: function (attributeModel) {
                    var refEntityTypes = [];

                    //find from manage model, looks like this:
                    // "referenceEntityInfo": [
                    //                     {
                    //                         "refRelationshipName": "hasReferenceTo",
                    //                         "refEntityType": "color"
                    //                     }
                    //                  ]
                    if (attributeModel.referenceEntityInfo) {
                        for (var i = 0; i < attributeModel.referenceEntityInfo.length; i++) {
                            var refEntityInfo = attributeModel.referenceEntityInfo[i];
                            if (refEntityInfo.refRelationshipName == 'hasReferenceTo' && refEntityInfo.refEntityType) {
                                refEntityTypes.push(refEntityInfo.refEntityType);
                            }
                        }
                    }

                    var clonedContextData = DataHelper.cloneObject(this.contextData);
                    clonedContextData[ContextHelper.CONTEXT_TYPE_DATA] = [];

                    var itemContext = {
                        'type': refEntityTypes
                    };

                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    return DataRequestHelper.createEntityGetRequest(clonedContextData);
                },
                _getMappedColumn: function (columName, attributeModelObject) {
                    if (columName && attributeModelObject) {
                        if (attributeModelObject.referenceEntityInfo) {
                            for (var i = 0; i < attributeModelObject.referenceEntityInfo.length; i++) {
                                var refEntityInfo = attributeModelObject.referenceEntityInfo[i];
                                if (refEntityInfo.refRelationshipName == 'hasReferenceTo') {

                                    var columNameToReturn;
                                    columName = columName.toLowerCase();

                                    if (columName == "id") {
                                        // Id is mandatory for Lov.
                                        // Hence if pattern for Id not available then set entity.name
                                        columNameToReturn = refEntityInfo.id;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "entity.name";
                                        }
                                    }

                                    if (columName == "title") {
                                        // Default fallback to Name, otherwise it will show empty values
                                        columNameToReturn = refEntityInfo.listTitle;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "{entity.name}";
                                        }
                                    }

                                    if (columName == "subtitle") {
                                        columNameToReturn = refEntityInfo.listSubTitle;
                                    }

                                    if (columName == "image") {
                                        columNameToReturn = refEntityInfo.image;
                                    }

                                    if (columName == "color") {
                                        columNameToReturn = refEntityInfo.color;
                                    }

                                    // To Remove above code?
                                    // var columNameToReturn = refEntityInfo[columName.toLowerCase()];
                                    // if(DataHelper.isEmptyObject(columNameToReturn) && columName == "id") {
                                    //     // Id is mandatory for Lov.
                                    //     // Hence if pattern for Id not available then set entity.name
                                    //     columNameToReturn = "entity.name";
                                    // }
                                    return columNameToReturn;
                                }
                            }
                        }
                    }
                },
                _hasValue: function (value) {
                    if (value) {
                        return true;
                    } else {
                        return false;
                    }
                },
                _getLabel: function (label) {
                    if (this._isGridType) {
                        return "";
                    } else {
                        return label;
                    }
                }
            });
        })();
    </script>
</dom-module>