<link rel="import" href="../../../bower_components/polymer/polymer.html">
<link rel="import" href="../../../bower_components/iron-flex-layout/iron-flex-layout.html">


<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-ui-behavior/bedrock-ui-behavior.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">
<link rel="import" href="../bedrock-validator/bedrock-validator.html">
<link rel="import" href="../bedrock-helpers/format-helper.html">

<link rel="import" href="../pebble-textbox/pebble-textbox.html">
<link rel="import" href="../pebble-textbox-collection/pebble-textbox-collection.html">
<link rel="import" href="../pebble-textarea/pebble-textarea.html">
<link rel="import" href="../pebble-richtexteditor/pebble-richtexteditor.html">
<link rel="import" href="../pebble-dropdown/pebble-dropdown.html">
<link rel="import" href="../pebble-boolean/pebble-boolean.html">
<link rel="import" href="../pebble-button/pebble-button.html">
<link rel="import" href="../pebble-date-picker/pebble-date-picker.html">
<link rel="import" href="../pebble-datetime-picker/pebble-datetime-picker.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-style-common.html">
<link rel="import" href="../bedrock-style-manager/styles/bedrock-styles-scroll-bar.html">
<link rel="import" href="../pebble-icons/pebble-icons.html">
<link rel="import" href="../pebble-icon/pebble-icon.html">
<link rel="import" href="../pebble-popover/pebble-popover.html">
<link rel="import" href="../pebble-dialog/pebble-dialog.html">
<link rel="import" href="../pebble-info-icon/pebble-info-icon.html">
<link rel="import" href="../rock-entity-combo-box/rock-entity-combo-box.html">
<link rel="import" href="../rock-nested-attribute-grid/rock-nested-attribute-grid.html">

<link rel="import" href="pebble-error-list.html">
<!--
`rock-attribute`
Represents the attribute component in the framework. It understands the details of the attribute from 
the parameters it has recieved and renders appropriate UI elements to manage an attribute value.
@demo demo/index.html 
-->
<dom-module id="rock-attribute">
    <template>
        <style include="bedrock-style-common bedrock-styles-scroll-bar">
            :host(.fallback-value) {
                --locale-coalesce-marker: {
                    color: var(--color-variant-1);
                };                
            }

            :host([changed]) .attribute{
                background-color: var(--edit-attribute-bgcolor) !important;                
            }

            .attribute {
                @apply --layout-horizontal;
                --pebble-grid-container: {
                    background-color: var(--palette-white, #ffffff);
                    margin-left: 0;
				    margin-right: 0;
                    padding-right: 20px;
                    padding-left: 20px;
                }
            }

            :host(.coalesced-value) {
                --context-coalesce-marker: {
                    font-style: italic;
                }
            }
            .attribute-coalesced-label .attribute-view-label{                
                font-style: italic;
            }
            .attribute-coalesced-label{
                --context-coalesce-label:{
                    font-style: italic;
                }
            }
            .attribute-non-coalesced-label .attribute-view-label{
                color:#000;
                font-weight:500;
            }
            .attribute-non-coalesced-label{
                --context-coalesce-label:{
                    color:#000;
                    font-weight:500;
                }
            } 
            .attribute {
                @apply --layout-horizontal;
            }

            .attribute.list {
                @apply --layout-center-center;
                padding: 5px 20px 25px 10px;
                margin-bottom: 10px;
            }

            .attribute-main {
                width: 100%;
                position: relative;
                @apply --attribute-main;
            }

            .attribute-icons-wrapper {
                text-align: right
            }

            .attribute-icons {
                display: inline-block;
                opacity: 0;
                transition: all 0.3s;
                -webkit-transition: all 0.3s;
            }

            .attribute-icons pebble-info-icon {
                opacity: 1;
            }

            .attribute-main:hover .attribute-icons {
                opacity: 1;
            }

            .attribute-view {
                border-bottom: 1px solid #E0E0E0;
                box-shadow: 0 2px 6px -6px #000;
                -webkit-box-shadow: 0 2px 6px -6px #000;
                -moz-box-shadow: 0 2px 6px -6px #000;
                -ms-box-shadow: 0 2px 6px -6px #000;
            }

            .attribute-view,
            .attribute-edit {
                clear: both;
            }

            .attribute-edit {
                @apply --attribute-edit;
                --pebble-dt-default-inputarea: {
                    width: 100%;
                }
            }

            .attribute-view.grid {
                margin-top: 0;
            }

            .attribute-view.grid .attribute-view-value {
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
            }

            .attribute-view.grid {
                --pebble-textarea-input: {
                    max-height: 25px;
                }
            }

            .attribute-view-value {
                font-size: var(--default-font-size, 14px);
                display: inline-block;
                width: 100%;
                vertical-align: middle;
                max-height: 100px;
                overflow-y: auto;
                @apply --locale-coalesce-marker;
                @apply --context-coalesce-marker;
            }

            .attribute-icons pebble-icon {                
                padding: 0;
                transition: all 0.3s;
                -webkit-transition: all 0.3s;
                --pebble-icon-color:{
                    fill: var(--secondary-icon-color, #c1cad4);
                }
            }

            .attribute-icons pebble-icon:hover {
                --pebble-icon-color:{
                    fill: var(--primary-icon-color, #75808b);
                }
            }

            .datetimepicker-container {
                width: 100%;
                position: relative;
            }

            #dateTimeTriggerContainer {
                position: absolute;
                right: -11px;
                bottom: -6px;
            }

            #dateTimeTriggerContainer {
                --paper-button: {
                    min-width: auto;
                }
            }

            #error-display {
                position: absolute;
                right: 0;
                left: 0;
                bottom: -23px;
            }

            .error {
                color: var(--error-color, #ed204c);
                font-size: var(--font-size-sm, 12px);
                font-weight: var(--font-medium, 500);
                letter-spacing: 0.011em;
                line-height: 11px;
                width: 85%;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                display: inline-block;
            }

            .error-circle {
                height: 18px;
                width: 18px;
                line-height: 18px;
                text-align: center;
                border-radius: 50%;
                background: var(--error-color, #ed204c);
                color: var(--palette-white, #fff);
                font-size: var(--font-size-xs, 10px);
                float: right;
                margin-top: 1px;
            }

            pebble-textbox-collection {
                --text-collection-label: {
                    font-size: var(--font-size-sm, 12px);
                    color: var(--label-text-color, #96B0C5);
                };
                --text-collection-manage-tag-container: {
                    height: 65px;
                }
            }

            .close-item {
                position: absolute;
                top: 30px;
                right: -14px;
            }

            .delete-item {
                position: absolute;
                top: 27px;
                right: -38px;
            }

            pebble-popover#view-source-information-popover {
                font-weight: normal;
                text-transform: initial;
                text-align: left;
                margin-left: -12px;
                margin-top: 7px;
                --default-popup-b-p: 5px;
                --default-popup-t-p: 5px;
                --default-font-size: 12px;
                width: 180px;
            }

            pebble-richtexteditor p{
                margin: 0px;
            }

            /*For IE/Edge Specifically...else new line being created in edge due to Quill Issue*/
            pebble-richtexteditor .ql-clipboard {   
                left: -100000px;
                height: 1px;
                overflow-y: hidden;
                position: absolute !important;
                top: 50%;
            }
            /*For IE/Edge Specifically...to get placeholder text and border*/

            pebble-richtexteditor .ql-editor.ql-blank::before {
                color: rgba(0, 0, 0, 0.6);
                content: "Enter the text here...";
                font-style: italic;
                pointer-events: none;
                position: absolute;
            }

            pebble-richtexteditor .ql-editor {
                border: 1px solid #c1c1c1!important;
                border-top: 0;
                font-size: var(--default-font-size, 14px)!important;
                color: var(--attrpanel-color-text, #1a2028);
                padding: 12px 15px;
                tab-size: 4;
                white-space: pre-wrap;
                word-wrap: break-word;
            }

            pebble-popover#view-source-information-popover::after,
            pebble-popover#view-source-information-popover::before {
                bottom: 100%;
                left: 20px;
                border: solid transparent;
                content: " ";
                height: 0;
                width: 0;
                position: absolute;
                pointer-events: none;
            }

            pebble-popover#view-source-information-popover::after {
                border-color: rgba(255, 255, 255, 0);
                border-bottom-color: #ffffff;
                border-width: 6px;
                margin-left: -6px;
            }

            pebble-popover#view-source-information-popover::before {
                border-color: rgba(194, 225, 245, 0);
                border-bottom-color: rgb(216, 221, 228);
                border-width: 7px;
                margin-left: -7px;
            }

            .source-information-header,
            .source-information-description,
            .source-information-path {
                padding-left: 10px;
                padding-right: 10px;
            }

            .source-information-header {
                font-weight: bold;
                border-bottom: thin solid rgb(216, 221, 228);
                padding-bottom: 3px;
            }

            .source-information-path {
                margin-top: 10px;
                margin-bottom: 0px;
            }

            .source-information-path .path-item {
                color: var(--link-text-color, #139ee7);
                display: inline-block;
            }

            .source-information-path .path-item::after {
                content: " >>";
                color: var(--default-text-color, #444444);
            }

            .source-information-path .path-item:last-of-type::after {
                content: "";
            }

            li {
                text-align: inherit;
            }
        </style>
        <div class$="attribute [[functionalMode]]">
            <div class$="attribute-main [[_getCoalescedLabelClass()]]">
                <div class="attribute-icons-wrapper">
                    <div class="attribute-icons" hidden$="[[_isGridType]]">
                        <template is="dom-if" if="[[!_isEditMode(mode)]]">
                            <template is="dom-if" if="[[_isAttributeEditable(attributeModelObject)]]">
                                <pebble-icon disabled$=[[readonly]] name="edit" class="pebble-icon-size-16 m-r-5 m-l-5 tooltip-bottom" icon="pebble-icon:action-edit"
                                    data-tooltip="Edit" on-tap="_onEditClick" tabindex="-1"></pebble-icon>
                            </template>
                        </template>
                        <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                            <template is="dom-if" if="[[_hasValue(attributeObject.value)]]">
                                <pebble-icon name="clear" class="pebble-icon-size-12 m-l-5 tooltip-bottom close-item" icon="pebble-icon:window-action-close" data-tooltip="Clear value"
                                    on-tap="_onClearClick" tabindex="-1"></pebble-icon>
                            </template>
                        </template>
                        <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                            <template is="dom-if" if="[[showDeleteIcon]]">
                                <pebble-icon name="delete" class="pebble-icon-size-16 m-l-5 tooltip-left delete-item" icon="pebble-icon:action-delete" data-tooltip="Remove Attribute"
                                    on-tap="_onDeleteClick" tabindex="-1"></pebble-icon>
                            </template>
                            <pebble-icon name="revert" class="pebble-icon-size-16 m-l-5 tooltip-bottom" icon="pebble-icon:revert" data-tooltip="Revert"
                                on-tap="_onRevertClick" tabindex="-1"></pebble-icon>
                        </template>


                        <template is="dom-if" if="[[_sourceInfoVisible]]">
                            <pebble-icon name="owner" class="pebble-icon-size-16 m-r-5 m-l-5 tooltip-bottom" icon="pebble-icon:hierarchy" id="view-source-information"
                                data-tooltip="View source information" on-tap="_onSourceInformationClick" tabindex="-1"></pebble-icon>

                            <pebble-popover id="view-source-information-popover" for="view-source-information">
                                <div class="attributes-description">
                                    <div class="source-information-header">Source Information</div>
                                    <div class="source-information-description">This value was sourced from the following path</div>
                                    <template is="dom-if" if="[[_hasFallbackValue()]]">
                                        <ul class="source-information-path">
                                            Locale:
                                            </br>
                                            <template is="dom-repeat" items="[[_fallbackList]]">
                                                <li class="path-item">[[item]]</li>
                                            </template>
                                        </ul>
                                    </template>
                                    <template is="dom-if" if="[[_hasContextCoalescedValue()]]">
                                        <ul class="source-information-path">
                                            Context:
                                            </br>
                                            <template is="dom-repeat" items="[[_contextCoalescePathList]]">
                                                <li class="path-item">[[item]]</li>
                                            </template>
                                        </ul>
                                    </template>
                                    <template is="dom-if" if="[[_hasRelatedEntityCoalescedValue()]]">
                                        <ul class="source-information-path">
                                            Related Entity:
                                            </br>
                                            <template is="dom-if" if="[[!_isRelatedEntityRecieved]]">
                                                Calculating . . .
                                            </template>
                                            <template is="dom-if" if="[[_isRelatedEntityRecieved]]">
                                                <a href="[[_relatedEntityLink]]">
                                                    [[_relatedEntityName]]
                                                </a>
                                            </template>
                                        </ul>
                                    </template>
                                </div>
                            </pebble-popover>
                        </template>
                        
                        <pebble-icon name="time" class="pebble-icon-size-16 m-r-5 m-l-5 tooltip-bottom" icon="pebble-icon:time" data-tooltip="Manage historical data"
                            on-tap="_onTimeClick" tabindex="-1"></pebble-icon>

                        <pebble-icon name="locale" hidden class="pebble-icon-size-16 m-r-5 m-l-5 tooltip-bottom" icon="pebble-icon:language" data-tooltip="Manage in multiple locales"
                            on-tap="_onLocaleClick" tabindex="-1"></pebble-icon>
                        <div class="clearfix"></div>
                    </div>

                </div>
                <template is="dom-if" if="[[_isComponentEditable(mode, attributeModelObject)]]">
                    <div class$="[[_getAttributeEditClass(changed)]]">
                        <!-- TEXTAREA -->
                        <template is="dom-if" if="[[_isTextArea(attributeModelObject)]]">
                            <pebble-textarea id="input" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                                label="{{_getLabel(attributeModelObject.externalName)}}" value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]"
                                invalid="{{invalid}}" tabindex="[[tabindex]]"></pebble-textarea>
                        </template>

                        <!-- DROPDOWN -->
                        <template is="dom-if" if="[[_isDropDown(attributeModelObject)]]">
                            <pebble-dropdown id="input" label="{{_getLabel(attributeModelObject.externalName)}}" items="{{attributeModelObject.allowedValues}}"
                                selected-value="{{attributeObject.value}}" invalid="{{invalid}}" no-label-float="[[noLabelFloat]]"
                                description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]">
                            </pebble-dropdown>
                        </template>
                        <!-- BOOLEAN -->
                        <template is="dom-if" if="[[_isBoolean(attributeModelObject)]]">
                            <pebble-boolean id="input" label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" invalid="{{invalid}}"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" true-text="[[_isNullOrEmpty(attributeModelObject.trueText, 'TRUE')]]"
                                false-text="[[_isNullOrEmpty(attributeModelObject.falseText,'FALSE')]]" tabindex="[[tabindex]]">
                            </pebble-boolean>
                        </template>
                        <!-- DATE -->
                        <template is="dom-if" if="[[_isDate(attributeModelObject)]]">
                            <pebble-datetime-picker id="datePicker" min-date="[[_convertToDate(attributeModelObject.rangeFrom)]]" max-date="[[_convertToDate(attributeModelObject.rangeTo)]]"
                                label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" picker-type="date"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- DATETIME -->
                        <template is="dom-if" if="[[_isDateTime(attributeModelObject)]]">
                            <pebble-datetime-picker id="dateTimePicker" min-date="[[_convertToDate(attributeModelObject.rangeFrom)]]" max-date="[[_convertToDate(attributeModelObject.rangeTo)]]"
                                label="[[_getLabel(attributeModelObject.externalName)]]" value="{{attributeObject.value}}" picker-type="datetime"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]" default-time="[[_getDefaultTime(attributeObject.value)]]">
                            </pebble-datetime-picker>
                        </template>
                        <!-- TEXTBOX-COLLECTION -->
                        <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                            <div class="text-collection-container">
                                <pebble-textbox-collection label="{{_getLabel(attributeModelObject.externalName)}}" id="txtCollection" no-label-float="[[noLabelFloat]]"
                                    description-object="[[_getDescriptionObject()]]" values="{{attributeObject.value}}" tabindex="[[tabindex]]" 
                                    selected-values-color="[[_fallbackColor]]" selected-values-font-style="[[_coalescedFontStyle]]">
                                </pebble-textbox-collection>
                            </div>
                        </template>
                        <!-- If display type is not supported then textbox is used -->
                        <!-- TEXTBOX -->
                        <template is="dom-if" if="[[_isTextBox(attributeModelObject)]]">
                            <pebble-textbox id="input" label="{{_getLabel(attributeModelObject.externalName)}}" value="{{attributeObject.value}}" maxlength="[[attributeModelObject.maxLength]]"
                                invalid="{{invalid}}" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]"
                                tabindex="[[tabindex]]"></pebble-textbox>
                        </template>
                    </div>
                </template>

                <template is="dom-if" if="[[!_isComponentEditable(mode, attributeModelObject)]]">
                    <template is="dom-if" if="[[_useDefaultReadMode(attributeModelObject)]]">
                        <div class$="attribute-view [[functionalMode]]">
                            <span hidden="[[_isGridType]]">
                                <span class="attribute-view-label">{{attributeModelObject.externalName}} </span>
                                <template is="dom-if" if="[[_getDescriptionObject()]]">
                                    <pebble-info-icon hidden$="[[_isGridOrNested(attributeModelObject)]]" description-object="[[_getDescriptionObject()]]"></pebble-info-icon>
                                </template>
                                <br>
                            </span>
                            <span class="attribute-view-value" title="{{_formatValue(attributeModelObject, attributeObject)}}">{{_formatValue(attributeModelObject, attributeObject)}}</span>
                            <br>
                        </div>
                    </template>
                    <!-- TEXTBOX-COLLECTION -->
                    <template is="dom-if" if="[[_isTextboxCollection(attributeModelObject)]]">
                        <div class="text-collection-container">
                            <pebble-textbox-collection label="{{_getLabel(attributeModelObject.externalName)}}" id="txtCollection" values="{{attributeObject.value}}"
                                no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" tabindex="[[tabindex]]"
                                selected-values-color="[[_fallbackColor]]" selected-values-font-style="[[_coalescedFontStyle]]" is-readonly>
                            </pebble-textbox-collection>
                        </div>
                    </template>

                </template>

                <template is="dom-if" if="[[_isLOV(attributeModelObject)]]">
                    <template is="dom-if" if="[[_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="multi-select-combo-box" apply-locale-coalesce="[[applyLocaleCoalesce]]" no-popover apply-locale-coalesced-style apply-context-coalesced-style selected-values-color="[[_fallbackColor]]"
                            selected-values-font-style="[[_coalescedFontStyle]]" selected-values-locale="{{attributeObject.selectedLocales}}"
                            id-field="[[_getMappedColumn('id', attributeModelObject)]]" value-field="[[_getMappedColumn('value', attributeModelObject)]]"
                            image-id-field="[[_getMappedColumn('imageId', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            sub-title-pattern="[[_getMappedColumn('subtitle', attributeModelObject)]]" multi-select label="[[_getLabel(attributeModelObject.externalName)]]"
                            is-readonly="[[!_isComponentEditable(mode, attributeModelObject)]]" request-data="[[_prepareRequestObjectForLov(attributeModelObject, dependentAttributeObjects)]]"
                            selected-ids="{{attributeObject.referenceDataId}}" selected-values="{{attributeObject.value}}" tabindex="[[tabindex]]"
                            no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]" context-data="[[contextData]]"
                            on-tag-removed="_onTagItemRemoved">
                        </rock-entity-combo-box>
                    </template>
                    <template is="dom-if" if="[[!_isCollection(attributeModelObject)]]">
                        <rock-entity-combo-box id="combo-box" apply-locale-coalesce="[[applyLocaleCoalesce]]" no-popover apply-locale-coalesced-style apply-context-coalesced-style selected-values-color="[[_fallbackColor]]"
                            selected-values-font-style="[[_coalescedFontStyle]]" selected-values-locale="{{attributeObject.selectedLocales}}"
                            id-field="[[_getMappedColumn('id', attributeModelObject)]]" value-field="[[_getMappedColumn('value', attributeModelObject)]]"
                            image-id-field="[[_getMappedColumn('imageId', attributeModelObject)]]" title-pattern="[[_getMappedColumn('title', attributeModelObject)]]"
                            sub-title-pattern="[[_getMappedColumn('subtitle', attributeModelObject)]]" label="[[_getLabel(attributeModelObject.externalName)]]"
                            is-readonly="[[!_isComponentEditable(mode, attributeModelObject)]]" request-data="[[_prepareRequestObjectForLov(attributeModelObject, dependentAttributeObjects)]]"
                            selected-id="{{attributeObject.referenceDataId}}" selected-value="{{attributeObject.value}}" tabindex="[[tabindex]]"
                            context-data="[[contextData]]" no-label-float="[[noLabelFloat]]" description-object="[[_getDescriptionObject()]]"
                            on-tag-removed="_onTagItemRemoved">
                        </rock-entity-combo-box>
                    </template>
                </template>

                <!-- NESTED ATTRIBUTES -->
                <template is="dom-if" if="[[_isNested(attributeModelObject)]]">
                    <template is="dom-if" if="[[!_isGridType]]">
                        <rock-nested-attribute-grid label="{{_getLabel(attributeModelObject.externalName)}}" attribute-model-object="[[attributeModelObject]]"
                            original-attribute-object="[[_cloneObject(attributeObject)]]" attribute-object="{{attributeObject}}"
                            context-data="[[contextData]]" mode="[[mode]]" changed="{{changed}}" apply-locale-coalesce="[[applyLocaleCoalesce]]" ></rock-nested-attribute-grid>
                    </template>
                    <template is="dom-if" if="[[_isGridType]]">
                        <span id="nestedAttributeLink" on-tap="_nestedAttributeLinkTapped">Click here</span>
                        <pebble-dialog id="nestedAttributeModal" modal show-ok button-ok-text="ok" show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key
                            dialog-title="{{attributeModelObject.externalName}}">
                            <rock-nested-attribute-grid label="{{_getLabel(attributeModelObject.externalName)}}" attribute-model-object="[[attributeModelObject]]"
                                original-attribute-object="[[_cloneObject(attributeObject)]]" attribute-object="{{attributeObject}}"
                                context-data="[[contextData]]" mode="[[mode]]" apply-locale-coalesce="[[applyLocaleCoalesce]]" ></rock-nested-attribute-grid>
                        </pebble-dialog>
                    </template>
                </template>

                <!-- RICHTEXTEDITOR -->
                <template is="dom-if" if="[[_isRichTextEditor(attributeModelObject)]]">
                    <!-- Show the popover for read-only mode for the grid-->
                    <template is="dom-if" if="[[_isGridType]]">
                        <template is="dom-if" if="[[!_isEditMode(mode)]]">
                            <span id="rtelink" on-mouseenter="_rteLinkHovered">Show More</span>
                            <pebble-popover id="rtePopover" class="p-10" for="rtelink" no-overlap horizontal-align="right">
                                <pebble-richtexteditor id="input" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                                    label="{{_getLabel(attributeModelObject.externalName)}}" invalid="{{invalid}}" value="{{attributeObject.value}}"
                                    tabindex="[[tabindex]]" read-only="[[!_isComponentEditable(mode, attributeModelObject)]]"
                                    selected-values-font-style="[[_coalescedFontStyle]]" selected-values-color="[[_fallbackColor]]"></pebble-richtexteditor>
                            </pebble-popover>
                        </template>
                        <template is="dom-if" if="[[_isEditMode(mode)]]">
                            <span id="rteEditLink" on-tap="_rteEditLinkTapped">Click to Edit</span>
                            <pebble-dialog id="rteSingleEdit" modal show-ok button-ok-text="ok" show-close-icon no-cancel-on-outside-click no-cancel-on-esc-key
                                dialog-title="Rich Text Editor">
                                <rock-attribute id="singleEdit" mode="[[mode]]" functional-mode="list" attribute-model-object="{{attributeModelObject}}"
                                    attribute-object="{{attributeObject}}"></rock-attribute>
                            </pebble-dialog>
                        </template>
                    </template>
                    <template is="dom-if" if="[[!_isGridType]]">
                        <pebble-richtexteditor id="input" description-object="[[_getDescriptionObject()]]" validation-errors="{{validationErrors}}"
                                label="{{_getLabel(attributeModelObject.externalName)}}" invalid="{{invalid}}" value="{{attributeObject.value}}"
                                tabindex="[[tabindex]]" read-only="[[!_isComponentEditable(mode, attributeModelObject)]]" selected-values-font-style="[[_coalescedFontStyle]]"
                                selected-values-color="[[_fallbackColor]]"></pebble-richtexteditor>
                    </template>
                </template>

                <bedrock-validator validation-errors="{{validationErrors}}" input="[[_getInputValue(attributeObject.value)]]" input-data-type="[[attributeModelObject.dataType]]"
                    pattern="[[attributeModelObject.pattern]]" allowed-input="[[attributeModelObject.allowedInput]]" min-length="[[attributeModelObject.minLength]]" max-length="[[attributeModelObject.maxLength]]"
                    precision="[[attributeModelObject.precision]]" required="[[attributeModelObject.required]]" invalid="{{invalid}}"
                    min="[[attributeModelObject.rangeFrom]]" max="[[attributeModelObject.rangeTo]]" min-inclusive="[[attributeModelObject.isRangeFromInclusive]]"
                    max-inclusive="[[attributeModelObject.isRangeToInclusive]]" date-format="[[attributeModelObject.dateFormat]]"
                    type="[[attributeModelObject.validationType]]" type-array="[[attributeModelObject.validationTypeArray]]"></bedrock-validator>

                <div id="error-display" hidden="[[_errorAbsent(errors)]]" on-tap="_errorTapped">
                    <span class="error">[[errorMessage]] </span>
                    <span id="error-circle" class="error-circle">[[errorLength]]</span>
                </div>
            </div>
            <!-- <div>
                    <template is="dom-if" if="[[_isEditMode(mode)]]">
                        <pebble-icon name="clear" icon="pebble-icon:governance-failed" title="Clear" on-tap="_onClearClick" tabindex="-1"></pebble-icon>
                    </template>
                </div> -->
        </div>
        <pebble-popover id="errorPopover" for="error-circle" no-overlap horizontal-align="right">
            <pebble-error-list id="attrErrorList" errors="[[errors]]" show-fix-now="[[!_isEditMode(mode)]]"></pebble-error-list>
        </pebble-popover>
        <bedrock-pubsub target-id="attrErrorList" event-name="fix-error" handler="_fixError"></bedrock-pubsub>

    </template>
    <script>
        (function () {
            'use strict';
            Polymer({
                is: 'rock-attribute',
                ready: function () {
                    //console.log('attribute ready '+this._isInitialized);
                    this._isInitialized = true;
                },
                attached: function () {
                    //console.log('attribute attached');
                },
                properties: {
                    /**
                     * <b><i>Content development is under progress... </b></i>
                     */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * If set as true , it indicates the component is in read only mode
                     */
                    readonly: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Indicates whether the attribute is rendered in edit mode or view mode.
                     * The two possible values are <b>view</b> and <b>edit</b>.
                     */
                    mode: {
                        type: String,
                        value: "view",
                        notify: true
                    },
                    /**
                     * Indicates the JSON for the attribute value object. This object records all the user changes to the value.
                     * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                     */
                    attributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },
                    /**
                     * Indicates the JSON for the original attribute value object. This object does not record all the user changes to the value.
                     * Sample: {
                                "value":"Nivea Creme 400 Ml"
                              }
                     */
                    originalAttributeObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Indicates the JSON for the attribute model object.
                     * It renders appropriate UI element to edit the attribute, to configure the validation, and other behaviors.
                     * Sample: {
                                "name": "name",
                                "externalName": "Name",
                                "displayType": "textbox",
                                "minLength": 5,
                                "maxLength": 10
                              }
                     */
                    attributeModelObject: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    dependentAttributeObjects: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    dependentAttributeModelObjects: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },
                    /**
                     * Indicates whether or not an attribute object value is changed.
                     */
                    changed: {
                        type: Boolean,
                        value: false,
                        notify: true,
                        reflectToAttribute: true
                    },
                    _isInitialized: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Specifies the errors in an attribute object received from the server.
                     */
                    serverErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Specifies the errors that are raised after validating the attribute object value.
                     */
                    validationErrors: {
                        type: Array,
                        value: function () {
                            return [];
                        },
                        notify: true,
                        observer: '_errorsChanged'
                    },
                    /**
                     * Indicates all server errors and validation errors of attribute object value.
                     */
                    errors: {
                        type: Array,
                        notify: true,
                        computed: '_getAllErrors(serverErrors,validationErrors)'
                    },
                    /**
                     * Specifies the length of the error message.
                     */
                    errorLength: {
                        type: Number,
                        notify: true,
                        value: 0
                    },
                    /**
                     * Specifies the error message to be shown.
                     */
                    errorMessage: {
                        type: String,
                        notify: true,
                        computed: '_getErrorMessage(errors)'
                    },
                    /**
                     * Indicates the functional mode of the attribute object.
                     */
                    functionalMode: {
                        type: String,
                        notify: true,
                        value: "list"
                    },
                    _isGridType: {
                        type: Boolean,
                        notify: true,
                        computed: '_isGrid(functionalMode)'
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i>
                     */
                    tabindex: {
                        type: Number
                    },
                    showDeleteIcon: {
                        type: Boolean,
                        value: false
                    },
                    /**
                     * Indicates whether to disable the floating label or not.
                     * Set the value as <b>true</b> to disable the floating label.
                     */
                    noLabelFloat: {
                        type: Boolean,
                        value: true
                    },

                    _fallbackList: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _contextCoalescePathList: {
                        type: Array,
                        value: function () {
                            return [];
                        }
                    },

                    _sourceInfoVisible: {
                        type: Boolean,
                        value: false
                    },
                    _fallbackColor: {
                        type: String,
                        value: ""
                    },
                    _coalescedFontStyle: {
                        type: String,
                        value: ""
                    },
                    _isRelatedEntityRecieved: {
                        type: Boolean,
                        value: false
                    },
                    _relatedEntityLink: {
                        type: String,
                        value: ""
                    },
                    _relatedEntityName: {
                        type: String,
                        value: ""
                    },
                    applyLocaleCoalesce: {
                        type: Boolean,
                        value: false
                    },
                },
                observers: [
                    '_attributeObjectChanged(attributeObject.*)'
                ],
                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],
                FALLBACK_PATH_DELIMITER: ">>",
                addValidationErrors: function (errorMessage) {
                    var validationErrors = this.validationErrors;
                    if (validationErrors.indexOf(errorMessage) == -1) {
                        validationErrors.push(errorMessage);
                    }
                    this.validationErrors = [];
                    this.validationErrors = validationErrors;
                },
                removeValidationErrorsAt: function (index) {
                    var validationErrors = this.validationErrors;
                    validationErrors.splice(index, 1);
                    this.validationErrors = [];
                    this.validationErrors = validationErrors;
                },
                _formatValue: function (model, object) {
                    if (model &&
                        model.dataType) {
                            if (model.dataType.toLowerCase() == "date" ||
                            model.dataType.toLowerCase() == "datetime") {
                        return FormatHelper.convertFromISODateTime(object.value, model.dataType, model.dateFormat);
                    }
                    if(model.dataType.toLowerCase() == "boolean") {
                            if(object.value == "true" || object.value == "false") {
                                return object.value=="true" ? model.trueText: model.falseText;
                            }
                        }
                        }
                   
                    return object.value;
                },
                _isEditMode: function (mode) {
                    return mode === "edit";
                },
                _getValue: function (val, trueText, falseText) {
                    if(val) {
                       return FormatHelper.checkTrueBooleanVal(val, trueText, falseText);
                    }
                    
                    return val;
                },
                _isAttributeEditable: function (attributeModelObject) {
                    return attributeModelObject.hasWritePermission && !attributeModelObject.readOnly;
                },
                _isComponentEditable: function (mode, attributeModelObject) {
                    return mode === "edit" && attributeModelObject.hasWritePermission && !attributeModelObject.readOnly;
                },
                _onChange: function (event) {
                    //todo: this is not working right now, have to find out how to propagate change event up the control hierarchy
                    if (this.shadowRoot) {
                        this.dispatchEvent(new CustomEvent(event.type, {
                            detail: {
                                sourceEvent: event
                            },
                            node: this,
                            cancelable: event.cancelable,
                            bubbles: event.bubbles,
                            composed: true
                        }));
                    }
                },
                _getCoalescedLabelClass:function(){   
                    var coalescedClass = (this.attributeModelObject && this.attributeModelObject.modelContextCoalesce) ? "attribute-coalesced-label" : "attribute-non-coalesced-label"                 
                    return coalescedClass;
                },
                _isTextBox: function (model) {
                    //If display type is not supported then also textbox is used
                    var displayType = model.displayType ? model.displayType.toLowerCase() : model.displayType;
                    return displayType === "textbox" && !model.isCollection ||
                        (!this._isTextArea(model) && !this._isDropDown(model) &&
                            !this._isBoolean(model) && !this._isDate(model) &&
                            !this._isDateTime(model) && !this._isTextboxCollection(model) &&
                            !this._isLOV(model) && !this._isRichTextEditor(model)) && !this._isNested(model);
                },
                _isTextArea: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textarea";
                },
                _isRichTextEditor: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "richtexteditor";
                },
                _isLOVSingleValued: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && !model.isCollection;
                },
                _isLOV: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist";
                },
                _isLOVCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "referencelist" && model.isCollection;
                },
                _isDropDown: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "dropdown";
                },
                _isBoolean: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "boolean";
                },
                _isDate: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "date";
                },
                _isDateTime: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "datetime";
                },
                _isTextboxCollection: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "textbox" && model.isCollection;
                },
                _useDefaultReadMode: function (model) {
                    var displayType = model.displayType ? model.displayType.toLowerCase() : "";
                    return !(model.isCollection || displayType === "referencelist" || displayType === "richtexteditor" || displayType === "nestedgrid");
                },
                _isCollection: function (model) {
                    return model.isCollection;
                },
                _isGridOrNested: function (model) {
                    return (this._isNested(model) || this._isGridType);
                },
                _isNested: function (model) {
                    return model.displayType && model.displayType.toLowerCase() === "nestedgrid";
                },
                _onEditClick: function (e) {
                    if (e.currentTarget.disabled) {
                        return;
                    }
                    const mode = 'edit';
                    this._showFixNow = false;

                    this.dispatchEvent(new CustomEvent("attribute-mode-changed", {
                        detail: { mode },
                        bubbles: true,
                        composed: true
                    }));
                },
                getControlIsDirty: function () {
                    return this.mode == "edit";
                },
                _getInputValue: function(value) {
                    if(this.attributeModelObject.displayType == "boolean" && (this.attributeObject.value==this.attributeModelObject.trueText || this.attributeObject.value==this.attributeModelObject.falseText) ) {
                        return this.attributeObject.value==this.attributeModelObject.trueText ? "true" : "false";
                    }
                    
                    return this.attributeObject.value;
                },
                _attributeObjectChanged: function (changeRecord) {
                    if (this.attributeObject.value && this.attributeObject.action) {
                        var isCollection = this.attributeModelObject && this.attributeModelObject.isCollection ? true : false;
                        if (!isCollection || (isCollection && this.attributeObject.value.length > 0)) {
                            delete this.attributeObject.action;
                        }
                    }

                    if(this.attributeModelObject.dataType == "boolean" && (this.attributeObject.value != "true" &&  this.attributeObject.value != "false")) {
                        this.attributeObject.value = this._getValue(this.attributeObject.value, this.attributeModelObject.trueText, this.attributeModelObject.falseText);
                    }

                    if (this._isInitialized && changeRecord.path != "attributeObject" && changeRecord.path != "attributeObject.errors") {
                        this.changed = true;
                        this.dispatchEvent(new CustomEvent("attribute-value-changed", { detail: this.attributeObject, bubbles: true, composed: true }));
                        //console.log("newValue after ready " + JSON.stringify(newValue));
                    }
                    this._fallbackList = this._getFallbackPath();
                    this._contextCoalescePathList = this.attributeObject.contextCoalescePaths;
                    this._updateMarkerClass();
                    this._showSourceInfo();
                },
                _getAttributeEditClass: function (changed) {
                    if (changed) {
                        return 'attribute-edit attribute-edit-changed';
                    } else {
                        return 'attribute-edit';
                    }
                },
                _onRevertClick: function (e) {
                    this.attributeObject = this._cloneObject(this.originalAttributeObject); //can't assign directly, its by ref - thus using cloning
                    this.dispatchEvent(new CustomEvent("attribute-value-changed", { detail: { revertClicked: true }, bubbles: true, composed: true }));
                    this.changed = false;
                },
                _onClearClick: function (e) {
                    var setValue = this.attributeModelObject && this.attributeModelObject.isCollection ? [] : "";
                    this.set("attributeObject.value", setValue);
                    this.set("attributeObject.referenceDataId", setValue);
                    this.set("attributeObject.action", "delete");
                    this.changed = true;
                },
                _cloneObject: function (o) {
                    return DataHelper.cloneObject(o);
                },
                _onTimeClick: function () {
                    var _dataObj = DataHelper.cloneObject(this.attributeModelObject);
                    if(!_.isEmpty(this.contextData)){
                        var itemContext = ContextHelper.getFirstItemContext(this.contextData)
                        if(itemContext && itemContext.relationships && itemContext.relationships.length > 0){
                            _dataObj.relationshipName = itemContext.relationships[0];
                        }
                    }
                    var eventDetail = {
                        data: _dataObj,
                        name: "dimension-grid-open"
                    }

                    this.fireBedrockEvent("dimension-grid-open", eventDetail, {
                        ignoreId: true
                    });
                },
                _onSourceInformationClick: function (e) {
                    var sourceInformation = this.$$("#view-source-information-popover");
                    if (sourceInformation) {
                        sourceInformation.show();
                    }
                    e.stopPropagation();

                    if (this._hasRelatedEntityCoalescedValue()) {
                        var eventDetail = {
                            data: {
                                "id": this.attributeObject.osid,
                                "type": this.attributeObject.ostype
                            },
                            callback: this._onRelatedEntityInfoGet.bind(this),
                            name: "source-info-open"
                        }
                        ComponentHelper.fireBedrockEvent("source-info-open", eventDetail, {
                            ignoreId: true
                        });
                    }
                },
                _showPicker: function (e) {
                    var pickerId = e.target.getAttribute('picker-id');
                    if (pickerId) {
                        var picker = this.shadowRoot.querySelector("#" + pickerId);
                        if (picker) {
                            picker.show();
                        } else {
                            alert('picker with picker-id ' + pickerId + ' not found');
                        }
                    } else {
                        alert('picker-id attribute not found on target.');
                    }
                },
                _getAllErrors: function (serverErrors, validationErrors) {
                    return serverErrors.concat(validationErrors);
                },
                _getErrorMessage: function (errors) {
                    if (errors.length) {
                        return this.errors[0];
                    }
                },
                /**
                 * <b><i>Content development is under progress... </b></i>
                 */
                hasModelErrors: function () {
                    return this.validationErrors && this.validationErrors.length > 0;
                },
                _errorsChanged: function () {
                    if (this.serverErrors && this.validationErrors) {
                        this.errorLength = this.serverErrors.length + this.validationErrors.length;
                    }
                },
                _errorAbsent: function (errors) {
                    if (this._isGridType) {
                        return true;
                    }
                    return errors.length == 0;
                },
                _errorTapped: function () {
                    this.$.errorPopover.positionTarget = this.shadowRoot.querySelector('#error-circle');
                    this.$.errorPopover.open();
                },
                _fixError: function (e) {
                    this._onEditClick(e);
                    this.$.errorPopover.close();
                },
                _isGrid: function (functionalMode) {
                    return functionalMode == "grid";
                },
                _rteLinkHovered: function (e) {
                    this.shadowRoot.querySelector('#rtePopover').show();
                },
                _rteEditLinkTapped: function (e) {
                    this.shadowRoot.querySelector('#rteSingleEdit').open();
                },
                _nestedAttributeLinkTapped: function (e) {
                    this.shadowRoot.querySelector('#nestedAttributeModal').open();
                },
                //TODO: this did not work for entityTypes, need to check why
                _prepareRequestObjectForLov: function (attributeModel, dependentAttributeObjects) {
                    var refEntityTypes = [];

                    //find from manage model, looks like this:
                    // "referenceEntityInfo": [
                    //                     {
                    //                         "refRelationshipName": "hasReferenceTo",
                    //                         "refEntityType": "color"
                    //                     }
                    //                  ]
                    if (attributeModel.referenceEntityInfo) {
                        for (let i = 0; i < attributeModel.referenceEntityInfo.length; i++) {
                            var refEntityInfo = attributeModel.referenceEntityInfo[i];
                            if (refEntityInfo.refRelationshipName == 'hasReferenceTo' && refEntityInfo.refEntityType) {
                                refEntityTypes.push(refEntityInfo.refEntityType);
                            }
                        }
                    }

                    var relationshipsCriterion = [];
                    var dependencyInfo = attributeModel.dependencyInfo;
                    if (!DataHelper.isEmptyObject(dependencyInfo) && !DataHelper.isEmptyObject(this.dependentAttributeObjects) && !DataHelper.isEmptyObject(this.dependentAttributeModelObjects)) {
                        for (let i = 0; i < dependencyInfo.length; i++) {
                            var dependentAttrInfo = dependencyInfo[i];
                            var dependentAttributeModelObject = this.dependentAttributeModelObjects.find(attrModel => attrModel.name === dependentAttrInfo.dependentOn)
                            var dependentAttributeObject = this.dependentAttributeObjects.find(attr => attr.name === dependentAttrInfo.dependentOn)

                            if (dependentAttributeObject && dependentAttributeObject.value && dependentAttributeObject.value.length && dependentAttributeObject.action !== "delete") {
                                var relCriteria = this._prepareRelationshipCriterion(dependentAttrInfo.dependencyRelationship, dependentAttributeObject.referenceDataId, dependentAttributeModelObject.referenceEntityTypes[0]);
                                relationshipsCriterion.push(relCriteria);
                            }
                        }
                    }

                    var clonedContextData = DataHelper.cloneObject(this.contextData);

                    var itemContext = {
                        'type': refEntityTypes,
                        'relationshipsCriterion': relationshipsCriterion
                    };

                    clonedContextData[ContextHelper.CONTEXT_TYPE_ITEM] = [itemContext];

                    

                    var requestData = DataRequestHelper.createEntityGetRequest(clonedContextData);
                    var referenceDataId = this.attributeObject.referenceDataId;
                    return requestData;
                },
                _prepareRelationshipCriterion: function (relName, relToId, relToType) {
                    relToId = relToId || "";
                    var relCriteria = {};
                    relCriteria[relName] = {
                        "relTo": {}
                    };
                    if (typeof relToId == Array) {
                        relCriteria[relName].relTo.ids = relToId;
                    } else {
                        relCriteria[relName].relTo.id = relToId;
                    }
                    relCriteria[relName].relTo.type = relToType;
                    return relCriteria
                },

                _getMappedColumn: function (columName, attributeModelObject) {
                    if (columName && attributeModelObject) {
                        if (attributeModelObject.referenceEntityInfo) {
                            for (var i = 0; i < attributeModelObject.referenceEntityInfo.length; i++) {
                                var refEntityInfo = attributeModelObject.referenceEntityInfo[i];
                                if (refEntityInfo.refRelationshipName == 'hasReferenceTo') {

                                    var columNameToReturn;
                                    columName = columName.toLowerCase();

                                    if (columName == "id") {
                                        // Id is mandatory for Lov.
                                        // Hence if pattern for Id not available then set entity.id
                                        columNameToReturn = refEntityInfo.id;
                                        if (DataHelper.isEmptyObject(columNameToReturn)) {
                                            columNameToReturn = "entity.id";
                                        }
                                    }

                                    // if (columName == "title") {
                                    //     // Default fallback to Name, otherwise it will show empty values
                                    //     columNameToReturn = refEntityInfo.listTitle;
                                    //     if (DataHelper.isEmptyObject(columNameToReturn)) {
                                    //         columNameToReturn = "{entity.name}";
                                    //     }
                                    // }

                                    if (columName == "subtitle") {
                                        columNameToReturn = refEntityInfo.listSubTitle;
                                    }

                                    if (columName == "image") {
                                        columNameToReturn = refEntityInfo.image;
                                    }
                                    if (columName == "imageid") {
                                        columNameToReturn = refEntityInfo.thumbnail;
                                        if (!columNameToReturn || columNameToReturn.toLowerCase() === "none") {
                                            columNameToReturn = "";
                                        }
                                    }

                                    if (columName == "color") {
                                        columNameToReturn = refEntityInfo.color;
                                    }

                                    // if (columName == "value") {
                                    //     //refEntityInfo.value = "referencedatavalue";
                                    //     columNameToReturn = refEntityInfo.listValueAttribute;
                                    //     if (DataHelper.isEmptyObject(columNameToReturn)) {
                                    //         columNameToReturn = "entity.name";
                                    //     }
                                    // }

                                    return columNameToReturn;
                                }
                            }
                        }
                    }
                },
                _hasValue: function (value) {
                    if (value) {
                        return true;
                    } else {
                        return false;
                    }
                },
                _getLabel: function (label) {
                    if (this._isGridType) {
                        return "";
                    } else {
                        return label;
                    }
                },
                _onDeleteClick: function (e) {
                    this.fireBedrockEvent("attribute-delete", { data: this.attributeModelObject }, { ignoreId: true });
                },
                _onTagItemRemoved: function (e) {
                    // Note:- In a scenario where attribute is of type Reference List and is Non Collection then,
                    //        removing a tag should perform the same action what the component is performing when
                    //        user clicks on clear Icon - ok
                    var isCollection = this.attributeModelObject && this.attributeModelObject.isCollection ? true : false;
                    if (!isCollection || (isCollection && this.attributeObject && _.isEmpty(this.attributeObject.value))) {
                        this._onClearClick(e);
                    }
                },
                _updateMarkerClass: function () {
                    var root = this.root && this.root.host;
                    if (!root) return;
                    if (this._hasFallbackValue()) {
                        root.classList.add('fallback-value');
                        this.set("_fallbackColor", "#0bb2e8");
                    } else {
                        root.classList.remove('fallback-value');
                        this.set("_fallbackColor", "");
                    }

                    if (this._hasContextCoalescedValue() || this._hasRelatedEntityCoalescedValue()) {
                        root.classList.add('coalesced-value');
                        this.set("_coalescedFontStyle", "italic");
                    } else {
                        root.classList.remove('coalesced-value');
                        this.set("_coalescedFontStyle", "");
                    }
                },
                _hasFallbackValue: function () {
                    return !!(this.attributeModelObject && this.attributeModelObject.isLocalizable &&
                        this.attributeObject.properties && this.attributeObject.properties.localeCoalescePath);

                },
                _hasContextCoalescedValue: function () {
                    return this.attributeObject.contextCoalescePaths && this.attributeObject.contextCoalescePaths.length;
                },

                _hasRelatedEntityCoalescedValue: function () {
                    return this.attributeObject.os === "graph" && !_.isEmpty(this.attributeObject.osid) && !_.isEmpty(this.attributeObject.ostype);
                },

                _getFallbackPath: function () {
                    const { properties } = this.attributeObject;
                    const localeCoalescePath = properties && properties.localeCoalescePathExternalName;
                    if (localeCoalescePath) {
                        return localeCoalescePath.split(this.FALLBACK_PATH_DELIMITER);
                    }
                    return [];
                },
                _getDescriptionObject: function () {
                    if (!this.attributeModelObject.isNestedChild) {
                        return this.attributeModelObject.properties;
                    }
                },
                _showSourceInfo: function () {
                    this._sourceInfoVisible = this._hasFallbackValue() || this._hasContextCoalescedValue() || this._hasRelatedEntityCoalescedValue();
                },
                _getFallbackValueColor: function () {
                    if (this._hasFallbackValue()) {
                        // console.log("start of getComputedStyleValue: ", window.performance.now());
                        // var color = this.getComputedStyleValue("--color-variant-1");
                        // console.log("end of getComputedStyleValue: ", window.performance.now());
                        // return color;

                        //TODO: Currently hard coded color code value, as the above computation function
                        //taking ~8ms per attribute. Need to figure out better way to extract css variable value.
                        return "#0bb2e8";
                    }
                },

                _onRelatedEntityInfoGet: function (entity) {
                    if (!_.isEmpty(entity)) {
                        this._isRelatedEntityRecieved = true;
                        this._relatedEntityLink = "entity-manage?id=" + entity.id + "&type=" + entity.type;
                        this._relatedEntityName = entity.name;
                    } else {
                        this._isRelatedEntityRecieved = true;
                        this._relatedEntityName = "NA";
                    }
                },

                _getDefaultTime: function (dateTimeValue) {
                    if(!dateTimeValue && this.appSetting('dateTimePicker.defaultTime')) {
                        return this.appSetting('dateTimePicker.defaultTime');
                    }
                },

                _convertToDate: function (strDate) {
                    if (strDate) {
                        var date = new Date(strDate);
                        if (date && date != "Invalid Date") {
                            return new Date(date.toDateString());
                        }
                    }
                }
            });
        })();
    </script>
</dom-module>