<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">

<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">
<link rel="import" href="../liquid-entity-govern-data-get/liquid-entity-govern-data-get.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-grid/entity-search-grid-datasource.html">

<!--
`rock-entity-search-grid` Represents a component that renders the entities in grid.
It filters the data as per filter criteria.

@demo demo/index.html
-->

<dom-module id="rock-entity-search-grid">
    <style>

    </style>
    <template>
        <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="{{attributeModelRequest}}" on-entity-model-composite-get-response="_onCompositeModelGetResponse"></liquid-entity-model-composite-get>
        <liquid-entity-govern-data-get name="governDataGet" operation="initiatesearch" request-data="{{_governDataRequest}}" on-response="_onGovernDataResponse"></liquid-entity-govern-data-get>
        <template is="dom-if" if="[[_isWorkflowRequest(_loadGrid, _loadWithoutWorkflow)]]">
            <entity-search-grid-datasource id="searchGrid" request="{{request}}" data-source="{{dataSource}}" data-formatter="{{dataFormatter}}"
                current-record-size="{{size}}" total-records="{{totalRecords}}" total-count="{{totalCount}}"></entity-search-grid-datasource>
            <rock-grid id="entityGrid" data-source="{{dataSource}}" data-source-id="searchGrid" record-size="{{totalRecords}}" config="{{gridConfig}}"
                grid-data-size="{{size}}" attribute-models="{{attributeModels}}" page-size="[[pageSize]]" selected-item="{{selectedItem}}"
                selected-items="{{selectedItems}}" total-count="{{totalCount}}"></rock-grid>
        </template>
    </template>

    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'rock-entity-search-grid',
                properties: {
                    /**
                     * Indicates the request object that is passed to the data element to retrive the attribute model data.
                     */
                    attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the configuration object that is passed to the grid.
                     */
                    gridConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the request object to initiate the search.
                     * Note: Create Empty Object.... Ask Vishal
                     */
                    request: {
                        type: Object,
                        value: function () {
                            return {
                                "params": {
                                    "query": {
                                        "contexts": [],
                                        "valueContexts": [],
                                        "filters": {
                                            "attributesCriterion": [],
                                            "typesCriterion": []
                                        }
                                    },
                                    "fields": {
                                        "ctxTypes": [
                                            "properties"
                                        ],
                                        "attributes": []
                                    },
                                    "options": {
                                        "from": 0,
                                        "to": 0
                                    }
                                }
                            };
                        }
                    },
                    /**
                     * Specifies the filters that are used to filter the search.
                     */
                    searchFilters: {
                        type: Array,
                        notify: true,
                        value: function () {
                            return [];
                        },
                        observer: '_loadSearchResultsByFilters'
                    },
                    /**
                     * Specifies the query object that are used to initiate the search.
                     */
                    searchQuery: {
                        type: String,
                        notify: true,
                        value: "",
                        observer: '_loadSearchResultsByQuery'
                    },
                    /**
                     * Specifies the workflow criterion for search.
                     */
                    workflowCriterion: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the format of the data that are passed to the remote-data.
                     */
                    dataFormatter: {
                        notify: true,
                        value: function () {
                            return this._getAttributeFormattedData.bind(this);
                        }
                    },

                    attributeModels: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },

                    /**
                     * Indicates the number of items fetched at a time from the data-source.
                     */
                    pageSize: {
                        type: Number,
                        notify: true,
                        value: 10
                    },

                    /**
                     * Indicates the total record size of the current grid.				 
                     */
                    totalRecords: {
                        notify: true,
                        type: Number,
                        value: 0
                    },

                    /**
                     * Indicates selected item
                     */
                    selectedItem: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },

                    /**
                     * Indicates selected items
                     */
                    selectedItems: {
                        type: Array,
                        value: [],
                        notify: true
                    },

                    _governDataRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _loadGrid: {
                        type: Boolean
                    },

                    _loadWithoutWorkflow: {
                        type: Boolean
                    },
                },

                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],

                observers: [
                    '_onGridConfigChange(gridConfig)'
                ],


                refresh: function () {
                    this._onGridConfigChange(this.gridConfig, this.contextData);
                },

                /**
                 * Can be used to get the grid data.
                 */
                getData: function () {
                    return this._getEntityGrid().getData();
                },

                /**
                 * Can be used to set the multi-selection for the grid.
                 */
                setMultiSelection: function (flag) {
                    if (this.$$('#entityGrid') && flag != undefined) {
                        this._getEntityGrid().setMultiSelection(flag);
                    }
                },

                /**
                 * Can be used to clear the current selection state.
                 */
                clearSelection: function () {
                    this._getEntityGrid().clearSelection();
                },

                /**
                 *  To select an item
                 */
                selectItem: function (item) {
                    this._getEntityGrid().selectItem(item);
                },

                /**
                 * To set scroll position dynamically
                 */
                scrollToIndex: function (index) {
                    this._getEntityGrid().scrollToIndex(index);
                },

                /**
                 * Reset the grid size
                 */
                notifyResize: function () {
                    this._getEntityGrid().notifyResize();
                },

                /**
                 * To get selected grid row
                 */
                getSelectedGridRow: function () {
                    return this._getEntityGrid().getSelectedGridRow();
                },

                /**
                 * To get selected item index
                 */
                getSelectedItemIndex: function () {
                    return this._getEntityGrid().getSelectedItemIndex();
                },
                _addWorkflowDetailsToConfig: function () {
                    if (!(this.workflowCriterion && this.workflowCriterion.dataRequest && this.workflowCriterion.dataRequest.params && this.workflowCriterion.dataRequest.params.query)) {
                        return;
                    }
                    var query = this.workflowCriterion.dataRequest.params.query;
                    var workflow, workflowStatus;
                    if (query.contexts && query.contexts.length) {
                        workflow = query.contexts[0].workflow;
                    }
                    if (query.filters && query.filters.attributesCriterion && query.filters.attributesCriterion.length) {
                        var workflowStatusObj = query.filters.attributesCriterion[0]["activities/activityName"];
                        if (workflowStatusObj) {
                            workflowStatus = workflowStatusObj.eq;
                        }
                    }
                    this.set('gridConfig.workflowDetails', { "workflow": workflow, "workflowStatus": workflowStatus });
                },
                /**
                 * Can be used to reload the grid.
                 */
                reloadGrid: function () {
                    if (!_.isEmpty(this.workflowCriterion)) {
                        this._addWorkflowDetailsToConfig();
                        var governDataLiquid = this.$$("[name=governDataGet]");
                        if (governDataLiquid) {
                            var workflowName = this.workflowCriterion.workflowName;
                            var workflowActivityName = this.workflowCriterion.workflowActivityName;
                            var userId = this.workflowCriterion;
                            var req = {
                                "params": {
                                    "query": {
                                        "contexts": [
                                            {
                                                "workflow": workflowName
                                            }
                                        ],
                                        "filters": {
                                            "attributesCriterion": [
                                                {
                                                    "activities/activityName": {
                                                        "eq": workflowActivityName
                                                    }
                                                },
                                                {
                                                    "activities/assignedUser": {
                                                        "eq": userId
                                                    }
                                                }
                                            ],
                                            "typesCriterion": []
                                        }
                                    }
                                }
                            };
                            
                            req.params.options = { "from": 0, "to": 0 };

                            this._governDataRequest = req;
                            governDataLiquid.generateRequest();
                        }
                    } else {
                        this._loadGrid = true;
                        this._loadWithoutWorkflow = true;
                        this._reloadGrid(undefined);
                    }
                },

                _onGridConfigChange: function (gridConfig) {
                    var dataRequest = {};

                    if (_.isEmpty(this.contextData) || _.isEmpty(this.gridConfig)) {
                        return;
                    }

                    if (!this.gridConfig.dataRequest) {
                        return;
                    }

                    var attributeNames = this.gridConfig.dataRequest.attributes;
                    var typesCriterion = this.gridConfig.dataRequest.typesCriterion;
                    var firstEntityType = undefined;

                    if (typesCriterion && typesCriterion.length > 0) {
                        firstEntityType = typesCriterion[0]; // TODO:: how to get attribute models for multiple entity types
                    }

                    this._updateItemContexts();
                    this.set('gridConfig.dataContexts', this.contextData[ContextHelper.CONTEXT_TYPE_DATA]);
                    this.set('gridConfig.valueContexts', this.contextData[ContextHelper.CONTEXT_TYPE_VALUE]);
                    var compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(
                        this.contextData);

                    this.set("attributeModelRequest", compositeModelGetRequest);
                    var liquidModelGet = this.$$("[name=compositeAttributeModelGet]");
                    if (liquidModelGet) {
                        liquidModelGet.generateRequest();
                    }
                },

                _onCompositeModelGetResponse: function (e) {
                    if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                        this.attributeModels = DataTransformHelper.transformAttributeModels(e.detail.response
                            .content.entityModels[0], this.contextData);
                        this.reloadGrid();
                    }
                },

                _onGovernDataResponse: function (e) {
                    var response = e.detail.response;
                    var ids = [0];
                    if (response) {
                        if (response.content && response.content.items) {
                            var items = response.content.items;
                            if (items.length > 0) {
                                ids = [...new Set(items.map((obj) => obj.id))];
                            }
                        }
                    }
                    this._loadWithoutWorkflow = undefined;
                    this._loadWithoutWorkflow = false;
                    this._loadGrid = true;
                    this._reloadGrid(ids);
                },

                _searchResultFiltersChanged: function (currentFilters) {
                    this.set("request.params.query.filters", currentFilters);
                },

                _getAttributeFormattedData: function (data) {
                    var dataArray = [];
                    var formattedEntities = [];
                    if (data && data.content) {
                        var entities = data.content.entities;
                        if (entities && entities.length > 0) {
                            formattedEntities = DataTransformHelper.transformEntitiesToGridFormat(
                                entities, this.attributeModels, this.contextData, this.gridConfig.tabular.columns);
                        }
                    }

                    return formattedEntities;
                },

                _loadSearchResultsByFilters: function () {
                    var grid = Polymer.dom(this).node.$$('rock-grid');
                    var dataSource = Polymer.dom(this).node.$$('entity-search-grid-datasource');

                    if (dataSource && grid && this.searchFilters) {
                        this.request.params.query.filters.attributesCriterion = this.searchFilters;
                        dataSource.resetDataSource();
                        grid.reRenderGrid();
                    }
                },

                _loadSearchResultsByQuery: function () {
                    var grid = Polymer.dom(this).node.$$('rock-grid');
                    var dataSource = Polymer.dom(this).node.$$('entity-search-grid-datasource');

                    if (dataSource && grid) {
                        if (!this.request.params.query) {
                            this.request.params.query = {};
                        }

                        if (!this.request.params.query.filters) {
                            this.request.params.query.filters = {};
                        }

                        if (this.searchQuery && this.searchQuery != "") {
                            this.request.params.query.filters.keywordsCriterion = {
                                "keywords": this.searchQuery,
                                "operator": "and"
                            }
                        } else {
                            delete this.request.params.query.filters.keywordsCriterion;
                        }

                        dataSource.resetDataSource();
                        grid.reRenderGrid();
                    }
                },

                _updateItemContexts: function () {
                    var itemContexts = [];
                    if (!this.gridConfig.dataRequest) {
                        return;
                    }
                    var attributeNames = this.gridConfig.dataRequest.attributes;
                    for (var i in this.gridConfig.dataRequest.typesCriterion) {
                        var itemContext = {};
                        itemContext.attributeNames = attributeNames;
                        itemContext.type = this.gridConfig.dataRequest.typesCriterion[i];
                        itemContexts.push(itemContext);
                    }
                    this.contextData[ContextHelper.CONTEXT_TYPE_ITEM] = itemContexts;
                },

                _reloadGrid: function (ids) {

                    this._updateItemContexts();
                    this.request = DataRequestHelper.createEntityGetRequest(this.contextData);
                    if (!_.isEmpty(ids)) {
                        this.request.params.query.ids = ids;
                    }

                    if (this.searchFilters && !_.isEmpty(this.searchFilters)) {
                        this.request.params.query.filters.attributesCriterion = this.searchFilters;
                    }

                    if (this.searchQuery && this.searchQuery != "") {
                        this.request.params.query.filters.keywordsCriterion = {
                            "keywords": this.searchQuery,
                            "operator": "and"
                        }
                    }
                    var grid = Polymer.dom(this).node.$$('rock-grid');
                    var dataSource = Polymer.dom(this).node.$$('entity-search-grid-datasource');

                    if (dataSource && grid) {
                        dataSource.resetDataSource();
                        grid.reRenderGrid();
                    }
                    setTimeout(function () {
                        this._setGridHeight();
                    }.bind(this), 100);
                },

                _getEntityGrid: function () {
                    return ElementHelper.getElement(this, "#entityGrid");
                },

                _isWorkflowRequest: function (loadGrid, loadWithoutWorkflow) {
                    if (_.isEmpty(this.workflowCriterion) && !loadWithoutWorkflow) {
                        return false;
                    }
                    return true;
                },

                _setGridHeight: function () {
                    var layout = this.parentElement.parentNode.parentNode.root.querySelector('#rockLayoutContainer')
                    var rockGridHeight = 0;

                    if (layout) {
                        var footer = layout.querySelector('rock-footer');
                        rockGridHeight = layout.offsetHeight;

                        if (footer) {
                            rockGridHeight = rockGridHeight - footer.offsetHeight;
                        }
                    }

                    var rockGrid = Polymer.dom(this).node.$$('rock-grid');
                    if (rockGrid && rockGridHeight > 0) {
                        rockGrid._getIronDataTable().style.height = rockGridHeight - 80 + 'px';
                    }
                }


            });
        })();
    </script>
</dom-module>