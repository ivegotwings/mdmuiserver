<link rel="import" href="../../../bower_components/polymer/polymer.html">

<link rel="import" href="../bedrock-pubsub/bedrock-pubsub.html">
<link rel="import" href="../bedrock-helpers/data-helper.html">
<link rel="import" href="../bedrock-helpers/context-helper.html">
<link rel="import" href="../bedrock-helpers/data-request-helper.html">
<link rel="import" href="../bedrock-helpers/data-transform-helper.html">
<link rel="import" href="../bedrock-component-context-behavior/bedrock-component-context-behavior.html">

<link rel="import" href="../liquid-dataobject-utils/liquid-dataobject-utils.html">
<link rel="import" href="../liquid-entity-model-composite-get/liquid-entity-model-composite-get.html">
<link rel="import" href="../liquid-entity-data-get/liquid-entity-data-get.html">

<link rel="import" href="../pebble-spinner/pebble-spinner.html">
<link rel="import" href="../pebble-toggle-button/pebble-toggle-button.html">

<link rel="import" href="../rock-grid/rock-grid.html">
<link rel="import" href="../rock-grid-data-sources/entity-search-grid-datasource.html">
<link rel="import" href="../rock-business-function-dialog/rock-business-function-dialog.html">
<link rel="import" href="../rock-govern-data-grid/rock-govern-data-grid.html">

<!--
`rock-entity-search-grid` Represents a component that renders the entities in the grid.
It filters the data as per filter criteria.

@demo demo/index.html
-->

<dom-module id="rock-entity-search-grid">
    <template>
    <style>
        pebble-toggle-button {
            --pebble-toggle-button-checked-bar-color: var(--success-color, #4caf50);
            --pebble-toggle-button-checked-button-color: var(--success-color, #4caf50);
            --pebble-toggle-button-checked-ink-color: var(--success-color, #4caf50);
            --pebble-toggle-button-label-color: var(--secondary-button-text-color, #75808b);
        }

        .toggle-button {
            float: right;
            padding: 22px 20px 0px 0px;
            font-size: var(--font-size-sm, 12px);
        }
        /* Firefox specific fix for toggle button */

        @media all and (min--moz-device-pixel-ratio:0) and (min-resolution: 3e1dpcm) {
            .toggle-button {
                padding: 0;
            }
        }
        /* IE11 specific fix for toggle button */

        @media screen and (-ms-high-contrast: active),
        (-ms-high-contrast: none) {
            .toggle-button {
                padding: 0;
            }
        }
            pebble-toggle-button {
                --pebble-toggle-button-checked-bar-color: var(--success-color, #4caf50);
                --pebble-toggle-button-checked-button-color: var(--success-color, #4caf50);
                --pebble-toggle-button-checked-ink-color: var(--success-color, #4caf50);
                --pebble-toggle-button-label-color: var(--secondary-button-text-color, #75808b);
            }
            .toggle-button {
                float: right;
                padding: 22px 20px 0px 0px;
                font-size: var(--font-size-sm, 12px);            
            }
        </style>
        <pebble-spinner active="[[_loading]]"></pebble-spinner>
        <template is="dom-if" if="{{_isViewLoaded}}">
            <liquid-entity-model-composite-get name="compositeAttributeModelGet" request-data="{{attributeModelRequest}}" on-entity-model-composite-get-response="_onCompositeModelGetResponse"></liquid-entity-model-composite-get>
        </template>
        <template is="dom-if" if="[[_isWorkflowRequest(_loadGrid, _loadWithoutWorkflow)]]">
            <template is="dom-if" if="[[_showToggle()]]">
                <pebble-toggle-button class="toggle-button" noink checked="{{_loadGovernData}}">Govern Data</pebble-toggle-button>
            </template>
            <template is="dom-if" if="[[!_loadGovernData]]">
                <entity-search-grid-datasource id="searchGrid" request="{{request}}" r-data-source="{{rDataSource}}" r-data-formatter="{{rDataFormatter}}"
                    buffer-record-size="{{size}}" current-record-size="{{currentRecordSize}}" result-record-size="{{resultRecordSize}}"
                    total-count="{{totalCount}}" attribute-models="{{attributeModels}}" is-combined-get="[[_isCombinedGetReq]]"></entity-search-grid-datasource>
                <rock-grid hidden$="[[_loadGovernData]]" id="entityGrid" grid-data-source="{{rDataSource}}" r-data-source-id="searchGrid" result-record-size="{{resultRecordSize}}"
                    current-record-size="{{currentRecordSize}}" config="{{gridConfig}}" grid-data-size="{{size}}" attribute-models="{{attributeModels}}"
                    page-size="[[pageSize]]" selected-item="{{selectedItem}}" selected-items="{{selectedItems}}" total-count="{{totalCount}}"
                    max-configured-count="[[maxConfiguredCount]]" has-combined-get-results="[[_isCombinedGetReq]]"></rock-grid>
            </template>
            <template is="dom-if" if="[[_loadGovernData]]">
                <rock-govern-data-grid id="governGrid" context-data="[[contextData]]" request="[[request]]" entity-name-attribute="[[governDataConfig.entityNameAttribute]]"></rock-govern-data-grid>
            </template>
            <bedrock-pubsub event-name="grid-download-item" handler="_onDownload" target-id="entityGrid"></bedrock-pubsub>
            <bedrock-pubsub event-name="grid-upload-item" handler="_onUpload" target-id="entityGrid"></bedrock-pubsub>
            <bedrock-pubsub event-name="grid-bulk-edit-items" handler="_onBulkEdit" target-id="entityGrid"></bedrock-pubsub>
        </template>
        
        <rock-business-function-dialog id="entityUploadDialog"></rock-business-function-dialog>
        <rock-business-function-dialog id="entityDownloadDialog"></rock-business-function-dialog>
        <rock-business-function-dialog id="entityEditDialog"></rock-business-function-dialog>
    </template>

    <script>
        (function () {
            'use strict';

            Polymer({
                is: 'rock-entity-search-grid',
                properties: {
                    _isViewLoaded:{
                        type:Boolean,
                        value:false
                    },
                    /**
                     * Indicates the request object that is passed to the data element to retrieve the attribute model data.
                     */
                    attributeModelRequest: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    contextData: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the configuration object that is passed to the grid.
                     */
                    gridConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the request object to initiate the search.
                     * 
                     */
                    request: {
                        type: Object,
                        value: function () {
                            return {
                                "params": {
                                    "query": {
                                        "contexts": [],
                                        "valueContexts": [],
                                        "filters": {
                                            "attributesCriterion": [],
                                            "typesCriterion": []
                                        }
                                    },
                                    "fields": {
                                        "ctxTypes": [
                                            "properties"
                                        ],
                                        "attributes": []
                                    },
                                    "options": {
                                        "from": 0,
                                        "to": 0
                                    }
                                }
                            };
                        }
                    },
                    /**
                     * Specifies the filters to filter the search.
                     */
                    searchFilters: {
                        type: Array,
                        notify: true,
                        value: function () {
                            return [];
                        },
                        // observer: '_loadSearchResultsByFilters'
                    },
                    /**
                     * Specifies the query object that initiates the search.
                     */
                    searchQuery: {
                        type: String,
                        notify: true,
                        value: "",
                        // observer: '_loadSearchResultsByQuery'
                    },
                    /**
                     * Specifies the workflow criterion for the search.
                     */
                    typesCriterion: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the workflow criterion for the search.
                     */
                    workflowCriterion: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return {};
                        }
                    },
                    /**
                     * Specifies the format of the data that are passed to the `remote-data`.
                     */
                    rDataFormatter: {
                        type: Object,
                        notify: true,
                        value: function () {
                            return this._getAttributeFormattedData.bind(this);
                        }
                    },
                    rDataSource: {
                        type: Object,
                        notify: true
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    attributeModels: {
                        type: Object,
                        value: function () {
                            return {}
                        }
                    },

                    /**
                     * Indicates the number of items fetched at a time from the data-source.
                     */
                    pageSize: {
                        type: Number,
                        notify: true,
                        value: 50
                    },

                    /**
                     * Indicates the total record size of the current grid.				 
                     */
                    currentRecordSize: {
                        notify: true,
                        type: Number,
                        value: 0
                    },

                    /**
                     * Indicates a selected item.
                     */
                    selectedItem: {
                        type: Object,
                        value: function () {
                            return {};
                        },
                        notify: true
                    },

                    /**
                     * Indicates an array of selected items.
                     */
                    selectedItems: {
                        type: Array,
                        value: [],
                        notify: true
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    savedSearchCriterion: {
                        type: Object,
                        value: function () {
                            return true;
                        }
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    savedSearchId: {
                        type: String,
                        value: ""
                    },
                    /**
                     * <b><i>Content development is under progress... </b></i> 
                     */
                    maxConfiguredCount: {
                        type: Number,
                        value: function () {
                            return DataObjectFalcorUtil.getPathKeys().dataIndexInfo.entityData.maxRecordsToReturn;
                        }
                    },
                    governDataConfig: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    governAttributesCriterion: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _governDataGetReq: {
                        type: Object,
                        value: function () {
                            return {};
                        }
                    },

                    _loadGrid: {
                        type: Boolean
                    },

                    _loadWithoutWorkflow: {
                        type: Boolean
                    },

                    _loading: {
                        type: Boolean,
                        value: false
                    },
                    _loadGovernData: {
                        type: Boolean,
                        value: false
                    },
                    _isCombinedGetReq: {
                        type: Boolean,
                        value: false
                    }
                },

                behaviors: [
                    RUFBehaviors.UIBehavior,
                    RUFBehaviors.ComponentContextBehavior
                ],

                observers: [
                    '_onGridConfigChange(gridConfig, savedSearchCriterion)'
                ],

                attached: function(){
                    Polymer.RenderStatus.beforeNextRender(this, function() {
                        this._isViewLoaded = true;
                    });
                },
                /**
                 * <b><i>Content development is under progress... </b></i> 
                 */
                refresh: function () {
                    this._onGridConfigChange(this.gridConfig, this.savedSearchCriterion);
                },

                /**
                 * Can be used to get the grid data.
                 */
                getData: function () {
                    return this._getEntityGrid().getData();
                },

                /**
                 * Can be used to set the multi-selection for the grid.
                 */
                setMultiSelection: function (flag) {
                    if (this.shadowRoot.querySelector('#entityGrid') && flag != undefined) {
                        this._getEntityGrid().setMultiSelection(flag);
                    }
                },

                /**
                 * Can be used to clear the current selection state.
                 */
                clearSelection: function () {
                    this._getEntityGrid().clearSelection();
                },

                /**
                 *  Can be used to select an item.
                 */
                selectItem: function (item) {
                    this._getEntityGrid().selectItem(item);
                },

                /**
                 * Can be used to set the "scroll position" dynamically.
                 */
                scrollToIndex: function (index) {
                    this._getEntityGrid().scrollToIndex(index);
                },

                /**
                 * Can be used to reset the grid size.
                 */
                notifyResize: function () {
                    this._getEntityGrid().notifyResize();
                },

                /**
                 * Can be used to get the selected grid row.
                 */
                getSelectedGridRow: function () {
                    return this._getEntityGrid().getSelectedGridRow();
                },

                /**
                 * Can be used to get the selected item index.
                 */
                getSelectedItemIndex: function () {
                    return this._getEntityGrid().getSelectedItemIndex();
                },
                getSelectedItemsAsQuery: function () {
                    return this._getEntityGrid().getSelectedItemsAsQuery();
                },
                getSelectionMode: function () {
                    return this._getEntityGrid().getSelectionMode();
                },
                _addWorkflowDetailsToConfig: function () {
                    if (!(this.workflowCriterion && this.workflowCriterion.workflowName && this.workflowCriterion.workflowActivityName)) {
                        return;
                    }

                    this.set('gridConfig.workflowDetails', {
                        "workflow": this.workflowCriterion.workflowName,
                        "workflowStatus": this.workflowCriterion.workflowActivityExternalName
                    });
                },
                /**
                 * Can be used to reload the grid.
                 */
                reloadGrid: function () {
                    if (!_.isEmpty(this.workflowCriterion)) {
                        this._addWorkflowDetailsToConfig();
                        var workflowActivityName = this.workflowCriterion.workflowActivityName;
                        var userId = this.workflowCriterion.userId;
                        var businessConditionName = this.workflowCriterion.businessConditionName;
                        var contexts = [];
                        contexts.push({
                            "workflow": this.workflowCriterion.workflowShortName
                        });

                        var options = {
                            "contexts": contexts,
                            "typesCriterion": this.typesCriterion,
                            "userId": userId,
                            "workflowActivityName": workflowActivityName,
                            "businessConditionName": businessConditionName,
                            "attributes": "",
                            "excludeNonContextual": true
                        }

                        var req = DataRequestHelper.createGovernGetRequest(options);

                        if (!_.isEmpty(req)) {
                            this._governDataGetReq = req;
                            // governDataLiquid.generateRequest();
                            this._loadWithoutWorkflow = undefined;
                            this._loadWithoutWorkflow = false;
                            this._loadGrid = true;
                            this._reloadGrid(true);
                        }
                    } else {
                        this._loadGrid = true;
                        this._loadWithoutWorkflow = true;
                        this._reloadGrid(false);
                    }
                },

                _onGridConfigChange: function (gridConfig, savedSearchCriterion) {
                    var dataRequest = {};

                    if (_.isEmpty(this.contextData) || _.isEmpty(gridConfig)) {
                        return;
                    }

                    if (!_.isEmpty(this.contextData)) {
                        if (Object.keys(this.contextData).length == 1 && this.contextData[ContextHelper.CONTEXT_TYPE_USER]) {
                            return;
                        }
                    }

                    //TODO:: Search has to be restructured.
                    // Below is temporary fix.
                    if (!_.isEmpty(this.savedSearchId) && _.isEmpty(savedSearchCriterion)) {
                        return;
                    }

                    if (!gridConfig.dataRequest) {
                        return;
                    }

                    var attributeNames = gridConfig.dataRequest.attributes;
                    var typesCriterion = gridConfig.dataRequest.typesCriterion;
                    var firstEntityType = undefined;

                    if (typesCriterion && typesCriterion.length > 0) {
                        firstEntityType = typesCriterion[0]; // TODO:: how to get attribute models for multiple entity types
                    }

                    this._updateItemContexts();
                    this.set('gridConfig.dataContexts', this.contextData[ContextHelper.CONTEXT_TYPE_DATA]);
                    this.set('gridConfig.valueContexts', this.contextData[ContextHelper.CONTEXT_TYPE_VALUE]);
                    var compositeModelGetRequest = DataRequestHelper.createEntityModelCompositeGetRequest(this.contextData);
                    if (compositeModelGetRequest) {
                        this.set("attributeModelRequest", compositeModelGetRequest);
                        var liquidModelGet = this.shadowRoot.querySelector("[name=compositeAttributeModelGet]");
                        if (liquidModelGet) {
                            liquidModelGet.generateRequest();
                        }
                    }
                },

                _onCompositeModelGetResponse: function (e) {
                    if (e && e.detail && DataHelper.validateGetAttributeModelsResponse_New(e.detail.response)) {
                        this.attributeModels = DataTransformHelper.transformAttributeModels(e.detail.response.content.entityModels[0], this.contextData);
                    }
                    this.reloadGrid();
                },

                _searchResultFiltersChanged: function (currentFilters) {
                    this.set("request.params.query.filters", currentFilters);
                },

                _getAttributeFormattedData: function (data) {
                    var dataArray = [];
                    var formattedEntities = [];
                    if (data && data.content) {
                        var entities = data.content.entities;
                        if (entities && entities.length > 0) {
                            formattedEntities = DataTransformHelper.transformEntitiesToGridFormat(entities, this.attributeModels, this.contextData, this.gridConfig.tabular.columns);
                        }
                    }

                    return formattedEntities;
                },

                _loadSearchResultsByFilters: function () {
                    var grid = this._getEntityGrid();
                    var dataSource = this._getEntityDataSource();

                    if (grid && this.searchFilters) {
                        var attrsCriterion = this._removeUnSupportedFilters(this.searchFilters);
                        this._entityDataGetReq.params.query.filters.attributesCriterion = attrsCriterion;
                        this._governDataGetReq.params.query.filters.attributesCriterion = this._getDefaultGovernAttributesCriterion();
                        this._updateGovernRequestAttributesCriterion(attrsCriterion);

                        if (this._isCombinedGetReq) {
                            this.request = DataRequestHelper.createCombinedGetRequest(this._governDataGetReq, this._entityDataGetReq);
                        } else {
                            this.request = this._entityDataGetReq;
                        }

                        if (dataSource) {
                            dataSource.resetDataSource();
                        }
                        grid.reRenderGrid();
                    }
                },

                // Remove unsupported filters which were added for tags
                _removeUnSupportedFilters: function (filters) {
                    for (var i = 0; i < filters.length; i++) {
                        if (filters[i] && !_.isEmpty(filters[i])) {
                            for (var key in filters[i]) {
                                if (!filters[i].hasOwnProperty(key)) continue;
                                for (var j in filters[i][key]) {
                                    if (!filters[i][key].hasOwnProperty(j)) continue;
                                    if (j != 'eq' &&
                                        j != 'gte' &&
                                        j != 'lte' &&
                                        j != 'contains' &&
                                        j != 'exact' &&
                                        j != 'type' &&
                                        j != 'operator') {
                                        delete filters[i][key][j];
                                    }
                                }
                            }
                        }
                    }

                    return filters;
                },

                _loadSearchResultsByQuery: function () {
                    var grid = this._getEntityGrid();
                    var dataSource = this._getEntityDataSource();

                    if (grid) {
                        if (!this._entityDataGetReq.params.query) {
                            this._entityDataGetReq.params.query = {};
                        }

                        if (!this._entityDataGetReq.params.query.filters) {
                            this._entityDataGetReq.params.query.filters = {};
                        }

                        if (this.searchQuery && this.searchQuery != "") {

                            var keyWordItem = {}
                            var splitQueryByAnd = this.searchQuery.toLowerCase().split(' and ');
                            var splitQueryByOr = this.searchQuery.toLowerCase().split(' or ');

                            if (splitQueryByAnd.length > 1) {
                                keyWordItem.operator = "_AND"
                            } else if (splitQueryByOr.length > 1) {
                                keyWordItem.operator = "_OR"
                            } else {
                                keyWordItem.operator = "_AND"
                            }
                            keyWordItem.keywords = splitQueryByAnd.join(' ');

                            this._entityDataGetReq.params.query.filters.keywordsCriterion = keyWordItem;
                        } else {
                            delete this._entityDataGetReq.params.query.filters.keywordsCriterion;
                        }

                        if (this._isCombinedGetReq) {
                            this.request = DataRequestHelper.createCombinedGetRequest(this._governDataGetReq, this._entityDataGetReq);
                        } else {
                            this.request = this._entityDataGetReq;
                        }

                        if (dataSource) {
                            dataSource.resetDataSource();
                        }
                        grid.reRenderGrid();
                    }
                },

                _updateItemContexts: function () {
                    var itemContexts = this.getItemContexts();
                    if (!itemContexts && itemContexts.length) {
                        return;
                    }
                    var attributeNames = this.gridConfig.dataRequest.attributes;
                    for (var i in itemContexts) {
                        itemContexts[i].attributeNames = attributeNames;
                    }
                },

                _reloadGrid: function (isCombinedGetReq) {
                    this._updateItemContexts();
                    this._entityDataGetReq = DataRequestHelper.createEntityGetRequest(this.contextData);

                    if (this.searchFilters && !_.isEmpty(this.searchFilters)) {
                        this._entityDataGetReq.params.query.filters.attributesCriterion = this.searchFilters;
                        this._updateGovernRequestAttributesCriterion(this.searchFilters);
                    }

                    if (this.searchQuery && this.searchQuery != "") {
                        this._entityDataGetReq.params.query.filters.keywordsCriterion = {
                            "keywords": this.searchQuery,
                            "operator": "and"
                        }
                    }

                    this._isCombinedGetReq = isCombinedGetReq;

                    if (isCombinedGetReq) {
                        this.request = DataRequestHelper.createCombinedGetRequest(this._governDataGetReq, this._entityDataGetReq);
                    } else {
                        this.request = this._entityDataGetReq;
                    }

                    var grid = this._getEntityGrid();
                    var dataSource = this._getEntityDataSource();

                    if (grid) {
                        if (dataSource) {
                            dataSource.resetDataSource();
                        }
                        grid.reRenderGrid();
                    }
                    setTimeout(function () {
                        this._setGridHeight();
                    }.bind(this), 100);
                },

                _getEntityGrid: function () {
                    if (!this._loadGovernData) {
                        return ElementHelper.getElement(this, "#entityGrid");
                    } else {
                        return ElementHelper.getElement(this, "#governGrid");
                    }
                },
                _getEntityDataSource: function () {
                    if (!this._loadGovernData) {
                        return undefined;
                    } else {
                        return ElementHelper.getElement(this, "#searchGrid");
                    }
                },

                _isWorkflowRequest: function (loadGrid, loadWithoutWorkflow) {
                    if (_.isEmpty(this.workflowCriterion) && !loadWithoutWorkflow) {
                        return false;
                    }
                    return true;
                },

                _setGridHeight: function () {
                    if (this.parentElement && this.parentElement.parentNode) {
                        var layout = this.parentElement.parentNode.parentNode.root.querySelector('#rockLayoutContainer')
                        var rockGridHeight = 0;

                        if (layout) {
                            var footer = layout.querySelector('rock-footer');
                            rockGridHeight = layout.offsetHeight;

                            if (footer) {
                                rockGridHeight = rockGridHeight - footer.offsetHeight;
                            } else {
                                rockGridHeight = rockGridHeight;
                            }
                        }
                        var grid = this._getEntityGrid();

                        if (grid && rockGridHeight > 0) {
                            grid._getIronDataTable().style.height = rockGridHeight - 80 + 'px';
                        }
                    }
                },
                _onDownload: function (e, detail) {
                    var selectedItems = this.getSelectedItems();
                    var selectionMode = this.getSelectionMode();
                    var selectionQuery = this.getSelectedItemsAsQuery();

                    if (selectedItems && selectedItems.length && this.contextData) {
                        var entityDownloadDialog = this.shadowRoot.querySelector("#entityDownloadDialog");
                        entityDownloadDialog.name = "rock-entity-download";
                        entityDownloadDialog.sharedData = {
                            "context-data": this.contextData,
                            "selection-query": selectionQuery,
                            "selection-mode": selectionMode,
                            "selected-entities": selectedItems
                        };
                        entityDownloadDialog.open();
                    } else {
                        this.showInformationToast("Please select at least one entity from grid to download.");
                    }
                },
                _onUpload: function (e, detail) {
                    this.shadowRoot.querySelector("#entityUploadDialog").name = "rock-entity-upload";
                    this.shadowRoot.querySelector("#entityUploadDialog").sharedData = { "context-data": this.contextData };
                    this.shadowRoot.querySelector("#entityUploadDialog").open();
                },
                _onBulkEdit: function (e, detail) {
                    var selectedItems = this.getSelectedItems();
                    var selectionMode = this.getSelectionMode();
                    var selectionQuery = this.getSelectedItemsAsQuery();
                    if (selectedItems && selectedItems.length && this.contextData) {
                        var entityEditDialog = this.shadowRoot.querySelector("#entityEditDialog");
                        entityEditDialog.name = "rock-entity-bulk-edit";
                        entityEditDialog.configName = "wizardConfig";
                        entityEditDialog.sharedData = {
                            "context-data": this.contextData,
                            "workflow-criterion": this.workflowCriterion,
                            "selection-query": selectionQuery,
                            "selection-mode": selectionMode,
                            "selected-entities": selectedItems
                        };
                        entityEditDialog.open();
                    } else {
                        this.showInformationToast("Please select at least one entity from grid to edit.");
                    }
                },
                /**
                 * <b><i>Content development is under progress... </b></i> 
                 */
                getSelectedItems: function () {
                    var grid = this._getEntityGrid();
                    return grid.getSelectedItems();
                },
                _showToggle: function () {
                    if (this.governDataConfig && this.governDataConfig.showGovernDataToggle) {
                        return true;
                    }
                    return false;
                },

                _getDefaultGovernAttributesCriterion: function () {
                    var defaultCriterion = [];
                    var currentCriterion = this._governDataGetReq.params.query.filters.attributesCriterion;

                    if (currentCriterion) {
                        currentCriterion.forEach(function (criterion) {
                            if (criterion && Object.keys(criterion).length == 1) {
                                switch (Object.keys(criterion)[0]) {
                                    case "activities":
                                    case "status":
                                    case "businessConditions":
                                        defaultCriterion.push(criterion);
                                        break;
                                }
                            }
                        }, this);
                    }
                    return defaultCriterion;
                },

                _updateGovernRequestAttributesCriterion: function (attributesCriterion) {

                    if (this.governAttributesCriterion) {
                        if (this.governAttributesCriterion.include && this.governAttributesCriterion.include.length) {

                            if (this.governAttributesCriterion.include.length == 1 && this.governAttributesCriterion.include[0] == "_ALL") {
                                attributesCriterion.forEach(function (attrCritrn) {
                                    attrCritrn[Object.keys(attrCritrn)[0]].nonContextual = true;
                                    this._governDataGetReq.params.query.filters.attributesCriterion.push(attrCritrn)
                                }, this);
                            } else {
                                var attributes = this.governAttributesCriterion.include;

                                if (attributes && attributes.length) {
                                    attributes.forEach(function (attr) {
                                        for (var i = 0; i < attributesCriterion.length; i++) {
                                            if (attributesCriterion[i][attr]) {
                                                var attrCriterion = attributesCriterion[i];
                                                attrCriterion[attr].nonContextual = true;
                                                this._governDataGetReq.params.query.filters.attributesCriterion.push(attrCriterion);
                                                break;
                                            }
                                        }
                                    }, this);
                                }
                            }
                        }
                    }
                }
            });
        })();
    </script>
</dom-module>